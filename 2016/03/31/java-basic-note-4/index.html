<!doctype html>
<html class="theme-next use-motion theme-next-next">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


  <meta name="google-site-verification" content="VvyjvVXcJQa0QklHipu6pwm2PJGnnchIqX7s5JbbT_0" />



  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.0"/>


    <meta name="description" content="放宽心，多努力" />



	<meta name="keywords" content="Java," />

  <title> Java基础笔记（四） IO/NIO与序列化 // 神奕的博客 </title>
</head>

<body>
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">神奕的博客</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
            
          

          <div id="posts" class="posts-expand">
            
  

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Java基础笔记（四） IO/NIO与序列化
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2016-03-31
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="/categories/Lang-Java/">Lang.-Java</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/03/31/java-basic-note-4/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/31/java-basic-note-4/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          <font color="red">本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</font>

<h1 id="第十一章_I/O与序列化">第十一章 I/O与序列化</h1><h2 id="1、File类">1、File类</h2><p>Java中访问本地系统是通过<code>java.io.File</code>类。 File类可以使用 <strong>绝对路径</strong> 或 <strong>相对路径</strong> 来创建 File 对象，然后调用 File 对象的方法来操作文件和目录。<br><a id="more"></a><br><strong>&gt;&gt; File类常用方法</strong></p>
<ol>
<li><p>访问文件名相关的方法</p>
<ul>
<li><code>String getName()</code>：获取文件名</li>
<li><code>String getPath()</code>：获取路径名</li>
<li><code>String getAbsolutePath()</code>：获取绝对路径名</li>
<li><code>File getAbsoluteFile()</code>：返回绝对路径的File对象</li>
<li><code>String getParent()</code>：返回上一级目录名</li>
<li><code>boolean renameTo(File newName)</code>：重命名</li>
</ul>
</li>
<li><p>文件检测相关的方法</p>
<ul>
<li><code>boolean exists()</code>：判断是否存在</li>
<li><code>boolean canWrite()</code>：判断是否可写</li>
<li><code>boolean canRead()</code>：判断是否可读</li>
<li><code>boolean isFile()</code>：判断是否是文件（而不是目录）</li>
<li><code>boolean isDirectory()</code>：判断是否是目录</li>
<li><code>boolean isAbsolute()</code>：判断是否是绝对路径</li>
</ul>
</li>
<li><p>获取常规文件信息</p>
<ul>
<li><code>long lastModified()</code>：返回文件的最后修改时间</li>
<li><code>long length()</code>：返回文件内容的长度</li>
</ul>
</li>
<li><p>文件操作相关的方法</p>
<ul>
<li><code>boolean createNewFile()</code>：当此File对象所对应的文件不存在时，创建它。</li>
<li><code>boolean delete()</code>：删除文件或路径</li>
<li><code>static File createTempFile(String prefix, String suffix)</code>：创建临时空文件</li>
<li><code>void deleteOnExit()</code>：指定当Java虚拟机退出时，删除该文件或目录</li>
</ul>
</li>
<li><p>目录操作相关的方法</p>
<ul>
<li><code>boolean mkdir()</code>：创建目录</li>
<li><code>String[] list()</code>：列出当前目录的所有子文件名和子目录名，返回String数组</li>
<li><code>File[] listFiles()</code>：列出当前目录的所有子文件名和子目录名，返回File数组</li>
<li><code>static File[] listRoots()</code>：列出系统所有的根路径，静态方法。</li>
</ul>
</li>
</ol>
<p><strong>&gt;&gt; 文件过滤器</strong></p>
<p>上述File类的<code>list()</code>方法有一个重载版本：</p>
<ul>
<li><code>String[] list(FilenameFilter filter)</code></li>
</ul>
<p>通过过滤器参数可以只列出符合条件的文件或目录。<code>FilenameFilter</code>接口内只有一个方法<code>accept(File dir, String name)</code>，该方法将依次对所有的子文件名或子目录名进行迭代，返回<code>true</code>则表示符合要求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">".gz"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"/home/master/software"</span>);</span><br><span class="line">		String[] nameList = file.list(<span class="keyword">new</span> MyFilter());</span><br><span class="line">		<span class="keyword">for</span>(String n : nameList) &#123;</span><br><span class="line">			System.out.println(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<h2 id="2、理解Java的IO流">2、理解Java的IO流</h2><p><strong>&gt;&gt; 流的分类</strong></p>
<p>Java中把不同的输入/输出源（键盘、文件、网络连接等）抽象表述为“流”（Stream）。按照不同的分类方式，可以将流分为不同的类型。</p>
<ol>
<li><p>按照流的流向来分：</p>
<ul>
<li><strong>输入流</strong>：从程序的角度，只能从中读取数据，不能向其写入数据 —— 输入流主要由<code>InputStream</code>和<code>Reader</code>作为基类。</li>
<li><strong>输出流</strong>：从程序的角度，只能向其写入数据，不能从中读取数据 —— 输出流主要由<code>OutputStream</code>和<code>Writer</code>作为基类。</li>
</ul>
</li>
<li><p>按照操作的数据单元来分：</p>
<ul>
<li><strong>字节流</strong>：字节流操作的数据单元是一个字节（8个bit）—— 字节流主要由<code>InputStream</code>和<code>OutputStream</code>作为基类。</li>
<li><strong>字符流</strong>：字符流操作的数据单元是一个字符（两个字节，16个bit）—— 字符流主要由<code>Reader</code>和<code>Writer</code>作为基类。</li>
</ul>
</li>
<li><p>按照流的角色来分：</p>
<ul>
<li><strong>节点流</strong>：直接与IO设备（如磁盘、网络）交互的流，称为节点流，节点流也被称为低级流。</li>
<li><strong>处理流</strong>：对一个已存在的流进行封装，封装后的流称为处理流，处理流也被称为高级流。</li>
</ul>
</li>
</ol>
<p><strong>&gt;&gt; 流的概念模型</strong></p>
<p>Java把所有IO设备里的有序数据抽象成流模型。</p>
<p>对于输入流的 InputStream 和 Reader 而言，它们把输入设备抽象成一个“水管”，水管里的每个“水滴”依次排序，如下图：</p>
<p><img src="http://img.blog.csdn.net/20160329155324549" alt=""></p>
<p>输入流使用 <strong>隐式的指针</strong> 来记录读取位置，每当程序从输入流里读取一个或多个“水滴”后，记录指针自动向后移动。</p>
<p>对于输出流的 OutputStream 和 Writer 而言，它们同样把输出设备抽象成一个“水管”，只是这个水管里一开始没有“水滴”，如下图：</p>
<p><img src="http://img.blog.csdn.net/20160329155410023" alt=""></p>
<p>当程序执行输出时，相当于依次把“水滴”放入水管中，输出流同样采用 隐式的指针 来标识当前水滴即将放入的位置。</p>
<p><strong>&gt;&gt; 基类的接口</strong></p>
<p>InputStream 和 Reader 是所有输入流的抽象基类，它们都包含如下三个方法：</p>
<ul>
<li><p><code>int read()</code>：从输入流读取单个字节/字符，返回所读取到的字节/字符数据。</p>
</li>
<li><p><code>int read(byte[]/char[] buf)</code>：从输入流中最多读取 buf.length 个字节/字符数据，并将其存在 buf 数组中，返回实际读取的字节/字符数量。</p>
</li>
<li><p><code>int read(byte[]/char[] buf, int off, int len)</code>：从输入流中最多读取 len 个字节/字符数据，并将其存在 buf 数组中。放入数组 buf 时，并不是从数组起点开始，而是从 off 位置开始，返回实际读取的字节/字符数量。</p>
</li>
</ul>
<p>可以看出，两个基类提供的方法基本一样，只是读取的数据单元不相同。当 read 方法返回 -1 时，表明到了输入流的结尾。</p>
<p>OutputStream 和 Writer 是所有输出流的抽象基类，它们都包含了如下三个方法：</p>
<ul>
<li><p><code>void write(int c)</code>：将指定的字节/字符输出到输出流中。</p>
</li>
<li><p><code>void write(byte[]/char[] buf)</code>：将字节数组/字符数组中的数据输出到指定的输出流中。</p>
</li>
<li><p><code>void write(byte[]/char[] buf, int off, int len)</code>：将字节数组/字符数组从 off 位置开始，长度为 len 的字节/字符输出到输出流中。</p>
</li>
</ul>
<p>其中 Writer 还包含额外的两个方法：</p>
<ul>
<li><code>void write(String str)</code></li>
<li><code>void write(String str, int off, int len)</code></li>
</ul>
<hr>
<p><br></p>
<h2 id="3、处理流模型">3、处理流模型</h2><p>像 FileInputStream、FileReader 等实现类都是节点流，它们都是直接与文件交互的。<strong>处理流</strong>则是对节点流进行了一层包装，处理流的好处主要在于：</p>
<ol>
<li><p><strong>性能的提高</strong>：主要以增加缓冲的方式来提高I/O的效率；</p>
</li>
<li><p><strong>操作的便捷</strong>：处理流可能提供一系列更便捷的方法来一次输入/输出大批量的内容；</p>
</li>
<li><p><strong>接口的统一</strong>：通过处理流来读写，程序可以采用完全相同的代码来访问不同的数据源，随着处理流所包装的节点流的变化，程序访问的数据源也相应变化。（这是典型的<strong>装饰器</strong>设计模式）</p>
</li>
</ol>
<p>Java程序无须理会访问的设备是磁盘、网络还是文件，只需要将这些节点流包装成处理流，通过处理流来执行输入/输出功能。在关闭I/O流资源时，只要关闭最上层的处理流即可。</p>
<p><img src="http://img.blog.csdn.net/20160329172503354" alt=""></p>
<p>那么，怎么识别处理流呢？只要流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流。</p>
<hr>
<p><br></p>
<h2 id="4、输入/输出流体系">4、输入/输出流体系</h2><p>Java的输入/输出体系提供了近40个类，如下表 —— <strong>粗体</strong>标出的类属于节点流，必须直接与指定的物理节点关联；<em>斜体</em>标出的代表抽象基类，无法直接创建实例。</p>
<p><img src="http://img.blog.csdn.net/20160329173315803" alt=""></p>
<p>从表中可以看出，我们不仅可以把 数组 或 字符串 当作物理节点来访问，也可以把 管道 作为物理节点进行进程间通信。另外，Java提供了 4 个缓冲流（处理流），用以增加缓冲功能，提高输入输出效率。</p>
<h3 id="&gt;&gt;_转换流"><strong>&gt;&gt; 转换流</strong></h3><p>Java提供了两个转换流，用来将字节流转换成字符流：</p>
<ul>
<li><code>InputStreamReader</code>：将字节输入流转换成字符输入流；</li>
<li><code>OutputStreamWriter</code>：将字节输出流转换成字符输出流。</li>
</ul>
<p>由于字符流比字节流操作更方便，如果输入输出的是二进制内容，通常使用字节流；而如果是文本内容，则应该考虑字符流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(line.equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">				System.exit(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"输入内容为："</span>+line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上例所示，标准输入<code>System.in</code>是 InputStream 类的实例，使用不太方便。由于键盘输入都是文本内容，所以可以使用<code>InputStreamReader</code>转换成字符流，普通的 Reader 读取输入依然不方便，可以再将普通 Reader 包装成<code>BufferedReader</code>，然后逐行进行读取。</p>
<h3 id="&gt;&gt;_推回输入流"><strong>&gt;&gt; 推回输入流</strong></h3><p>Java提供了两个与众不同的流<code>PushbackInputStream</code>、<code>PushbackReader</code>，叫推回输入流。</p>
<ul>
<li><p><code>void unread(int b)</code>：将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容；</p>
</li>
<li><p><code>void unread(byte[]/char[] buf)</code>：将一个字节数组/字符数组推回到推回缓冲区里，从而允许重复读取刚刚读取的内容；</p>
</li>
<li><p><code>void unread(byte[]/char[] buf, int off, int len)</code>：将一个数组从off开始，长为len的字节/字符推回到推回缓冲区，从而允许重复读取刚刚读取的内容。</p>
</li>
</ul>
<p>简单地说，Pushback 输入流就是将刚刚从输入流中读出来的内容推回去，再读一遍 —— 不过不是推回到原来的输入流中，而是推回到<strong>推回缓冲区</strong>中。每次 Pushback 输入流调用<code>read()</code>方法时总是先从推回缓冲区中读，读完了以后再从原输入流中读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"D:/a.txt"</span>);</span><br><span class="line">		PushbackReader pr = <span class="keyword">new</span> PushbackReader(reader, <span class="number">32</span>);  <span class="comment">// 推回缓冲区的长度为32</span></span><br><span class="line">		<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];    <span class="comment">// 每次读取16个字符</span></span><br><span class="line">		String lastStr = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = pr.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			String currentStr = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">			<span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>((targetIndex = (lastStr + currentStr).indexOf(<span class="string">"yesterday"</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				pr.unread((lastStr + currentStr).toCharArray());  <span class="comment">// 推回</span></span><br><span class="line">				<span class="keyword">if</span>(targetIndex &gt; <span class="number">16</span>)</span><br><span class="line">					buf = <span class="keyword">new</span> <span class="keyword">char</span>[targetIndex];</span><br><span class="line">				pr.read(buf, <span class="number">0</span>, targetIndex);  <span class="comment">// 再次读取指定长度的内容</span></span><br><span class="line">				System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, targetIndex));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.print(lastStr);</span><br><span class="line">				lastStr = currentStr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序使用<code>PushbackReader</code>输入流，试图在文件中找出 “yesterday” 字符串，然后打印出目标字符串之前的内容。注意：如果push back到推回缓冲区的内容超出了推回缓冲区的大小，会报 IOException。</p>
<hr>
<p><br></p>
<h2 id="5、重定向">5、重定向</h2><p>在Java中，<code>System.in</code>和<code>System.out</code>代表标准输入与输出，默认情况下它们分别代表键盘和显示器。</p>
<p>在 System 类里提供了三个重定向标准输入/输出的方法：</p>
<ul>
<li><code>static void setErr(PrintStream err)</code>：重定向标准错误输出流</li>
<li><code>static void setIn(InputStream in)</code>：重定向标准输入流</li>
<li><code>static void setOut(PrintStream out)</code>：重定向标准输出流</li>
</ul>
<p>示例：将 System.out 重定向到文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/out.txt"</span>));</span><br><span class="line">		System.setOut(ps);  <span class="comment">// 重定向输出到文件</span></span><br><span class="line">		System.out.print(<span class="string">"Hello Java!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<h2 id="6、RandomAccessFile">6、RandomAccessFile</h2><p><code>RandomAccessFile</code>是Java提供的功能最丰富的文件访问类，它只能读写<strong>文件</strong>，不能读写其他IO设备。与普通的输入/输出流不同的是：<code>RandomAccessFile</code>支持“随机访问”的方式，允许自由定位文件记录指针。</p>
<p>它包含了如下2个方法来操作文件记录指针：</p>
<ul>
<li><code>long getFilePointer()</code>：返回文件记录指针的位置；</li>
<li><code>void seek(long pos)</code>：将文件记录指针定位到 pos 位置。</li>
</ul>
<p>RandomAccessFile 有两个构造器：<code>RandomAccessFile(String name, String mode)</code>和<code>RandomAccessFile(File file, String mode)</code>，第二个参数 mode 指定文件的访问模式：</p>
<ul>
<li><code>&quot;r&quot;</code>：以只读的方式打开指定文件；</li>
<li><code>&quot;rw&quot;</code>：以读、写的方式打开指定文件，如果文件不存在，创建该文件；</li>
<li><code>&quot;rws&quot;</code>：以读、写的方式打开指定文件。相对于”rw”，要求对“文件内容”或“元数据”的每个更新都同步写入到底层存储设备。</li>
<li><code>&quot;rwd&quot;</code>：以读、写的方式打开指定文件。相对于”rw”，要求对“文件内容”的每个更新都同步写入到底层存储设备。（不对metadata同步更新）</li>
</ul>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:/a.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">		System.out.println(<span class="string">"文件指针的初始位置："</span> + raf.getFilePointer());</span><br><span class="line">		raf.seek(<span class="number">100</span>);   <span class="comment">// 从100字节处开始读</span></span><br><span class="line">        <span class="comment">//raf.seek(raf.length());   // 定位到文件尾</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = raf.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RandomAccessFile 的 read() 方法、write() 方法与 InputStream/OutputStream 类似。</p>
<hr>
<p><br></p>
<h2 id="7、对象序列化（Serialize）">7、对象序列化（Serialize）</h2><h3 id="&gt;&gt;_序列化的含义和意义"><strong>&gt;&gt; 序列化的含义和意义</strong></h3><ul>
<li><p>含义：<strong>序列化机制</strong>允许将内存中的Java对象转换成<strong>字节序列</strong>，保存到磁盘上或通过网络进行传输；其他程序（从磁盘上或从网络上）获取到这些字节序列，就可以将这些字节序列恢复成原来的Java对象。</p>
</li>
<li><p>意义：序列化使得对象可以脱离程序的运行而独立存在，它是RMI（Remote Method Invoke，即远程方法调用）的参数和返回值必须实现的机制，而 RMI 又是Java EE技术的基础 —— 所有的分布式应用都需要跨平台、跨网络，所以序列化也是分布式技术的基础。</p>
</li>
</ul>
<h3 id="&gt;&gt;_使用”对象流”实现序列化"><strong>&gt;&gt; 使用”对象流”实现序列化</strong></h3><p>若想将某个对象序列化，该对象的类需要实现<code>Serializable</code>接口或<code>Externalizable</code>接口。</p>
<p>这里先讲<code>Serializable</code>，步骤如下：</p>
<ol>
<li>让目标类实现<code>Serializable</code>标记接口即可，无须实现任何方法；</li>
<li>创建一个<code>ObjectOutputStream</code>对象输出流，调用<code>writeObject()</code>方法将目标类的对象输出到磁盘或网络；</li>
</ol>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"带参数的构造器"</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/person.txt"</span>));</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="string">"科比·布莱恩特"</span>,<span class="number">38</span>);</span><br><span class="line">		oos.writeObject(person);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面程序，一个Person对象被序列化输出到文件中，该文件的内容就是<code>person</code>对象。</p>
<p><img src="http://img.blog.csdn.net/20160329230042893" alt=""></p>
<p>可以看到文件的内容是乱码的，因为是二进制。</p>
<p>如果希望从二进制流中恢复Java对象，则需要使用反序列化（Deserialize），步骤如下：</p>
<ol>
<li>创建一个<code>ObjectInputStream</code>输入流（这是一个处理流），从文件中读取二进制流。</li>
<li>调用<code>readObject()</code>方法读取流中的对象，该方法返回一个 Object 类型的对象，再强制类型转换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:/person.txt"</span>));</span><br><span class="line">		Person p = (Person)ois.readObject();</span><br><span class="line">		System.out.println(<span class="string">"名字："</span> + p.getName() + <span class="string">"\n年龄："</span> + p.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li><p>反序列化恢复Java对象时，必须提供该对象所属类的 class 文件，否则将报<code>ClassNotFoundException</code>异常。</p>
</li>
<li><p>反序列化恢复Java对象时，并没有看到程序调用构造器，这表明反序列化机制无须通过构造器来初始化Java对象。</p>
</li>
<li><p>当一个可序列化类有多个父类时，这些父类要么有无参数的构造器，要么也是可序列化的，否则将抛出<code>InvalidClassException</code> —— 父类最好都是可序列化的，因为如果某个父类不可序列化，而只是带有无参数构造器，那么该父类中定义的成员变量值不会序列化到二进制流中。</p>
</li>
</ul>
<h3 id="&gt;&gt;_多次序列化同一个对象"><strong>&gt;&gt; 多次序列化同一个对象</strong></h3><p>如果某个类的成员变量是另一种引用类型，那么这个引用类也必须是可序列化的，否则拥有该类型成员变量的类是不可序列化的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Person student;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, Person student)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此处省略成员变量的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Teacher对象持有一个Person对象的引用，当尝试序列化一个Teacher对象时，程序会顺带将该Person对象也进行序列化，所以Person类也必须是可序列化的，否则Teacher类将不可序列化。</p>
<p>先假设有如下一种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/a.txt"</span>));</span><br><span class="line">		Person student = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>, <span class="number">500</span>);</span><br><span class="line">		Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">"唐僧"</span>, student);</span><br><span class="line">		Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">"菩提师祖"</span>, student);</span><br><span class="line">		oos.writeObject(t1);</span><br><span class="line">		oos.writeObject(t2);</span><br><span class="line">		oos.writeObject(student);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当序列化 t1 对象时，程序会顺带序列化 student 对象；当序列化 t2 对象时，程序一样会顺带序列化 student 对象；最后再显式序列化了 student 对象 —— 也就是说<code>student</code>对象被序列化了三次。</p>
<p>如果程序向输出流中写入了三个student对象，那么反序列化恢复时将得到三个student对象，也就是说反序列化后，t1 和 t2 所引用的不是同一个Person对象，这显然就出现了Bug！为了避免这种情况的出现，Java采用了一种特殊的序列化算法：</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号；</li>
<li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过了。若没有，系统才会将该对象转换成字节序列输出；</li>
<li>如果某个对象已经序列化过了，程序将直接输出一个序列化编号，不会重复序列化该对象。</li>
</ul>
<p>++所以当多次调用<code>writeObject()</code>输出同一个对象时，只有第一次调用会将该对象转换成字节序列输出。++</p>
<p>验证一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:/a.txt"</span>));</span><br><span class="line">		Teacher t1 = (Teacher)ois.readObject();</span><br><span class="line">		Teacher t2 = (Teacher)ois.readObject();</span><br><span class="line">		Person stu = (Person)ois.readObject();</span><br><span class="line">		System.out.println(t1.getStudent() == stu);  <span class="comment">// true</span></span><br><span class="line">		System.out.println(t2.getStudent() == stu);  <span class="comment">// true</span></span><br><span class="line">		<span class="comment">// 反序列化时读的顺序，必须和序列化时写的顺序一致。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="&gt;&gt;_transient关键字"><strong>&gt;&gt; transient关键字</strong></h3><p>如果一个类中的某些实例变量是敏感信息，或者是不可序列化的，因此不希望对该实例变量进行<strong>递归序列化</strong>，则可以使用<code>transient</code>关键字修饰该实例变量，那么在Java对象序列化时 该变量就会被系统忽略掉。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;   <span class="comment">// transient只能修饰实例变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"带参数的构造器"</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略成员变量的setter方法和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被<code>transient</code>关键字修饰的 age 变量将被完全隔离在序列化机制之外，反序列化恢复后将无法取得该成员变量的值。</p>
<h3 id="&gt;&gt;_Externalizable序列化机制"><strong>&gt;&gt; Externalizable序列化机制</strong></h3><p>前面介绍了要让某个类的对象可序列化，该类只要实现<code>Serializable</code>接口，不用实现任何方法。Java还提供了另一种序列化机制 —— 实现<code>Externalizable</code>接口，并实现下面两个方法：</p>
<ul>
<li><p><code>void writeExternal(ObjectOutput out)</code>：实现序列化，调用ObjectOutput的writeObject()方法；</p>
</li>
<li><p><code>void readExternal(ObjectInput in)</code>：实现反序列化，调用ObjectInput的readObject()方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"带参数的构造器"</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略成员变量的setter方法和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">		out.writeInt(age);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">			ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();</span><br><span class="line">		<span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 Externalizable 接口并重写两个方法以后，其余的步骤跟前面一样。</p>
<p>那么，这两种序列化机制有什么不同呢？</p>
<table>
<thead>
<tr>
<th style="text-align:left">实现Serializable接口</th>
<th style="text-align:left">实现Externalizable接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">系统自动存储必要信息</td>
<td style="text-align:left">程序员决定存储哪些信息</td>
</tr>
<tr>
<td style="text-align:left">Java内建支持，易于实现，只需实现该接口，无须任何代码支持</td>
<td style="text-align:left">仅仅提供两个空方法，实现该接口必须为两个空方法提供实现</td>
</tr>
<tr>
<td style="text-align:left">性能略差</td>
<td style="text-align:left">性能略好</td>
</tr>
</tbody>
</table>
<p>虽然实现 Externalizable 接口能带来一定的性能提升，但导致了编程复杂度的增加，所以大部分时候都采用 Serializable 接口的方式。</p>
<h3 id="&gt;&gt;_版本兼容"><strong>&gt;&gt; 版本兼容</strong></h3><p>前面提到了，反序列化时必须提供对象的所属类的 class 文件。但是，如果类定义被修改导致 class 文件变了呢？</p>
<ul>
<li>如果修改类时仅仅修改了方法，反序列化不受影响</li>
<li>如果修改类时仅仅修改了静态变量或 transient 修饰的变量，反序列化同样不受影响</li>
<li>如果修改类时修改了未被 transient 修饰的实例变量，版本不兼容，则反序列化可能会失败</li>
</ul>
<p>Java序列化机制允许为类提供一个<code>private static final long</code>的<code>serialVersionUID</code>值，该类变量的值用于标识该 Java 类的序列化版本。即便一个类升级了，只要它的 serialVersionUID 类变量值保持不变，序列化机制也会把它们当成同一个序列化版本。</p>
<p>JDK提供了一个<code>serialver</code>命令行工具来生成一个类的 serialVersionUID 版本值：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ serialver com.songlee.test.Person</span><br><span class="line">com.songlee.test.<span class="string">Person:</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="typename">long</span> serialVersionUID = <span class="number">2790932326217855955</span>L;</span><br></pre></td></tr></table></figure></p>
<p>显示指定 serialVersionUID 有利于程序在不同 JVM 之间移植，避免类定义没有改变却因为JVM不同导致版本不兼容的情况出现。</p>
<hr>
<p><br></p>
<h2 id="8、NIO">8、NIO</h2><p>前面介绍的<code>java.io.</code>包下的输入/输出流都是<strong>阻塞式</strong>的，而且，面向流的输入/输出通常效率不高，故 Java 从1.4版本开始，引入了一系列改进的输入/输出处理的新功能，这些新功能统称为<strong>新IO（New IO，简称NIO）</strong>。</p>
<h3 id="&gt;&gt;_Java_NIO概述"><strong>&gt;&gt; Java NIO概述</strong></h3><p>NIO新增了许多IO处理的类，这些类都被放在<code>java.nio</code>包下。与传统IO采用流处理模型不同的是，NIO采用<strong>内存映射文件</strong>的方式来处理输入/输出，即将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了，这种方式比传统IO要快得多。</p>
<table>
<thead>
<tr>
<th style="text-align:left">IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向流（Stream-oriented）</td>
<td style="text-align:left">面向块/缓冲（Buffer-oriented）</td>
</tr>
<tr>
<td style="text-align:left">阻塞IO（Blocking IO）</td>
<td style="text-align:left">非阻塞IO（Non-blocking IO）</td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">选择器（Selectors）</td>
</tr>
</tbody>
</table>
<p>Java NIO主要有3个核心部分：</p>
<ul>
<li><code>Channel</code>（通道）</li>
<li><code>Buffer</code>（缓冲）</li>
<li><code>Selector</code>（选择器）</li>
</ul>
<h3 id="&gt;&gt;_Channel">&gt;&gt; Channel</h3><p>在NIO中所有的输入输出都是从一个<code>Channel</code>开始。Channel（通道）类似于传统的流对象，但与传统的流对象有两个主要的区别：</p>
<ol>
<li>Channel提供了一个<code>map()</code>方法，可以直接将“一块数据”映射到Buffer中；</li>
<li>程序不能直接访问Channel中的数据，读写都不行，Channel只能与Buffer进行交互。</li>
</ol>
<p>也就是说，程序必须通过读写Buffer来访问Channel中的数据。</p>
<p><img src="http://img.blog.csdn.net/20160330115401052" alt=""></p>
<hr>
<p>下面是Java NIO中一些主要的Channel实现：</p>
<ul>
<li>FileChannel</li>
<li>Pipe.SinkChannel、Pipe.SourceChannel</li>
<li>SocketChannel、ServerSocketChannel</li>
<li>DatagramChannel</li>
</ul>
<p>可以看出这些通道涵盖了管道IO、UDP和TCP网络IO，以及文件IO等 —— <strong>除了FileChannel之外，其他的Channel都可以通过</strong><code>configureBlocking(false)</code><strong>方法设置为非阻塞模式</strong>，这也是为什么NIO称为非阻塞IO。</p>
<hr>
<p>所有的Channel都不应该通过构造器来直接创建，而应该通过传统流对象 InputStream/OutputStream 的<code>getChannel()</code>方法返回对应的Channel。通道Channel最常用的有三个方法：</p>
<ul>
<li><code>map()</code>：将Channel中的部分或全部数据映射成 ByteBuffer</li>
<li><code>read()</code>：一系列重载形式，用于读取Channel中的数据到Buffer中</li>
<li><code>write()</code>：一系列重载形式，用于将Buffer中的数据写到Channel中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:/a.txt"</span>);</span><br><span class="line">		FileChannel inChannel = <span class="keyword">new</span> FileInputStream(file).getChannel();</span><br><span class="line">		FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/b.txt"</span>).getChannel();</span><br><span class="line">		<span class="comment">// 将a.txt文件中的全部数据映射成ByteBuffer</span></span><br><span class="line">		ByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, file.length());</span><br><span class="line">		outChannel.write(buffer);  <span class="comment">// 再将数据写到outChannel，输出到b.txt文件</span></span><br><span class="line">		</span><br><span class="line">		buffer.clear();</span><br><span class="line">		CharBuffer charBuf = Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer);</span><br><span class="line">		System.out.println(charBuf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过 map 一次将全部数据映射到 Buffer 中，当然也可以使用Channel的 read/write 方法多次读写，类似于传统IO一样。</p>
<h3 id="&gt;&gt;_Buffer">&gt;&gt; Buffer</h3><p><code>Buffer</code>（缓冲）是一个抽象类，它用于和Channel交互。在Java NIO中的一些常用的Buffer实现有：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>实际使用较多的是<code>ByteBuffer</code>和<code>CharBuffer</code>，其中 ByteBuffer 还有一个子类<code>MappedByteBuffer</code>，它是 Channel.map() 方法的返回类型。</p>
<hr>
<p>在Buffer中有三个重要的概念：</p>
<ul>
<li><strong>容量（capacity）</strong>：该Buffer的最大数据容量，创建后不能改变。</li>
<li><strong>界限（limit）</strong>：该Buffer中的一个位置索引，位于 limit 后的数据不可读也不可写。</li>
<li><strong>位置（position）</strong>：用于指明下一个被读或被写的位置的索引。（类似于传统IO中的记录指针）</li>
</ul>
<p>另外，Buffer还支持一个可选的标记 mark（类似于传统IO流中的mark），通过<code>reset()</code>方法可以将 position 定位到 mark 处。这些值满足大小关系：<code>0 ≤ mark ≤ position ≤ limit ≤ capacity</code>：</p>
<p><img src="http://img.blog.csdn.net/20160330163602708" alt=""></p>
<hr>
<p>Buffer类都没有构造器，需通过各实现类的静态方法<code>XxxBuffer.allocate(int capacity)</code>来创建。 —— 刚创建时 position=0，limit=capacity，当通过 put() 方法或从Channel中读取一些数据放入Buffer中时，position会相应地向后移动。当装入数据结束后：</p>
<ul>
<li><code>flip()</code>：调用Buffer的 flip() 方法，limit置为position，position置0，为从Buffer中取出数据做好准备。</li>
<li><code>clear()</code>：数据读取完以后，调用Buffer的 clear() 方法，该方法将 position置0，limit置为capacity，回到刚创建时的状态，为再次装入数据做好准备。</li>
</ul>
<p>下面的代码可以验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		CharBuffer buffer = CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">		System.out.println(<span class="string">"position:"</span>+buffer.position());</span><br><span class="line">		System.out.println(<span class="string">"limit:"</span>+buffer.limit());</span><br><span class="line">		System.out.println(<span class="string">"capacity:"</span>+buffer.capacity());</span><br><span class="line">		</span><br><span class="line">		buffer.put(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(<span class="string">"放入一些数据后, position："</span>+buffer.position());</span><br><span class="line">		</span><br><span class="line">		buffer.flip();       <span class="comment">// 准备读取数据</span></span><br><span class="line">		System.out.println(<span class="string">"执行flip方法后, position:"</span>+buffer.position());</span><br><span class="line">		System.out.println(<span class="string">"执行flip方法后, limit:"</span>+buffer.limit());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"通过get方法读取数据："</span>+buffer.get()+buffer.get());</span><br><span class="line">		System.out.println(<span class="string">"读取一些数据后，position: "</span>+buffer.position());</span><br><span class="line">		</span><br><span class="line">		buffer.clear();     <span class="comment">// 回到刚创建时的状态</span></span><br><span class="line">		System.out.println(<span class="string">"执行clear方法后, position:"</span>+buffer.position());</span><br><span class="line">		System.out.println(<span class="string">"执行clear方法后, limit:"</span>+buffer.limit());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"绝对位置的get方法: "</span>+buffer.get(<span class="number">3</span>));  <span class="comment">// 通过绝对位置获取数据</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>Buffer提供了一系列重载形式的 put() 和 get() 方法来访问 Buffer 中的数据，分为相对和绝对两种方式：</p>
<ul>
<li>相对（Relative）：从当前 position 处开始读取或写入，然后 position 进行相应的移动。</li>
<li>绝对（Absolute）：直接根据索引（下标）向Buffer中读取或写入数据，不会影响 position 的值。</li>
</ul>
<h3 id="&gt;&gt;_Selector">&gt;&gt; Selector</h3><p>选择器<code>Selector</code>是Java里实现<strong>IO复用</strong>的概念，通过它一个线程可以管理多个Channel通道，从而管理多个网络连接。</p>
<blockquote>
<p>试想一下，如果一个线程负责处理一个网络IO，那么线程占用达到上限的时候怎么办？</p>
</blockquote>
<p>在使用 Selector 时，还涉及到两个重要的概念：</p>
<ol>
<li><p><strong>SelectableChannel</strong>：可选择的通道，使用Selector管理的通道必须都是SelectableChannel，它的特点是存在 阻塞模式 和 非阻塞模式。（除了FileChannel，其他类型的Channel都属于SelectableChannel）</p>
</li>
<li><p><strong>SelectionKey</strong>：当一个SelectableChannel向Selector中注册时，就会创建并返回一个选择键。简单点说，SelectionKey就是通道在 Selector 中的注册的标记。它维护了两个集合：</p>
<ul>
<li>interest集合：表示选择器对该channel的哪些操作感兴趣，只会检测这些操作是否准备就绪。</li>
<li>ready集合：表示该channel已经为这些操作准备就绪。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();       <span class="comment">// 创建一个Selector</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);          <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>
<p>与向Selector注册之前，Channel必须处于非阻塞模式下。注意<code>register()</code>方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听该Channel时对什么操作感兴趣 —— 可监听以下四种类型：</p>
<ul>
<li>SelectionKey.OP_CONNECT：连接</li>
<li>SelectionKey.OP_ACCEPT：接收</li>
<li>SelectionKey.OP_READ：读</li>
<li>SelectionKey.OP_WRITE：写</li>
</ul>
<p>当你向Selector注册了多个通道以后，准备开始工作了，就可以调用几个重载的 select() 方法来检测有哪些channel准备就绪了（该channel至少有一种操作准备就绪）：</p>
<ul>
<li><code>select()</code>：阻塞到至少有一个通道的一个interest操作准备就绪了。</li>
<li><code>select(long timeout)</code>：同样会阻塞，但超时会返回。</li>
<li><code>selectNow()</code>：不会阻塞</li>
</ul>
<p>上述三个方法均返回的是本次执行select时已经准备就绪的channel数；如果不为 0，就可以调用selector的<code>selectedKeys()</code>方法，得到这些已就绪的channel对应的 SelectionKey 对象的集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(selector.select() != <span class="number">0</span>) &#123;</span><br><span class="line">	Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">	Iterator it = keys.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">		SelectionKey k = (SelectionKey)it.next();</span><br><span class="line">		<span class="keyword">if</span>(k.isAcceptable()) &#123;  </span><br><span class="line">	        <span class="comment">// a connection was accepted by a ServerSocketChannel.  </span></span><br><span class="line">	    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(k.isConnectable()</span>) </span>&#123;  </span><br><span class="line">	        <span class="comment">// a connection was established with a remote server.  </span></span><br><span class="line">	    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(k.isReadable()</span>) </span>&#123;  </span><br><span class="line">	        <span class="comment">// the channel is ready for reading  </span></span><br><span class="line">	    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(k.isWritable()</span>) </span>&#123;  </span><br><span class="line">	        <span class="comment">// the channel is ready for writing  </span></span><br><span class="line">	    &#125;</span><br><span class="line">		it.remove();   <span class="comment">// 手动移除</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码遍历已就绪的SelectionKey集合，并检测选择键所对应的channel的就绪事件。</p>
<p>当得到已就绪的SelectionKey集合后，调用<code>SelectionKey.channel()</code>方法就可以得到每个SelectionKey所对应的channel对象，然后就可以对通道进行处理了。通常，我们使用Selector单线程来监控多个通道，而对于select得到的channel和对应的IO操作，就可以开辟新线程或者使用线程池来处理。这也正是IO复用的意义所在。</p>
<h3 id="&gt;&gt;_字符集和Charset">&gt;&gt; 字符集和Charset</h3><p>对于计算机里二进制与字符之间的转换，涉及到两个概念：<strong>编码（Encode）</strong> 和 <strong>解码（Decode）</strong>。</p>
<p><img src="http://img.blog.csdn.net/20160330173916938" alt=""></p>
<p>Java 1.4提供了<code>Charset</code>来处理二进制和字符之间的转换，该类包含了创建解码器和编码器的方法，还提供了一个<code>availableCharsets()</code>静态方法来获取 Charset 所支持的所有字符集。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SortedMap&lt;String, Charset&gt; map = Charset.availableCharsets();</span><br><span class="line">		map.keySet().forEach((str) -&gt; System.out.println(map.get(str))); <span class="comment">// 输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码使用 lambda 表达式遍历输出系统支持的所有字符集 —— Java默认使用 Unicode 字符集，但有些操作系统并不使用 Unicode 字符集，那么程序读取数据时就可能出现乱码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line">CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line">ByteBuffer byteBuf = encoder.encode(charBuf);</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line">CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">CharBuffer charBuf = decoder.decode(byteBuf);</span><br></pre></td></tr></table></figure></p>
<p>Charset对象的<code>newEncoder()</code>和<code>newDecoder()</code>可以创建编码器和解码器，然后就可以进行二进制和字符的相互转换了。</p>
<h3 id="&gt;&gt;_文件锁">&gt;&gt; 文件锁</h3><p>从Java 1.4开始NIO中引入了<code>FileLock</code>文件锁，使用文件锁可以有效地阻止多个进程并发修改同一个文件，文件锁可以控制文件的全部或部分字节的访问。<code>FileChannel</code>中提供了阻塞/非阻塞的两个方法来获取 FileLock 对象：</p>
<ul>
<li><code>lock()</code>：试图锁定某个文件并返回 FileLock 对象，如果无法得到文件锁，程序将一直阻塞。</li>
<li><code>tryLock()</code>：尝试锁定某个文件，它将直接返回而不是阻塞，如果获得了文件锁，返回该 FileLock 对象，否则返回 null。</li>
</ul>
<p>上述两个方法还有两个重载形式，用于对部分文件内容而非整个文件加锁：</p>
<ul>
<li><code>lock(long position, long size, boolean shared)</code>：对文件从 position 开始，长度为 size 的部分内容加锁。参数 shared 为true时，该锁是一个共享锁；shared 为false时，该锁是一个互斥锁。</li>
<li><code>tryLock(long position, long size, boolean shared)</code>：非阻塞式的加锁方法，参数作用同上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FileChannel channel = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/a.txt"</span>).getChannel();</span><br><span class="line">		FileLock lock = channel.tryLock();  <span class="comment">// 使用非阻塞的方式获取文件锁</span></span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		lock.release();   <span class="comment">// 释放文件锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完文件后通过 FileLock 的 release() 方法释放文件锁。</p>
<hr>
<p><br></p>
<h2 id="9、NIO-2">9、NIO.2</h2><p>在Java 4引入了NIO后，Java 7又对原有的NIO进行了重大改进：</p>
<ul>
<li>提供了全面的文件IO和文件系统访问支持，位于<code>java.nio.file</code>包下；</li>
<li>基于异步Channel的IO。</li>
</ul>
<p>Java 7把这种改进称为<strong>NIO.2</strong></p>
<h3 id="&gt;&gt;Path、Paths和Files"><strong>&gt;&gt;Path、Paths和Files</strong></h3><p>早期的Java只提供了一个 File 类来访问文件系统，但 File 类的功能比较有限，方法性能也不高，而且大多数方法在出错时仅返回失败而不会提供异常信息。为了弥补这种不足，NIO.2 引入了<code>Path</code>接口和<code>Files</code>、<code>Paths</code>两个工具类。</p>
<ul>
<li><code>Path</code>：代表一个平台无关的平台路径；</li>
<li><code>Paths</code>：工具类，包含了两个返回 Path 的静态工厂方法，比如<code>Path path = Paths.get(&quot;.&quot;)</code>；</li>
<li><code>Files</code>：工具类，包含了大量的操作文件的静态方法，例如文件复制、文件读写、列出路径下所有文件目录等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"."</span>);                 <span class="comment">// 。表示当前路径</span></span><br><span class="line">		Files.list(path).forEach(p -&gt; System.out.println(p));</span><br><span class="line">		Files.isHidden(Paths.get(<span class="string">"b.txt"</span>));         <span class="comment">// 判断是否是隐藏文件</span></span><br><span class="line">		Files.size(Paths.get(<span class="string">"out.txt"</span>));           <span class="comment">// 获取文件大小</span></span><br><span class="line">		FileStore C = Files.getFileStore(Paths.get(<span class="string">"C:"</span>));   <span class="comment">// C盘</span></span><br><span class="line">		System.out.println(<span class="string">"C盘全部空间:"</span> + C.getTotalSpace());</span><br><span class="line">		System.out.println(<span class="string">"C盘可用空间:"</span> + C.getUsableSpace());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们应该熟悉 Files 工具类，它可以大大简化文件系统的访问。更多请自行查询API。</p>
<h3 id="&gt;&gt;FileVisitor遍历文件和目录"><strong>&gt;&gt;FileVisitor遍历文件和目录</strong></h3><p>早期Java版本中，如果要遍历指定目录下的所有文件和子目录，只能进行递归遍历，复杂且灵活性低。</p>
<p>NIO引入了 Files 工具类以后，现在可以用更优雅的方式遍历文件和子目录了。首先，我们需要实现一个<code>FileVisitor</code>文件访问器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFileVisitor</span> <span class="keyword">implements</span> <span class="title">FileVisitor</span>&lt;<span class="title">Path</span>&gt; </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir,</span><br><span class="line">			BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问子目录之前触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问子目录之后触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问file文件时触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问file文件失败时触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述四个方法都返回一个<code>FileVisitorResult</code>对象，它是一个枚举类，代表了访问之后的后续行为。</p>
<ul>
<li><code>CONTINUE</code>：继续访问；</li>
<li><code>SKIP_SIBLINGS</code>：继续访问，但不访问该文件/目录的兄弟文件/目录；</li>
<li><code>SKIP_SUBTREE</code>：继续访问，但不访问该文件/目录的子目录树；</li>
<li><code>TERMINATE</code>：中止访问。</li>
</ul>
<p>实际使用时没必要实现全部的4个方法，所以Java提供了一个 SimpleFileVisitor 简化版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"."</span>);                 <span class="comment">// 。表示当前路径</span></span><br><span class="line">		Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span><br><span class="line">			            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			        System.out.println(<span class="string">"正在访问 "</span>+ file + <span class="string">" 文件"</span>);</span><br><span class="line">			        <span class="keyword">if</span>(file.endsWith(<span class="string">"MyClass.java"</span>)) &#123;</span><br><span class="line">			        	System.out.println(<span class="string">"---已找到目标文件---"</span>);</span><br><span class="line">			        	<span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">			        &#125;</span><br><span class="line">			        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">			    &#125;</span><br><span class="line">				</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">			    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir,</span><br><span class="line">			            BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			        System.out.println(<span class="string">"正在访问 "</span> + dir + <span class="string">" 目录"</span>);</span><br><span class="line">			        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">			    &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上面代码，Files工具类提供了静态方法<code>Files.walkFileTree(Path, FileVisitor)</code>用于遍历指定目录下的所有文件和目录，当找到以 MyClass.java 结尾的目标文件后，程序停止遍历。—— 本程序可用于对指定目录进行搜索。</p>
<h3 id="&gt;&gt;_WatchService监控文件变化">&gt;&gt; WatchService监控文件变化</h3><p>NIO.2的<code>Path</code>类提供了一个方法，可以优雅地监控指定目录下文件的变化：</p>
<ul>
<li><code>register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events)</code></li>
</ul>
<p>其中 WatchService 代表一个文件系统监听服务，它负责监听path目录下的文件变化；event参数指定要监听哪些类型的事件。</p>
<p>一旦使用register()完成注册之后，就可以调用WatchService的三个方法来获取被监听目录的文件变化事件：</p>
<ul>
<li><code>WatchKey poll()</code>:获取下一个WatchKey，如果没有WatchKey发生就立即返回null；</li>
<li><code>WatcheKey poll(long timeout,TimeUnit unit)</code>:尝试等待timeout时间去获取下一个WatchKey；</li>
<li><code>WatchKey take()</code>:获取下一个WatchKey，如果没有发生就一直等待。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		WatchService watcher = FileSystems.getDefault().newWatchService();</span><br><span class="line">		Path path = Paths.get(<span class="string">"D:/"</span>);</span><br><span class="line">		path.register(watcher,         <span class="comment">// 注册</span></span><br><span class="line">				StandardWatchEventKinds.ENTRY_CREATE,</span><br><span class="line">				StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">				StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			WatchKey key = watcher.take();   <span class="comment">// 获取下一个文件变化事件</span></span><br><span class="line">			<span class="keyword">for</span>(WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">				System.out.println(event.context()+<span class="string">" 文件发生了 "</span>+event.kind()+<span class="string">"事件！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!key.reset()) &#123;  <span class="comment">// 重设WatchKey，重设失败则退出监听</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序监听D:盘下文件的新建、修改和删除事件。如果程序需要一直监控，则应该使用<code>take()</code>阻塞式方法；如果只需要监控指定时间，则可以考虑使用<code>poll()</code>方法。</p>
<h3 id="&gt;&gt;_访问文件属性">&gt;&gt; 访问文件属性</h3><p>本章开头介绍了，传统的<code>File</code>类可以获取一些简单的文件属性，比如最后修改时间、文件长度、是否隐藏文件等。</p>
<p>为了获取或修改更多的文件属性，NIO.2在<code>java.nio.file.attribute</code>包下提供了大量的工具类，运用这些工具类，开发者可以非常简单地读取、修改文件属性。这些工具类主要分为以下两类：</p>
<ul>
<li><code>XxxAttributeView</code>：代表某种文件属性的视图。</li>
<li><code>XxxAttributes</code>：代表某种文件属性的集合，程序一般通过 XxxAttributeView 对象获取 XxxAttributes。</li>
</ul>
<p>这里只介绍两种，很多请自行查询：</p>
<ul>
<li>BasicFileAttributeView：它可以获取或修改文件的基本属性，包括文件的最后修改时间，最后访问时间，创建时间，大小，是否为目录，是否为符号链接等。它的readAttribute()方法返回一个BasicFileAttributes对象，对文件夹基本属性的修改是通过BasicFileAtributes对象完成。</li>
<li>DosFileAttributeView：它主要用于获取或修改文件DOS相关属性，比如文件是否只读，是否隐藏，是否是系统文件，是否是存档文件等。它的readAttributes()方法返回一个DosFileAttributes对象对这些属性的修改其实是由DosfileAttributes对象来完成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path=Paths.get(<span class="string">"D:/a.txt"</span>);  </span><br><span class="line">        BasicFileAttributeView attrView = Files.getFileAttributeView(path, BasicFileAttributeView.class);  </span><br><span class="line">        BasicFileAttributes attrs = attrView.readAttributes();  </span><br><span class="line">        System.out.println(<span class="string">"创建时间"</span> + <span class="keyword">new</span> Date(attrs.creationTime().toMillis()));  </span><br><span class="line">        System.out.println(<span class="string">"文件大小"</span> + attrs.size());  </span><br><span class="line">        DosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class);  </span><br><span class="line">        dosView.setHidden(<span class="keyword">true</span>);  </span><br><span class="line">        dosView.setReadOnly(<span class="keyword">true</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Java/">
                #Java
              </a>
            
          </div>
        

        
          <div class="post-nav">
            <div class="post-nav-prev post-nav-item">
              
            </div>

            <div class="post-nav-next post-nav-item">
              
                <a href="/2016/03/19/java-basic-note-3/">Java基础笔记（三） 多线程</a>
              
            </div>
          </div>
        

        
        
      </div>
    
  </div>



  
    <div class="comments" id="comments">
      
        <div class="ds-thread" data-thread-key="2016/03/31/java-basic-note-4/"
             data-title="Java基础笔记（四） IO/NIO与序列化" data-url="http://yoursite.com/2016/03/31/java-basic-note-4/">
        </div>

      
    </div>
  

          </div>

          
        </div>

        
<div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>

<div id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview">
          站点概览
        </li>
      </ul>
    

    <div class="site-overview">
      <div class="site-author motion-element">
        <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/6904366?v=3&s=140" alt="Song Lee" />
        <p class="site-author-name">Song Lee</p>
      </div>
      <p class="site-description motion-element">放宽心，多努力</p>
      <div class="site-state motion-element">
        <div class="site-state-item site-state-posts">
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </div>
        <div class="site-state-item site-state-tags">
            <span class="site-state-item-count">28</span>
            <span class="site-state-item-name">标签</span>
        </div>
        <div class="site-state-item site-state-pages">
            <span class="site-state-item-count">4</span>
            <span class="site-state-item-name">页面</span>
        </div>
      </div>

      
        <div class="feed-link motion-element">
          <a href="/atom.xml">
            <i class="menu-item-icon icon-feed"></i>
            RSS
          </a>
        </div>
      

      <div class="links-of-author motion-element">
        
          
            <span class="links-of-author-item">
              <a href="https://github.com/SongLee24">GitHub</a>
            </span>
          
            <span class="links-of-author-item">
              <a href="http://blog.csdn.net/lisonglisonglisong">CSDN</a>
            </span>
          
            <span class="links-of-author-item">
              <a href="http://weibo.com/lisonglisong">Weibo</a>
            </span>
          
            <span class="links-of-author-item">
              <a href="http://www.douban.com/people/122455925/">DouBan</a>
            </span>
          
            <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/shen-yi-59">ZhiHu</a>
            </span>
          
        
      </div>

      
      
        <div class="cc-license motion-element">
          <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
            <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
          </a>
        </div>
      

    </div>

    
      <div class="post-toc-wrap sidebar-panel-active">
        <div class="post-toc-indicator-top post-toc-indicator"></div>
        <div class="post-toc">
          
          
            <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章_I/O与序列化"><span class="nav-number">1.</span> <span class="nav-text">第十一章 I/O与序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、File类"><span class="nav-number">1.1.</span> <span class="nav-text">1、File类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、理解Java的IO流"><span class="nav-number">1.2.</span> <span class="nav-text">2、理解Java的IO流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、处理流模型"><span class="nav-number">1.3.</span> <span class="nav-text">3、处理流模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、输入/输出流体系"><span class="nav-number">1.4.</span> <span class="nav-text">4、输入/输出流体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_转换流"><span class="nav-number">1.4.1.</span> <span class="nav-text">>> 转换流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_推回输入流"><span class="nav-number">1.4.2.</span> <span class="nav-text">>> 推回输入流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、重定向"><span class="nav-number">1.5.</span> <span class="nav-text">5、重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、RandomAccessFile"><span class="nav-number">1.6.</span> <span class="nav-text">6、RandomAccessFile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、对象序列化（Serialize）"><span class="nav-number">1.7.</span> <span class="nav-text">7、对象序列化（Serialize）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_序列化的含义和意义"><span class="nav-number">1.7.1.</span> <span class="nav-text">>> 序列化的含义和意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_使用”对象流”实现序列化"><span class="nav-number">1.7.2.</span> <span class="nav-text">>> 使用”对象流”实现序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_多次序列化同一个对象"><span class="nav-number">1.7.3.</span> <span class="nav-text">>> 多次序列化同一个对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_transient关键字"><span class="nav-number">1.7.4.</span> <span class="nav-text">>> transient关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_Externalizable序列化机制"><span class="nav-number">1.7.5.</span> <span class="nav-text">>> Externalizable序列化机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_版本兼容"><span class="nav-number">1.7.6.</span> <span class="nav-text">>> 版本兼容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、NIO"><span class="nav-number">1.8.</span> <span class="nav-text">8、NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_Java_NIO概述"><span class="nav-number">1.8.1.</span> <span class="nav-text">>> Java NIO概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_Channel"><span class="nav-number">1.8.2.</span> <span class="nav-text">>> Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_Buffer"><span class="nav-number">1.8.3.</span> <span class="nav-text">>> Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_Selector"><span class="nav-number">1.8.4.</span> <span class="nav-text">>> Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_字符集和Charset"><span class="nav-number">1.8.5.</span> <span class="nav-text">>> 字符集和Charset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_文件锁"><span class="nav-number">1.8.6.</span> <span class="nav-text">>> 文件锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、NIO-2"><span class="nav-number">1.9.</span> <span class="nav-text">9、NIO.2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#>>Path、Paths和Files"><span class="nav-number">1.9.1.</span> <span class="nav-text">>>Path、Paths和Files</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>FileVisitor遍历文件和目录"><span class="nav-number">1.9.2.</span> <span class="nav-text">>>FileVisitor遍历文件和目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_WatchService监控文件变化"><span class="nav-number">1.9.3.</span> <span class="nav-text">>> WatchService监控文件变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#>>_访问文件属性"><span class="nav-number">1.9.4.</span> <span class="nav-text">>> 访问文件属性</span></a></li></ol></li></ol></li></ol></div>
          
        </div>
        <div class="post-toc-indicator-bottom post-toc-indicator"></div>
      </div>
    

  </div>
</div>


      </div>
    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2014 - 
  2016
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Song Lee</span>
</div>

<div class="powered-by">
  <div style="float:left;margin-top:7px;margin-right:10px;">
	<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254974724'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1254974724%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".fancybox").fancybox();
    });
  </script>

  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  
  
<script type="text/javascript" id="bootstrap.scrollspy.custom">
  /* ========================================================================
  * Bootstrap: scrollspy.js v3.3.2
  * http://getbootstrap.com/javascript/#scrollspy
  * ========================================================================
  * Copyright 2011-2015 Twitter, Inc.
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  * ======================================================================== */

  /**
   * Custom by iissnan
   *
   * - Add a `clear.bs.scrollspy` event.
   * - Esacpe targets selector.
   */


  +function ($) {
    'use strict';

    // SCROLLSPY CLASS DEFINITION
    // ==========================

    function ScrollSpy(element, options) {
      this.$body          = $(document.body)
      this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
      this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
      this.selector       = (this.options.target || '') + ' .nav li > a'
      this.offsets        = []
      this.targets        = []
      this.activeTarget   = null
      this.scrollHeight   = 0

      this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
      this.refresh()
      this.process()
    }

    ScrollSpy.VERSION  = '3.3.2'

    ScrollSpy.DEFAULTS = {
      offset: 10
    }

    ScrollSpy.prototype.getScrollHeight = function () {
      return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }

    ScrollSpy.prototype.refresh = function () {
      var that          = this
      var offsetMethod  = 'offset'
      var offsetBase    = 0

      this.offsets      = []
      this.targets      = []
      this.scrollHeight = this.getScrollHeight()

      if (!$.isWindow(this.$scrollElement[0])) {
        offsetMethod = 'position'
        offsetBase   = this.$scrollElement.scrollTop()
      }

      this.$body
        .find(this.selector)
        .map(function () {
          var $el   = $(this)
          var href  = $el.data('target') || $el.attr('href')
          var $href = /^#./.test(href) && $(escapeSelector(href)) // Need to escape selector.

          return ($href
            && $href.length
            && $href.is(':visible')
            && [[$href[offsetMethod]().top + offsetBase, href]]) || null
        })
        .sort(function (a, b) { return a[0] - b[0] })
        .each(function () {
          that.offsets.push(this[0])
          that.targets.push(this[1])
        })


    }

    ScrollSpy.prototype.process = function () {
      var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
      var scrollHeight = this.getScrollHeight()
      var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
      var offsets      = this.offsets
      var targets      = this.targets
      var activeTarget = this.activeTarget
      var i

      if (this.scrollHeight != scrollHeight) {
        this.refresh()
      }

      if (scrollTop >= maxScroll) {
        return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
      }

      if (activeTarget && scrollTop < offsets[0]) {
        $(this.selector).trigger('clear.bs.scrollspy')  // Add a custom event.
        this.activeTarget = null
        return this.clear()
      }

      for (i = offsets.length; i--;) {
        activeTarget != targets[i]
          && scrollTop >= offsets[i]
          && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
          && this.activate(targets[i])
      }
    }

    ScrollSpy.prototype.activate = function (target) {
      this.activeTarget = target

      this.clear()

      var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

      var active = $(selector)
        .parents('li')
        .addClass('active')

      if (active.parent('.dropdown-menu').length) {
        active = active
          .closest('li.dropdown')
          .addClass('active')
      }

      active.trigger('activate.bs.scrollspy')
    }

    ScrollSpy.prototype.clear = function () {
      $(this.selector)
        .parentsUntil(this.options.target, '.active')
        .removeClass('active')
    }


    // SCROLLSPY PLUGIN DEFINITION
    // ===========================

    function Plugin(option) {
      return this.each(function () {
        var $this   = $(this)
        var data    = $this.data('bs.scrollspy')
        var options = typeof option == 'object' && option

        if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
        if (typeof option == 'string') data[option]()
      })
    }

    var old = $.fn.scrollspy

    $.fn.scrollspy             = Plugin
    $.fn.scrollspy.Constructor = ScrollSpy


    // SCROLLSPY NO CONFLICT
    // =====================

    $.fn.scrollspy.noConflict = function () {
      $.fn.scrollspy = old
      return this
    }


    // SCROLLSPY DATA-API
    // ==================

    $(window).on('load.bs.scrollspy.data-api', function () {
      $('[data-spy="scroll"]').each(function () {
        var $spy = $(this)
        Plugin.call($spy, $spy.data())
      })
    })

  }(jQuery);
</script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0 && isDesktop()) {
        setTimeout(function () {
          $('.sidebar-toggle').trigger('click');
        }, 800);
      }
    });
  </script>



<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"2","bdPos":"left","bdTop":"195.5"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>


  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"songlee24"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
  
</body>
</html>
