<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SongLee's Blog]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-10T08:13:55.451Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python3标准库（二） re模块]]></title>
    <link href="http://yoursite.com/2014/09/01/python-library-02/"/>
    <id>http://yoursite.com/2014/09/01/python-library-02/</id>
    <published>2014-09-01T10:12:17.000Z</published>
    <updated>2015-05-10T08:13:55.451Z</updated>
    <content type="html"><![CDATA[<p><strong>正则表达式（Regular Expression）</strong>是字符串处理的常用工具，通常被用来检索、替换那些符合某个模式（Pattern）的文本。很多程序设计语言都支持正则表达式，像Perl、Java、C/C++。在 Python 中是通过标准库中的 <strong>re 模块</strong> 提供对正则的支持。</p>
<p><br></p>
<h3 id="一、正则表达式介绍">一、正则表达式介绍</h3><p><strong>1）用途</strong></p>
<p>通过使用正则表达式，可以： </p>
<ul>
<li><p>测试字符串内的模式。—— 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 <a id="more"></a></p>
</li>
<li><p>替换文本。—— 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</p>
</li>
<li><p>基于模式匹配从字符串中提取子字符串。—— 可以查找文档内或输入域内特定的文本。</p>
</li>
</ul>
<p><strong>2）语法</strong></p>
<p>本文主要介绍正则的基本语法以及 re 模块的使用，不包括如何编写高效的正则表达式、如何优化正则表达式，这些主题请看其他教程。</p>
<p>下图列出了Python支持的一些正则表达式元字符和语法：</p>
<p><img src="http://img.blog.csdn.net/20140929200042391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>3）贪婪模式与非贪婪模式</strong></p>
<p>“贪婪模式”总是尝试匹配尽可能多的字符；“非贪婪模式”则相反，总是匹配尽可能少的字符。例如，用”ab<em>“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab</em>?”，将找到”a”。</p>
<p><br></p>
<h3 id="二、使用_re_模块">二、使用 re 模块</h3><p><strong>1）编译正则表达式</strong></p>
<p>re 模块提供了 <a href="https://docs.python.org/3/library/re.html#re.compile" target="_blank" rel="external">re.compile()</a> 函数将一个字符串编译成 pattern object，用于匹配或搜索。函数原型如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>re.compile() 还接受一个可选的参数 flag，用于指定正则匹配的模式。关于匹配模式，后面将会讲到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">'ab*'</span>, re.IGNORECASE)</span><br></pre></td></tr></table></figure>
<p><strong>2）反斜杠的困扰</strong></p>
<p>在 python 的字符串中，\ 是被当做转义字符的。在正则表达式中，\ 也是被当做转义字符。这就导致了一个问题：如果你要匹配 \ 字符串，那么传递给 re.compile() 的字符串必须是”\\\\“。</p>
<p>由于字符串的转义，所以实际传递给 re.compile() 的是”\\“，然后再通过正则表达式的转义，”\\“ 会匹配到字符”\“。这样虽然可以正确匹配到字符 \，但是很麻烦，而且容易漏写反斜杠而导致 Bug。那么有什么好的解决方案呢？ </p>
<p><strong>原始字符串</strong>很好的解决了这个问题，通过在字符串前面添加一个r，表示原始字符串，不让字符串的反斜杠发生转义。那么就可以使用<code>r&quot;\\&quot;</code>来匹配字符 <code>\</code>了。</p>
<p><strong>3）pattern object 执行匹配</strong></p>
<p>一旦你编译得到了一个 pattern object，你就可以使用 pattern object 的方法或属性进行匹配了，下面列举几个常用的方法，更多请看<a href="https://docs.python.org/3/library/re.html#regular-expression-objects" target="_blank" rel="external">这里</a>。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.match" target="_blank" rel="external"><code>regex.match(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>匹配从 pos 到 endpos 的字符子串的开头。匹配成功返回一个 match object，不匹配返回 None。</li>
<li>pos 的默认值是0，endpos 的默认值是 len(string)，所以默认情况下是匹配整个字符串的开头。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = re.compile(<span class="string">"ar&#123;1&#125;"</span>)</span><br><span class="line">print(pattern.match(<span class="string">"army"</span>))     <span class="comment"># "ar"在开头，匹配成功</span></span><br><span class="line">print(pattern.match(<span class="string">"mary"</span>))     <span class="comment"># "ar"不在开头，匹配失败</span></span><br><span class="line">print(pattern.match(<span class="string">"mary"</span>, <span class="number">1</span>))  <span class="comment"># "ar"不在开头，但在子串的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(0, 2), match='ar'&gt;</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(1, 3), match='ar'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.search" target="_blank" rel="external"><code>regex.search(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>扫描整个字符串，并返回它找到的第一个匹配（Match object）。</li>
<li>和 regex.match() 一样，可以通过 pos 和 endpos 指定范围。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">"ar&#123;1&#125;"</span>)</span><br><span class="line">match = pattern.search(<span class="string">"mary"</span>)   <span class="comment"># search</span></span><br><span class="line">print(match)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(1, 3), match='ar'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.findall" target="_blank" rel="external"><code>regex.findall(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>找到所有匹配的子串，并返回一个 list 。</li>
<li>可选参数 pos 和 endpos 和上面一样。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"\d+"</span>)</span><br><span class="line">lst = pattern.findall(<span class="string">"abc1def2rst3xyz"</span>)   <span class="comment"># findall</span></span><br><span class="line">print(lst)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># ['1', '2', '3']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.finditer" target="_blank" rel="external"><code>regex.finditer(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>找到所有匹配的子串，并返回由这些匹配结果（match object）组成的迭代器。</li>
<li>可选参数 pos 和 endpos 和上面一样。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"\d+"</span>)</span><br><span class="line">p = pattern.finditer(<span class="string">"abc1def2rst3xyz"</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(3, 4), match='1'&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(7, 8), match='2'&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(11, 12), match='3'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>4）match object 获取结果</strong></p>
<p>在上面讲到，通过 pattern object 的方法（除 findall 外）进行匹配得到的返回结果都是 <strong>match object</strong>。每一个 match object 都包含了匹配到的相关信息，比如，起始位置、匹配到的子串。那么，我们如何从 match object 中提取这些信息呢？</p>
<p>match object 提供了一些方法，下面列举几个常用的方法，更多请看<a href="https://docs.python.org/3/library/re.html#match-objects" target="_blank" rel="external">这里</a>。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.match.group" target="_blank" rel="external"><code>match.group([group1, ...])</code></a>：</p>
<ul>
<li>返回 match object 中的字符串。</li>
<li>每一个 ( ) 都是一个分组，分组编号从1开始，从左往右，每遇到一个左括号，分组编号+1。</li>
<li>组 0 总是存在的，它就是整个表达式 。</li>
<li>没有参数时，group1默认为0，这时返回整个匹配到的字符串。</li>
<li>指定一个参数（整数）时，返回该分组匹配到的字符串。</li>
<li>指定多个参数时，返回由那几个分组匹配到的字符串组成的 tuple。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m)               <span class="comment"># &lt;_sre.SRE_Match object; span=(0, 11), match='Kobe Bryant'&gt;</span></span><br><span class="line">print(m.group())       <span class="comment"># Kobe Bryant</span></span><br><span class="line">print(m.group(<span class="number">1</span>))      <span class="comment"># Kobe</span></span><br><span class="line">print(m.group(<span class="number">2</span>))      <span class="comment"># Bryant</span></span><br><span class="line">print(m.group(<span class="number">1</span>, <span class="number">2</span>))   <span class="comment"># ('Kobe', 'Bryant')</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.groups" target="_blank" rel="external"><code>match.groups()</code></a>：</p>
<ul>
<li>返回由所有分组匹配到的字符串组成的 tuple。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+)\.(\d+)"</span>, <span class="string">"24.1632"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">'24'</span>, <span class="string">'1632'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.start" target="_blank" rel="external"><code>match.start([group])</code></a>：</p>
<ul>
<li>没有参数时，返回匹配到的字符串的起始位置。</li>
<li>指定参数（整数）时，返回该分组匹配到的字符串的起始位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m.start())       <span class="comment"># 0</span></span><br><span class="line">print(m.start(<span class="number">2</span>))      <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.end" target="_blank" rel="external"><code>match.end([group])</code></a>：</p>
<ul>
<li>没有参数时，返回匹配到的字符串的结束位置。</li>
<li>指定参数（整数）时，返回该分组匹配到的字符串的结束位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m.end())       <span class="comment"># 11</span></span><br><span class="line">print(m.end(<span class="number">1</span>))      <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.span" target="_blank" rel="external"><code>match.span([group])</code></a>：</p>
<ul>
<li>返回一个二元 tuple 表示匹配到的字符串的范围，即 (start, end)。</li>
<li>指定参数时，返回该分组匹配到的字符串的 (start, end)。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m.span())     <span class="comment"># (0, 11)</span></span><br><span class="line">print(m.span(<span class="number">2</span>))    <span class="comment"># (5, 11)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>5）模块级别的函数</strong></p>
<p>上面讲到的函数都是<strong>对象的方法</strong>，要使用它们必须先得到相应的对象。本节将介绍一些<strong>Module-Level Functions</strong>，比如 match()，search()，findall() 等等。你不需要创建一个 pattern object 就可以直接调用这些函数。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.compile" target="_blank" rel="external"><code>re.compile(pattern, flags=0)</code></a>：上面已经介绍过。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.match" target="_blank" rel="external"><code>re.match(pattern, string, flags=0)</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"> </span><br><span class="line">m = re.match(<span class="string">r"(\w+) (\w+)"</span>,<span class="string">"Kobe Bryant, Lakers"</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/re.html#re.search" target="_blank" rel="external"><code>re.search(pattern, string, flags=0)</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.search(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"> </span><br><span class="line">m = re.search(<span class="string">r"(\w+) (\w+)"</span>,<span class="string">"Kobe Bryant, Lakers"</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/re.html#re.findall" target="_blank" rel="external"><code>re.findall(pattern, string, flags=0)</code></a>：与上面类似。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.finditer" target="_blank" rel="external"><code>re.finditer(pattern, string, flags=0)</code></a>：与上面类似。</p>
<p><strong>6）编译标志（匹配模式）</strong></p>
<p>在讲 re.compile() 函数时，曾说到该函数还接受可选的第二个参数，用以设置<strong>匹配模式</strong>。可选的匹配模式有：</p>
<ul>
<li><p><strong>re.IGNORECASE</strong>：忽略大小写，同 <strong>re.I</strong>。</p>
</li>
<li><p><strong>re.MULTILINE</strong>：多行模式，改变^和$的行为，同 <strong>re.M</strong>。</p>
</li>
<li><p><strong>re.DOTALL</strong>：点任意匹配模式，让’.’可以匹配包括’\n’在内的任意字符，同 <strong>re.S</strong>。 </p>
</li>
<li><p><strong>re.LOCALE</strong>：使预定字符类 \w \W \b \B \s \S 取决于当前区域设定， 同 <strong>re.L</strong>。</p>
</li>
<li><p><strong>re.ASCII</strong>：使 \w \W \b \B \s \S 只匹配 ASCII 字符，而不是 Unicode 字符，同 <strong>re.A</strong>。</p>
</li>
<li><p><strong>re.VERBOSE</strong>：详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。主要是为了让正则表达式更易读，同 <strong>re.X</strong>。例如，以下两个正则表达式是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = re.compile(<span class="string">r"""\d +  # the integral part</span><br><span class="line">                   \.    # the decimal point</span><br><span class="line">                   \d *  # some fractional digits"""</span>, re.X)</span><br><span class="line">b = re.compile(<span class="string">r"\d+\.\d*"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h3 id="三、修改字符串">三、修改字符串</h3><p>第二部分讲的是字符串的匹配和搜索，但是并没有改变字符串。下面就讲一下可以改变字符串的操作。</p>
<p><strong>1）分割字符串</strong></p>
<p><code>split()</code>函数<strong>在匹配的地方将字符串分割，并返回一个 list</strong>。同样的，re 模块提供了两种 split 函数，一个是 pattern object 的方法，一个是模块级的函数。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.split" target="_blank" rel="external"><code>regex.split(string, maxsplit=0)</code></a>：</p>
<ul>
<li>maxsplit用于指定最大分割次数，不指定将全部分割。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"[A-Z]+"</span>)</span><br><span class="line">m = pattern.split(<span class="string">"abcDefgHijkLmnoPqrs"</span>)</span><br><span class="line">print(m)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># ['abc', 'efg', 'ijk', 'mno', 'qrs']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.split" target="_blank" rel="external"><code>re.split(pattern, string, maxsplit=0, flags=0)</code></a>：</p>
<ul>
<li>模块级函数，功能与 regex.split() 相同。</li>
<li>flags用于指定匹配模式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = re.split(<span class="string">r"[A-Z]+"</span>,<span class="string">"abcDefgHijkLmnoPqrs"</span>)</span><br><span class="line">print(m)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># ['abc', 'efg', 'ijk', 'mno', 'qrs']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2）搜索与替换</strong></p>
<p>另一个常用的功能是<strong>找到所有的匹配，并把它们用不同的字符串替换</strong>。re 模块提供了<code>sub()</code>和<code>subn()</code>来实现替换的功能，而它们也分别有自己两个不同版本的函数。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.sub" target="_blank" rel="external"><code>regex.sub(repl, string, count=0)</code></a>：</p>
<ul>
<li>使用 repl 替换 string 中每一个匹配的子串，返回替换后的字符串。若找不到匹配，则返回原字符串。</li>
<li>repl 可以是一个字符串，也可以是一个函数。</li>
<li>当repl是一个字符串时，任何在其中的反斜杠都会被处理。</li>
<li>当repl是一个函数时，这个函数应当只接受一个参数（Match对象），并返回一个字符串用于替换。</li>
<li>count 用于指定最多替换次数，不指定时全部替换。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> m.group().upper()</span><br><span class="line"> </span><br><span class="line">pattern = re.compile(<span class="string">r"like"</span>, re.I)</span><br><span class="line">s1 = pattern.sub(<span class="string">r"love"</span>, <span class="string">"I like you, do you like me?"</span>)</span><br><span class="line">s2 = pattern.sub(fun, <span class="string">"I like you, do you like me?"</span>)</span><br><span class="line">print(s1)</span><br><span class="line">print(s2)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># I love you, do you love me?</span></span><br><span class="line"><span class="comment"># I LIKE you, do you LIKE me?</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.sub" target="_blank" rel="external"><code>re.sub(pattern, repl, string, count=0, flags=0)</code></a>：</p>
<ul>
<li>模块级函数，与 regex.sub() 函数功能相同。</li>
<li>flags 用于指定匹配模式。</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.subn" target="_blank" rel="external"><code>regex.subn(repl, string, count=0)</code></a>：</p>
<ul>
<li>同 sub()，只不过返回值是一个二元 tuple，即<code>(sub函数返回值, 替换次数)</code>。</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.subn" target="_blank" rel="external"><code>re.subn(pattern, repl, string, count=0, flags=0)</code></a>：</p>
<ul>
<li>同上</li>
</ul>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>正则表达式（Regular Expression）</strong>是字符串处理的常用工具，通常被用来检索、替换那些符合某个模式（Pattern）的文本。很多程序设计语言都支持正则表达式，像Perl、Java、C/C++。在 Python 中是通过标准库中的 <strong>re 模块</strong> 提供对正则的支持。</p>
<p><br></p>
<h3 id="一、正则表达式介绍">一、正则表达式介绍</h3><p><strong>1）用途</strong></p>
<p>通过使用正则表达式，可以： </p>
<ul>
<li><p>测试字符串内的模式。—— 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3标准库（一） 内置函数]]></title>
    <link href="http://yoursite.com/2014/08/30/python-library-01/"/>
    <id>http://yoursite.com/2014/08/30/python-library-01/</id>
    <published>2014-08-30T14:35:07.000Z</published>
    <updated>2015-05-10T08:12:50.112Z</updated>
    <content type="html"><![CDATA[<p>Python中内置了很多的函数，而学习标准库我们需要事先熟悉这些内置函数，所以在这里一个个进行介绍。有些函数比较简单，只给予文字描述，而有些函数会给出示例代码帮助理解。</p>
<p><strong>1、<a href="https://docs.python.org/3.4/library/functions.html#abs" target="_blank" rel="external"><code>abs(x)</code></a>：</strong>返回一个整数或浮点数的绝对值，如果是复数，返回它的模。</p>
<p><strong>2、<a href="https://docs.python.org/3.4/library/functions.html#all" target="_blank" rel="external"><code>all(iterable)</code></a>：</strong>当 iterable 中所有元素都为 True 时（或者 iterable 为空），返回 True 。</p>
<p><strong>3、<a href="https://docs.python.org/3.4/library/functions.html#any" target="_blank" rel="external"><code>any(iterable)</code></a>：</strong>当 iterable 中有元素为 True 时，则返回 True 。如果 iterable 为空，返回 False 。<a id="more"></a></p>
<p><strong>4、<a href="https://docs.python.org/3.4/library/functions.html#ascii" target="_blank" rel="external"><code>ascii(object)</code></a>：</strong>类似于repr()，返回一个输入对象的可打印的字符串。</p>
<p><strong>5、<a href="https://docs.python.org/3.4/library/functions.html#bin" target="_blank" rel="external"><code>bin(x)</code></a>：</strong>将整数 x 转化为一个二进制字符串。当 x 不是 int 对象时，x 必须实现__index__()方法来返回一个整型数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bin(<span class="number">9</span>)</span><br><span class="line"><span class="string">'0b1001'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6、<a href="https://docs.python.org/3.4/library/functions.html#bool" target="_blank" rel="external"><code>bool(x)</code></a>：</strong>将一个值转换成一个boolean类型的值，省略 x 将返回 False。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">bool</span><span class="params">()</span></span></span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">bool</span><span class="params">(<span class="string">'fedora'</span>)</span></span></span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p><strong>7、<a href="https://docs.python.org/3.4/library/functions.html#bytearray" target="_blank" rel="external"><code>bytearray()</code></a>：</strong> bytearray的构造函数。bytearray类型是一个可变的整数序列（0 &lt;= 整数 &lt; 256），即字节数组，例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = bytearray(b<span class="string">'after'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(a)   <span class="comment"># convert a bytearray object into a list of integers</span></span><br><span class="line">[<span class="number">97</span>, <span class="number">102</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">114</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>8、<a href="https://docs.python.org/3.4/library/functions.html#bytes" target="_blank" rel="external"><code>bytes()</code></a>：</strong> 字节对象（bytes object）的构造函数。bytes是bytearray的<strong>不可变</strong>版本：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = bytes(<span class="string">'after'</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(a)   <span class="comment"># convert a bytes object into a list of integers</span></span><br><span class="line">[<span class="number">97</span>, <span class="number">102</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">114</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>9、<a href="https://docs.python.org/3.4/library/functions.html#callable" target="_blank" rel="external"><code>callable(object)</code></a>：</strong>判断一个对象是否可调用，如果一个实例的类实现了<strong>call</strong>()方法，则它是可以调用的。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; f = lambda x,y <span class="symbol">:</span> x+y</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; callable(f)   <span class="comment"># f是函数对象，可调用</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = <span class="number">10</span>   <span class="comment"># a 不可调用</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; callable(a)</span><br><span class="line"><span class="constant">False</span></span><br></pre></td></tr></table></figure></p>
<p><strong>10、<a href="https://docs.python.org/3.4/library/functions.html#chr" target="_blank" rel="external"><code>chr(i)</code></a>：</strong>返回编码值 i 对应的字符（str类型），i 的有效值为 0 到 1114111。与<code>ord()</code>正好相反。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">chr</span><span class="params">(<span class="number">97</span>)</span></span></span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>11、<a href="https://docs.python.org/3.4/library/functions.html#classmethod" target="_blank" rel="external"><code>classmethod(function)</code></a>：</strong>返回一个类方法。</p>
<p><strong>12、<a href="https://docs.python.org/3.4/library/functions.html#compile" target="_blank" rel="external"><code>compile()</code></a>：</strong>编译一个源，返回一个代码对象，该代码对象可以用来作为exec()或者eval()的参数。</p>
<p><strong>13、<a href="https://docs.python.org/3.4/library/functions.html#complex" target="_blank" rel="external"><code>complex(re, im)</code></a>：</strong>复数的构造函数，re 为返回复数对象的实数部分，im 为虚数部分。</p>
<p><strong>14、<a href="https://docs.python.org/3.4/library/functions.html#delattr" target="_blank" rel="external"><code>delattr(object, name)</code></a>：</strong>删除一个对象的属性，相当于<code>del object.name</code>。</p>
<p><strong>15、<a href="https://docs.python.org/3.4/library/functions.html#func-dict" target="_blank" rel="external"><code>dict()</code></a>：</strong>字典类型的构造函数。</p>
<p><strong>16、<a href="https://docs.python.org/3.4/library/functions.html#dir" target="_blank" rel="external"><code>dir()</code></a>：</strong>返回一个包含了 object 所有属性的列表对象，如果没有参数，则包含当前作用域的所用属性。</p>
<p><strong>17、<a href="https://docs.python.org/3.4/library/functions.html#divmod" target="_blank" rel="external"><code>divmod(a, b)</code></a>：</strong>返回一个元组<code>(a//b, a%b)</code>。</p>
<p><strong>18、<a href="https://docs.python.org/3.4/library/functions.html#enumerate" target="_blank" rel="external"><code>enumerate(iterable, start=0)</code></a>：</strong>返回一个可迭代的 enumerate object，对其使用 next() 得到的是包含索引和元素的tuple，通常用于同时遍历索引和元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> enumerate(seasons):   <span class="comment"># 遍历</span></span><br><span class="line"><span class="prompt">... </span>    print(x, end=<span class="string">' '</span>)</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">(<span class="number">0</span>, <span class="string">'Spring'</span>) (<span class="number">1</span>, <span class="string">'Summer'</span>) (<span class="number">2</span>, <span class="string">'Fall'</span>) (<span class="number">3</span>, <span class="string">'Winter'</span>)</span><br></pre></td></tr></table></figure></p>
<p>相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span><span class="params">(sequence, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>19、<a href="https://docs.python.org/3.4/library/functions.html#eval" target="_blank" rel="external"><code>eval()</code></a>：</strong>执行一段代码，返回执行的结果。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; eval(<span class="string">'x+1'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>20、<a href="https://docs.python.org/3.4/library/functions.html#exec" target="_blank" rel="external"><code>exec()</code></a>：</strong>也是执行一段代码，返回None。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; exec(<span class="string">'x += 10'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; x</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p><strong>21、<a href="https://docs.python.org/3.4/library/functions.html#filter" target="_blank" rel="external"><code>filter(function, iterable)</code></a>：</strong>过滤器，返回由使函数 function 返回True的 iterable 元素组成的迭代器。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; f = lambda <span class="symbol">x:</span> x%<span class="number">2</span>==<span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(filter(f, lst))</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>22、<a href="https://docs.python.org/3.4/library/functions.html#float" target="_blank" rel="external"><code>float(x)</code></a>：</strong>返回一个浮点型的对象，无参时返回0.0</p>
<p><strong>23、<a href="https://docs.python.org/3.4/library/functions.html#format" target="_blank" rel="external"><code>format(value[, spec])</code></a>：</strong>格式化一个值，当参数是一个自定义对象的时候，该对象需要实现__format__()方法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">format</span><span class="params">(<span class="number">3.1415926</span>, <span class="string">'7.3g'</span>)</span></span></span><br><span class="line"><span class="string">'   3.14'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>24、<a href="https://docs.python.org/3.4/library/functions.html#func-frozenset" target="_blank" rel="external"><code>frozenset()</code></a>：</strong> frozenset 的构造函数。顾名思义，frozenset是一种 set 类型，且不可改变（没有add、remove等方法）。</p>
<p><strong>25、<a href="https://docs.python.org/3.4/library/functions.html#getattr" target="_blank" rel="external"><code>getattr(object, name)</code></a>：</strong>获得对象的name属性，当该属性不存在的时候可以使用一个默认值作为返回值。</p>
<p><strong>26、<a href="https://docs.python.org/3.4/library/functions.html#globals" target="_blank" rel="external"><code>globals()</code></a>：</strong>返回一个包含当前所有<strong>全局符号</strong>和对应值的字典。</p>
<p><strong>27、<a href="https://docs.python.org/3.4/library/functions.html#hasattr" target="_blank" rel="external"><code>hasattr(object, name)</code></a>：</strong>判断对象是否有name属性。</p>
<p><strong>28、<a href="https://docs.python.org/3.4/library/functions.html#hash" target="_blank" rel="external"><code>hash(object)</code></a>：</strong>返回对象的 hash 值，object 必须是可哈希的。<br><strong>注意：</strong>所有不可变的内置类型都是 hashable 的，比如 string，tuple；所有可变的内置类型都是 unhashable 的，比如 list，dict（即没有__hash__()方法）。</p>
<p><strong>29、<a href="https://docs.python.org/3.4/library/functions.html#help" target="_blank" rel="external"><code>help()</code></a>：</strong>查看一个对象的帮助文档。</p>
<p><strong>30、<a href="https://docs.python.org/3.4/library/functions.html#hex" target="_blank" rel="external"><code>hex(x)</code></a>：</strong>将一个整数转为小写的十六进制字符串（以’0x’开头），如果不是int对象，需要定义 __index__()方法。</p>
<p><strong>31、<a href="https://docs.python.org/3.4/library/functions.html#id" target="_blank" rel="external"><code>id()</code></a>：</strong>返回一个对象的 id 身份，可以看作该对象的内存地址。</p>
<p><strong>32、<a href="https://docs.python.org/3.4/library/functions.html#input" target="_blank" rel="external"><code>input()</code></a>：</strong>读取一行输入并返回一个字符串。</p>
<p><strong>33、<a href="https://docs.python.org/3.4/library/functions.html#int" target="_blank" rel="external"><code>int(x, base=10)</code></a>：</strong>返回相应进制的 int 值。</p>
<p><strong>34、<a href="https://docs.python.org/3.4/library/functions.html#isinstance" target="_blank" rel="external"><code>isinstance(object, class)</code></a>：</strong>判断对象 object 是不是类 class 或其派生类的实例。</p>
<p><strong>35、<a href="https://docs.python.org/3.4/library/functions.html#issubclass" target="_blank" rel="external"><code>issubclass(class,baseclass)</code></a>：</strong>判断一个类是否是另一个类的子类。</p>
<p><strong>36、<a href="https://docs.python.org/3.4/library/functions.html#iter" target="_blank" rel="external"><code>iter()</code></a>：</strong>返回一个可迭代的对象。</p>
<p><strong>37、<a href="https://docs.python.org/3.4/library/functions.html#len" target="_blank" rel="external"><code>len()</code></a>：</strong>返回一个长度值，与 object 中的__len__()有关。</p>
<p><strong>38、<a href="https://docs.python.org/3.4/library/functions.html#func-list" target="_blank" rel="external"><code>list()</code></a>：</strong> list 的构造函数。</p>
<p><strong>39、<a href="https://docs.python.org/3.4/library/functions.html#locals" target="_blank" rel="external"><code>locals()</code></a>：</strong>返回一个包含当前局部符号和对应值的字典，与 <code>globals()</code> 对应。</p>
<p><strong>40、<a href="https://docs.python.org/3.4/library/functions.html#map" target="_blank" rel="external"><code>map(function, iterable)</code></a>：</strong>映射函数，将 iterable 中的每个元素应用到 function 函数，返回由所有结果组成的迭代器。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; it = <span class="function"><span class="title">map</span><span class="params">(lambda x: x*<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">list</span><span class="params">(it)</span></span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>41、<a href="https://docs.python.org/3.4/library/functions.html#max" target="_blank" rel="external"><code>max()</code></a>：</strong>最大值。</p>
<p><strong>42、<a href="https://docs.python.org/3.4/library/functions.html#min" target="_blank" rel="external"><code>min()</code></a>：</strong>最小值。</p>
<p><strong>43、<a href="https://docs.python.org/3.4/library/functions.html#func-memoryview" target="_blank" rel="external"><code>memoryview(obj)</code></a>：</strong>返回一个 memory view 对象。</p>
<p><strong>44、<a href="https://docs.python.org/3.4/library/functions.html#next" target="_blank" rel="external"><code>next(iterator)</code></a>：</strong>产生下一个生成值，与__next__()有关。</p>
<p><strong>45、<a href="https://docs.python.org/3.4/library/functions.html#object" target="_blank" rel="external"><code>object()</code></a>：</strong>略。</p>
<p><strong>46、<a href="https://docs.python.org/3.4/library/functions.html#oct" target="_blank" rel="external"><code>oct(x)</code></a>：</strong>将一个整数转为一个八进制字符串。如果不是 int 对象，需要定义__index__()方法。</p>
<p><strong>47、<a href="https://docs.python.org/3.4/library/functions.html#open" target="_blank" rel="external"><code>open()</code></a>：</strong>打开一个文件，返回对应的文件对象。</p>
<p><strong>48、<a href="https://docs.python.org/3.4/library/functions.html#ord" target="_blank" rel="external"><code>ord(c)</code></a>：</strong>返回字符 c 的编码值，与<code>chr(i)</code>相反。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">ord</span><span class="params">(<span class="string">'a'</span>)</span></span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure></p>
<p><strong>49、<a href="https://docs.python.org/3.4/library/functions.html#pow" target="_blank" rel="external"><code>pow(x, y[, z])</code></a>：</strong><code>pow(x, y)</code>相当于<code>x**y</code>，<code>pow(x, y, z)</code>相当于<code>pow(x, y) % z</code>。</p>
<p><strong>50、<a href="https://docs.python.org/3.4/library/functions.html#print" target="_blank" rel="external"><code>print()</code></a>：</strong>打印输出。</p>
<p><strong>51、<a href="https://docs.python.org/3.4/library/functions.html#property" target="_blank" rel="external"><code>property(fget=None, fset=None, fdel=None, doc=None)</code></a>：</strong>函数 property() 的作用就是把类中的方法当作属性来访问。看下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__x = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__x</span><br><span class="line">        </span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure></p>
<p>为了操作数据成员 __x，我们需要使用 getx、setx、delx 方法，很麻烦。但是如果通过 property 函数将方法绑定到成员x，那么当获取成员x的值时，就会调用getx函数；当给成员x赋值时，就会调用setx函数；当删除x时，就会调用delx函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">c</span> = <span class="type">C</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.x)    # 相当于<span class="built_in">c</span>.getx()</span><br><span class="line"><span class="built_in">c</span>.x = <span class="number">20</span>      # 相当于<span class="built_in">c</span>.setx(<span class="number">20</span>)</span><br><span class="line">del <span class="built_in">c</span>.x       # 相当于<span class="built_in">c</span>.delx()</span><br></pre></td></tr></table></figure></p>
<p>这样通过 x 间接调用方法操作 __x 就方便多了。</p>
<p><strong>52、<a href="https://docs.python.org/3.4/library/functions.html#func-range" target="_blank" rel="external"><code>range(start, stop[, step])</code></a>：</strong>返回一个序列。</p>
<p><strong>53、<a href="https://docs.python.org/3.4/library/functions.html#repr" target="_blank" rel="external"><code>repr(object)</code></a>：</strong>将对象转化为可打印的字符串。</p>
<p><strong>54、<a href="https://docs.python.org/3.4/library/functions.html#reversed" target="_blank" rel="external"><code>reversed()</code></a>：</strong>倒序序列，对象需要实现__reversed__()方法。</p>
<p><strong>55、<a href="https://docs.python.org/3.4/library/functions.html#round" target="_blank" rel="external"><code>round(number[, ndigits])</code></a>：</strong>把浮点数转变成指定小数位数的数，ndigits默认为0。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">round</span><span class="params">(<span class="number">1.75368</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="number">1.754</span></span><br></pre></td></tr></table></figure></p>
<p><strong>56、<a href="https://docs.python.org/3.4/library/functions.html#func-set" target="_blank" rel="external"><code>set()</code></a>：</strong> set 的构造函数。</p>
<p><strong>57、<a href="https://docs.python.org/3.4/library/functions.html#setattr" target="_blank" rel="external"><code>setattr(object, name, value)</code></a>：</strong>为一个对象的name属性设置一个value值。</p>
<p><strong>58、<a href="https://docs.python.org/3.4/library/functions.html#slice" target="_blank" rel="external"><code>slice(start,stop[,step])</code></a>：</strong>切片函数，分割一个可分割的对象，返回其中的一部分。</p>
<p><strong>59、<a href="https://docs.python.org/3.4/library/functions.html#sorted" target="_blank" rel="external"><code>sorted()</code></a>：</strong>排序。</p>
<p><strong>60、<a href="https://docs.python.org/3.4/library/functions.html#staticmethod" target="_blank" rel="external"><code>staticmethod(function)</code></a>：</strong>返回一个静态的方法。要知道，一个类的静态方法没有隐式的第一个 self 参数，因为静态方法是独立于实例对象的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="decorator">@staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg1, arg2, ...)</span>:</span> ...</span><br></pre></td></tr></table></figure></p>
<p><strong>61、<a href="https://docs.python.org/3.4/library/functions.html#func-str" target="_blank" rel="external"><code>str()</code></a>：</strong>字符串的构造函数。</p>
<p><strong>62、<a href="https://docs.python.org/3.4/library/functions.html#sum" target="_blank" rel="external"><code>sum()</code></a>：</strong>求和。</p>
<p><strong>63、<a href="https://docs.python.org/3.4/library/functions.html#super" target="_blank" rel="external"><code>super()</code></a>：</strong> super() 常用于继承中调用父类的方法。例如，<a href="http://blog.csdn.net/lisonglisonglisong/article/details/38719743#t0" target="_blank" rel="external">类的继承</a>中，通常需要调用父类的构造方法，以初始化父类部分，有两种方法能达到这个目的。</p>
<p><strong>方法一：</strong>调用未绑定的父类构造方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="string">'A_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b = <span class="string">'B_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        <span class="comment"># ...其他超类</span></span><br><span class="line">        self.c = <span class="string">'C_method'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：</strong>使用super函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.a = <span class="string">'A_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.b = <span class="string">'B_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()    <span class="comment"># 等价于super(C,self).__init__()</span></span><br><span class="line">        self.c = <span class="string">'C_method'</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，方法一更直观，但是方法二使用 super 函数可以一次初始化所有超类（但要确保所有的超类的构造方法都使用了super函数）。当继承结构很复杂时，方法二明显更适用，当然 super 不仅可以用于构造方法还可以用于其他方法。</p>
<p>使用 super 还有一个好处，就是当改变父类名时，不需要再去修改其他地方，便于代码的维护。</p>
<p><strong>64、<a href="https://docs.python.org/3.4/library/functions.html#func-tuple" target="_blank" rel="external"><code>tuple()</code></a>：</strong>元组的构造函数。</p>
<p><strong>65、<a href="https://docs.python.org/3.4/library/functions.html#type" target="_blank" rel="external"><code>type()</code></a>：</strong>返回一个对象的类型，返回值与<code>object.__class__</code>一样。</p>
<p><strong>66、<a href="https://docs.python.org/3.4/library/functions.html#vars" target="_blank" rel="external"><code>vars(object)</code></a>：</strong>返回 object 中所有属性与对应值的字典。没有参数时作用和<code>locals()</code>一样。</p>
<p><strong>67、<a href="https://docs.python.org/3.4/library/functions.html#zip" target="_blank" rel="external"><code>zip()</code></a>：</strong> zip 函数接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组）。</p>
<p><strong>68、<a href="https://docs.python.org/3.4/library/functions.html#__import__" target="_blank" rel="external"><code>__import__()</code></a>：</strong>通过import语句调用。</p>
<p><br><br><br><br></p>
<h3 id="附：reduce函数">附：reduce函数</h3><p>在Python 3里，<a href="https://docs.python.org/3.4/library/functools.html#functools.reduce" target="_blank" rel="external"><code>reduce()</code></a>函数已经被从全局名字空间里移除了，它现在被放置在<code>functools</code>模块里。函数原型如下：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="function"><span class="keyword">function</span>, <span class="title">iterable</span><span class="params">[, initializer]</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>function 必须是二元函数，<strong>在省略第三个参数的情况下</strong>，函数先对 iterable 中的第1，2个数据进行操作，得到的结果再与第三个数据用 function() 函数运算……依次类推，最后得到一个结果。<strong>如果初始值 initializer 给定</strong>，第一次调用会是 initializer 和第一个元素而不是序列的头两个元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">10</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>map用于映射，reduce用于归并。</p>
<p>（全文完）<br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中内置了很多的函数，而学习标准库我们需要事先熟悉这些内置函数，所以在这里一个个进行介绍。有些函数比较简单，只给予文字描述，而有些函数会给出示例代码帮助理解。</p>
<p><strong>1、<a href="https://docs.python.org/3.4/library/functions.html#abs"><code>abs(x)</code></a>：</strong>返回一个整数或浮点数的绝对值，如果是复数，返回它的模。</p>
<p><strong>2、<a href="https://docs.python.org/3.4/library/functions.html#all"><code>all(iterable)</code></a>：</strong>当 iterable 中所有元素都为 True 时（或者 iterable 为空），返回 True 。</p>
<p><strong>3、<a href="https://docs.python.org/3.4/library/functions.html#any"><code>any(iterable)</code></a>：</strong>当 iterable 中有元素为 True 时，则返回 True 。如果 iterable 为空，返回 False 。]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（十二） 学习总结·附PDF]]></title>
    <link href="http://yoursite.com/2014/08/24/python-basic-12/"/>
    <id>http://yoursite.com/2014/08/24/python-basic-12/</id>
    <published>2014-08-24T07:32:32.000Z</published>
    <updated>2015-05-10T08:09:44.167Z</updated>
    <content type="html"><![CDATA[<p>Python是一门强大的解释型、面向对象的高级程序设计语言，它优雅、简单、可移植、易扩展，可用于桌面应用、系统编程、数据库编程、网络编程、web开发、图像处理、人工智能、数学应用、文本处理等等。</p>
<p>在学习Python的过程中，我做了一个比较详细、比较系统的学习笔记，适合Python的初学者用以快速入门。它讲解了Python 3.x的基本语法和高级特性，从基本数据类型、运算符、流程控制、函数、文件IO到模块、异常处理和面向对象，并且附上了很多经过测试的代码帮助读者去理解。</p>
<p>如果你是一个Python初学者，希望这个学习笔记能够对你有所帮助。相信如果你看完这个学习笔记，你会对Python有一个整体的了解。<a id="more"></a></p>
<p>Python3基础学习笔记：</p>
<ul>
<li><a href="http://songlee24.github.io/2014/08/08/python-basic-01/" target="_blank" rel="external">Python3基础（一） Hello World </a></li>
<li><a href="http://songlee24.github.io/2014/08/08/python-basic-02/" target="_blank" rel="external">Python3基础（二） 基本数据类型 </a></li>
<li><a href="http://songlee24.github.io/2014/08/08/python-basic-03/" target="_blank" rel="external">Python3基础（三） 运算符 </a></li>
<li><a href="http://songlee24.github.io/2014/08/09/python-basic-04/" target="_blank" rel="external">Python3基础（四） 条件与循环控制</a></li>
<li><a href="http://songlee24.github.io/2014/08/09/python-basic-05/" target="_blank" rel="external">Python3基础（五） 函数</a></li>
<li><a href="http://songlee24.github.io/2014/08/13/python-basic-06/" target="_blank" rel="external">Python3基础（六） 深入list列表</a></li>
<li><a href="http://songlee24.github.io/2014/08/14/python-basic-07/" target="_blank" rel="external">Python3基础（七） 输入和输出</a></li>
<li><a href="http://songlee24.github.io/2014/08/18/python-basic-08/" target="_blank" rel="external">Python3基础（八） 模块</a></li>
<li><a href="http://songlee24.github.io/2014/08/19/python-basic-09/" target="_blank" rel="external">Python3基础（九） 错误和异常</a></li>
<li><a href="http://songlee24.github.io/2014/08/20/python-basic-10/" target="_blank" rel="external">Python3基础（十） 类的初印象</a></li>
<li><a href="http://songlee24.github.io/2014/08/21/python-basic-11/" target="_blank" rel="external">Python3基础（十一） 类的拓展 </a></li>
<li><a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/" target="_blank" rel="external">Python FAQ1：传值，还是传引用？</a></li>
<li><a href="http://songlee24.github.io/2014/08/15/python-FAQ-02/" target="_blank" rel="external">Python FAQ2：赋值、浅拷贝、深拷贝的区别？</a></li>
</ul>
<p><strong>为了方便大家离线阅读，我把上面所有的学习笔记用 markdown 排版制作了一个精良的PDF，供大家下载。</strong></p>
<p><strong>下载地址：</strong><a href="http://download.csdn.net/detail/lisong694767315/7807405" target="_blank" rel="external">http://download.csdn.net/detail/lisong694767315/7807405</a></p>
<p><br><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python是一门强大的解释型、面向对象的高级程序设计语言，它优雅、简单、可移植、易扩展，可用于桌面应用、系统编程、数据库编程、网络编程、web开发、图像处理、人工智能、数学应用、文本处理等等。</p>
<p>在学习Python的过程中，我做了一个比较详细、比较系统的学习笔记，适合Python的初学者用以快速入门。它讲解了Python 3.x的基本语法和高级特性，从基本数据类型、运算符、流程控制、函数、文件IO到模块、异常处理和面向对象，并且附上了很多经过测试的代码帮助读者去理解。</p>
<p>如果你是一个Python初学者，希望这个学习笔记能够对你有所帮助。相信如果你看完这个学习笔记，你会对Python有一个整体的了解。]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（十一） 类的拓展]]></title>
    <link href="http://yoursite.com/2014/08/21/python-basic-11/"/>
    <id>http://yoursite.com/2014/08/21/python-basic-11/</id>
    <published>2014-08-20T17:29:34.000Z</published>
    <updated>2015-05-10T08:06:31.094Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://songlee24.github.io/2014/08/20/python-basic-10/" target="_blank" rel="external">类的初印象</a>中，我们已经简单的介绍了类，包括类的定义、类对象和实例对象。本文将进一步学习类的继承、迭代器、发生器等等。</p>
<p><br></p>
<h3 id="一、类的继承">一、类的继承</h3><p><strong>单继承</strong></p>
<p>派生类的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>基类名 BaseClassName 对于派生类来说必须是可见的。也可以继承在其他模块中定义的基类：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DerivedClassName</span><span class="container">(<span class="title">module</span>.<span class="type">BaseClassName</span>)</span>:</span></span><br></pre></td></tr></table></figure></p>
<p>对于派生类的属性引用：首先会在当前的派生类中搜索，如果没有找到，则会递归地去基类中寻找。</p>
<p>从C++术语上讲，Python 类中所有的方法都是<code>vitual</code>的，所以派生类可以覆写（override）基类的方法。在派生类中一个覆写的方法可能需要调用基类的方法，可以通过以下方式：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BaseClassName</span>.<span class="keyword">method</span>(self, arguments)</span><br></pre></td></tr></table></figure></p>
<p>介绍两个函数：</p>
<ul>
<li><code>isinstance(object, class_name)</code>：内置函数，用于判断实例对象 object 是不是类 class<em>name 或其派生类的实例，即`object.<em>_class</em></em> `是 class_name 或其派生类时返回 True。</li>
<li><code>issubclass(class1, class2)</code>：内置函数，用于检查类 class1 是不是 class2 的派生类。例如<code>issubclass(bool, int)</code>会返回 True，因为 bool 是 int 的派生类。 </li>
</ul>
<p><strong>多重继承</strong></p>
<p>Python支持多重继承，一个多重继承的定义形如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DerivedClassName</span><span class="container">(<span class="type">Base1</span>, <span class="type">Base2</span>, <span class="type">Base3</span>)</span>:</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-<span class="type">N</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>大多数的情况（未使用super）下，多重继承中属性搜索的方式是，深度优先，从左到右。在继承体系中，同样的类只会被搜寻一次。如果一个属性在当前类中没有被找到，它就会搜寻 Base1，然后递归地搜寻 Base1 的基类，然后如果还是没有找到，那么就会搜索 Base2，依次类推。</p>
<p>对于菱形继承，Python 3采用了 C3 线性化算法去搜索基类，保证每个基类只搜寻一次。所以对于使用者，无须担心这个问题，如果你想了解更多细节，可以看看<a href="http://hi.baidu.com/tim_bi/item/c26137837f34c0c8b071544e" target="_blank" rel="external">Python类的方法解析顺序</a>。</p>
<p><br></p>
<h3 id="二、自定义异常类">二、自定义异常类</h3><p>在《<a href="http://songlee24.github.io/2014/08/19/python-basic-09/" target="_blank" rel="external">Python3的错误和异常</a>》中，我们简单地介绍了Python中的异常处理、异常抛出以及清理动作。在学习了类的继承以后，我们就可以定义自己的异常类了。</p>
<p>自定义异常需要从 <strong>Exception</strong> 类派生，既可以是直接也可以是间接。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'My exception occurred, value:'</span>, e.value)</span><br><span class="line">    <span class="comment"># 输出：My exception occurred, value: 4</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中， Exception 的默认方法 __init__() 被覆写了，现在新的异常类可以像其他的类一样做任何的事。当创建一个模块时，可能会有多种不同的异常，一种常用的做法就是，创建一个基类，然后派生出各种不同的异常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Base class for exceptions in this module."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, expression, message)</span>:</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, previous, next, message)</span>:</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意的是，如果一个 except 后跟了一个异常类，则这个 except 语句不能捕获该异常类的基类，但能够捕获该异常类的子类。例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class <span class="function"><span class="title">B</span><span class="params">(Exception)</span></span>:</span><br><span class="line">    pass</span><br><span class="line">class <span class="function"><span class="title">C</span><span class="params">(B)</span></span>:</span><br><span class="line">    pass</span><br><span class="line">class <span class="function"><span class="title">D</span><span class="params">(C)</span></span>:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> [B, C, D]:</span><br><span class="line">    try:</span><br><span class="line">        raise <span class="function"><span class="title">e</span><span class="params">()</span></span></span><br><span class="line">    except D:</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'D'</span>)</span></span></span><br><span class="line">    except C:</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'C'</span>)</span></span></span><br><span class="line">    except B:</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'B'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码会按顺序输出B、C、D。如果将三个 except 语句逆序，则会打印B、B、B。</p>
<p><br></p>
<h3 id="三、迭代器（Iterator）">三、迭代器（Iterator）</h3><p>到目前为止，你可能注意到，大多数的容器对象都可以使用 for 来迭代：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [1, 2, 3]:</span><br><span class="line">    <span class="keyword">print</span>(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (1, 2, 3):</span><br><span class="line">    <span class="keyword">print</span>(element)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;'<span class="keyword">one</span>':1, '<span class="keyword">two</span>':2&#125;:</span><br><span class="line">    <span class="keyword">print</span>(key)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> <span class="keyword">in</span> <span class="string">"123"</span>:</span><br><span class="line">    <span class="keyword">print</span>(<span class="keyword">char</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">line</span> <span class="keyword">in</span> <span class="keyword">open</span>(<span class="string">"myfile.txt"</span>):</span><br><span class="line">    <span class="keyword">print</span>(<span class="keyword">line</span>)</span><br></pre></td></tr></table></figure></p>
<p>这种形式可以说是简洁明了。其实，for 语句在遍历容器的过程中隐式地调用了<code>iter()</code>，这个函数返回一个迭代器对象，迭代器对象定义了 <code>__next__()</code> 方法，用以在每次访问时得到一个元素。当没有任何元素时，__next__() 将产生 StopIteration 异常来告诉 for 语句停止迭代。</p>
<p>内置函数 <code>next()</code>可以用来调用 __next__() 方法，示例：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; s = <span class="string">'abc'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; it = iter(s)   <span class="comment"># 获取迭代器对象</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">StopIteration</span></span><br></pre></td></tr></table></figure></p>
<p>在了解了迭代器的机制之后，就可以很简单的将迭代行为增加到你的类中。定义一个 <code>__iter__()</code>方法返回一个具有 __next__() 的对象，如果这个类定义了 __next__() , 那么 __iter__() 仅需要返回 self：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span>:</span></span><br><span class="line">    <span class="string">""" 逆序迭代一个序列 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>  self.data[self.index]</span><br></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">rev = <span class="constant">Reverse</span>(<span class="string">'spam'</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="symbol">rev:</span></span><br><span class="line">    print(c, <span class="keyword">end</span>=<span class="string">' '</span>)   <span class="comment"># 输出：m a p s </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单步测试</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; rev = <span class="constant">Reverse</span>(<span class="string">'spam'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; it = iter(rev)    <span class="comment"># 返回的 self 本身</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)          <span class="comment"># 相当于 next(rev)，因为iter(rev)返回本身</span></span><br><span class="line"><span class="string">'m'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it) </span><br><span class="line"><span class="string">'p'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(it)</span><br><span class="line"><span class="string">'s'</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、生成器（Generator）">四、生成器（Generator）</h3><p>生成器（Generator）是用来创建迭代器的工具，它的形式跟函数一样，唯一的不同是生成器使用 <code>yield</code> 语句返回，而不是 return 语句。</p>
<p>有了生成器，我们不再需要自定义迭代器类（例如上面的 class Reverse），因为自定义迭代器类需要手动实现 <strong>__iter__()</strong> 和 <strong>__next__()</strong> 方法，也是有点麻烦。而生成器则会自动创建 __iter()__ 和 __next__()，可以更方便地生成一个迭代器，而且代码也会更短更简洁。例如，这里用生成器实现与 class Reverse 相同作用的迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[idx]</span><br></pre></td></tr></table></figure></p>
<p>原来要十多行代码写一个迭代器类，现在使用生成器只需要3行代码！来测试一下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="constant">Reverse</span>(<span class="string">'spam'</span>)<span class="symbol">:</span></span><br><span class="line">    print(c, <span class="keyword">end</span>=<span class="string">' '</span>)      <span class="comment"># 输出：m a p s </span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 单步测试</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; rev = <span class="constant">Reverse</span>(<span class="string">'spam'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(rev)</span><br><span class="line"><span class="string">'m'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(rev)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(rev)</span><br><span class="line"><span class="string">'p'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; next(rev)</span><br><span class="line"><span class="string">'s'</span></span><br></pre></td></tr></table></figure></p>
<p>怎么样？现在感受到生成器的强大了吧。确实，生成器让我们可以方便的创建迭代器，而不必去自定义迭代器类那么麻烦。下面我们来了解一下生成器的工作过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 这是一个简单的生成器 """</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>g = generator_func()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>执行过程大致如下：</p>
<ol>
<li>调用生成器函数将返回一个生成器。</li>
<li>第一次调用生成器的 next 方法时，生成器才开始执行生成器函数。直到遇到 yield 时暂停执行（挂起），并且将 yield 的参数作为此次的返回值。</li>
<li>之后每次调用 next 方法，生成器将从上次暂停的位置恢复并继续执行，直到再次遇到yield 时暂停，同样将 yield 的参数返回。</li>
<li>当调用 next 方法时生成器函数结束，则此次调用将抛出 StopIteration 异常（for循环终止条件）。</li>
</ol>
<p>所以说，生成器的神奇之处在于每次使用 next() 执行生成器函数遇到 yield 返回时，生成器函数的“状态”会被冻结，所有的数据值和执行位置会被记住，一旦 next() 再次被调用，生成器函数会从它上次离开的地方继续执行。</p>
<p><br></p>
<h3 id="五、类用作ADT">五、类用作ADT</h3><p>有些时候，类似于 Pascal 的“record”或 C 的“struct”这样的数据类型非常有用，绑定一些命名的数据。在 Python 中一个空的类定义就可以做到：<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="literal">pass</span></span><br><span class="line"></span><br><span class="line">john = <span class="constant">Employee</span>()  <span class="comment"># Create an empty employee record</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the fields of the record</span></span><br><span class="line">john.<span class="literal">name</span> = <span class="string">'John Doe'</span></span><br><span class="line">john.dept = <span class="string">'computer lab'</span></span><br><span class="line">john.salary = <span class="number">1000</span></span><br></pre></td></tr></table></figure></p>
<p>一段 Python 代码中如果需要一个抽象数据类型，那么可以通过传递一个类给那个方法，就好像有了那个数据类型一样。</p>
<p>例如，如果你有一个函数用于格式化某些从文件对象中读取的数据，你可以定义一个有 read() 和 readline() 方法的类用于读取数据，然后将这个类作为一个参数传递给那个函数。</p>
<p><br><br><br><br><br></p>
<h3 id="附：类变量与实例变量的区别">附：类变量与实例变量的区别</h3><p><strong>类变量（class variable）</strong>是类的属性和方法，它们会被类的所有实例共享。而<strong>实例变量（instance variable）</strong>是实例对象所特有的数据。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>:</span></span><br><span class="line">    kind = <span class="string">'dog'</span>    <span class="comment"># class variable shared by all instances</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        self.color = color    <span class="comment"># instance variable unique to each instance</span></span><br><span class="line"></span><br><span class="line">a1 = animal(<span class="string">'black'</span>)</span><br><span class="line">a2 = animal(<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">print(a1.kind, a2.kind)     <span class="comment"># shared by all animals</span></span><br><span class="line">print(a1.color, a2.color)   <span class="comment"># unique to each animal</span></span><br></pre></td></tr></table></figure></p>
<p>当类变量（被所有实例共享）是一个可变的对象时，如 list 、dict ，那么在一个实例对象中改变该属性，其他实例的这个属性也会发生变化。这应该不难理解，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>:</span></span><br><span class="line">    actions = []    <span class="comment"># class variable shared by all instances</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        self.color = color    <span class="comment"># instance variable unique to each instance</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addActions</span><span class="params">(self, action)</span>:</span></span><br><span class="line">        self.actions.append(action)</span><br><span class="line"></span><br><span class="line">a1 = animal(<span class="string">'black'</span>)</span><br><span class="line">a2 = animal(<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">a1.addActions(<span class="string">'run'</span>)      <span class="comment"># 动物a1会跑</span></span><br><span class="line">a2.addActions(<span class="string">'fly'</span>)      <span class="comment"># 动物a2会飞</span></span><br><span class="line"></span><br><span class="line">print(a1.actions, a2.actions)   <span class="comment"># 输出：['run', 'fly'] ['run', 'fly']</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果显示：动物 a1 和 a2 总是又相同的行为（actions），显然这不是我们想要的，因为不同的动物有不同的行为，比如狗会跑、鸟会飞、鱼会游……</p>
<p>对这个问题进行改进，我们只需要将 <strong>actions</strong> 这个属性变成实例变量，让它对每个实例对象都 unique ，而不是被所有实例共享：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        self.color = color    <span class="comment"># instance variable</span></span><br><span class="line">        self.actions = []     <span class="comment"># instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addActions</span><span class="params">(self, action)</span>:</span></span><br><span class="line">        self.actions.append(action)</span><br><span class="line"></span><br><span class="line">a1 = animal(<span class="string">'black'</span>)</span><br><span class="line">a2 = animal(<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">a1.addActions(<span class="string">'run'</span>)      <span class="comment"># 动物a1会跑</span></span><br><span class="line">a2.addActions(<span class="string">'fly'</span>)      <span class="comment"># 动物a2会飞</span></span><br><span class="line"></span><br><span class="line">print(a1.actions, a2.actions)   <span class="comment"># 输出：['run'] ['fly']</span></span><br></pre></td></tr></table></figure></p>
<p>（全文完）<br><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://songlee24.github.io/2014/08/20/python-basic-10/">类的初印象</a>中，我们已经简单的介绍了类，包括类的定义、类对象和实例对象。本文将进一步学习类的继承、迭代器、发生器等等。</p>
<p><br></p>
<h3 id="一、类的继承">一、类的继承</h3><p><strong>单继承</strong></p>
<p>派生类的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（十） 类的初印象]]></title>
    <link href="http://yoursite.com/2014/08/20/python-basic-10/"/>
    <id>http://yoursite.com/2014/08/20/python-basic-10/</id>
    <published>2014-08-19T18:10:39.000Z</published>
    <updated>2015-05-10T08:00:19.308Z</updated>
    <content type="html"><![CDATA[<p>Python是一种面向对象的脚本语言，所以它也提供了面向对象编程的所有基本特征：<em>允许多继承的类继承机制、派生类可以重写它父类的任何方法、一个方法可以调用父类中同名的方法、对象可以包含任意数量和类型的数据成员</em>。关于继承，将在下一篇博文里面介绍，本文只简单的介绍Python中的类的定义和使用。</p>
<h3 id="一、类定义">一、类定义</h3><p>最简单的类的定义形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>类定义会创建一个新的命名空间，作为一个局部的作用域。在Python中，类本身就是对象，当一个类定义结束后, 一个 Class Object 就被创建。</p>
<p><br></p>
<h3 id="二、类对象">二、类对象</h3><p>类对象（Class Object）支持两种操作：<strong>属性引用</strong> 和 <strong>实例化</strong>。</p>
<p><strong>属性引用</strong></p>
<p>类对象的属性引用和 Python 中所有的属性引用一样，形式为：<code>obj.name</code> 。类对象创建后，类命名空间中所有的名字都是有效属性名，像下面这个类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""A simple example class"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p>
<p>它有一个属性 i 和 方法 f ，所以可以用<code>MyClass.i</code> 和 <code>MyClass.f</code> 进行属性引用，分别返回一个整数和一个函数对象。__doc__ 也是一个合法的属性，返回属于这个类的文档字符串。</p>
<p><strong>实例化</strong></p>
<p>类的实例化形式为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="function"><span class="title">MyClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>创建了一个新的实例，并且将其指定给局部变量 x 。</p>
<p>在创建实例时，通常可能都需要有特定的初始状态，所以一个类可以定义一个名为 <code>__init__()</code>的特殊方法（构造方法）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure></p>
<p>当一个类定义了 __init__() 方法，类在实例化时会<strong>自动调用</strong> __init__() 方法，用于创建新的类实例。 就像C++中的构造函数一样， __init__() 也可以有更多的参数，这时实例化提供给类的参数会传给 __init__() ，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line"></span><br><span class="line">stu = student(<span class="string">'Selena'</span>, <span class="number">19</span>)</span><br><span class="line">print(stu.name, stu.age)     <span class="comment"># 输出：Selena 19</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、实例对象">三、实例对象</h3><p>类对象实例化得到<strong>实例对象（Instance Object）</strong>，实例对象只能进行 <strong>属性引用</strong> 这一种操作。合法的属性有两种：数据属性 和 方法。</p>
<p><strong>数据属性</strong></p>
<p>数据属性（data attributes）相当于C++中的数据成员，在Python中，数据属性不需要声明，当它们第一次指定时就会被引入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">x = MyClass()</span><br><span class="line">x.counter = <span class="number">1</span></span><br><span class="line">print(x.counter)</span><br><span class="line"><span class="keyword">del</span> x.counter</span><br></pre></td></tr></table></figure></p>
<p>注：在Python中每个值都是一个对象，可以通过<code>object.__class__</code>来获取对象的 class （即类型），其作用与 type() 相同。</p>
<p><strong>方法</strong></p>
<p>在类对象中定义的函数与普通函数只有一个特别的区别：<strong>它们的第一个参数必须是<code>self</code>，用以指定调用该方法的实例对象。</strong> </p>
<p><strong>注意</strong>：类的方法只有被绑定到实例对象上才能够被调用。比如上面的例子中，x 是 MyClass类的一个实例对象，所以它可以直接调用 f 方法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="function"><span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>为什么 f() 定义时是有一个参数的，而这里调用不需要参数呢？ 因为在调用时， x 对象作为参数传递给了函数的第一个参数（即 self）。也就是说，<code>x.f()</code> 是严格等价于 <code>MyClass.f(x)</code>的。</p>
<p>所以在多数情况下，调用一个方法（有个 n 个参数），和调用相应的函数（也有那 n 个参数，但是再额外加入一个使用该方法的对象） 是等价的。</p>
<p>另外，函数也可以在 class 外定义，指定该函数对象给类中的局部变量就可以了，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function defined outside the class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(x, y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    f = f1</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">c = C()    <span class="comment"># 实例化</span></span><br><span class="line">c.f(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">c.g()</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、私有成员">四、私有成员</h3><p>从C++术语上讲，Python 类的成员（包括数据成员）通常都是 <strong>public</strong> 的，并且所有的成员函数都是 <strong>virtual</strong> 的。</p>
<p>那么，如何在类中定义私有变量或私有方法呢？ </p>
<p>答：在Python中规定，以<strong>两个下划线开头的名字</strong>为私有成员，不能在类的外部使用。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    __str = <span class="string">'python'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.__str   <span class="comment"># 'A' object has no attribute '__str'</span></span><br><span class="line">a.__f()   <span class="comment"># 'A' object has no attribute '__f'</span></span><br><span class="line">a.f()     <span class="comment"># 输出：python</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
<h3 id="附：作用域的探讨">附：作用域的探讨</h3><p>在讲<a href="http://songlee24.github.io/blog/2014/08/09/python3ji-chu-wu-han-shu/" target="_blank" rel="external">函数变量作用域</a>时，曾经说过在一个局部作用域内重新绑定全局变量，需要使用<code>global</code>声明。否则，尝试给这个变量赋值，只是会简单的创建一个新的局部变量，而不会改变那个全局变量。</p>
<p>这里再介绍一个<code>nonlocal</code>语句，它用于指示，在外层的局部作用域中的变量可以在这里进行重新绑定。下面是一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scope_test</span><span class="params">()</span>:</span>   <span class="comment"># 作用域测试</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_local</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="string">'local x'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_nonlocal</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = <span class="string">'nonlocal x'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        x = <span class="string">'global x'</span></span><br><span class="line"></span><br><span class="line">    x = <span class="string">'test x'</span>   <span class="comment"># 局部变量</span></span><br><span class="line"></span><br><span class="line">    do_local()</span><br><span class="line">    print(<span class="string">'After do_local():'</span>, x)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    print(<span class="string">'After do_nonlocal():'</span>, x)</span><br><span class="line">    do_global()</span><br><span class="line">    print(<span class="string">'After do_global():'</span>, x)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line">print(<span class="string">'In global scope:'</span>, x)</span><br></pre></td></tr></table></figure></p>
<p>可以看出，局部的赋值 <strong>do_local()</strong> 并没有改变 scope_test 绑定的 x 变量，而 <strong>do_nonlocal()</strong> 则改变了 scope_test 中的 x，而 <strong>do_global()</strong> 则改变了模块级别的绑定，即全局变量。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python是一种面向对象的脚本语言，所以它也提供了面向对象编程的所有基本特征：<em>允许多继承的类继承机制、派生类可以重写它父类的任何方法、一个方法可以调用父类中同名的方法、对象可以包含任意数量和类型的数据成员</em>。关于继承，将在下一篇博文里面介绍，本文只简单的介绍Python中的类的定义和使用。</p>
<h3 id="一、类定义">一、类定义</h3><p>最简单的类的定义形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（九） 错误和异常]]></title>
    <link href="http://yoursite.com/2014/08/19/python-basic-09/"/>
    <id>http://yoursite.com/2014/08/19/python-basic-09/</id>
    <published>2014-08-19T05:44:15.000Z</published>
    <updated>2015-05-10T07:57:26.421Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍Python中的错误和异常，涉及到简单的异常处理、抛出异常以及清理动作。至于<strong>自定义异常类</strong>，将在介绍类与继承的时候讲到。</p>
<h3 id="一、定义">一、定义</h3><p>常见的两种错误：语法错误 和 异常。</p>
<p><strong>1、语法错误（Syntax Errors）</strong></p>
<p>语法错误，也就是解析时错误。当我们写出不符合python语法的代码时，在解析时会报SyntaxError，并且会显示出错的那一行，并用小箭头指明最早探测到错误的位置。比如：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = input(<span class="string">'please input an integer:'</span>)</span><br><span class="line"><span class="keyword">if</span> int(x) &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p>
<p>在python 3中会报语法错误：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">File</span> <span class="string">"/home/songlee/test"</span>, <span class="keyword">line</span> 3</span><br><span class="line">    <span class="keyword">print</span> 'hello world'</span><br><span class="line">                      ^</span><br><span class="line">SyntaxError: invalid <span class="keyword">syntax</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、异常（Exceptions）</strong></p>
<p>即使语句或表达式在语法上是正确的，但在尝试运行时也可能发生错误，运行时错误就叫做 异常（Exceptions） 。异常并不是致命的问题，因为我们可以在程序中对异常进行处理。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">ZeroDivisionError</span><span class="symbol">:</span> division by zero</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="number">2</span> + x*<span class="number">3</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> name <span class="string">'x'</span> is <span class="keyword">not</span> <span class="keyword">defined</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'2'</span> + <span class="number">2</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">TypeError</span><span class="symbol">:</span> <span class="constant">Can</span><span class="string">'t convert '</span>int<span class="string">' object to str implicitly</span></span><br></pre></td></tr></table></figure></p>
<p>上面展示了三种exception的类型：ZeroDivisionError、NameError、TypeError ，它们都是内置异常的名称。标准异常的名字是内建的标识符 (但并不是关键字)。</p>
<p><br></p>
<h3 id="二、处理异常（try…except…）">二、处理异常（try…except…）</h3><p>我们可以使用 try…except… 语句来处理异常。try 语句块中是要执行的语句，except 语句块中是异常处理语句。一个 try 语句可以有多条的 except 语句，用以指定不同的异常，但至多只有一个会被执行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    x = <span class="function"><span class="title">int</span><span class="params">(input(<span class="string">'please input an integer:'</span>)</span></span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">30</span>/x &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'Hello World!'</span>)</span></span></span><br><span class="line">except ValueError:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'That was no valid number. Try again...'</span>)</span></span></span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'The divisor can not be zero, Try again...'</span>)</span></span></span><br><span class="line">except:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'Handling other exceptions...'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，当输入a（非数字）时，将抛出<strong><em>ValueError</em></strong>异常；当输入0时，将抛出<strong><em>ZeroDivisionError</em></strong>异常；当抛出<strong><em>其他类型</em></strong>的异常时，将执行except:后的处理语句。</p>
<p>如果在 try 语句执行时，出现了一个异常，该语句的剩下部分将被跳过。并且如果该异常的类型匹配到了 except 后面的异常名，那么该 except 后的语句将被执行。注意，如果 except 后面没有跟异常名，表示它匹配任何类型的异常，<code>except:</code>必须放在最后。</p>
<p>一个 except 语句可以同时包括多个异常名，但需要用括号括起来，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>try / except 语句可以有一个可选的 else 语句。else 语句必须要放在所有 except 语句后面，当<strong>没有异常发生</strong>的时候，else 从句将被执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    name = input(<span class="string">'please input an integer:'</span>)</span><br><span class="line">    f = open(name, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    print(<span class="string">'Cannot open'</span>, name)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Unexpected errors.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'close the file'</span>, name)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、抛出异常（raise）">三、抛出异常（raise）</h3><p><strong>raise 语句</strong>允许程序员强制地抛出一个特定的异常，例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; raise <span class="constant">NameError</span>(<span class="string">'HiThere'</span>)     <span class="comment"># 抛出异常</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> <span class="constant">HiThere</span></span><br></pre></td></tr></table></figure></p>
<p>raise 抛出的异常必须是一个异常实例或类（派生自 Exception 的类）。</p>
<p><br></p>
<h3 id="四、清理动作（finally）">四、清理动作（finally）</h3><p>try 语句有另一种可选的<code>finally</code>从句，用于自定义一些扫尾清理的工作。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    x = <span class="function"><span class="title">int</span><span class="params">(input(<span class="string">'please input an integer:'</span>)</span></span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'Hello World!'</span>)</span></span></span><br><span class="line">except ValueError:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'It was not a number. Try again.'</span>)</span></span></span><br><span class="line">finally:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'Some clean-up actions!'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>与 else 从句的区别在于：</strong> else 语句只在没有异常发生的情况下执行，而 finally 语句则不管异常发生与否都会执行。准确的说，finally 语句总是在退出 try 语句前被执行，无论是正常退出、异常退出，还是通过break、continue、return退出。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divide(x, y):</span><br><span class="line">...     <span class="keyword">try</span>:</span><br><span class="line">...             <span class="literal">result</span> = x / y</span><br><span class="line">...     <span class="keyword">except</span> <span class="type">ZeroDivisionError</span>:</span><br><span class="line">...             print('error: division by zero!')</span><br><span class="line">...     <span class="keyword">else</span>:</span><br><span class="line">...             print('executing <span class="keyword">else</span>-clause,', '<span class="literal">result</span> <span class="keyword">is</span>', <span class="literal">result</span>)</span><br><span class="line">...     <span class="keyword">finally</span>:</span><br><span class="line">...             print('executing <span class="keyword">finally</span>-clause')</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; divide(<span class="number">2</span>, <span class="number">1</span>)      <span class="comment"># 正常退出</span></span><br><span class="line">executing <span class="keyword">else</span>-clause, <span class="literal">result</span> <span class="keyword">is</span> <span class="number">2</span>.<span class="number">0</span></span><br><span class="line">executing <span class="keyword">finally</span>-clause</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; divide(<span class="number">2</span>, <span class="number">0</span>)      <span class="comment"># 异常退出</span></span><br><span class="line">error: division by zero!</span><br><span class="line">executing <span class="keyword">finally</span>-clause</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; divide('<span class="number">2</span>', '<span class="number">1</span>')  <span class="comment"># 异常退出，异常未被处理。</span></span><br><span class="line">executing <span class="keyword">finally</span>-clause</span><br><span class="line"><span class="type">Traceback</span> (most recent call last):</span><br><span class="line">  <span class="type">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  <span class="type">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> divide</span><br><span class="line"><span class="type">TypeError</span>: unsupported operand <span class="keyword">type</span>(s) <span class="keyword">for</span> /: 'str' <span class="keyword">and</span> 'str'</span><br></pre></td></tr></table></figure></p>
<p>从上面看出，finally 语句在任何情况下都被执行了。对于没有被 except 处理的异常，将在执行完 finally 后被重新抛出。</p>
<p>另外，有些对象预定义了标准的<strong>清理动作（clean-up actions）</strong>。当对象不再需要时，该动作将被执行，无论对其使用的操作是否成功。例如下面的<a href="http://songlee24.github.io/2014/08/14/python-basic-07/" target="_blank" rel="external">文件I/O</a>例子：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="function"><span class="title">open</span><span class="params">(<span class="string">"myfile.txt"</span>)</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(line, end=<span class="string">""</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这段代码的问题在于，在此代码成功执行后，文件依然被打开着。但<code>with</code>语句可以让文件对象在使用后被正常的清理掉：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">with</span> <span class="built_in">open</span>(<span class="string">"myfile.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="operator">in</span> f:</span><br><span class="line">        print(<span class="built_in">line</span>, <span class="function"><span class="keyword">end</span>="")</span></span><br></pre></td></tr></table></figure></p>
<p>在执行该语句后，文件 f 就会被关闭，就算是在读取时碰到了问题，文件 f 也会被关闭。像文件这样的对象，总会提供预定义的清理工作。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍Python中的错误和异常，涉及到简单的异常处理、抛出异常以及清理动作。至于<strong>自定义异常类</strong>，将在介绍类与继承的时候讲到。</p>
<h3 id="一、定义">一、定义</h3><p>常见的两种错误：语法错误 和 异常。</p>
<p><strong>1、语法错误（Syntax Errors）</strong></p>
<p>语法错误，也就是解析时错误。当我们写出不符合python语法的代码时，在解析时会报SyntaxError，并且会显示出错的那一行，并用小箭头指明最早探测到错误的位置。比如：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（八） 模块]]></title>
    <link href="http://yoursite.com/2014/08/18/python-basic-08/"/>
    <id>http://yoursite.com/2014/08/18/python-basic-08/</id>
    <published>2014-08-18T13:45:54.000Z</published>
    <updated>2015-05-10T07:52:11.121Z</updated>
    <content type="html"><![CDATA[<p>在程序中定义<a href="http://songlee24.github.io/2014/08/09/python-basic-05/" target="_blank" rel="external">函数</a>可以实现代码重用。但当你的代码逐渐变得庞大时，你可能想要把它分割成几个文件，以便能够更简单地维护。同时，你希望在一个文件中写的代码能够被其他文件所重用，这时我们应该使用<strong>模块（module）</strong>。</p>
<h3 id="一、导入模块">一、导入模块</h3><p>在Python中，一个<code>.py</code>文件就构成一个模块。一个模块中的定义可以<strong>导入（import）</strong>到另一个模块或主模块。</p>
<p>比如你可以通过内置模块platform来查看你当前的操作平台信息：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line">s = platform.platform()</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># 我的输出：Linux-3.15.8-200.fc20.x86_64-x86_64-with-fedora-20-Heisenbug</span></span><br></pre></td></tr></table></figure></p>
<p>又比如你可以通过内置模块time获取当前的时间：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> time</span></span><br><span class="line">s = time.ctime()</span><br><span class="line"><span class="built_in">print</span>(s)<span class="preprocessor"></span><br><span class="line"># 输出：Mon Aug 18 16:04:57 2014</span></span><br></pre></td></tr></table></figure></p>
<p>每个模块有其私有的符号表，在该模块内部当成全局符号表来使用。 当我们将一个模块导入到当前模块时，只有被导入模块的名称被放入当前模块的全局符号表里，所以我们不用担心变量名发生冲突。</p>
<p><strong>其他几种导入方式：</strong></p>
<p>1、<code>import a as b</code>：导入模块a，并将模块a重命名为b。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import <span class="tag">time</span> as x   </span><br><span class="line">s = x.<span class="function"><span class="title">ctime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure></p>
<p>2、<code>from a import func</code>：直接把模块内的函数或变量的名称导入当前模块符号表里。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line">s = ctime()   <span class="comment"># 这时可以直接调用函数，而不用再使用time.ctime()</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>3、<code>from a import *</code>：导入模块中所有的名字（以下划线开头的名字除外）到当前模块符号表里。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">s = ctime()   </span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>注意：导入 * 是不好的，因为它常常产生难以阅读的代码，并且会容易产生名字冲突。</p>
<p><br></p>
<h3 id="二、模块搜索路径">二、模块搜索路径</h3><p>当导入名为 a 的模块时, 解释器会先从内建模块尝试匹配，如果没找到，则将在 <code>sys.path</code> 记录的所有目录中搜索 a.py 文件，而<code>sys.path</code>则包括：</p>
<ul>
<li>当前程序所在目录</li>
<li>标准库的安装目录</li>
<li>操作系统环境变量PYTHONPATH所包含的目录</li>
</ul>
<p>变量 sys.path 是一个字符串列表，它为解释器指定了模块的搜索路径。它通过环境变量 PATHONPATH 初始化为一个默认路径，当没有设置 PYTHONPATH 时, 就使用内建默认值来初始化。你可以通过标准 list 操作来修改它：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import sys</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sys.path.append(<span class="string">'/ufs/guido/lib/python'</span>)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、模块的__name__">三、模块的__name__</h3><p>对于任何一个模块，模块的名字都可以通过全局变量 <code>__name__</code>得到：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">time</span></span><br><span class="line">s = <span class="built_in">time</span>.__name__</span><br><span class="line"><span class="built_in">print</span>(s)    # 输出<span class="built_in">time</span></span><br></pre></td></tr></table></figure></p>
<p>一个模块既可以在其它模块中导入使用，也可以当作脚本直接运行。不同的是，当导入到其他模块时，__name__的值是被导入模块的名字；而当作为脚本运行时，__name__的值被设为<strong>“__main__“</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">'This program is being run by itself'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">'I am being imported into another module'</span>)</span><br></pre></td></tr></table></figure></p>
<p>当作脚本执行：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">test</span>.py </span><br><span class="line">This <span class="keyword">program</span> is being <span class="keyword">run</span> <span class="keyword">by</span> itself</span><br></pre></td></tr></table></figure></p>
<p>当作导入模块使用：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import test</span><br><span class="line"><span class="constant">I</span> am being imported into another <span class="class"><span class="keyword">module</span></span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、dir()_函数">四、dir() 函数</h3><p>在<a href="http://songlee24.github.io/2014/08/13/python-basic-06/" target="_blank" rel="external">Python3基础六</a>中我们提到，可以通过内置dir()函数查询一个类或者对象的所有属性。除此之外，我们还可以用它列出一个模块里定义的所有名字，它返回一个有序字串列表：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import builtins</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dir(builtins)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="五、包">五、包</h3><p>可以把多个模块，即多个.py文件，放在同一个文件夹中，构成一个<strong>包（Package）</strong>。例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          顶级包</span><br><span class="line">      __init__<span class="class">.py</span>               初始化这个声音包</span><br><span class="line">      formats/                  格式转换子包</span><br><span class="line">              __init__<span class="class">.py</span></span><br><span class="line">              wavread<span class="class">.py</span></span><br><span class="line">              wavwrite<span class="class">.py</span></span><br><span class="line">              aiffread<span class="class">.py</span></span><br><span class="line">              aiffwrite<span class="class">.py</span></span><br><span class="line">              auread<span class="class">.py</span></span><br><span class="line">              auwrite<span class="class">.py</span></span><br><span class="line">              ...</span><br><span class="line">      effects/                  音效子包</span><br><span class="line">              __init__<span class="class">.py</span></span><br><span class="line">              echo<span class="class">.py</span></span><br><span class="line">              surround<span class="class">.py</span></span><br><span class="line">              reverse<span class="class">.py</span></span><br><span class="line">              ...</span><br><span class="line">      filters/                  过滤器子包</span><br><span class="line">              __init__<span class="class">.py</span></span><br><span class="line">              equalizer<span class="class">.py</span></span><br><span class="line">              vocoder<span class="class">.py</span></span><br><span class="line">              karaoke<span class="class">.py</span></span><br><span class="line">              ...</span><br></pre></td></tr></table></figure></p>
<p>注意：在每个包文件夹里都必须包含一个 __init__.py 的文件，告诉Python，该文件夹是一个包。__init__.py 可以是一个空文件。</p>
<p>我们可以通过<code>import 包名.模块名</code>导入包中的子模块，例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sound<span class="class">.effects</span><span class="class">.echo</span></span><br></pre></td></tr></table></figure></p>
<p>当然，也可以使用<code>from... import...</code>句式导入包中的模块：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo               <span class="comment"># 导入echo子模块</span></span><br><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter    <span class="comment"># 导入echo子模块中的函数或变量</span></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *                  <span class="comment"># 导入__all__变量中所有的子模块</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在程序中定义<a href="http://songlee24.github.io/2014/08/09/python-basic-05/">函数</a>可以实现代码重用。但当你的代码逐渐变得庞大时，你可能想要把它分割成几个文件，以便能够更简单地维护。同时，你希望在一个文件中写的代码能够被其他文件所重用，这时我们应该使用<strong>模块（module）</strong>。</p>
<h3 id="一、导入模块">一、导入模块</h3><p>在Python中，一个<code>.py</code>文件就构成一个模块。一个模块中的定义可以<strong>导入（import）</strong>到另一个模块或主模块。</p>
<p>比如你可以通过内置模块platform来查看你当前的操作平台信息：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python FAQ2：赋值、浅拷贝、深拷贝的区别？]]></title>
    <link href="http://yoursite.com/2014/08/15/python-FAQ-02/"/>
    <id>http://yoursite.com/2014/08/15/python-FAQ-02/</id>
    <published>2014-08-14T16:58:57.000Z</published>
    <updated>2015-05-10T07:39:06.313Z</updated>
    <content type="html"><![CDATA[<p>在写Python过程中，经常会遇到对象的拷贝，如果不理解<strong>浅拷贝</strong>和<strong>深拷贝</strong>的概念，你的代码就可能出现一些问题。所以，在这里按个人的理解谈谈它们之间的区别。<br><br></p>
<h3 id="一、赋值（assignment）">一、赋值（assignment）</h3><p>在《<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/" target="_blank" rel="external">Python FAQ1</a>》一文中，对赋值已经讲的很清楚了，关键要理解<strong>变量与对象的关系</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="number">139701469405552</span></span><br><span class="line"><span class="number">139701469405552</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在Python中，用一个变量给另一个变量<strong>赋值</strong>，其实就是给当前内存中的对象增加一个“标签”而已。</p>
<p>如上例，通过使用内置函数 id() ，可以看出 a 和 b 指向内存中同一个对象。<code>a is b</code>会返回 True 。<br><br></p>
<h3 id="二、浅拷贝（shallow_copy）">二、浅拷贝（shallow copy）</h3><p><strong>注意：浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。</strong></p>
<p>所谓“浅拷贝”，是指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象）</p>
<p>常见的浅拷贝有：切片操作、工厂函数、对象的copy()方法、copy模块中的copy函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = list(a)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b))          <span class="comment"># a和b身份不同</span></span><br><span class="line"><span class="number">140601785066200</span> <span class="number">140601784764968</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):       <span class="comment"># 但它们包含的子对象身份相同</span></span><br><span class="line"><span class="prompt">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="number">140601911441984</span> <span class="number">140601911441984</span></span><br><span class="line"><span class="number">140601911442016</span> <span class="number">140601911442016</span></span><br><span class="line"><span class="number">140601911442048</span> <span class="number">140601911442048</span></span><br></pre></td></tr></table></figure></p>
<p>从上面可以明显的看出来，a 浅拷贝得到 b，a 和 b 指向内存中不同的 <strong>list</strong> 对象，但它们的元素却指向相同的 <strong>int</strong> 对象。这就是浅拷贝！<br><br></p>
<h3 id="三、深拷贝（deep_copy）">三、深拷贝（deep copy）</h3><p>所谓“深拷贝”，是指创建一个新的对象，然后递归的拷贝原对象所包含的子对象。深拷贝出来的对象与原对象没有任何关联。</p>
<p>深拷贝只有一种方式：copy模块中的deepcopy函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="tag">b</span> = copy.<span class="function"><span class="title">deepcopy</span><span class="params">(a)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(id(a)</span></span>, <span class="function"><span class="title">id</span><span class="params">(b)</span></span>)</span><br><span class="line"><span class="number">140601785065840</span> <span class="number">140601785066200</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="function"><span class="title">zip</span><span class="params">(a, b)</span></span>:</span><br><span class="line">...     <span class="function"><span class="title">print</span><span class="params">(id(x)</span></span>, <span class="function"><span class="title">id</span><span class="params">(y)</span></span>)</span><br><span class="line">... </span><br><span class="line"><span class="number">140601911441984</span> <span class="number">140601911441984</span></span><br><span class="line"><span class="number">140601911442016</span> <span class="number">140601911442016</span></span><br><span class="line"><span class="number">140601911442048</span> <span class="number">140601911442048</span></span><br></pre></td></tr></table></figure>
<p>看了上面的例子，有人可能会疑惑：</p>
<p><strong>为什么使用了深拷贝，a和b中元素的id还是一样呢？</strong> </p>
<p>答：这是因为对于<strong>不可变对象</strong>，当需要一个新的对象时，python可能会返回已经存在的某个类型和值都一致的对象的引用。而且这种机制并不会影响 a 和 b 的相互独立性，因为当两个元素指向同一个不可变对象时，对其中一个赋值不会影响另外一个。</p>
<p>我们可以用一个包含可变对象的列表来确切地展示“浅拷贝”与“深拷贝”的区别：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = copy.copy(a)              <span class="comment"># 浅拷贝得到b</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>c = copy.deepcopy(a)          <span class="comment"># 深拷贝得到c</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b))           <span class="comment"># a 和 b 不同</span></span><br><span class="line"><span class="number">139832578518984</span> <span class="number">139832578335520</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):        <span class="comment"># a 和 b 的子对象相同</span></span><br><span class="line"><span class="prompt">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="number">139832578622816</span> <span class="number">139832578622816</span></span><br><span class="line"><span class="number">139832578622672</span> <span class="number">139832578622672</span></span><br><span class="line"><span class="number">139832578623104</span> <span class="number">139832578623104</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(c))           <span class="comment"># a 和 c 不同</span></span><br><span class="line"><span class="number">139832578518984</span> <span class="number">139832578622456</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, c):        <span class="comment"># a 和 c 的子对象也不同</span></span><br><span class="line"><span class="prompt">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="number">139832578622816</span> <span class="number">139832578621520</span></span><br><span class="line"><span class="number">139832578622672</span> <span class="number">139832578518912</span></span><br><span class="line"><span class="number">139832578623104</span> <span class="number">139832578623392</span></span><br></pre></td></tr></table></figure></p>
<p>从这个例子中可以清晰地看出浅拷贝与深拷贝地区别。</p>
<p><br><br><br></p>
<h3 id="总结：">总结：</h3><p>1、赋值：简单地拷贝对象的引用，两个对象的id相同。<br>2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。<br>3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。</p>
<p>浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写Python过程中，经常会遇到对象的拷贝，如果不理解<strong>浅拷贝</strong>和<strong>深拷贝</strong>的概念，你的代码就可能出现一些问题。所以，在这里按个人的理解谈谈它们之间的区别。<br><br></p>
<h3 id="一、赋值（assignment）">一、赋值（assignment）</h3><p>在《<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/">Python FAQ1</a>》一文中，对赋值已经讲的很清楚了，关键要理解<strong>变量与对象的关系</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="number">139701469405552</span></span><br><span class="line"><span class="number">139701469405552</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（七） 输入和输出]]></title>
    <link href="http://yoursite.com/2014/08/14/python-basic-07/"/>
    <id>http://yoursite.com/2014/08/14/python-basic-07/</id>
    <published>2014-08-14T13:16:46.000Z</published>
    <updated>2015-05-10T07:36:42.774Z</updated>
    <content type="html"><![CDATA[<p>一个程序可以从键盘读取输入，也可以从文件读取输入；而程序的结果可以输出到屏幕上，也可以保存到文件中便于以后使用。本文介绍Python中最基本的I/O函数。</p>
<p><br></p>
<h3 id="一、控制台I/O">一、控制台I/O</h3><p><strong>读取键盘输入</strong></p>
<p>内置函数<code>input([prompt])</code>，用于从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = input(<span class="string">"Enter your input:"</span>)</span><br></pre></td></tr></table></figure></p>
<p>注：在Python 3.x版本中取消了 raw_input() 函数。</p>
<p><strong>打印到屏幕</strong></p>
<p>最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print([<span class="link_label">object, ...</span>][<span class="link_reference">, sep=' '</span>][<span class="link_label">, end='endline_character_here'</span>][<span class="link_reference">, file=redirect_to_here</span>])</span><br></pre></td></tr></table></figure></p>
<p>方括号内是可选的，sep表示分割符，end表示结束符，file表示重定向文件。如果要给sep、end、file指定值必须使用关键字参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'hello'</span>, <span class="string">'world'</span>, sep=<span class="string">'%'</span>)    <span class="comment"># 输出hello%world</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello'</span>, <span class="string">'world'</span>, end=<span class="string">'*'</span>)    <span class="comment"># 输出hello world*，并且不换行</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、文件I/O">二、文件I/O</h3><p>读写文件之前，先用open()函数打开一个文件，它会返回一个文件对象（file object）：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="function"><span class="title">open</span><span class="params">(filename，mode)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果不指定mode参数，文件将默认以<strong>‘r’</strong>模式打开。模式中的字符有：</p>
<ul>
<li><strong>r</strong>：只读</li>
<li><strong>w</strong>：只写，如果文件已存在则将其覆盖。如果该文件不存在，创建新文件</li>
<li><strong>+</strong>：读写（<strong>不能单独使用</strong>）</li>
<li><strong>a</strong>：打开文件用于追加，只写，不存在则创建新文件</li>
<li><strong>b</strong>：以二进制模式打开（<strong>不能单独使用</strong>）</li>
</ul>
<p>所以可能的模式大概有<strong>r、w、r+、w+、rb、wb、rb+、wb+、a、a+、ab、ab+</strong>，注意只有w和a可以创建文件。</p>
<p>通常情况下，文件都是以文本模式（text mode）打开的，也就是说，从文件中读写的是以一种特定的编码格式进行编码（默认的是 UTF-8）的<strong>字符串</strong>。如果文件以二进制模式（binary mode）打开，数据将以<strong>字节对象</strong>的形式进行读写：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">'a.txt'</span>,<span class="string">'wb+'</span>)</span><br><span class="line">f.<span class="built_in">write</span>(<span class="string">'I like apple!'</span>)   <span class="comment"># 报错</span></span><br><span class="line">f.<span class="built_in">write</span>(b<span class="string">'I like apple!'</span>)  <span class="comment"># 以bytes对象的形式进行读写</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://docs.python.org/3.4/library/stdtypes.html#bytes" target="_blank" rel="external"><strong>Bytes对象</strong></a>是0到127的不可修改的整数序列，或纯粹的 ASCII 字符，它的用途是存储二进制数据。  </p>
<ol>
<li>可以通过<strong>在一个字符串前面加上’b’</strong>来创建一个bytes literal；</li>
<li>也可以通过<strong>bytes() 函数</strong>创建一个 bytes 对象。</li>
</ol>
<p>注意：如果bytes() 函数的初始化器是一个字符串，那么必须提供一种编码。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1 = b<span class="attribute">'This</span> <span class="keyword">is</span> <span class="typename">string</span>'</span><br><span class="line">b2 = bytes(<span class="attribute">'This</span> <span class="keyword">is</span> <span class="typename">string</span>', <span class="attribute">'UTF</span>-<span class="number">8</span>')   # 必须指定编码格式</span><br></pre></td></tr></table></figure></p>
<p>字符串对象与字节对象是不兼容的，要将 bytes 转变为 str， bytes 对象必须要进行解码，使用<strong>decode()</strong> 方法：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = bytes(<span class="string">'This is string'</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line">print(b, b.decode(), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="preprocessor"># 输出：</span></span><br><span class="line"><span class="preprocessor"># b'This is string'</span></span><br><span class="line"><span class="preprocessor"># This is string</span></span><br></pre></td></tr></table></figure></p>
<p><strong>文件对象的方法</strong>（假设f是一个文件对象）：</p>
<ul>
<li><strong>f.read(size) ：</strong>读取size个字节的数据，然后作为字符串或 bytes 对象返回。size是一个可选参数，如果不指定size，则读取文件的所有内容。</li>
<li><strong>f.readline() ：</strong>读取一行。在字符串末尾会留下换行符 (\n)，如果到文件尾，返回空字符串。</li>
<li><strong>f.readlines() ：</strong>读取所有行，储存在列表中，每个元素是一行，相当于<code>list(f)</code>。</li>
<li><strong>f.write(string) ：</strong>将 string 写入到文件中，返回写入的字符数。如果以二进制模式写文件，需要将string转换为 bytes 对象。</li>
<li><strong>f.tell() ：</strong>返回文件对象当前所处的位置，它是从文件开头开始算起的字节数。 </li>
<li><strong>f.seek(offset, from_what) ：</strong>改变文件对象所处的位置。offset是相对参考位置的偏移量，from_what 取值 0（文件头, 默认）、1（当前位置）、2（文件尾）表示参考位置。</li>
<li><strong>f.close() ：</strong>关闭文件对象。</li>
</ul>
<p>这些都是很常用的方法，当然文件对象不止这些方法。根据打开的模式不同，open() 返回的文件对象类型也不同：</p>
<ul>
<li><strong>TextIOWrapper</strong>：文本模式，返回TextIOWrapper对象。</li>
<li><strong>BufferedReader</strong>：读二进制，即rb，返回BufferedReader对象。</li>
<li><strong>BufferedWriter</strong>：写和追加二进制，即wb、ab，返回BufferedWriter对象。</li>
<li><strong>BufferedRandom</strong>：读/写模式，即含有+的模式，返回BufferedRandom对象。</li>
</ul>
<p>可以在这些文件对象上运行 dir() 或 help()，查看它们所有的方法。</p>
<p><strong>补充</strong>：</p>
<p>1、在文本模式下，seek()方法只会相对于文件起始位置进行定位。（除了定位文件尾可以用 <code>seek(0, 2)</code>之外）<br>2、可以循环迭代一个文件对象一行一行读取：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="operator">in</span> f:</span><br><span class="line">print(<span class="built_in">line</span>, <span class="function"><span class="keyword">end</span>='')</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、格式化输出">三、格式化输出</h3><p>一般来说，我们希望更多的控制输出格式，而不是简单的以空格分割。这里有两种方式：</p>
<ul>
<li>第一种是由你自己控制。使用字符串切片、连接操作以及 <a href="https://docs.python.org/3.4/library/stdtypes.html#str.center" target="_blank" rel="external">string</a> 包含的一些有用的操作。</li>
<li>第二种是使用<a href="https://docs.python.org/3.4/library/stdtypes.html#str.format" target="_blank" rel="external">str.format()</a>方法。</li>
</ul>
<p>下面给一个示例：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 第一种方式：自己控制</span></span><br><span class="line"><span class="keyword">for</span> x in range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	print(str(x).rjust(<span class="number">2</span>), str(x*x).rjust(<span class="number">3</span>), end=<span class="string">' '</span>)</span><br><span class="line">	print(str(x*x*x).rjust(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 第二种方式：str.format()</span></span><br><span class="line"><span class="keyword">for</span> x in range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	print(<span class="string">'&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;'</span>.format(x, x*x, x*x*x))</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 输出都是：</span></span><br><span class="line"><span class="preprocessor">#  1   1    1</span></span><br><span class="line"><span class="preprocessor">#  2   4    8</span></span><br><span class="line"><span class="preprocessor">#  3   9   27</span></span><br><span class="line"><span class="preprocessor">#  4  16   64</span></span><br><span class="line"><span class="preprocessor">#  5  25  125</span></span><br><span class="line"><span class="preprocessor">#  6  36  216</span></span><br><span class="line"><span class="preprocessor">#  7  49  343</span></span><br><span class="line"><span class="preprocessor">#  8  64  512</span></span><br><span class="line"><span class="preprocessor">#  9  81  729</span></span><br><span class="line"><span class="preprocessor"># 10 100 1000</span></span><br></pre></td></tr></table></figure></p>
<p>第一种方式中，字符串对象的 <strong>str.rjust()</strong> 方法的作用是将字符串靠右，并默认在左边填充空格，类似的方法还有 <strong>str.ljust()</strong> 和 <strong>str.center()</strong> 。这些方法并不会写任何东西，它们仅仅返回新的字符串，如果输入很长，它们并不会截断字符串。<strong>我们注意到，</strong>同样是输出一个平方与立方表，使用str.format()会方便很多。</p>
<p>str.format()的基本用法如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print<span class="list">(<span class="quoted">'We</span> are the &#123;&#125; who say <span class="string">"&#123;&#125;!"</span>'.format<span class="list">(<span class="quoted">'knights</span>', <span class="quoted">'Ni</span>')</span>)</span></span><br><span class="line">We are the knights who say <span class="string">"Ni!"</span></span><br></pre></td></tr></table></figure></p>
<p>括号及括号里的字符将会被 format() 中的参数替换.。括号中的数字用于指定传入对象的位置：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(<span class="string">'&#123;0&#125; and &#123;1&#125;'</span>.format(<span class="string">'Kobe'</span>, <span class="string">'James'</span>))</span><br><span class="line"><span class="constant">Kobe</span> <span class="keyword">and</span> <span class="constant">James</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(<span class="string">'&#123;1&#125; and &#123;0&#125;'</span>.format(<span class="string">'Kobe'</span>, <span class="string">'James'</span>))</span><br><span class="line"><span class="constant">James</span> <span class="keyword">and</span> <span class="constant">Kobe</span></span><br></pre></td></tr></table></figure></p>
<p>如果在 format() 中使用了<strong>关键字参数</strong>，那么它们的值会指向使用该名字的参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'The &#123;thing&#125; is &#123;adj&#125;.'</span>.format(thing=<span class="string">'flower'</span>, adj=<span class="string">'beautiful'</span>))</span><br><span class="line">The flower <span class="keyword">is</span> beautiful.</span><br></pre></td></tr></table></figure></p>
<p>可选项<code>&#39;:&#39;</code>和格式标识符可以跟着 field name，这样可以进行更好的格式化：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(<span class="string">'The value of PI is &#123;0:.3f&#125;.'</span>.<span class="built_in">format</span>(math.<span class="constant">pi</span>))</span><br><span class="line">The <span class="built_in">value</span> <span class="operator">of</span> <span class="constant">PI</span> is <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure></p>
<p>在<code>&#39;:&#39;</code>后传入一个整数，可以保证该域至少有这么多的宽度，用于美化表格时很有用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>table = &#123;<span class="string">'Jack'</span>:<span class="number">4127</span>, <span class="string">'Rose'</span>:<span class="number">4098</span>, <span class="string">'Peter'</span>:<span class="number">7678</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> name, phone <span class="keyword">in</span> table.items():</span><br><span class="line"><span class="prompt">... </span>    print(<span class="string">'&#123;0:10&#125; ==&gt; &#123;1:10d&#125;'</span>.format(name, phone))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">Peter      ==&gt;       <span class="number">7678</span></span><br><span class="line">Rose       ==&gt;       <span class="number">4098</span></span><br><span class="line">Jack       ==&gt;       <span class="number">4127</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以将<a href="http://songlee24.github.io/blog/2014/08/09/python3ji-chu-wu-han-shu/" target="_blank" rel="external">参数解包</a>进行格式化输出。例如，将table解包为关键字参数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table = &#123;<span class="string">'Jack'</span>:<span class="number">4127</span>, <span class="string">'Rose'</span>:<span class="number">4098</span>, <span class="string">'Peter'</span>:<span class="number">7678</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Jack is &#123;Jack&#125;, Rose is &#123;Rose&#125;, Peter is &#123;Peter&#125;.'</span>.format(**table))</span><br><span class="line"># 输出：Jack <span class="keyword">is</span> <span class="number">4127</span>, Rose <span class="keyword">is</span> <span class="number">4098</span>, Peter <span class="keyword">is</span> <span class="number">7678.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>补充：</strong>  </p>
<p>% 操作符也可以实现字符串格式化。它将左边的参数作为类似 sprintf() 式的格式化字符串，而将右边的代入：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">print(<span class="attribute">'The</span> value <span class="keyword">of</span> PI <span class="keyword">is</span> %<span class="number">10.3</span>f.' %math.pi)</span><br><span class="line"># 输出：The value <span class="keyword">of</span> PI <span class="keyword">is</span>      <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure></p>
<p>因为这种旧式的格式化最终会从Python语言中移除，应该更多的使用 str.format() 。</p>
<p><br><br><br><br></p>
<h3 id="附：文本模式与二进制模式">附：文本模式与二进制模式</h3><p>1、在Windows系统中，文本模式下，默认是将Windows平台的行末标识符 \r\n 在读时转为 \n ，而在写时将 \n 转为 \r\n 。 这种隐藏的行为对于文本文件是没有问题的，但是对于二进制数据像 JPEG 或 EXE 是会出问题的。在使用这些文件时请小心使用二进制模式。</p>
<p>2、在类Unix/Linux系统中，行末标识符为 \n，即文件以 \n 代表换行。所以Unix/Linux系统中在文本模式和二进制模式下并无区别。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个程序可以从键盘读取输入，也可以从文件读取输入；而程序的结果可以输出到屏幕上，也可以保存到文件中便于以后使用。本文介绍Python中最基本的I/O函数。</p>
<p><br></p>
<h3 id="一、控制台I/O">一、控制台I/O</h3><p><strong>读取键盘输入</strong></p>
<p>内置函数<code>input([prompt])</code>，用于从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（六） 深入list列表]]></title>
    <link href="http://yoursite.com/2014/08/13/python-basic-06/"/>
    <id>http://yoursite.com/2014/08/13/python-basic-06/</id>
    <published>2014-08-12T16:14:05.000Z</published>
    <updated>2015-05-10T07:35:18.179Z</updated>
    <content type="html"><![CDATA[<p>正如<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/" target="_blank" rel="external">Python FAQ1附录</a>中说的， Python中任何值都是一个对象，所以任何类型（int、str、list…）都是一个类。而类就必然有它的方法或属性，我们要记下这么多类的所有方法显然是不可能的，这里介绍两个小技巧：</p>
<ul>
<li><strong>dir()</strong> ：内置函数，用来查询一个类或者对象所有属性，比如<code>&gt;&gt;&gt; dir(list)</code>。</li>
<li><strong>help()</strong> ：内置函数，用来查询具体的说明文档，比如<code>&gt;&gt;&gt; help(int)</code>。</li>
</ul>
<p>在<a href="http://songlee24.github.io/2014/08/08/python-basic-02/" target="_blank" rel="external">Python的基本数据类型</a>中，我们初步了解了list列表，也介绍了列表是Python 中使用最频繁的数据类型。本文将进一步深入学习列表的使用。<br><a id="more"></a><br></p>
<h3 id="一、列表的方法">一、列表的方法</h3><p>list.<strong>append</strong>(x)<br>在列表的尾部添加一个项，等价于 <code>a[len(a):] = [x]</code>。</p>
<p>list.<strong>extend</strong>(L)<br>将给定的列表L接到当前列表后面，等价于 <code>a[len(a):] = L</code>。</p>
<p>list.<strong>insert</strong>(i, x)<br>在给定的位置 i 前插入项，例如：a.insert(0, x) 会在列表的头部插入，而 a.insert(len(a), x) 则等价于 a.append(x)。</p>
<p>list.<strong>remove</strong>(x)<br>移除列表中第一个值为 x 的项，没有的话会产生一个错误。</p>
<p>list.<strong>pop</strong>([i])<br>删除列表给定位置的项，并返回它。如果没有指定索引，<code>a.pop()</code> 移除并返回列表的最后一项。（方括号表示可选）</p>
<p>list.<strong>clear</strong>()<br> 删除列表中的所有项，相当于 <code>del a[:]</code>。</p>
<p>list.<strong>index</strong>(x)<br>返回列表中第一个值为 x 的项的索引。如果没有匹配的项, 则产生一个错误。</p>
<p>list.<strong>count</strong>(x)<br>返回列表中 x 出现的次数。</p>
<p>list.<strong>sort</strong>()<br>就地完成列表排序。</p>
<p>list.<strong>reverse</strong>()<br>就地完成列表项的翻转。</p>
<p>list.<strong>copy</strong>()<br>返回列表的一个浅拷贝，相当于<code>a[:]</code>。<br><br></p>
<h3 id="二、列表当栈">二、列表当栈</h3><p>List的方法使得其可以很方便地作为一个<strong>栈</strong>来使用。我们知道，栈的特点是最后进入的元素最先出来（即后入先出），用<code>append()</code>方法进行压栈，用不指定索引的<code>pop()</code>方法进行出栈。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">	stack.append(x)   <span class="comment"># 入栈</span></span><br><span class="line">	print(<span class="string">'push'</span>, x, end=<span class="string">' '</span>)</span><br><span class="line">	print(stack)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Now stack is'</span>, stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(stack)&gt;<span class="number">0</span>:</span><br><span class="line">	print(<span class="string">'pop'</span>, stack.pop(), end=<span class="string">' '</span>) <span class="comment"># 出栈</span></span><br><span class="line">	print(stack)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、列表当队列">三、列表当队列</h3><p>列表还可以当作<strong>队列</strong>来使用，队列的特性是第一个加入的元素第一个取出来（即先入先出）。然而，把列表当队列使用效率并不高，因为从列表的尾部添加和弹出元素是很快的，而在列表的开头插入或弹出是比较慢的（因为所有元素都得移动一个位置）。</p>
<p>要实现一个队列, 使用标准库的<a href="https://docs.python.org/3.4/library/collections.html#collections.deque" target="_blank" rel="external">collections.deque</a>， 它被设计成在两端添加和弹出都很快。示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from collections import <span class="built_in">deque</span></span><br><span class="line"><span class="built_in">queue</span> = <span class="built_in">deque</span>()       <span class="preprocessor"># 创建空队列</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> x in <span class="title">range</span><span class="params">(1,6)</span>:</span><br><span class="line">	<span class="built_in">queue</span>.<span class="title">append</span><span class="params">(x)</span>   # 入队</span><br><span class="line">	<span class="title">print</span><span class="params">('push', x, end=' ')</span></span><br><span class="line">	<span class="title">print</span><span class="params">(<span class="built_in">list</span>(<span class="built_in">queue</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">print</span><span class="params">('Now <span class="built_in">queue</span> is', <span class="built_in">list</span>(<span class="built_in">queue</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="title">len</span><span class="params">(<span class="built_in">queue</span>)</span>&gt;0:</span><br><span class="line">	<span class="title">print</span><span class="params">('pop', <span class="built_in">queue</span>.popleft()</span>, end</span>=<span class="string">' '</span>)  <span class="preprocessor"># 出队</span></span><br><span class="line">	print(<span class="built_in">list</span>(<span class="built_in">queue</span>))</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、列表推导式">四、列表推导式</h3><p>列表推导式提供了从序列创建列表的简单途径。通常程序会对序列的每一个元素做些操作，并以其结果作为新列表的元素，或者根据指定的条件来创建子序列。</p>
<p>列表推导式的结构是：在一个<strong>方括号</strong>里，首先是一个表达式，随后是一个 for 子句，然后是零个或更多的 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。 示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 推导式</span></span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"><span class="comment"># 输出是[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x!=y]  <span class="comment"># 推导式</span></span><br><span class="line"><span class="built_in">print</span>(pairs)</span><br><span class="line"><span class="comment"># 输出是[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="五、列表嵌套">五、列表嵌套</h3><p>Python中并没有二维数组的概念，但我们可以通过<strong>列表嵌套</strong>达到同样的目的。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">mat</span> = [</span><br><span class="line">		[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">		[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">		[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">	  ]</span><br></pre></td></tr></table></figure></p>
<p>同样，我们可以使用推导式生成嵌套的列表：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mat = <span class="string">[[1,2,3], [4,5,6], [7,8,9]]</span></span><br><span class="line">new_mat = [ [row[i] <span class="keyword">for</span> row <span class="keyword">in</span> mat] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] ] # 嵌套</span><br><span class="line"><span class="built_in">print</span>(new_mat)</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><strong>附：del语句</strong></p>
<p><code>del</code>语句可以通过给定索引（而不是值）来删除列表中的项，它与返回一个值的<strong>pop()</strong>方法不同。del语句也可以移除列表中的切片，或者清除整个列表 ：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">2</span>]    <span class="comment"># 删除指定索引项</span></span><br><span class="line">print(lst)    </span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># 删除切片</span></span><br><span class="line">print(lst)</span><br><span class="line"><span class="keyword">del</span> lst[:]    <span class="comment"># 删除整个列表</span></span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p>
<p>del也可以用于删除变量实体：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">del</span> lst</span><br></pre></td></tr></table></figure></p>
<p>在删除变量实体之后引用 <strong>lst</strong> 的话会产生错误。</p>
<p>（全文完）</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>正如<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/">Python FAQ1附录</a>中说的， Python中任何值都是一个对象，所以任何类型（int、str、list…）都是一个类。而类就必然有它的方法或属性，我们要记下这么多类的所有方法显然是不可能的，这里介绍两个小技巧：</p>
<ul>
<li><strong>dir()</strong> ：内置函数，用来查询一个类或者对象所有属性，比如<code>&gt;&gt;&gt; dir(list)</code>。</li>
<li><strong>help()</strong> ：内置函数，用来查询具体的说明文档，比如<code>&gt;&gt;&gt; help(int)</code>。</li>
</ul>
<p>在<a href="http://songlee24.github.io/2014/08/08/python-basic-02/">Python的基本数据类型</a>中，我们初步了解了list列表，也介绍了列表是Python 中使用最频繁的数据类型。本文将进一步深入学习列表的使用。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python FAQ1：传值，还是传引用？]]></title>
    <link href="http://yoursite.com/2014/08/12/python-FAQ-01/"/>
    <id>http://yoursite.com/2014/08/12/python-FAQ-01/</id>
    <published>2014-08-11T16:19:24.000Z</published>
    <updated>2015-05-10T07:30:07.259Z</updated>
    <content type="html"><![CDATA[<p>在C/C++中，传值和传引用是函数参数传递的两种方式。由于思维定式，从C/C++转过来的Python初学者也经常会感到疑惑：<strong>在Python中，<a href="http://songlee24.github.io/2014/08/09/python-basic-05/" target="_blank" rel="external">函数</a>参数传递是传值，还是传引用呢？</strong></p>
<p>看下面两段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">foo(x)    <span class="comment"># 输出5</span></span><br><span class="line">print(x)  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2]</span></span><br><span class="line">foo(x)</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>看完第一段代码，会有人说这是<strong>值传递</strong>，因为函数并没有改变x的值；看完第二段代码，又会有人说这是<strong>传引用</strong>，因为函数改变了x的内容。</p>
<p>那么，Python中的函数到底是传值还是传引用呢？看下面的解释。</p>
<p><br></p>
<h3 id="一、变量和对象">一、变量和对象</h3><p>我们需要先知道Python中的“变量”与C/C++中“变量”是不同的。</p>
<p><strong>在C/C++中</strong>，当你初始化一个变量时，就是声明一块存储空间并写入值。相当于<strong>把一个值放入一个盒子里</strong>：<br><code>int a = 1;</code><br><img src="http://img.blog.csdn.net/20140811213617169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>现在”a”盒子里放了一个整数1，当给变量a赋另外一个值时会替换盒子a里面的内容：<br><code>a = 2;</code><br><img src="http://img.blog.csdn.net/20140811214003681?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>当你把变量a赋给另外一个变量时，会拷贝a盒子中的值并放入一个新的“盒子”里：<br><code>int b = a;</code><br><img src="http://img.blog.csdn.net/20140811214347058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><img src="http://img.blog.csdn.net/20140811214003681?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>在Python中</strong>，一个变量可以说是<strong>内存中的一个对象的“标签”或“引用”</strong>：<br><code>a = 1</code><br><img src="http://img.blog.csdn.net/20140811215128273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>现在变量a指向了内存中的一个int型的对象（a相当于对象的标签）。如果给a重新赋值，那么标签a将会移动并指向另一个对象：<br><code>a = 2</code><br><img src="http://img.blog.csdn.net/20140811215650741?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>原来的值为1的int型对象仍然存在，但我们不能再通过a这个标识符去访问它了（<strong>当一个对象没有任何标签或引用指向它时，它就会被自动释放</strong>）。如果我们把变量a赋给另一个变量，我们只是给当前内存中对象增加一个“标签”而已：<br><code>b = a</code><br><img src="http://img.blog.csdn.net/20140811220515281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>综上所述，在Python中变量只是一个标签一个标识符，它指向内存中的对象。故<strong>变量并没有类型，类型是属于对象的</strong>，这也是Python中的变量可以被任何类型赋值的原因。</p>
<p><br></p>
<h3 id="二、可变对象与不可变对象">二、可变对象与不可变对象</h3><p>在<a href="http://songlee24.github.io/blog/2014/08/08/python3ji-chu-er/" target="_blank" rel="external"><strong>Python的基本数据类型</strong></a>中，我们知道numbers、strings和tuples是不可更改的对象，而list、dict是可以修改的对象。那么可变与不可变有什么区别呢？看下面示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">a</span> = <span class="number">1</span>     <span class="comment"># a指向内存中一个int型对象</span></span><br><span class="line"><span class="operator">a</span> = <span class="number">2</span>     <span class="comment"># 重新赋值</span></span><br></pre></td></tr></table></figure></p>
<p>当将a重新赋值时，因为原来值为1的对象是不能改变的，所以a会指向一个新的int对象，其值为2。（如上面的图示）<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lst</span> = [<span class="number">1</span>, <span class="number">2</span>]   <span class="comment"># lst指向内存中一个list类型的对象</span></span><br><span class="line">lst[<span class="number">0</span>] = <span class="number">2</span>     <span class="comment"># 重新赋值lst中第一个元素</span></span><br></pre></td></tr></table></figure></p>
<p>因为list类型是可以改变的，所以第一个元素变更为2。更确切的说，lst的第一个元素是int型，重新赋值时一个新的int对象被指定给第一个元素，但是对于lst来说，它所指的列表型对象没有变，只是列表的内容（其中一个元素）改变了。</p>
<p>好了，到这里我们就很容易解释本文开头的两段代码了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">foo(x)    <span class="comment"># 输出5</span></span><br><span class="line">print(x)  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码把x作为参数传递给函数，这时x和arg都指向内存中值为1的对象。然后在函数中arg = 5时，因为int对象不可改变，于是创建一个新的int对象（值为5）并且令arg指向它。而x仍然指向原来的值为1的int对象，所以函数没有改变x变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2]</span></span><br><span class="line">foo(x)</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码同样把x传递给函数foo，那么x和arg都会指向同一个list类型的对象。因为list对象是可以改变的，函数中使用append在其末尾添加了一个元素，list对象的内容发生了改变，但是x和arg仍然是指向这一个list对象，所以变量x的内容发生了改变。</p>
<p>那么Python中参数传递是传值，还是传引用呢？准确的回答：<strong>都不是</strong>。之所以不是传值，因为没有产生复制，而且函数拥有与调用者同样的对象。而似乎更像是C++的传引用？但是有时却不能改变实参的值。只能这样说：<strong>对于不可变的对象，它看起来像C++中的传值方式；对于可变对象，它看起来像C++中的按引用传递。</strong></p>
<p><br><br></p>
<h3 id="附：_Everything_is_Object_in_Python">附：  <strong>Everything is Object in Python</strong></h3><p>Python使用对象模型来储存数据，任何类型的值都是一个对象。所有的python对象都有3个特征：身份、类型和值。</p>
<ul>
<li><strong>身份</strong>：每一个对象都有自己的唯一的标识，可以使用内建函数<strong>id()</strong>来得到它。这个值可以被认为是该对象的内存地址。</li>
<li><strong>类型</strong>：对象的类型决定了该对象可以保存的什么类型的值，可以进行什么操作，以及遵循什么样的规则。<strong>type()</strong>函数来查看python 对象的类型。</li>
<li><strong>值</strong>：对象表示的数据项。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">id</span><span class="params">(a)</span></span></span><br><span class="line"><span class="number">140068196051520</span></span><br><span class="line">&gt;&gt;&gt; <span class="tag">b</span> = <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">id</span><span class="params">(b)</span></span></span><br><span class="line"><span class="number">140068196051552</span></span><br><span class="line">&gt;&gt;&gt; c = <span class="tag">a</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">id</span><span class="params">(c)</span></span></span><br><span class="line"><span class="number">140068196051520</span></span><br><span class="line">&gt;&gt;&gt; c is <span class="tag">a</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c is not <span class="tag">b</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>运算符<code>is</code>、<code>is not</code>就是通过id()的返回值（即身份）来判定的，也就是看它们是不是同一个对象的“标签”。</p>
<p>（全文完）<br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++中，传值和传引用是函数参数传递的两种方式。由于思维定式，从C/C++转过来的Python初学者也经常会感到疑惑：<strong>在Python中，<a href="http://songlee24.github.io/2014/08/09/python-basic-05/">函数</a>参数传递是传值，还是传引用呢？</strong></p>
<p>看下面两段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">foo(x)    <span class="comment"># 输出5</span></span><br><span class="line">print(x)  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（五） 函数]]></title>
    <link href="http://yoursite.com/2014/08/09/python-basic-05/"/>
    <id>http://yoursite.com/2014/08/09/python-basic-05/</id>
    <published>2014-08-09T15:58:33.000Z</published>
    <updated>2015-05-10T00:10:59.702Z</updated>
    <content type="html"><![CDATA[<p><strong>函数（function）</strong>是组织好的、可重复使用的、具有一定功能的代码段。函数能提高应用的模块性和代码的重复利用率，Python中已经提供了很多内建函数，比如print()，同时Python还允许用户自定义函数。</p>
<h3 id="定义">定义</h3><p>定义函数使用关键字<code>def</code>，后接函数名和放在圆括号( )中的可选参数列表，函数内容以<strong>冒号</strong>起始并且<strong>缩进</strong>。一般格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">	<span class="string">"""文档字符串"""</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>注意：参数列表可选，文档字符串可选，return语句可选。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="string">"""Print a Fibonacci series"""</span></span><br><span class="line">	a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> b &lt; n:</span><br><span class="line">		print(b, end=<span class="string">' '</span>)</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fib(<span class="number">2000</span>)  <span class="comment"># call</span></span><br><span class="line">f = fib    <span class="comment"># assignment</span></span><br><span class="line">f(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></p>
<p>函数名的值是一种用户自定义的函数类型。函数名的值可以被赋予另一个名字，使其也能作为函数使用。</p>
<p><br></p>
<h3 id="函数变量作用域">函数变量作用域</h3><p>在函数内部定义的变量拥有一个局部作用域，在函数外定义的拥有全局作用域。注意：在函数内部可以引用全局变量，但无法对其赋值（除非用<code>global</code>进行声明）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>         <span class="comment"># 全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'func1() print a ='</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">21</span>    <span class="comment"># 局部变量a</span></span><br><span class="line">	print(<span class="string">'func2() print a ='</span>, a) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> a</span><br><span class="line">	a = <span class="number">10</span>    <span class="comment"># 修改全局变量a</span></span><br><span class="line">	print(<span class="string">'func3() print a ='</span>, a)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br><span class="line">func3()</span><br><span class="line">print(<span class="string">'the global a ='</span>, a)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="函数调用">函数调用</h3><p><strong>1、普通调用</strong></p>
<p>与其他语言中函数调用一样，Python中在调用函数时，需要给定和形参相同个数的实参并按顺序一一对应。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">	print(<span class="string">'Name:'</span>,name,<span class="string">'Age:'</span>,age,<span class="string">'Gender:'</span>,gender,end=<span class="string">' '</span>)</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fun(<span class="string">'Jack'</span>, <span class="number">20</span>, <span class="string">'man'</span>) <span class="comment"># call</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、使用关键字参数调用函数</strong></p>
<p>函数也可以通过<code>keyword=value</code> 形式的关键字参数来调用，因为我们明确指出了对应关系，所以参数的顺序也就无关紧要了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">	print(<span class="string">'Name:'</span>,name,<span class="string">'Age:'</span>,age,<span class="string">'Gender:'</span>,gender,end=<span class="string">' '</span>)</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fun(gender=<span class="string">'man'</span>, name=<span class="string">'Jack'</span>, age=<span class="number">20</span>) <span class="comment"># using keyword arguments</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3、调用具有默认实参的函数</strong></p>
<p>Python中的函数也可以给一个或多个参数指定默认值，这样在调用时可以选择性地省略该参数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">fun</span><span class="params">(a, b, c=5)</span>:</span></span><br><span class="line">	print(a+b+c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2)</span></span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2,3)</span></span></span><br></pre></td></tr></table></figure></p>
<p><em>注意</em>：通常情况下默认值只被计算一次，但如果默认值是一个<strong>可变对象</strong>时会有所不同, 如列表, 字典, 或大多类的对象时。例如，下面的函数在随后的调用中会累积参数值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">fun</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">	L.append(a)</span><br><span class="line">	print(L)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1)</span>  # 输出[1]</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(2)</span>  # 输出[1, 2]</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(3)</span>  # 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4、调用可变参数函数</strong></p>
<p>通过在形参前加一个星号（*）或两个星号（**）来指定函数可以接收任意数量的实参。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(*args)</span>:</span></span><br><span class="line">	print(type(args))</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt;</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(**args)</span>:</span></span><br><span class="line">	print(type(args))</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">fun(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>,e=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br><span class="line"><span class="comment"># &#123;'d': 4, 'e': 5, 'b': 2, 'c': 3, 'a': 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>从两个示例的输出可以看出：当参数形如<code>*args</code>时，传递给函数的任意个实参会按位置被包装进一个元组（tuple）；当参数形如<code>**args</code>时，传递给函数的任意个<code>key=value</code>实参会被包装进一个字典（dict）。</p>
<p><strong>5、通过解包参数调用函数</strong></p>
<p>上一点说到传递任意数量的实参时会将它们打包进一个元组或字典，当然有打包也就有<strong>解包（unpacking）</strong>。通过 单星号和双星号对List、Tuple和Dictionary进行解包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span>:</span></span><br><span class="line">	print(a+b+c)</span><br><span class="line"></span><br><span class="line">fun()   <span class="comment"># 正常调用</span></span><br><span class="line">list1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">dict1 = &#123;<span class="string">'a'</span>:<span class="number">40</span>, <span class="string">'b'</span>:<span class="number">50</span>, <span class="string">'c'</span>:<span class="number">60</span>&#125;</span><br><span class="line">fun(*list1)   <span class="comment"># 解包列表</span></span><br><span class="line">fun(**dict1)  <span class="comment"># 解包字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 66</span></span><br><span class="line"><span class="comment"># 150</span></span><br></pre></td></tr></table></figure></p>
<p>注：*用于解包Sequence，**用于解包字典。解包字典会得到一系列的<code>key=value</code>，故本质上就是使用<strong>关键字参数</strong>调用函数。</p>
<p><br></p>
<h3 id="lambda表达式">lambda表达式</h3><p>lambda关键词能创建小型匿名函数。lambda函数能接收任何数量的参数但只能返回一个表达式的值，它的一般形式如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">lambda</span> [<span class="atom">arg1</span> [,<span class="atom">arg2</span>,.....<span class="atom">argn</span>]] : <span class="atom">expression</span></span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以在任何需要函数对象的地方使用，它们在语法上被限制为单一的表达式：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda x, y: x+<span class="literal">y</span></span><br><span class="line"><span class="keyword">print</span>(<span class="literal">f</span>(10, 20))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_fun</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> x: x+n</span><br><span class="line"></span><br><span class="line">f = make_fun(<span class="number">15</span>)</span><br><span class="line">print(f(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="文档字符串">文档字符串</h3><p>函式体的第一个语句可以是三引号括起来的字符串， 这个字符串就是函数的<strong>文档字符串</strong>，或称为docstring 。我们可以使用<code>print(function.__doc__)</code>输出文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""Some information of this function.</span><br><span class="line">	This is documentation string."""</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">print(fun.__doc__)</span><br></pre></td></tr></table></figure></p>
<p>文档字符串主要用于描述一些关于函数的信息，让用户交互地浏览和输出。建议养成在代码中添加文档字符串的好习惯。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>函数（function）</strong>是组织好的、可重复使用的、具有一定功能的代码段。函数能提高应用的模块性和代码的重复利用率，Python中已经提供了很多内建函数，比如print()，同时Python还允许用户自定义函数。</p>
<h3 id="定义">定义</h3><p>定义函数使用关键字<code>def</code>，后接函数名和放在圆括号( )中的可选参数列表，函数内容以<strong>冒号</strong>起始并且<strong>缩进</strong>。一般格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">	<span class="string">"""文档字符串"""</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（四） 条件与循环控制]]></title>
    <link href="http://yoursite.com/2014/08/09/python-basic-04/"/>
    <id>http://yoursite.com/2014/08/09/python-basic-04/</id>
    <published>2014-08-09T00:28:43.000Z</published>
    <updated>2015-05-09T23:59:59.883Z</updated>
    <content type="html"><![CDATA[<p>Python的流程控制语句包括：if条件语句、while循环语句、for循环语句、range函数以及break、continue、pass控制语句。这些语句在Python中的语义和在其他语言中是一样的，所以这里就只说它们的写法。</p>
<h3 id="if语句">if语句</h3><p>if语句是最常用的条件控制语句，Python中的一般形式为：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件一:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">elif</span> 条件二:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure></p>
<p>Python中用<code>elif</code>代替了<code>else if</code>，所以if语句的关键字为：if - elif - else。</p>
<p><strong>注意</strong>：<br>1、每个条件后面要使用<strong>冒号（:）</strong>，表示接下来是满足条件后要执行的语句块。<br>2、使用<strong>缩进</strong>来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>3、在Python中没有switch - case语句。</p>
<p>示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="function"><span class="title">int</span><span class="params">(input(<span class="string">"Please enter an integer: "</span>)</span></span>)</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Negative.'</span>)</span></span></span><br><span class="line">elif x == <span class="number">0</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Zero.'</span>)</span></span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Positive.'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="while语句">while语句</h3><p>Python中while语句的一般形式：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure></p>
<p>同样需要注意冒号和缩进。另外，在Python中<strong>没有do..while循环</strong>。</p>
<p>示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">10</span>:  <span class="comment"># 循环输出斐波纳契数列</span></span><br><span class="line">	print(b)</span><br><span class="line">	<span class="operator">a</span>, b = b, <span class="operator">a</span>+b</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="for语句">for语句</h3><p>Python中的for语句与C语言中的for语句有点不同：<strong>C语言中的for语句允许用户自定义迭代步骤和终止条件；而Python的for语句可以遍历任何序列（sequence），按照元素在序列中的出现顺序依次迭代。</strong>一般形式为：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">variable</span> <span class="keyword">in</span> <span class="keyword">sequence</span>:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'cat'</span>,<span class="string">'love'</span>,<span class="string">'apple'</span>,<span class="string">'python'</span>,<span class="string">'friends'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">words</span>:</span><br><span class="line">	print(<span class="keyword">item</span>, <span class="built_in">len</span>(<span class="keyword">item</span>))</span><br></pre></td></tr></table></figure></p>
<p>如果你需要在循环体内修改你正迭代的序列，你最好是制作一个副本，这时<a href="http://blog.csdn.net/lisonglisonglisong/article/details/38440761" target="_blank" rel="external">切片标记</a>就非常有用了：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'cat'</span>,<span class="string">'love'</span>,<span class="string">'apple'</span>,<span class="string">'python'</span>,<span class="string">'friends'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">words</span>[:]:    <span class="comment"># 制作整个列表的切片副本</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(<span class="keyword">item</span>) &gt;= <span class="number">6</span>:</span><br><span class="line">		<span class="keyword">words</span>.insert(<span class="number">0</span>, <span class="keyword">item</span>)</span><br><span class="line">print(<span class="keyword">words</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们注意到循环语句中还可以使用<code>else子句</code>，下面第五点有讲到。</p>
<p><br></p>
<h3 id="range函数">range函数</h3><p>如果你要遍历一个数字序列，那么内置的<strong>range()</strong>函数就可以派上用场了。函数range()常用于for循环中，用于产生一个算术数列：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">10</span>))   <span class="comment"># 默认从0开始</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">1</span>, <span class="number">11</span>))  <span class="comment"># 从1到11，前闭后开</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>))  <span class="comment"># 5表示步长，每隔5取一个数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">2</span>, <span class="number">11</span>)</span></span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(i)</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="break、continue、pass及else子句">break、continue、pass及else子句</h3><p><strong>break</strong></p>
<p>break语句与C语言中的一样，跳出最近的for或while循环。</p>
<p><strong>continue</strong></p>
<p>continue语句同样是从 C 语言借用的, 它终止当前迭代而进行循环的<br>下一次迭代。</p>
<p><strong>pass</strong></p>
<p>pass语句什么都不做，它只在语法上需要一条语句但程序不需要任何操作时使用。pass语句是为了保持程序结构的完整性。</p>
<p><strong>else子句</strong></p>
<p>在循环语句中还可以使用<code>else子句</code>，else子句在<strong>序列遍历结束</strong>（for语句）或<strong>循环条件为假</strong>（while语句）时执行，但循环被break终止时不执行：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 循环结束执行<span class="keyword">else</span>子句</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(2, 11):</span><br><span class="line">	<span class="keyword">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span>('<span class="keyword">for</span> statement is over.')</span><br><span class="line"></span><br><span class="line"># 被<span class="keyword">break</span>终止时不会执行<span class="keyword">else</span>子句</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(5):</span><br><span class="line">	<span class="keyword">if</span>(i == 4):</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span>('<span class="keyword">for</span> statement is over')  # 不会输出</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python的流程控制语句包括：if条件语句、while循环语句、for循环语句、range函数以及break、continue、pass控制语句。这些语句在Python中的语义和在其他语言中是一样的，所以这里就只说它们的写法。</p>
<h3 id="if语句">if语句</h3><p>if语句是最常用的条件控制语句，Python中的一般形式为：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（三） 运算符]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-03/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-03/</id>
    <published>2014-08-08T12:13:46.000Z</published>
    <updated>2015-05-10T07:24:58.749Z</updated>
    <content type="html"><![CDATA[<p>Python中的运算符大部分与C语言的类似，但也有很多不同的地方。这里就大概地罗列一下Python 3中的运算符。</p>
<h3 id="算术运算符">算术运算符</h3><a id="more"></a>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>x + y</td>
<td>加</td>
<td>10+20=30</td>
</tr>
<tr>
<td>x - y</td>
<td>减</td>
<td>10-5=5</td>
</tr>
<tr>
<td>x * y</td>
<td>乘</td>
<td>3*6=18</td>
</tr>
<tr>
<td>x / y</td>
<td>除-返回浮点数</td>
<td>2/4 = 0.5</td>
</tr>
<tr>
<td>x // y</td>
<td>取整除 - 返回商的整数部分</td>
<td>2//4 = 0</td>
</tr>
<tr>
<td>x % y</td>
<td>取余</td>
<td>15 % 4 = 3</td>
</tr>
<tr>
<td>-x</td>
<td>异号</td>
<td>-(-5) = 5</td>
</tr>
<tr>
<td>+x</td>
<td>不变号</td>
<td>+5 = 5</td>
</tr>
<tr>
<td>abs(x)</td>
<td>取绝对值</td>
<td>abs(-0.4) = 0.4</td>
</tr>
<tr>
<td>int(x)</td>
<td>x转换为整数</td>
<td>int(5.9) = 5</td>
</tr>
<tr>
<td>float(x)</td>
<td>x转换为浮点数</td>
<td>float(5) = 5.0</td>
</tr>
<tr>
<td>complex(re, im)</td>
<td>返回复数 - re为实数部分 im为虚数部分</td>
<td>complex(4,3) = 4+3j</td>
</tr>
<tr>
<td>c.conjugate()</td>
<td>返回c的共轭复数</td>
<td>c=4+3j; c.conjugate() = 4-3j</td>
</tr>
<tr>
<td>divmod(x, y)</td>
<td>返回一个数值对(x//y, x%y)</td>
<td>divmod(8, 3) = (2, 2)</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>x的y次幂</td>
<td>pow(2, 5) = 32</td>
</tr>
<tr>
<td>x**y</td>
<td>x的y次幂</td>
<td>2 ** 5 = 32</td>
</tr>
</tbody>
</table>
<p>Note：</p>
<ol>
<li>双斜杠 // 除法总是向下取整。 </li>
<li>从符点数到整数的转换可能会舍入也可能截断，建议使用math.floor()和math.ceil()明确定义的转换。</li>
<li>Python定义<code>pow(0, 0)</code>和<code>0 ** 0</code>等于1。</li>
</ol>
<p><br></p>
<h3 id="比较运算符">比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>is</td>
<td>判断两个标识符是不是引用自一个对象</td>
</tr>
<tr>
<td>is not</td>
<td>判断两个标识符是不是引用自不同对象</td>
</tr>
</tbody>
</table>
<p>Note： </p>
<ol>
<li>八个比较运算符优先级相同。</li>
<li>Python允许<code>x &lt; y &lt;= z</code>这样的链式比较，它相当于<code>x &lt; y and y &lt;= z</code>。 </li>
<li>复数不能进行大小比较，只能比较是否相等。</li>
</ol>
<p><br></p>
<h3 id="逻辑运算符">逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x or y</td>
<td>if x is false, then y, else x</td>
</tr>
<tr>
<td>x and y</td>
<td>if x is false, then x, else y</td>
</tr>
<tr>
<td>not x</td>
<td>if x is false, then True, else False</td>
</tr>
</tbody>
</table>
<p>Note： </p>
<ol>
<li><code>or</code>是个短路运算符，它只有在第一个运算数为False时才会计算第二个运算数的值。</li>
<li><code>and</code>也是个短路运算符，它只有在第一个运算数为True时才会计算第二个运算数的值。</li>
<li><code>not</code>的优先级比其他类型的运算符低，所以not a == b相当于not (a == b)，而 a == not b是错误的。</li>
</ol>
<p><br></p>
<h3 id="位运算符">位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x &#124; y</td>
<td>按位或运算符</td>
</tr>
<tr>
<td>x &amp; y</td>
<td>按位与运算符</td>
</tr>
<tr>
<td>x ^ y</td>
<td>按位异或运算符</td>
</tr>
<tr>
<td>x &lt;&lt; n</td>
<td>左移动运算符</td>
</tr>
<tr>
<td>x &gt;&gt; n</td>
<td>右移动运算符</td>
</tr>
<tr>
<td>~x</td>
<td>按位取反运算符</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="赋值运算符">赋值运算符</h3><p>复合赋值运算符与算术运算符是一一对应的：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
</tr>
<tr>
<td>//=</td>
<td>取整除法运算符</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="成员运算符">成员运算符</h3><p>Python提供了成员运算符，测试一个元素是否在一个序列（Sequence）中。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在指定的序列中找到值返回True，否则返回False。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回True，否则返回False。</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中的运算符大部分与C语言的类似，但也有很多不同的地方。这里就大概地罗列一下Python 3中的运算符。</p>
<h3 id="算术运算符">算术运算符</h3>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（二） 基本数据类型]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-02/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-02/</id>
    <published>2014-08-08T08:00:56.000Z</published>
    <updated>2015-05-09T23:57:04.233Z</updated>
    <content type="html"><![CDATA[<p>Python中的变量<strong>不需要声明</strong>。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在Python中，变量就是变量，它没有类型，<strong>我们所说的“类型”是变量所指的内存中对象的类型</strong>。Python 3中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<p>本文主要先介绍这几种数据类型的定义和它们之间的联系与区别。<br><a id="more"></a></p>
<h3 id="Numbers">Numbers</h3><p>Python 3支持<strong>int、float、bool、complex</strong>（复数）。数值类型的赋值和计算都是很直观的，就像大多数语言一样。内置的<code>type()</code>函数可以用来查询变量所指的对象类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="keyword">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; &lt;<span class="title">class</span> '<span class="title">float</span>'&gt; &lt;<span class="title">class</span> '<span class="title">bool</span>'&gt; &lt;<span class="title">class</span> '<span class="title">complex</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>数值运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余 </span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p><strong>要点</strong>：<br>1、Python可以同时为多个变量赋值，如<code>a, b = 1, 2</code>。<br>2、一个变量可以通过赋值指向不同类型的对象。<br>3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。<br>4、在混合计算时，Pyhton会把整型转换成为浮点数。</p>
<h3 id="Strings">Strings</h3><p>Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来，同时使用反斜杠(\)转义特殊字符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = <span class="string">'Yes,he doesn\'t'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(s, type(s), len(s))</span><br><span class="line">Yes,he doesn<span class="string">'t &lt;class '</span>st<span class="string">r'&gt; 14</span></span><br></pre></td></tr></table></figure></p>
<p>如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)</span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)</span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure></p>
<p>另外，反斜杠可以作为续行符，表示下一行是上一行的延续。还可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>跨越多行。</p>
<p>字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'str'</span>+<span class="string">'ing'</span>, <span class="string">'my'</span>*<span class="number">3</span>)</span><br><span class="line">string mymymy</span><br></pre></td></tr></table></figure></p>
<p>Python中的字符串有<strong>两种索引方式</strong>，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。注意，没有单独的字符类型，一个字符就是长度为1的字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></p>
<p>还可以对字符串进行<strong>切片</strong>，获取一段子串。用冒号分隔两个索引，形式为<code>变量[头下标:尾下标]</code>。截取的范围是前闭后开的，并且两个索引都可以省略：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word = <span class="string">'ilovepython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">1</span><span class="symbol">:</span><span class="number">5</span>]</span><br><span class="line"><span class="string">'love'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="symbol">:</span>]</span><br><span class="line"><span class="string">'ilovepython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">5</span><span class="symbol">:</span>]</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[-<span class="number">10</span><span class="symbol">:-</span><span class="number">6</span>]</span><br><span class="line"><span class="string">'love'</span></span><br></pre></td></tr></table></figure></p>
<p>与C字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如<code>word[0] = &#39;m&#39;</code>会导致错误。</p>
<p><strong>要点</strong>：<br>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。<br>2、字符串可以用+运算符连接在一起，用*运算符重复。<br>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。<br>4、Python中的字符串不能改变。</p>
<h3 id="List">List</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。列表是写在<strong>方括号</strong>之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = [<span class="string">'him'</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="string">'her'</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line">[<span class="string">'him'</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="string">'her'</span>]</span><br></pre></td></tr></table></figure></p>
<p>和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。详细的在这里就不赘述了。</p>
<p>列表还支持串联操作，使用+操作符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a + [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p>与Python字符串不一样的是，列表中的元素是可以改变的：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>] = []   <span class="comment"># 删除</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。</p>
<p><strong>要点</strong>：<br>1、List写在方括号之间，元素用逗号隔开。<br>2、和字符串一样，list可以被索引和切片。<br>3、List可以使用+操作符进行拼接。<br>4、List中的元素是可以改变的。</p>
<h3 id="Tuple">Tuple</h3><p>元组（tuple）与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。元组写在<strong>小括号</strong>里，元素之间用逗号隔开。元组中的元素类型也可以不相同：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = <span class="list">(<span class="number">1991</span>, <span class="number">2014</span>, <span class="quoted">'physics</span>', <span class="quoted">'math</span>')</span></span><br><span class="line">&gt;&gt;&gt; print<span class="list">(<span class="keyword">a</span>, type<span class="list">(<span class="keyword">a</span>)</span>, len<span class="list">(<span class="keyword">a</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1991</span>, <span class="number">2014</span>, <span class="quoted">'physics</span>', <span class="quoted">'math</span>')</span> &lt;class <span class="quoted">'tuple</span><span class="quoted">'&gt;</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。其实，可以把字符串看作一种特殊的元组。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(tup[<span class="number">0</span>], tup[<span class="number">1</span><span class="symbol">:</span><span class="number">5</span>])</span><br><span class="line"><span class="number">1</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup[<span class="number">0</span>] = <span class="number">11</span>  <span class="comment"># 修改元组元素的操作是非法的</span></span><br></pre></td></tr></table></figure></p>
<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">tup1 =</span> () <span class="comment"># 空元组</span></span><br><span class="line"><span class="variable">tup2 =</span> (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></p>
<p>另外，元组也支持用+操作符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup1, tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(tup1+tup2)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<p>string、list和tuple都属于<strong>sequence（序列）</strong>。</p>
<p>要点：<br>1、与字符串一样，元组的元素不能修改。<br>2、元组也可以被索引和切片，方法一样。<br>3、注意构造包含0或1个元素的元组的特殊语法规则。<br>4、元组也可以使用+操作符进行拼接。</p>
<h3 id="Sets">Sets</h3><p>集合（set）是一个<strong>无序不重复</strong>元素的集。基本功能是进行成员关系测试和消除重复元素。可以使用<strong>大括号</strong> 或者 <strong>set()函数</strong>创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; student = &#123;<span class="string">'Tom'</span>, <span class="string">'Jim'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(student)   <span class="comment"># 重复的元素被自动去掉</span></span><br><span class="line">&#123;<span class="string">'Jim'</span>, <span class="string">'Jack'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Rose'</span> in student  <span class="comment"># membership testing（成员测试）</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="comment"># set可以进行集合运算</span></span><br><span class="line">... </span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a - b     <span class="comment"># a和b的差集</span></span><br><span class="line">&#123;<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a | b     <span class="comment"># a和b的并集</span></span><br><span class="line">&#123;<span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a &amp; b     <span class="comment"># a和b的交集</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a ^ b     <span class="comment"># a和b中不同时存在的元素</span></span><br><span class="line">&#123;<span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>要点：<br>1、set集合中的元素不重复，重复了它会自动去掉。<br>2、set集合可以用大括号或者set()函数创建，但空集合必须使用set()函数创建。<br>3、set集合可以用来进行成员测试、消除重复元素。 </p>
<h3 id="Dictionary">Dictionary</h3><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。字典是一种映射类型（mapping type），它是一个无序的<strong>键 : 值</strong>对集合。关键字必须使用不可变类型，也就是说list和包含可变类型的tuple不能做关键字。在同一个字典中，关键字还必须互不相同。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dic = &#123;&#125;  <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel = &#123;<span class="string">'Jack'</span><span class="symbol">:</span><span class="number">1557</span>, <span class="string">'Tom'</span><span class="symbol">:</span><span class="number">1320</span>, <span class="string">'Rose'</span><span class="symbol">:</span><span class="number">1886</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel</span><br><span class="line">&#123;<span class="string">'Tom'</span><span class="symbol">:</span> <span class="number">1320</span>, <span class="string">'Jack'</span><span class="symbol">:</span> <span class="number">1557</span>, <span class="string">'Rose'</span><span class="symbol">:</span> <span class="number">1886</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel[<span class="string">'Jack'</span>]   <span class="comment"># 主要的操作：通过key查询</span></span><br><span class="line"><span class="number">1557</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; del tel[<span class="string">'Rose'</span>]  <span class="comment"># 删除一个键值对</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel[<span class="string">'Mary'</span>] = <span class="number">4127</span>  <span class="comment"># 添加一个键值对</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel</span><br><span class="line">&#123;<span class="string">'Tom'</span><span class="symbol">:</span> <span class="number">1320</span>, <span class="string">'Jack'</span><span class="symbol">:</span> <span class="number">1557</span>, <span class="string">'Mary'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(tel.keys())  <span class="comment"># 返回所有key组成的list</span></span><br><span class="line">[<span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Mary'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sorted(tel.keys()) <span class="comment"># 按key排序</span></span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Tom'</span> in tel       <span class="comment"># 成员测试</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Mary'</span> not in tel  <span class="comment"># 成员测试</span></span><br><span class="line"><span class="constant">False</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数 <strong>dict()</strong> 直接从键值对sequence中构建字典，当然也可以进行推导，如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dict([(<span class="string">'sape'</span>, <span class="number">4139</span>), (<span class="string">'guido'</span>, <span class="number">4127</span>), (<span class="string">'jack'</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">'jack'</span><span class="symbol">:</span> <span class="number">4098</span>, <span class="string">'sape'</span><span class="symbol">:</span> <span class="number">4139</span>, <span class="string">'guido'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; &#123;<span class="symbol">x:</span> x**<span class="number">2</span> for x in (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span><span class="symbol">:</span> <span class="number">4</span>, <span class="number">4</span><span class="symbol">:</span> <span class="number">16</span>, <span class="number">6</span><span class="symbol">:</span> <span class="number">36</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dict(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">'jack'</span><span class="symbol">:</span> <span class="number">4098</span>, <span class="string">'sape'</span><span class="symbol">:</span> <span class="number">4139</span>, <span class="string">'guido'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p>要点：<br>1、字典是一种映射类型，它的元素是键值对。<br>2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用{ }。 </p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中的变量<strong>不需要声明</strong>。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在Python中，变量就是变量，它没有类型，<strong>我们所说的“类型”是变量所指的内存中对象的类型</strong>。Python 3中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<p>本文主要先介绍这几种数据类型的定义和它们之间的联系与区别。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（一） Hello World]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-01/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-01/</id>
    <published>2014-08-08T02:35:14.000Z</published>
    <updated>2015-05-09T23:55:19.007Z</updated>
    <content type="html"><![CDATA[<p>对于新手一般会遇到一个问题：<strong>学习Python 2还是Python 3呢？</strong>  对于我个人而言，我是个完全的新手，没有历史包袱，所以我直接学习Python 3。我相信在未来几年，Python 3会逐步取代Python 2成为主流。</p>
<p>Python是一门解释型、面向对象、动态数据类型的高级程序设计语言，更多的介绍看<a href="https://docs.python.org/3.4/tutorial/appetite.html" target="_blank" rel="external">官方文档</a>。Python让程序更加的紧凑、可读性更强，用 Python 写的程序通常比同样的C、C++或Java程序要短得多，这是因为以下几个原因：<br><a id="more"></a></p>
<ul>
<li>高级数据结构使你能够在单条的语句中表达复杂的操作。</li>
<li>代码块的组织依赖于缩进而不是开始/结束符，例如{ }。</li>
<li>参数或变量不需要声明。</li>
</ul>
<p>OK！下面开始让我们进入Python的世界吧！</p>
<h3 id="第一个HelloWorld程序">第一个HelloWorld程序</h3><p><strong>1、交互模式</strong></p>
<p>交互模式即命令行模式，在Linux终端输入<code>$python</code>即可进入Python交互模式，主提示符&gt;&gt;&gt;提示你输入命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="constant">Python</span> <span class="number">3.3</span>.<span class="number">2</span> (default, <span class="constant">Jun</span> <span class="number">30</span> <span class="number">2014</span>, <span class="number">17</span><span class="symbol">:</span><span class="number">20</span><span class="symbol">:</span><span class="number">03</span>) </span><br><span class="line">[<span class="constant">GCC</span> <span class="number">4.8</span>.<span class="number">3</span> <span class="number">20140624</span> (<span class="constant">Red</span> <span class="constant">Hat</span> <span class="number">4.8</span>.<span class="number">3</span>-<span class="number">1</span>)] on linux</span><br><span class="line"><span class="constant">Type</span> <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>输入多行结构时就需要从属提示符了，例如下面这个if语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>flag=<span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">if</span> flag:</span><br><span class="line"><span class="prompt">... </span>    print(<span class="string">"Hello World!"</span>)</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">Hello World!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>注：在Python 3.x中，print是一个函数，所以必须使用括号输出。</p>
<p><strong>2、脚本文件</strong></p>
<p>我们也可以将代码写到一个.py文件中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后用python命令执行该脚本文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python hello<span class="class">.py</span> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p><strong>3、可执行脚本</strong></p>
<p>在类Unix系统中，Python脚本可以像Shell脚本那样直接执行，通过在脚本文件开头添加一行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br></pre></td></tr></table></figure></p>
<p>然后通过chmod命令修改权限为可执行：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>chmod +x hello.py</span><br></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello<span class="class">.py</span> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="基础语法">基础语法</h3><p><strong>1、编码</strong></p>
<p>默认情况下，Python 3源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。当然你也可以为源码文件指定不同的编码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、标识符</strong></p>
<p>在Python 3中，非-ASCII 标识符也是允许的了。但最好还是只使用英文、数字、下划线作为标识符，并且不能以数字开头。（区分大小写）</p>
<p><strong>3、python保留字</strong></p>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个<a href="https://docs.python.org/2/library/keyword.html" target="_blank" rel="external">keyword</a> module，可以输出当前版本的所有关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>4、注释</strong></p>
<p>Python中单行注释以#开头，多行注释用三个单引号（’’’）或者三个双引号（”””）将注释括起来。</p>
<p><strong>5、行与缩进</strong></p>
<p>python最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<p><br><br><br><br><br></p>
<h3 id="附：">附：</h3><p>在现在的Unix/Linux系统中都会内置Python解释器，在我的Fedora20系统中就同时装了python2和python3。在终端输入<code>$python</code>会使用python 2.x的解释器，输入<code>$python3</code>会使用python 3.x的解释器。现在我想修改一下<strong>软链接</strong>，让<code>$python</code>命令默认使用python 3.x解释器，<code>$python2</code>命令使用python 2.x解释器。怎么做？</p>
<p><strong>软链接：</strong> 一种特殊的文件，该文件的内容是指向另一个文件的位置或路径。它不占用磁盘空间，类似于Windows操作系统中的快捷方式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">硬链接：<span class="tag">ln</span> <span class="attr_selector">[参数]</span> 源文件 目标文件</span><br><span class="line">软链接：<span class="tag">ln</span> <span class="tag">-s</span> <span class="attr_selector">[源文件或目录]</span> <span class="attr_selector">[目标文件或目录]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>ln命令</strong>的功能是为某一个文件在另外一个位置建立一个同步的链接（软链接或者硬链接），现在我要修改python的软链接：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/python2.7 /</span>usr<span class="regexp">/bin/</span>python2  <span class="comment">// 创建python2软链接</span></span><br><span class="line">$ sudo rm <span class="regexp">/usr/</span>bin<span class="regexp">/python  /</span>/ 删除原来的python软链接</span><br><span class="line">$ sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/python3.3 /</span>usr<span class="regexp">/bin/</span>python  <span class="comment">// 创建新的python软链接</span></span><br></pre></td></tr></table></figure></p>
<p>修改了软链接以后的一个伴随的问题是：有些用python写的命令不能执行了，因为python2和python3的语法不兼容。比如<strong>yum命令</strong>，它是python写的，从yum文件开头的<code>#!/usr/bin/python</code>可以看出来。因为python软链接被修改为指向python 3.x解释器，所以执行yum命令时会报语法错误。</p>
<p>我们可以通过修改yum文件来修复这个问题，既然之前我们已经创建了python2软链接指向python 2.x解释器，所以我们修改yum文件开头为<code>#!/usr/bin/python2</code>就可以了，这样在执行yum命令时就会使用python 2.x解释器而不是python 3.x的解释器了。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于新手一般会遇到一个问题：<strong>学习Python 2还是Python 3呢？</strong>  对于我个人而言，我是个完全的新手，没有历史包袱，所以我直接学习Python 3。我相信在未来几年，Python 3会逐步取代Python 2成为主流。</p>
<p>Python是一门解释型、面向对象、动态数据类型的高级程序设计语言，更多的介绍看<a href="https://docs.python.org/3.4/tutorial/appetite.html">官方文档</a>。Python让程序更加的紧凑、可读性更强，用 Python 写的程序通常比同样的C、C++或Java程序要短得多，这是因为以下几个原因：<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1987年国际C语言混乱代码大赛获奖的一行代码]]></title>
    <link href="http://yoursite.com/2014/08/06/Obfuscated-C-Code-Contest/"/>
    <id>http://yoursite.com/2014/08/06/Obfuscated-C-Code-Contest/</id>
    <published>2014-08-06T09:15:43.000Z</published>
    <updated>2015-05-09T18:31:06.371Z</updated>
    <content type="html"><![CDATA[<p>最近<a href="http://coolshell.cn" target="_blank" rel="external">CoolShell博主</a>做了一个很有意思的在线puzzle，这些谜题很有趣同时也有一定的难度。由于水平有限，我并没有通关，我觉得这些题还是很值得一做的，从中可以学到很多东西。</p>
<p>例如其中的第二题：<br><img src="http://img.blog.csdn.net/20140806160507493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><a id="more"></a></p>
<p>题目中给出了一个键盘和一行看不懂的字符串。这个键盘的<strong>键盘布局</strong>和现在通用的键盘（<strong>QWERTY键盘</strong>）不一样，它叫做<strong><a href="http://baike.baidu.com/view/1410112.htm" target="_blank" rel="external">Dvorak键盘</a></strong>。这里就不多作解释了，详细的可以去Google。根据提示：<strong>我们需要通过两种键盘的布局映射，将给出的字符串转换成QWERTY键盘下的输出。</strong>当然，你可以自己一对一写出来，不过<a href="http://wbic16.xedoloh.com/dvorak.html" target="_blank" rel="external">在线转换工具</a>更方便。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">macb</span><span class="params">()</span> ? <span class="title">lpcbyu</span><span class="params">(&amp;gbcq/<span class="variable">_</span>\<span class="number">021</span><span class="comment">%ocq\012\0_=w(gbcq)/_dak._=&#125;_ugb_[0q60)s+</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>转换之后得到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() &#123; <span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是1987年<strong>国际C语言混乱代码大赛（The International Obfuscated C Code Contest, IOCCC）</strong>一等奖的获奖代码，由贝尔实验室的David Korn提交。当然平时我们不会写出这么复杂难懂的代码，但是分析这样的代码却可以扩展我们的知识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* unix被编译器内定为一个宏 </span><br><span class="line">	 * 相当于#define unix 1     */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"unix=%d\n"</span>, unix); <span class="comment">/* =1 */</span>	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印字符串"un"，因为"fun"是个字符数组</span><br><span class="line">	 * "fun"+1相当于字符指针右移，指向"un" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="string">"fun"</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* "have"是个字符数组，"have"[1]即字符a</span><br><span class="line">	 * 输出97，即第二个字符'a'的ASCII值。*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="string">"have"</span>[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在C语言中，x[1] = 1[x] */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span>)[<span class="string">"have"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 97 - 96 = 0x61 - 0x60 = 1 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span>)[<span class="string">"have"</span>] - <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所以 "fun"+((1)["have"]-0x60) 相当于"fun"+1，输出"un" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"fun"</span> + ((<span class="number">1</span>)[<span class="string">"have"</span>] - <span class="number">0x60</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将其中的1用unix代替 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 以上为后半部分 = "un" */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面两个都输出"bcde", 因为指针都是从'b'开始 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"abcde"</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;<span class="string">"abcde"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &amp;"abcde"[1] == &amp;(1)["abcde"]  输出一样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;(<span class="number">1</span>)[<span class="string">"abcde"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1用unix代替 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;unix[<span class="string">"abcde"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面输出"%six" 并换行 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;<span class="string">"?%six\n"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注意：</span><br><span class="line">	   \012 = 0x0a = \n, </span><br><span class="line">	   第一个字符 \021 被跳过</span><br><span class="line">	   \0 是空字符  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 同样输出"%six" 并换行 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;<span class="string">"\021%six\012\0"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相当于这样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;unix[<span class="string">"\021%six\012\0"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 把字符串"%six\n"当作格式，输出"ABix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>], <span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相当于这样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%six\n"</span>, <span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所以下面的可以输出"unix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%six\n"</span>, (unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 至此，问题解决！！！输出"unix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要用到了x[a]和指针运算的一些知识，相信上面的步骤和注释已经很清楚了，最终结果就是输出<code>unix</code>。<br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近<a href="http://coolshell.cn">CoolShell博主</a>做了一个很有意思的在线puzzle，这些谜题很有趣同时也有一定的难度。由于水平有限，我并没有通关，我觉得这些题还是很值得一做的，从中可以学到很多东西。</p>
<p>例如其中的第二题：<br><img src="http://img.blog.csdn.net/20140806160507493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">]]>
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之普通函数指针与成员函数指针]]></title>
    <link href="http://yoursite.com/2014/08/01/cpp-function-pointer/"/>
    <id>http://yoursite.com/2014/08/01/cpp-function-pointer/</id>
    <published>2014-08-01T11:43:55.000Z</published>
    <updated>2015-05-09T18:27:27.205Z</updated>
    <content type="html"><![CDATA[<p><strong>函数指针（function pointer）</strong>是通过指向函数的指针间接调用函数。相信很多人对指向一般函数的函数指针使用的比较多，而对指向类成员函数的函数指针则比较陌生。我最近也被问到了这方面的问题，心中却也没有清晰的答案。故决定去查阅资料，并按照自己的思路写下这篇学习总结。<br><br></p>
<h3 id="普通函数指针">普通函数指针</h3><p>通常我们所说的<strong>函数指针</strong>指的是指向一般普通函数的指针。和其他指针一样，函数指针指向某种特定类型，<strong>所有被同一指针运用的函数必须具有相同的形参类型和返回类型。</strong><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">// 声明函数指针</span></span><br></pre></td></tr></table></figure></p>
<p>这里，pf指向的函数类型是<code>int (int, int)</code>，即函数的参数是两个int型，返回值也是int型。注：<strong>*pf两端的括号必不可少，如果不写这对括号，则pf是一个返回值为int指针的函数。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// typedef一个类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1+s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pFun pf1 = add;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf1)(<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 调用add函数</span></span><br><span class="line">	pf1 = mns;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf1)(<span class="number">8</span>,<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// 调用mns函数</span></span><br><span class="line">	<span class="built_in">string</span> (*pf2)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;) = merge;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf2)(<span class="string">"hello "</span>, <span class="string">"world"</span>) &lt;&lt; endl;  <span class="comment">// 调用merge函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如示例代码，直接声明函数指针变量显得冗长而烦琐，所以我们可以使用<code>typedef</code>定义自己的函数指针类型。另外，函数指针还可以作为函数的形参类型，实参则可以直接使用函数名。<br><br></p>
<h3 id="成员函数指针">成员函数指针</h3><p><strong>成员函数指针（member function pointer）</strong>是指可以指向类的非静态成员函数的指针。类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。<strong>与普通函数指针不同的是，</strong><br>成员函数指针不仅要指定目标函数的形参列表和返回类型，还必须指出成员函数所属的类。因此，我们必须在*之前添加<code>classname::</code>以表示当前定义的指针指向classname的成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (A::*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">// 声明一个成员函数指针</span></span><br></pre></td></tr></table></figure></p>
<p>同理，这里<code>A::*pf</code>两端的括号也是必不可少的，如果没有这对括号，则pf是一个返回A类数据成员（int型）指针的函数。注意：和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = &amp;A::add;   <span class="comment">// 正确：必须显式地使用取址运算符（&amp;）</span></span><br><span class="line">pf = A::add;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<p><strong>当我们初始化一个成员函数指针时，其指向了类的某个成员函数，但并没有指定该成员所属的对象——直到使用成员函数指针时，才提供成员所属的对象。</strong>下面是一个成员函数指针的使用示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(A::*pClassFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 成员函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" + "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m+n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m+n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" - "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m-n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" * "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m*n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m*n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dev</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" / "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m/n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(pClassFun fun, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">// 类内部接口</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*fun)(m, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(A obj, pClassFun fun, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">// 类外部接口</span></span><br><span class="line">	<span class="keyword">return</span> (obj.*fun)(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"member function 'call':"</span> &lt;&lt; endl;</span><br><span class="line">	a.call(&amp;A::add, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::mns, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::mul, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::dev, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"external function 'call':"</span> &lt;&lt; endl;</span><br><span class="line">	call(a, &amp;A::add, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::mns, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::mul, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::dev, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如示例所示，我们一样可以使用<code>typedef</code>定义成员函数指针的类型别名。另外，<strong>我们需要留意函数指针的使用方法</strong>：对于普通函数指针，是这样使用<code>(*pf)(arguments)</code>，因为要调用函数，必须先解引用函数指针，而函数调用运算符()的优先级较高，所以<code>(*pf)</code>的括号必不可少；对于成员函数指针，唯一的不同是需要在某一对象上调用函数，所以只需要加上成员访问符即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(obj.*pf)(arguments)         <span class="comment">// obj 是对象</span></span><br><span class="line">(objptr-&gt;*pf)(arguments)     <span class="comment">// objptr是对象指针</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="函数表驱动">函数表驱动</h3><p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法就是将其存入一个<strong>函数表（function table）</strong>当中。当程序需要执行某个特定的函数时，就从表中查找对应的函数指针，用该指针来调用相应的程序代码，这个就是函数指针在<strong>表驱动法</strong>中的应用。</p>
<p><strong>表驱动法（Table-Driven Approach）</strong>就是用查表的方法获取信息。通常，在数据不多时可用逻辑判断语句（if…else或switch…case）来获取信息；但随着数据的增多，逻辑语句会越来越长，此时表驱动法的优势就体现出来了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(A::*pClassFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;    <span class="comment">// 构造函数，初始化表</span></span><br><span class="line">		table[<span class="string">"+"</span>] = &amp;A::add;</span><br><span class="line">		table[<span class="string">"-"</span>] = &amp;A::mns;</span><br><span class="line">		table[<span class="string">"*"</span>] = &amp;A::mul;</span><br><span class="line">		table[<span class="string">"/"</span>] = &amp;A::dev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" + "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m+n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m+n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" - "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m-n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" * "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m*n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m*n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dev</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" / "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m/n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找表，调用相应函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*table[s])(m, n);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, pClassFun&gt; table;  <span class="comment">// 函数表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.call(<span class="string">"+"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"-"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"*"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"/"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个示例，示例中的“表”通过map来实现（当然也可以使用数组）。表驱动法使用时需要注意：一是如何查表，从表中读取正确的数据；二是表里存放什么，如数值或函数指针。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>函数指针（function pointer）</strong>是通过指向函数的指针间接调用函数。相信很多人对指向一般函数的函数指针使用的比较多，而对指向类成员函数的函数指针则比较陌生。我最近也被问到了这方面的问题，心中却也没有清晰的答案。故决定去查阅资料，并按照自己的思路写下这篇学习总结。<br><br></p>
<h3 id="普通函数指针">普通函数指针</h3><p>通常我们所说的<strong>函数指针</strong>指的是指向一般普通函数的指针。和其他指针一样，函数指针指向某种特定类型，<strong>所有被同一指针运用的函数必须具有相同的形参类型和返回类型。</strong>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之动态数组类的封装]]></title>
    <link href="http://yoursite.com/2014/07/28/cpp-dynamic-array/"/>
    <id>http://yoursite.com/2014/07/28/cpp-dynamic-array/</id>
    <published>2014-07-27T17:52:34.000Z</published>
    <updated>2015-05-09T18:24:03.618Z</updated>
    <content type="html"><![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/" target="_blank" rel="external">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3><a id="more"></a>
<p>当用new为一个动态数组申请一块内存时，数组中的元素是<strong>连续存储</strong>的，例如 vector和string。当向一个动态数组添加元素时，如果没有空间容纳新元素，不可能简单地将新元素添加到内存中的其他位置——因为元素必须连续存储。所以<strong>必须重新分配一块更大的内存空间，将原来的元素从旧位置移动到新空间中，然后添加新元素，释放旧的内存空间</strong>。如果我们每添加一个新元素，就执行一次这样的内存分配和释放操作，效率将会慢到不行。</p>
<p>为了避免上述的代价，必须减少内存重新分配的次数。所以我们采取的策略是：<strong>在不得不分配新的内存空间时，分配比新的空间需求更大的内存空间（通常为2倍）</strong>。这样，在相当一段时间内，添加元素时就不用重新申请内存空间。注意，只有当迫不得已时才可以分配新的内存空间。</p>
<h3 id="类的四大函数">类的四大函数</h3><p>一个C++类一般至少有四大函数，即构造函数、拷贝构造函数、拷贝赋值运算符、析构函数。如果类未自己定义上述函数，C++编译器将为其合成4个默认的版本。但是往往编译器合成的并不是我们所期望的，为此我们有必要自己定义它们。</p>
<p><strong>构造函数</strong></p>
<p>类的<strong>构造函数（constructor）</strong>用来初始化类对象的非static数据成员，无论何时只要类的对象被创建，就会执行构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();  <span class="comment">// 构造函数</span></span><br><span class="line">	Foo(<span class="built_in">string</span> &amp;s);  <span class="comment">// 接受一个参数的构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数的名字和类名相同，没有返回类型。类可以包含多个构造函数（重载），它们之间在参数数量或类型上需要有所区别。<strong>构造函数有一个初始化部分和一个函数体</strong>，成员的初始化是在函数体执行之前完成的。</p>
<p><strong>拷贝构造函数</strong></p>
<p>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数（copy constructor）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝构造函数定义了如何用一个对象<strong>初始化</strong>另一个同类型的对象。拷贝初始化通常使用拷贝构造函数来完成。<strong>拷贝初始化</strong>发生在下列情况中：</p>
<ul>
<li>使用等号（=）初始化一个变量</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素</li>
</ul>
<p><strong>拷贝赋值运算符</strong></p>
<p>类的<strong>拷贝赋值运算符（copy-assignment operator）</strong>是一个名为<code>operator=</code>的函数。类似于其他任何函数，它也有一个返回类型和一个参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝赋值运算符定义了如何将一个对象<strong>赋值</strong>给另一个同类型的对象。赋值运算符是一个成员函数也是一个二元运算符，其左侧运算对象就绑定到隐式的this指针，右侧运算对象作为显式参数传递。<strong>注意</strong>：为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>
<p><strong>析构函数</strong></p>
<p>类的<strong>析构函数（destructor）</strong>用来释放类对象使用的资源并销毁类对象的非static数据成员，无论何时只要一个对象被销毁，就会自动执行析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~Foo();  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>析构函数的名字由波浪号（~）加类名构成，也没有返回类型。由于析构函数不接受参数，因此它不能被重载。<strong>析构函数有一个函数体和一个析构部分</strong>，销毁一个对象时，首先执行析构函数体，然后按初始化顺序的逆序销毁成员。</p>
<h3 id="运算符的重载">运算符的重载</h3><p>重载的运算符是具有特殊名字的函数：<strong>它们的名字由关键字<code>operator</code>和其后要定义的运算符号共同组成</strong>。和其他函数一样，重载的运算符也包含返回类型、参数列表、函数体，比如拷贝赋值运算符。</p>
<p>当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。有些运算符必须作为成员，而另一些运算符作为普通函数比作为成员更好：</p>
<ul>
<li>赋值（=）、下标（[ ]）、调用（( )）和成员访问箭头（-&gt;）运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常应该是成员。</li>
<li>具有<strong>对称性</strong>的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
<p>当然，除了赋值运算符之外，我们还需要为动态数组定义<strong>下标运算符operator []</strong>。下标运算符必须是成员函数。为了让下标可以出现在赋值运算符的任意一端，下标运算符函数通常返回所访问元素的引用。</p>
<h3 id="动态数组类的封装">动态数组类的封装</h3><p>下面给出了动态数组DArray类的接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DArray</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> *m_Data;  <span class="comment">// 存放数组的动态内存指针</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;      <span class="comment">// 数组的元素个数</span></span><br><span class="line">	<span class="keyword">int</span> m_Max;       <span class="comment">// 预留给动态数组的内存大小</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;     <span class="comment">// 初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">()</span></span>;     <span class="comment">// 释放动态内存</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">InvalidateIndex</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 判断下标的合法性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DArray();        <span class="comment">// 默认构造函数</span></span><br><span class="line">	DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue = <span class="number">0</span>);  <span class="comment">// 构造函数，设置数组大小，默认值为dValue</span></span><br><span class="line">	DArray(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	DArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	~DArray();       <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;    <span class="comment">// 输出显式所有数组元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;   <span class="comment">// 获取数组的大小（元素个数）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetSize</span><span class="params">(<span class="keyword">int</span> nSize)</span></span>;  <span class="comment">// 重新设置数组的大小</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 获取指定位置元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetAt</span><span class="params">(<span class="keyword">int</span> nIndex,<span class="keyword">double</span> dValue)</span></span>; <span class="comment">// 重置指定元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;     <span class="comment">// 删除指定位置地元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertAt</span><span class="params">(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 插入一个新的元素到数组中</span></span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span>;      <span class="comment">// 重载下标运算符[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是我的实现：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DArray::Init()</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = <span class="number">0</span>;   <span class="comment">// 默认情况下数组不包含元素</span></span><br><span class="line">	m_Max = <span class="number">1</span>;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DArray::Free()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DArray::InvalidateIndex(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&gt;=<span class="number">0</span> &amp;&amp; nIndex&lt;m_Size)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">DArray::DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize == <span class="number">0</span>)</span><br><span class="line">		Init();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Size = nSize;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i]=dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = arr.m_Size;  <span class="comment">/*复制常规成员*/</span></span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];   <span class="comment">/*复制指针指向的内容*/</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_Data, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">DArray&amp; DArray::<span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;arr)  <span class="comment">/*自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	m_Size = arr.m_Size;</span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	<span class="comment">/* 先将右侧对象拷贝到临时对象中，然后再销毁左侧对象*/</span> </span><br><span class="line">	<span class="keyword">double</span> *m_Temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">	<span class="built_in">memcpy</span>(m_Temp, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">	m_Data = m_Temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">DArray::~DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Free();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> DArray::Print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: The empty array can't be Printed."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m_Size; ++i)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m_Data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组大小</span></span><br><span class="line"><span class="keyword">int</span> DArray::GetSize()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组大小</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetSize(<span class="keyword">int</span> nSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize &lt; m_Size)   <span class="comment">/*截断*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nSize; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m_Size&lt;=nSize &amp;&amp; nSize&lt;=m_Max)  <span class="comment">/*新增元素置0*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nSize &gt; m_Max)   <span class="comment">/*需要重新分配空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span> *temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			temp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	m_Size = nSize; <span class="comment">/*设置数组大小*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素</span></span><br><span class="line"><span class="keyword">double</span> DArray::GetAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of GetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置指定位置元素的值</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of SetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line"><span class="keyword">void</span> DArray::PushBack(<span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/*数组大小加1*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除一个元素</span></span><br><span class="line"><span class="keyword">void</span> DArray::DeleteAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of DeleteAt is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nIndex; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = m_Data[i+<span class="number">1</span>];</span><br><span class="line">		m_Data[m_Size-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		--m_Size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个新元素到指定位置</span></span><br><span class="line"><span class="keyword">void</span> DArray::InsertAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of InsertAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)  <span class="comment">/* 未满，插入 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>               <span class="comment">/* 重新分配空间 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/* 数组大小加1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载下标运算符[]</span></span><br><span class="line"><span class="keyword">double</span> DArray::<span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;=m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index in [] is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过简单的测试，暂时还没有发现Bug。可能测试并不全面，如果你发现了问题，希望你能在评论里告诉我，万分感谢！！！<br><br><br><br></p>
<h3 id="附：String类的实现">附：String类的实现</h3><p>C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能要求具备 std::string 的功能，但至少要求能正确管理资源。</p>
<p>如果你弄懂了上面DArray类的写法，那么实现String类应该就不难了。因为面试官一般只是想考查你能不能正确地写出构造函数、析构函数、拷贝构造函数、拷贝赋值运算符以及+、[ ]、&lt;&lt;、&gt;&gt;运算符重载等等。下面给出一个String类的接口，你可以自己试试手实现一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;  </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp;,String&amp;); <span class="comment">//重载&lt;&lt;运算符  </span></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp;,String&amp;); <span class="comment">//重载&gt;&gt;运算符  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    String();   <span class="comment">// 默认构造函数</span></span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* str);       <span class="comment">// 带参构造函数  </span></span><br><span class="line">    String(<span class="keyword">const</span> String&amp; rhs);        <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs);   <span class="comment">// 拷贝赋值运算符  </span></span><br><span class="line">    String <span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span>;  <span class="comment">//operator+  </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator!=   </span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span>);              <span class="comment">//operator[]  </span></span><br><span class="line">    <span class="function">size_t <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_str() <span class="keyword">const</span>;</span><br><span class="line">    ~String();    <span class="comment">// 析构函数 </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是String类的实现，注意一些得分点：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::String()</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	m_data[<span class="number">0</span>] = <span class="string">'\0'</span>;  <span class="comment">/*得分点：空字符串存放结束标志'\0'*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参的构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)  <span class="comment">/*得分点：自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">	<span class="keyword">delete</span> [] m_data; <span class="comment">/*得分点：释放左侧对象资源*/</span></span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator+</span></span><br><span class="line">String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	String newStr;</span><br><span class="line">	newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data)+<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(newStr.m_data, m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator==</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(m_data, rhs.m_data) == <span class="number">0</span>) <span class="comment">/*相等返回0*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator!=</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;<span class="built_in">strlen</span>(m_data))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_data[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of [] is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String大小</span></span><br><span class="line">size_t String::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取C风格字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* String::c_str() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str.m_data;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&gt;&gt;运算符</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">255</span>];</span><br><span class="line">	is &gt;&gt; temp;</span><br><span class="line">	str = temp;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之new与delete、malloc与free]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-new-malloc/"/>
    <id>http://yoursite.com/2014/07/25/cpp-new-malloc/</id>
    <published>2014-07-25T14:06:45.000Z</published>
    <updated>2015-05-09T18:20:44.204Z</updated>
    <content type="html"><![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br><a id="more"></a><br>标准库定义了operator new函数的几个重载版本，没有使用<code>noexcept</code>说明的版本在内存分配失败时可能会抛出bad_alloc异常，而使用了的不会抛出异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t )</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t );	</span><br><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用new表达式时，实际执行了三步操作：</p>
<ul>
<li>new表达式调用上面的<strong>operator new</strong>（或者<strong>operator new[]</strong>）的标准库函数，函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</li>
<li>编译器运行相应的<strong>构造函数</strong>以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ul>
<p>对于operator new函数或者operator new[]函数来说，它的返回类型必须是void*，第一个形参的类型必须是size_t且该形参不能含有默认实参。当编译器调用operator new或者operator new[]函数时，会把存储指定对象或者指定对象的数组所需的字节数传给size_t形参。</p>
<p><strong>delete表达式</strong></p>
<p>标准库也定义了operator delete函数的几个重载版本，<code>noexcept</code>说明符表示在内存分配失败时返回空指针而不是抛出bad_alloc异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用delete表达式时，实际执行了两步操作：</p>
<ul>
<li>对指针所指的对象或者所指的数组中的元素执行对应的<strong>析构函数</strong>。</li>
<li>编译器调用<strong>operator delete</strong>（或者<strong>operator delete[]</strong>）的标准库函数释放内存空间。</li>
</ul>
<p>对于operator delete函数或者operator delete[]函数来说，它们的返回类型必须是void，第一个形参的类型必须是void*。执行一条delete表达式将调用相应的operator函数，并用指向待释放内存的指针来初始化void*形参。<br><br></p>
<h3 id="malloc和free">malloc和free</h3><p>malloc和free是C/C++中的<strong>标准库函数</strong>，也是用于申请动态内存和释放内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="built_in">malloc</span>( size_t size );</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">free</span><span class="params">( <span class="keyword">void</span>* ptr )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>malloc函数</strong>接受一个表示待分配字节数的size_t，返回指向分配空间的指针；如果分配失败，则返回空指针。<strong>free函数</strong>接受一个void<em>，它是malloc返回的指针的副本，free将相关内存返还给系统。<em>*注意</em></em>：malloc函数并不会调用构造函数来初始化内存，free函数也不会自动调用析构函数。<br><br></p>
<h3 id="new和malloc、delete和free的区别">new和malloc、delete和free的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;     <span class="comment">// 没有初始化列表， 所以没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();   <span class="comment">// 空初始化列表， 执行zero初始化,  所以初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);  <span class="comment">// 非空初始化列表， 执行值初始化， 所以初始化为3</span></span><br><span class="line"><span class="comment">// 注：对于没有构造函数的内置类型，new会不会初始化在于有没有初始列表（空列表“()”也算）</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];     <span class="comment">// 分配大小为sizeof(int)*100;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p5 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"><span class="keyword">double</span> *p6 = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p><strong>new和malloc的区别：</strong></p>
<ol>
<li><p>new是一个运算符，malloc()是一个库函数。</p>
</li>
<li><p>new会调用构造函数，而malloc()不会。</p>
</li>
<li><p>new返回指定类型的指针，而malloc()返回void*。</p>
</li>
<li><p>new会自动计算需要分配的空间，而malloc()需要手工计算字节数。</p>
</li>
<li><p>new可以被重载，而malloc()不能。<br><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> [] p2;</span><br><span class="line"><span class="built_in">free</span>(p3);</span><br><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>delete和free的区别：</strong></p>
<ol>
<li><p>delete是一个运算符，free()是一个库函数。</p>
</li>
<li><p>delete会调用析构函数，而free()不会。</p>
</li>
<li><p>delete可以被重载，而free()不能。</p>
</li>
</ol>
<p><br><br><br><br></p>
<h3 id="总结：">总结：</h3><p>malloc和free是C/C++中的标准库函数，new和delete是C++的运算符。对于非内置数据类型的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
</feed>