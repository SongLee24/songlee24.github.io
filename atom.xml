<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SongLee's Blog]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-10T11:24:31.089Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[华为OJ2011-最长公共子串]]></title>
    <link href="http://yoursite.com/2015/03/18/hua-wei-OJ2011/"/>
    <id>http://yoursite.com/2015/03/18/hua-wei-OJ2011/</id>
    <published>2015-03-18T11:19:52.000Z</published>
    <updated>2015-05-10T11:24:31.089Z</updated>
    <content type="html"><![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串<a id="more"></a></p>
<p><strong>输出：</strong></p>
<p>输出一个整数</p>
<p><strong>样例输入：</strong><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">asdfas</span> werasdfaswer</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、解题报告">二、解题报告</h3><p>与最长公共子序列（参见《<a href="http://songlee24.github.io/2014/11/27/dynamic-programming/" target="_blank" rel="external">动态规划DP</a>》）一样，最长公共子串也可以使用动态规划解决，只不过思路不太一样。准确地说，是打表的方式不一样。</p>
<p>举个例子：s1 = <code>bab</code>，s2 = <code>caba</code>。表如下</p>
<center><br><img src="http://img.blog.csdn.net/20150423105150153" alt=""><br></center>

<p>具体打表的方法是：</p>
<ul>
<li>第一行、第一列初始化为 0；</li>
<li>对于其他的格子：<ul>
<li>若对应的两个字符相等，格子的值设为左上角的值加 1。</li>
<li>若对应的两个字符不相等，直接置 0 。</li>
</ul>
</li>
</ul>
<p><br><br>这样的话，表中的最大元素就是 最长公共子串 的<strong>长度</strong>。并且也可以很容易看出最长公共子串有 2 个，分别是<code>ba</code>和<code>ab</code>。</p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLCStringLength</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> input, s1, s2;</span><br><span class="line">	getline(<span class="built_in">cin</span>, input);</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">	ss &gt;&gt; s1;</span><br><span class="line">	ss &gt;&gt; s2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getLCStringLength(s1, s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、扩展">三、扩展</h3><p>如何输出所有的最长公共子串？</p>
<p>很简单，我们记录下 s1 和 s2 的公共子串分别在 s1 、s2 中起始位置（即表中值为 1 的坐标）。打表完成以后，我们已经知道了最长公共子串的长度<code>length</code>，通过<code>substr()</code>判断即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.substr(i-<span class="number">1</span>, length) == s2.substr(j-<span class="number">1</span>, length)</span><br></pre></td></tr></table></figure></p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCString</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; firstPos;  <span class="comment">// 记录子串开始的坐标 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">				<span class="keyword">if</span>(table[i][j] == <span class="number">1</span>) </span><br><span class="line">					firstPos.push_back(make_pair(i, j));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出所有的最长公共子串</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator beg = firstPos.begin();</span><br><span class="line">	<span class="keyword">for</span>( ; beg!=firstPos.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start1 = beg-&gt;first-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> start2 = beg-&gt;second-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s1.substr(start1, biggest) == s2.substr(start2, biggest))</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s1.substr(start1, biggest) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"hello,world,james"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"james is saying hello"</span>;</span><br><span class="line">	printLCString(s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（二）]]></title>
    <link href="http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/"/>
    <id>http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/</id>
    <published>2015-03-16T18:40:53.000Z</published>
    <updated>2015-05-10T11:17:34.068Z</updated>
    <content type="html"><![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）<a id="more"></a></p>
<ul>
<li>进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行 pop 操作。</li>
</ul>
<p><strong>3.4</strong> 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</p>
<ul>
<li>每次只能移动一个盘子</li>
<li>盘子只能从柱子顶端滑出移到下一根柱子</li>
<li>盘子只能叠在比它大的盘子上</li>
</ul>
<p>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><strong>3.5</strong> 实现一个<code>MyQueue</code>类，该类用两个栈来实现一个队列。</p>
<p><strong>3.6</strong> 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code>和<code>isEmpty</code>。</p>
<p><strong>3.7</strong> 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>等。</p>
<p><br><br></p>
<h3 id="4、树与图">4、树与图</h3><p><strong>4.1</strong> 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</p>
<p><strong>4.2</strong> 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</p>
<p><strong>4.3</strong> 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</p>
<p><strong>4.4</strong> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</p>
<p><strong>4.5</strong> 实现一个函数，检查一棵二叉树是否为二叉查找树。</p>
<p><strong>4.6</strong> 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</p>
<p><strong>4.7</strong> 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</p>
<p><strong>4.8</strong> 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</p>
<p><strong>4.9</strong> 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</p>
<p><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>3.1 描述如何只用一个数组来实现三个栈。</strong></p>
<p>这个问题的难易程度取决于每个栈是<em>固定分割</em> 还是 <em>动态分割</em>。</p>
<ul>
<li><strong>固定分割</strong>：也就是每个栈分配固定大小的空间。这是最简单的实现方法，但是效率不高，因为即使某个栈是空的，它的空间也不能被别的栈使用。下面是每个栈占数组1/3的实现代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100</span>;  <span class="comment">// 每个栈的大小</span></span><br><span class="line">	<span class="keyword">int</span> tops[<span class="number">3</span>];                  <span class="comment">// 3个栈的栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>*size];              <span class="comment">// 共享的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">absTopOfStack</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// 返回栈顶指针在数组中的绝对量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		tops[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::absTopOfStack(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> flag * size + tops[flag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tops[flag] == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(tops[flag]+<span class="number">1</span> &gt;= size) <span class="comment">/*检查有无空闲空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Out of space.\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		++tops[flag];</span><br><span class="line">		arr[absTopOfStack(flag)] = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = arr[absTopOfStack(flag)];</span><br><span class="line">	arr[absTopOfStack(flag)] = <span class="number">0</span>;   <span class="comment">/*清零*/</span></span><br><span class="line">	--tops[flag];  <span class="comment">/*指针自减*/</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> arr[absTopOfStack(flag)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>动态分割</strong>：允许栈的大小灵活可变，要实现起来难度有点大。</p>
<ul>
<li><p><strong>思路一</strong>：我们可以先考虑<em>用一个数组实现两个栈</em>，思路很简单：分别用数组的两端作为两个栈的起点，向中间扩展，若两个栈中的元素总和不超过n，两个栈不会重叠。基于同样的想法，我们可以把第三个栈实现在数组的中部，当前两个栈中有一个满了（即将重叠第三个栈时），平移第三个栈以扩展栈空间。这种方法由于需要搬移元素所以效率不高。</p>
</li>
<li><p><strong>思路二</strong>：链式栈。通过链表的方式来实现栈，如下图：</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150407021806320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>链式栈</strong>是在一个数组上实现多个栈（3个、4个、5个…）的通用解决方案。下面是示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;       <span class="comment">// 存储关键字</span></span><br><span class="line">	<span class="keyword">int</span> preIndex;  <span class="comment">// 记录上一个元素的位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> top1, top2, top3;</span><br><span class="line">	<span class="keyword">int</span> array_size;  <span class="comment">// 数组的大小，即栈的最大容量</span></span><br><span class="line">	<span class="keyword">int</span> current_ptr; <span class="comment">// 下一个元素入栈的位置</span></span><br><span class="line">	Node* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks(<span class="keyword">int</span> size);</span><br><span class="line">	~Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks(<span class="keyword">int</span> size):array_size(size),</span><br><span class="line">	top1(-<span class="number">1</span>),top2(-<span class="number">1</span>),top3(-<span class="number">1</span>),current_ptr(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arr = <span class="keyword">new</span> Node[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stacks::~Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> top1 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> top2 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> top3 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error flag of stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(current_ptr == array_size) <span class="comment">// 栈已满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is full.\n"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		arr[current_ptr].key = value;</span><br><span class="line">		<span class="keyword">switch</span> (flag)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top1;</span><br><span class="line">			top1 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top2;</span><br><span class="line">			top2 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top3;</span><br><span class="line">			top3 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++current_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		value = arr[top1].key;</span><br><span class="line">		top1 = arr[top1].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		value = arr[top2].key;</span><br><span class="line">		top2 = arr[top2].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		value = arr[top3].key;</span><br><span class="line">		top3 = arr[top3].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top1].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top2].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top3].key;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.2 请设计一个栈，除pop与push方法，还支持min方法，可返回栈元素中的最小值。pop、push和min三个方法的时间复杂度必须为O(1)。</strong></p>
<p>通常来说<code>pop</code>和<code>push</code>方法的时间复杂度就是O(1)，关键是<code>min</code>方法。</p>
<p>可能有人会想 在Stack类里添加一个int型的变量用来记录最小值。当新元素入栈时，比较新元素与最小值，若新元素更小则更新最小值，此时<code>push</code>的时间效率是O(1)；但是当 minValue 出栈时，我们需要遍历整个栈，找出新的最小值，此时<code>pop</code>操作的时间效率就不符合O(1)的要求了。</p>
<ul>
<li><strong>思路一</strong>：记录每种状态下的最小值。通过给栈元素增加一个 min 字段，每个元素在入栈时记录当前状态下的最小值。这么一来，要找到最小值，直接查看栈顶元素的 min 就行了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	node n;</span><br><span class="line">	n.value = v;</span><br><span class="line">	n.min = v &lt; min() ? v : min();</span><br><span class="line">	s.push(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> top = s.top().value;</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> s.top().min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：利用辅助栈保存最小值。这种方法比思路一更节省空间一些 ———— 因为思路一中每个栈元素都要记录 min，而使用辅助栈，当入栈元素大于当前最小值时，不需要记录。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_s;  <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(v &lt;= min())</span><br><span class="line">		min_s.push(v);</span><br><span class="line">	s.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> top = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">if</span>(top == min())</span><br><span class="line">		min_s.pop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(min_s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> min_s.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong> 3.3 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）</strong></p>
<p>根据题意，<code>SetOfStacks</code>中应该有一个栈数组，而<code>push</code>和<code>pop</code>都是操作栈数组中的最后一个栈。入栈时若最后一个栈被填满，就需新建一个栈；出栈后若最后一个栈为空，就必须从栈数组中移除这个栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SetOfStacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; stacks;</span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 一个栈的最大存储量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SetOfStacks(<span class="keyword">int</span> cap);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现**********/</span></span><br><span class="line">SetOfStacks::SetOfStacks(<span class="keyword">int</span> cap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SetOfStacks::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!stacks.empty() &amp;&amp; stacks.back().size() &lt; capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		stacks.back().push(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 必须新建一个栈</span></span><br><span class="line">		s.push(v);</span><br><span class="line">		stacks.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SetOfStacks::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(stacks.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = stacks.back().top();</span><br><span class="line">	stacks.back().pop();</span><br><span class="line">	<span class="keyword">if</span>(stacks.back().empty())</span><br><span class="line">		stacks.pop_back();  <span class="comment">// 移除</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶：实现一个popAt(int index)方法，根据指定的子栈，执行 pop 操作。</strong></p>
<p>设想当弹出 栈1 的栈顶元素时，我们需要移出 栈2 的栈底元素，并将其推到栈1中。随后，将栈3的栈底元素推入栈2，将栈4的栈底元素推入栈3，以此类推。</p>
<p>有人可能会说，没必要执行“推入”操作，有些栈不填满也可以啊！而且还降低了时间复杂度。但是若之后有人假定所有的栈（最后一个栈除外）都是填满的，就可能出现意想不到的 error！这个问题并没有“标准答案”，你应该跟面试官讨论各种做法的优劣。</p>
<p><br><br><strong>3.4 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</strong></p>
<ul>
<li><strong>每次只能移动一个盘子</strong></li>
<li><strong>盘子只能从柱子顶端滑出移到下一根柱子</strong></li>
<li><strong>盘子只能叠在比它大的盘子上</strong></li>
</ul>
<p><strong>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</strong></p>
<p><img src="http://img.blog.csdn.net/20150407021526401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>首先我们从最简单的开始整理自己的思路：</p>
<ul>
<li>当<code>n=1</code>时，因为只有一个盘子，所以可以直接将盘子1从柱1移至柱3.</li>
<li>当<code>n=2</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1从柱1移至柱2。</li>
<li>将盘子2从柱1移至柱3。</li>
<li>将盘子1从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=3</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将上面两个盘子从柱1移至柱2，同上。</li>
<li>将盘子3移至柱3。</li>
<li>将盘子1、2从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=4</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1、2、3移至柱2，具体做法参见前面。</li>
<li>将盘子4移至柱3。</li>
<li>将盘子1、2、3移至柱3。</li>
</ol>
</li>
</ul>
<p>把柱1上的盘子移至柱3，需要柱2作为缓冲。可以看出，上面的过程是递归的，很自然地就可以导出递归算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Tower</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; disks;  <span class="comment">// 用整数的大小表示盘子的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> d)</span></span>;             <span class="comment">// 向柱子上添加盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveButtomTo</span><span class="params">(Tower &amp;t)</span></span>; <span class="comment">// 移动最下面那块盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveDisks</span><span class="params">(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span></span>;  <span class="comment">// 利用buf将n块盘子移至dest</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************实现*********************/</span></span><br><span class="line"><span class="keyword">void</span> Tower::add(<span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!disks.empty() &amp;&amp; disks.top() &lt;= d) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error placing disk "</span> &lt;&lt; d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		disks.push(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Tower::moveButtomTo(Tower &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> top = disks.top();</span><br><span class="line">	disks.pop();</span><br><span class="line">	t.add(top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现 —— 注意使用引用</span></span><br><span class="line"><span class="keyword">void</span> Tower::moveDisks(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/*将上面的n-1块盘子移至缓冲区*/</span></span><br><span class="line">		moveDisks(n-<span class="number">1</span>, buf, dest);</span><br><span class="line">		<span class="comment">/*将最下面那块盘子移至目的地*/</span></span><br><span class="line">		moveButtomTo(dest);</span><br><span class="line">		<span class="comment">/*将缓冲区的n-1块盘子移至目的地*/</span></span><br><span class="line">		buf.moveDisks(n-<span class="number">1</span>, dest, *<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************测试*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tower tower[<span class="number">3</span>];  <span class="comment">// 3根柱子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		tower[<span class="number">0</span>].add(i);</span><br><span class="line">	<span class="comment">// 移动</span></span><br><span class="line">	tower[<span class="number">0</span>].moveDisks(<span class="number">5</span>, tower[<span class="number">2</span>], tower[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.5 实现一个MyQueue类，该类用两个栈来实现一个队列。</strong></p>
<p>队列和栈的主要区别就是元素进出顺序。假设两个栈分别是 Newest 和 Oldest，为了用这两个栈达到先进先出（FIFO）的效果，在入队时我们将元素压入 Newest 栈，然后将 Newest 的元素弹出，压入 Oldest 栈中（这样就达到了反转的效果），在出队时，我们从 Oldest 栈中弹出元素。</p>
<p>注意，为了避免频繁的执行从 Newest 到 Oldest 的反转操作，我们规定：只有在发现 Oldest 为空时，才执行反转操作 —— 将 Newest 中的所有元素弹出并压入 Oldest 中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Newest;  <span class="comment">// 新入队的元素</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Oldest;  <span class="comment">// 准备出队的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverseStacks</span><span class="params">()</span></span>;  <span class="comment">// 将Newest元素弹出，压入Oldest </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;           <span class="comment">// 队列大小</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span></span>;  <span class="comment">// 入队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span>;        <span class="comment">// 出队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>;            <span class="comment">// 队首元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Oldest为空才进行反转，避免频繁操作</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::reverseStacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Oldest.empty())  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!Newest.empty()) &#123;</span><br><span class="line">			Oldest.push(Newest.top());</span><br><span class="line">			Newest.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Oldest.size()+Newest.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入Newest，最新元素始终位于它的顶端</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::enqueue(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	Newest.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Oldest出队</span></span><br><span class="line"><span class="keyword">int</span> MyQueue::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">int</span> value = Oldest.top();</span><br><span class="line">	Oldest.pop();</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::top()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">return</span> Oldest.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.6 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek和isEmpty。</strong></p>
<p>可以想到的一种做法是，搜索整个栈，找出最小元素，将其压入另一个栈；然后，在剩余元素中找出最小的，并将其入栈。但这种做法实际上需要两个额外的栈，一个用来存放最终的有序序列，一个在搜索时用作缓冲区。</p>
<p>那么，只使用一个额外的栈怎么做呢？可以从S1逐一弹出元素，然后按顺序插入S2中，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150407021739968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>S1是未排序的，S2是排好序的：</p>
<ul>
<li><p>从S1中弹出5，我们需要在S2中找到合适的位置插入这个数，所以将 12 和 8 移至 S1 中，然后将 5 压入 S2。</p>
</li>
<li><p>那么 8 和 12 需不需要移回 S2 呢？其实不需要，对于这两个数，我们可以像处理 5 那样重复相关步骤就可以了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Sort(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = s.top();</span><br><span class="line">		s.pop();          <span class="comment">// 弹出元素存到临时变量</span></span><br><span class="line">		<span class="keyword">while</span>(!r.empty() &amp;&amp; r.top() &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(r.top());</span><br><span class="line">			r.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		r.push(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>3.7 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 enqueue、dequeueAny、dequeueDog 和 dequeueCat 等。</strong></p>
<p><strong>思路一</strong>：只维护一个队列。那么 dequeueAny 就容易实现，而 dequeueDog 和 dequeueCat 就需迭代访问整个队列，找到第一只被收养的狗或猫。这种解法明显效率不高。</p>
<p><strong>思路二</strong>：为猫和狗各维护一个队列。那么 dequeueDog 和 dequeueCat 很容易实现，而 dequeueAny 需要比较猫队列与狗队列的队首，看哪个“更老”。为了方便 dequeueAny 的实现，我们给每个动物加一个额外的变量，以标记进入队列的先后顺序。这种解法显然更简单更高效！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> order;    <span class="comment">// 标记先后顺序</span></span><br><span class="line">	Animal(<span class="built_in">string</span> s):name(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******* 狗 *******/</span></span><br><span class="line"><span class="keyword">class</span> Dog : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dog(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* 猫 *******/</span></span><br><span class="line"><span class="keyword">class</span> Cat : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cat(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******队列*******/</span></span><br><span class="line"><span class="keyword">class</span> Queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;Dog&gt; dogs;</span><br><span class="line">	<span class="built_in">list</span>&lt;Cat&gt; cats;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue():order(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Dog d)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		d.order = order++;</span><br><span class="line">		dogs.push_back(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Cat c)</span>  <span class="comment">// 重载</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		c.order = order++;</span><br><span class="line">		cats.push_back(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Dog <span class="title">dequeueDog</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Dog d = dogs.front();</span><br><span class="line">		dogs.pop_front();</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Cat <span class="title">dequeueCat</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Cat c = cats.front();</span><br><span class="line">		cats.pop_front();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Animal <span class="title">dequeueAny</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dogs.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">		<span class="keyword">if</span>(cats.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dogs.front().order &lt; cats.front().order)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
<hr>
<p><strong>下面的题是关于树或图，做下面的题之前，首先我们要能够创建一棵二叉树或一个图：</strong></p>
<ul>
<li><strong>创建二叉树</strong>：二叉树是什么相信就不用我多说了，可以递归地根据输入创建一棵二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">&#125; *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归地创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		T = NULL;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = x;</span><br><span class="line">	createBinaryTree(T-&gt;left);</span><br><span class="line">	createBinaryTree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	createBinaryTree(T); </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>创建二叉查找树</strong>： 可以由一个数组生成一棵二叉查找树，见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757" target="_blank" rel="external">二叉查找树（BST）</a>》。</p>
</li>
<li><p><strong>创建图</strong>：图有两种存储方式，邻接矩阵和邻接表，这里采用邻接表来创建图。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Graph  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">int</span> V;                         <span class="comment">// 顶点数  </span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                <span class="comment">// 邻接表  </span></span><br><span class="line"> </span><br><span class="line">	Graph(<span class="keyword">int</span> V);                  <span class="comment">// 构造函数  </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;    <span class="comment">// 向图中添加边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span>  </span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;  </span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span>  </span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)  </span><br><span class="line">&#123;  </span><br><span class="line">	adj[v].push_back(w);          <span class="comment">// 将w添加到v的链表  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><strong>4.1 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</strong></p>
<p>本题明确地给出了平衡树的定义，我们的解法就是根据定义直接递归检查每棵子树的高度。代码中的 checkHeight 方法以递归方式获取左右子树的高度。若子树是平衡的，返回该子树的实际高度；若子树不平衡，返回-1，这时所有递归都会立即返回：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line"> * 平衡返回高度，不平衡返回-1</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查左子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> leftHeight = checkHeight(T-&gt;left);</span><br><span class="line">	<span class="keyword">if</span>(leftHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查右子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> rightHeight = checkHeight(T-&gt;right);</span><br><span class="line">	<span class="keyword">if</span>(rightHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查当前结点是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> diff = leftHeight&gt;rightHeight ? </span><br><span class="line">		leftHeight-rightHeight : rightHeight-leftHeight;</span><br><span class="line">	<span class="keyword">if</span>(diff &gt; <span class="number">1</span>)  <span class="comment">// 不平衡，返回-1</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>          <span class="comment">// 平衡，返回高度</span></span><br><span class="line">		<span class="keyword">return</span> leftHeight&gt;rightHeight ? leftHeight+<span class="number">1</span> : rightHeight+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkHeight(T) == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.2 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</strong></p>
<p>只需通过图的遍历，比如深度优先搜索或广度优先搜索，就能解决这个问题。</p>
<p>我们从其中一个结点出发，在遍历过程中检查是否找到另一个结点。在这个算法中，访问过的结点都应标记为“已访问”，以免循环和重复访问结点。下面的示例代码使用了广度优先搜索：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPathExist</span><span class="params">(Graph g, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;  <span class="comment">// 当做队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> V = g.getVertexNum();  <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)  </span><br><span class="line">		visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">	visited[start] = <span class="keyword">true</span>; <span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	<span class="built_in">queue</span>.push_back(start);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node = <span class="built_in">queue</span>.front(); <span class="comment">// 出队</span></span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=g.adj[node].begin(); i!=g.adj[node].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(*i == end)  <span class="comment">// 是否等于另一个结点</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">					<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.3 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</strong></p>
<p>要让二叉查找树的高度最小，就必须让左右子树的结点数越接近越好。根据二叉查找树的性质（中序遍历的序列是一个递增的有序序列），可以让该数组中间的值成为根节点，前半区间成为左子树，后半区间成为右子树。然后，每一个区间中间的值又成为子树的根节点，以此类推。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* createMinBST(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &gt; high)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span> NULL; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">	TreeNode* T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = A[mid];</span><br><span class="line">	T-&gt;left = createMinBST(A, low, mid-<span class="number">1</span>);</span><br><span class="line">	T-&gt;right = createMinBST(A, mid+<span class="number">1</span>, high);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.4 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</strong></p>
<p>根据题意，你可能认为这个问题需要一层一层遍历，每一层构成一个链表。但其实可以用任意方式遍历树，只要记住结点位于哪一层即可。</p>
<p>下面是使用先序遍历实现的一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLevelLists</span><span class="params">(BiTree T, <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode*&gt;&gt; &amp;lists, <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lists.size() &lt;= level)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>&lt;TreeNode*&gt; lst;</span><br><span class="line">		lst.push_back(T);</span><br><span class="line">		lists.push_back(lst);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		lists.at(level).push_back(T);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	createLevelLists(T-&gt;left, lists, level+<span class="number">1</span>);  <span class="comment">// 左子树</span></span><br><span class="line">	createLevelLists(T-&gt;right, lists, level+<span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以使用其他遍历方式，比如层序遍历、广度优先搜索。</p>
<p><br><br><strong>4.5 实现一个函数，检查一棵二叉树是否为二叉查找树。</strong></p>
<ul>
<li><strong>思路一</strong>：检查中序序列是否是升序。这是二叉查找树的性质，但<strong>需要注意的是</strong>，这种方法无法正确处理树中的重复值。若假定这棵树不包含重复值，则这种方法是有效的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inOrder</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*检查左子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;left, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查当前结点*/</span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= last)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	last = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查右子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;right, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = INT_MIN;</span><br><span class="line">	<span class="keyword">return</span> inOrder(T, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：自上而下传递最小和最大值，判断每个结点是否在范围内。假定根结点的值是20，最开始的范围是（<code>INT_MIN</code>,<code>INT_MAX</code>），根结点明显在这个范围内。然后判断左孩子是否在（<code>INT_MIN</code>, 20）这个范围内，右孩子是否在（20 ,<code>INT_MAX</code>）这个范围内。以此类推，递归下去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= min || T-&gt;data &gt; max)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!checkBST(T-&gt;left,min,T-&gt;data) || !checkBST(T-&gt;right,T-&gt;data,max))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> checkBST(T, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.6 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</strong></p>
<p>见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757#t2" target="_blank" rel="external">BST的前驱与后继</a>》，本题要求的是中序遍历中的后继结点。求一个结点 x 的后继，有两种情况：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继是右子树中值最小的结点，即右子树最左边的结点。</p>
</li>
<li><p>若结点 x 的右子树为空，表示已遍访 x 的子树。我们必须回到 x 的父结点，记父结点为 p ：</p>
<ul>
<li><p>如果 x 是 p 的左儿子，那么下一个要访问的结点就是 p ；</p>
</li>
<li><p>如果 x 是 p 的右儿子，表示已遍访 p 的子树，这时需从 p 往上继续访问，直到遇到一个祖先结点 pp，它的左儿子也是结点 x 的祖先。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* successor_BST(TreeNode* n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* tmp = n-&gt;right;</span><br><span class="line">		<span class="keyword">while</span>(tmp-&gt;left!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* p = n-&gt;parent;</span><br><span class="line">		<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right==n)</span><br><span class="line">		&#123;</span><br><span class="line">			n = p;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.7 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</strong></p>
<p>我们在解题之前应该先要问问面试官，这棵树的结点是否包含指向父结点的指针。</p>
<ul>
<li><p><strong>情况一</strong>：如果每个结点中包含指向父结点的指针，那么就可以直接向上追踪 p 和 q 的路径，直到两者相交。当然，在向上追踪的过程中我们需要标记结点是否已经被访问过，比如可以给结点添加<code>isVisited</code>域、或者将已访问结点映射到散列表。</p>
</li>
<li><p><strong>情况二</strong>：如果结点不包含指向父结点的指针，又不得将额外的结点储存在另外的数据结构中。那么我们的做法就是：从上向下判断，若 p 和 q 都在某结点的左边，就到左子树中查找共同祖先；若都在该结点的右边，则在右子树中查找共同祖先。要是 p 和 q 不在同一边，那么就表示已经找到第一个共同祖先了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若p为root的子孙，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(root == p)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> cover(root-&gt;left, p) || cover(root-&gt;right, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* getCommonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	<span class="keyword">if</span>(T == p || T == q)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> pAtLeft = cover(T-&gt;left, p);</span><br><span class="line">	<span class="keyword">bool</span> qAtLeft = cover(T-&gt;left, q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*若p和q不在同一边，则表示已经找到第一个共同祖先*/</span></span><br><span class="line">	<span class="keyword">if</span>(pAtLeft != qAtLeft)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="comment">/*若在同一边，遍访那一边*/</span></span><br><span class="line">	TreeNode* child = pAtLeft ? T-&gt;left : T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(child, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* commonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cover(T, p) || !cover(T, q))  <span class="comment">// --错误检查--</span></span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(T, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.8 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</strong></p>
<p>首先考虑小数据量的情况，可以求出两棵树的前序和中序遍历序列，若 T2 前序遍历是 T1 前序遍历的子串，并且 T2 中序遍历是 T1 中序遍历的子串，则 T2 为 T1 的子树。假设T1的节点数为 N，T2的节点数为 M。遍历两棵树的时间复杂度是 O(N + M)， 判断字符串是否为另一个字符串的子串的复杂性也是 O(N + M)（比如使用KMP算法）。所以总的时间复杂度是<code>O(N+M)</code>，所需的空间也是<code>O(N+M)</code>。———— 这里需要注意一点：对于左结点或者右结点为 null 的情况，需要在字符串中插入特殊字符表示。</p>
<p>对于简单的情形，上面的解法还算不错。但是当数据量非常大时，暂存前序和中序序列可能要占用太多的内存，所以我们考虑另一种解法：遍历 T1，每当 T1 的某个节点与 T2 的根节点值相同时，就判断两棵子树是否相同。假设 T2 的根节点在 T1 中出现了 k 次，那么算法的时间复杂度就是<code>O(N + k*M)</code>，最坏情况下是<code>O(N*M)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配两棵子树，完全一样返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL &amp;&amp; t2 == NULL) <span class="comment">/*若两者都为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL || t2 == NULL) <span class="comment">/*若只有一个为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data != t2-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> matchTree(t1-&gt;left,t2-&gt;left) &amp;&amp; matchTree(t1-&gt;right,t2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历大树t1，当某个结点与t2根结点相同，matchTree判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">/*大的树已经空了，还未找到子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data == t2-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(matchTree(t1, t2))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subTree(t1-&gt;left, t2) || subTree(t1-&gt;right, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t2 == NULL)  <span class="comment">/*空树一定是子树*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">	<span class="keyword">return</span> subTree(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的两种解法，哪种解法比较好呢？</p>
<ul>
<li><p>方法一会占用 O(N + M) 的内存，而另外一种解法只会占用 O(logN + logM) 的内存（递归的栈内存）。当考虑扩展性时，内存使用的多寡是个很重要的因素。</p>
</li>
<li><p>方法一的时间复杂度为O(N + M)，方法二最差的时间复杂度是O(N*M)。但是最差情况的时间复杂度并没有代表性，我们需要进一步观察，因为更可能的情况是很早就发现两棵树的不同，早早的退出了 matchTree。</p>
</li>
</ul>
<p>总的来说，在空间效率上，第二种解法更好。在时间上，需要通过实际数据来验证。</p>
<p><br><br><strong>4.9 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</strong></p>
<p>下面我们采用简化推广法来解题。</p>
<p><strong>Step 1 </strong>： 简化——假设路径必须从根节点开始，但可以在任意结点结束，该怎么解决？</p>
<p>在这种情况下，问题就会变得容易很多。我们可以从根节点开始，向下访问子节点，计算每条路径上到当前节点为止的数值总和，若与给定值相同则打印当前路径。注意，就算找到总和，仍要继续访问这条路径（因为可能存在正负相抵消的情况）。</p>
<p><strong>Step 2 </strong>： 推广——路径可从任意结点开始</p>
<p>如果路径可以从任意结点开始，在任意结点结束。在这种情况下我们稍作调整，对于每个结点，都向“上”检查是否有总和为 sum 的路径。具体来讲就是：递归访问每个结点 p 时，我们将 root 到 p 的完整 path 传入函数；然后，函数会从 p 到 root 逆序将结点上的值加起来，当每条子路径的总和等于 sum 时，打印该条子路径。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印从start到end的路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> path[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求一棵子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> leftDepth = depth(n-&gt;left);</span><br><span class="line">		<span class="keyword">int</span> rightDepth = depth(n-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> leftDepth&gt;rightDepth ? leftDepth+<span class="number">1</span> : rightDepth+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum, <span class="keyword">int</span> path[], <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*将当前结点插入路径*/</span></span><br><span class="line">	path[level] = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从当前结点到root结点，看是否存在和为sum的路径*/</span></span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		t += path[i];</span><br><span class="line">		<span class="keyword">if</span>(t == sum)</span><br><span class="line">			print(path, i, level);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*递归*/</span></span><br><span class="line">	findSum(T-&gt;left, sum, path, level+<span class="number">1</span>);</span><br><span class="line">	findSum(T-&gt;right, sum, path, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = depth(T);</span><br><span class="line">	<span class="keyword">int</span> *path = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(dep*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	findSum(T, sum, path, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(path);<span class="comment">/*释放内存*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（一）]]></title>
    <link href="http://yoursite.com/2015/03/16/cracking-the-coding-interview-01/"/>
    <id>http://yoursite.com/2015/03/16/cracking-the-coding-interview-01/</id>
    <published>2015-03-16T15:50:18.000Z</published>
    <updated>2015-05-10T11:14:29.828Z</updated>
    <content type="html"><![CDATA[<h3 id="1、数组与字符串">1、数组与字符串</h3><p><strong>1.1</strong> 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p>
<p><strong>1.2</strong> 用C或C++实现<code>void reverse(char* str)</code>函数，即反转一个null结尾的字符串。</p>
<p><strong>1.3</strong> 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>1.4</strong> 编写一个方法，将字符串中的空格全部替换为“%20”。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。示例：输入<code>Mr John Smith</code>，输出<code>Mr%20John%20Smith</code>。<a id="more"></a></p>
<p><strong>1.5</strong> 利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。</p>
<p><strong>1.6</strong> 给定一幅由 N x N 矩阵表示的图像，其中每个像素的大小为 4 字节，编写一个方法，将图像旋转90度。不占用额外内存空间能否做到？</p>
<p><strong>1.7</strong> 编写一个算法，若 M x N 矩阵中某个元素为0，则将其所在的行与列清零。</p>
<p><strong>1.8</strong> 假定有一个方法<code>isSubstring</code>，可检查一个单词是否为其他字符串的子串。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成，要求只能调用一次<code>isSubstring</code>。（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串。）</p>
<p><br><br></p>
<h3 id="2、链表">2、链表</h3><p><strong>2.1</strong> 编写代码，移除未排序链表中的重复结点。如果不得使用临时缓冲区，又该怎么解决？</p>
<p><strong>2.2</strong> 实现一个算法，找出单向链表中倒数第 k 个结点。</p>
<p><strong>2.3</strong> 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。示例：</p>
<ul>
<li>输入：单向链表<code>a-&gt;b-&gt;c-&gt;d-&gt;e</code>中的结点c</li>
<li>结果：不返回任何数据，但该链表变为<code>a-&gt;b-&gt;d-&gt;e</code>。</li>
</ul>
<p><strong>2.4</strong> 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前。</p>
<p><strong>2.5</strong> 给定两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。示例：</p>
<ul>
<li>输入：（<code>7-&gt;1-&gt;6</code>）+（<code>5-&gt;9-&gt;2</code>），即 617+295</li>
<li>输出：<code>2-&gt;1-&gt;9</code>，即 912</li>
</ul>
<p>假设这些数位是正向存放的，请再做一遍。示例：</p>
<ul>
<li>输入：（<code>6-&gt;1-&gt;7</code>）+（<code>2-&gt;9-&gt;5</code>），即 617+295</li>
<li>输出：<code>9-&gt;1-&gt;2</code>，即 912</li>
</ul>
<p><strong>2.6</strong> 给定一个有环链表，实现一个算法返回环路的开头结点。有环链表的定义：在链表中某个结点的 next 元素指向在它前面出现过的结点，则表明该链表存在环路。示例：</p>
<ul>
<li>输入：<code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>（C结点出现了两次）</li>
<li>输出：C</li>
</ul>
<p><strong>2.7</strong> 编写一个函数，检查链表是否为回文。</p>
<p><br><br><br><br><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>1.1</strong> 如果允许使用数据结构，我首先想到的是<code>map</code>，下标操作<code>map[&#39;key&#39;]</code>在 key 存在时执行搜索操作，否则执行插入操作。示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; amap;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		amap[A[i]] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator beg = amap.begin();</span><br><span class="line">	<span class="keyword">for</span>(;beg!=amap.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(beg-&gt;second &gt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不允许使用额外的数据结构，该如何处理呢？假定字符集为 ASCII，那么我们可以创建一个标记数组，索引 i 对应的 bool 值指示该字符串是否含有字母表第 i 个字符。若这个字符第二次出现，则立即返回 false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">int</span> len)</span>   <span class="comment">// 假定字符集为 ASCII</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">256</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> char_set[<span class="number">256</span>] = &#123;<span class="keyword">false</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(char_set[A[i]]) <span class="comment">// 字符已经出现过</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		char_set[A[i]] = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.2</strong> 根据函数的原型<code>void reverse(char* str)</code>，我们并不知道字符串的长度，所以需要先求出长度再进行反转：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* tmp = str;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*tmp++ != <span class="string">'\0'</span>)  <span class="comment">// 求出字符串的长度</span></span><br><span class="line">		++len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> high = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)    <span class="comment">// 反转</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c = str[low];</span><br><span class="line">		str[low] = str[high];</span><br><span class="line">		str[high] = c;</span><br><span class="line">		++low;</span><br><span class="line">		--high;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.3</strong> 由题意可知，这是一个变位词的问题，可以看我的另一篇文章《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/28705787" target="_blank" rel="external">变位词问题</a>》。通常的做法是把两个字符串按字母表顺序排序，比较排序后的字符串是否相等：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.length() != s2.length())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 泛型算法 sort() 采用的是快速排序算法</span></span><br><span class="line">	sort(s1.begin(), s1.end(), myfunction);</span><br><span class="line">	sort(s2.begin(), s2.end(), myfunction);</span><br><span class="line">	<span class="keyword">if</span>(!s1.compare(s2))  <span class="comment">// 相等返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一种方法就是：检查两个字符串的各字符数是否相同。（假定字符集为ASCII）我们只需创建一个大小 256 的整型数组，遍历第一个字符串，给每个字符计数；遍历第二个字符串，递减对应字符的数量。最后判断数组元素是否全部为0。</p>
<p><br><br><strong>1.4</strong> 本题的思路就是进行两次扫描。第一次扫描记录字符串中有多少空格，从而计算最终字符串的长度；第二次扫描从后往前移动字符并插入20%。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">			++spaceNum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> newLen = len + spaceNum*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] != <span class="string">' '</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			str[newLen - <span class="number">1</span>] = str[i];</span><br><span class="line">			newLen = newLen - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[newLen - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">			str[newLen - <span class="number">2</span>] = <span class="string">'2'</span>;</span><br><span class="line">			str[newLen - <span class="number">3</span>] = <span class="string">'%'</span>;</span><br><span class="line">			newLen = newLen - <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.5</strong> 本题思路很简单：遍历字符串，将字符和对应的重复次数拷贝到新字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int转string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">stringstream</span> ss;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	ss &lt;&lt; n;</span><br><span class="line">	ss &gt;&gt; str;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">compress</span><span class="params">(<span class="built_in">string</span> str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> tmp;</span><br><span class="line">	<span class="keyword">char</span> c = str[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;str.length(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == c)</span><br><span class="line">			++count;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp + c + int2string(count);</span><br><span class="line">			c = str[i];</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp = tmp + c + int2string(count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> str.length()&gt;tmp.length() ? tmp:str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.6</strong> 归纳题意，简言之就是：对N阶方阵进行原地转置。（思路就是对每一层执行环状旋转，将上边移到右边、右边移到下边、下边移到左边、左边移到上边）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> **mtx, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> layer=<span class="number">0</span>; layer &lt; n/<span class="number">2</span>; ++layer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> first = layer;</span><br><span class="line">		<span class="keyword">int</span> last = n-<span class="number">1</span>-layer;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=first; i&lt;last; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> offset = i - first;</span><br><span class="line">			<span class="comment">// 暂存上边：top = mtx[first][i]</span></span><br><span class="line">			<span class="keyword">int</span> top = *((<span class="keyword">int</span>*)mtx+first*n+i);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 左到上：mtx[first][i] = mtx[last-offset][first]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+first*n+i) = *((<span class="keyword">int</span>*)mtx+(last-offset)*n+first);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 下到左：mtx[last-offset][first] = mtx[last][last-offset]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+(last-offset)*n+first) = *((<span class="keyword">int</span>*)mtx+last*n+(last-offset));</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 右到下：mtx[last][last-offset] = mtx[i][last]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+last*n+(last-offset)) = *((<span class="keyword">int</span>*)mtx+i*n+last);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 上到右：mtx[i][last] = top</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+i*n+last) = top;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意二维数组作参数传递的问题，另外调用的时候像这样<code>rotate((int**)A, 4)</code>。这个算法的时间复杂度为<code>O(n^2)</code>，已是最优的做法。</p>
<p><br><br><strong>1.7</strong> 这个问题貌似很简单，直接遍历嘛！只要发现为零的元素，就将其所在的行与列清零。不过这个方法有个陷阱：清零以后会导致连锁效应，最后整个矩阵都变成 0。我们的做法是：遍历两遍，第一遍记录要清零的行与列，第二遍再执行清零操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZero</span><span class="params">(<span class="keyword">int</span> **mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> *row = <span class="keyword">new</span> <span class="keyword">bool</span>[m](); <span class="comment">// 默认初始化为false</span></span><br><span class="line">	<span class="keyword">bool</span> *col = <span class="keyword">new</span> <span class="keyword">bool</span>[n]();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(*((<span class="keyword">int</span>*)mtx+i*n+j) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				row[i] = <span class="keyword">true</span>;</span><br><span class="line">				col[j] = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(row[i] || col[j])</span><br><span class="line">			&#123;</span><br><span class="line">				*((<span class="keyword">int</span>*)mtx+i*n+j) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] row;</span><br><span class="line">	<span class="keyword">delete</span> [] col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.8</strong> 如果<code>x = wat</code>，<code>y = erbottle</code>，则<code>s1 = xy</code>，<code>s2 = yx</code>。不论x和y之间的分割点在何处，我们会发现<code>yx</code>肯定是<code>xyxy</code>的子串。即，s2总是s1s1的子串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRotation</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.length() == s2.length() &amp;&amp; s1.length()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> isSubstring(s1+s1, s2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br><br>在解决链表问题时，首先我们得学会<strong>如何创建链表</strong>，下面是单链表创建和打印的示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node </span><br><span class="line">&#123;</span><br><span class="line">	node* next;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据数组创建单链表：尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	node *head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	node *s, *tail = head;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		s = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">		s-&gt;data = A[i++];</span><br><span class="line">		tail-&gt;next = s;</span><br><span class="line">		tail = s;</span><br><span class="line">	&#125;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">	<span class="keyword">return</span> head;  <span class="comment">/*头结点不保存数据*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(p!=NULL)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.1</strong> 要想移除链表中的重复结点，我们只需在遍历的过程中，将每个未重复结点加入一个缓冲区。若发现有结点在缓冲区已经存在（即重复），则将该结点从链表中移除。只需遍历一次即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; buffer;   <span class="comment">// 这里使用set容器</span></span><br><span class="line">	node *p = L-&gt;next;</span><br><span class="line">	node *pre = L;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> data = p-&gt;data;</span><br><span class="line">		<span class="keyword">if</span>(buffer.find(data) == buffer.end())</span><br><span class="line">		&#123;</span><br><span class="line">			buffer.insert(data);</span><br><span class="line">			pre = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">/* 重复 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;next = p-&gt;next;</span><br><span class="line">			node* q = p;  <span class="comment">// 记录删除的结点</span></span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(q);  <span class="comment">// 释放</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不借助额外的缓冲区，那么就只能两两比较以判断是否重复，时间复杂度为<code>O(n^2)</code>。需要使用两个指针来迭代：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == NULL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	node* current = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(current!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node* runner = current;</span><br><span class="line">		<span class="keyword">while</span>(runner-&gt;next!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(runner-&gt;next-&gt;data == current-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				node* p = runner-&gt;next;</span><br><span class="line">				runner-&gt;next = runner-&gt;next-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				runner = runner-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		current = current-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.2</strong> 本题有多种解法。</p>
<ul>
<li><p>解法一：有人可能首先会想到：这太简单了，先遍历一次链表获取长度 length，那么倒数第 k 个结点就是第 (length - k)个结点。但是，你觉得这会是面试官想要的答案吗？？</p>
</li>
<li><p>解法二：<strong>递归</strong>。先通过递归到达链表的末尾，然后从后往前进行计数，每次递归调用返回时，将计数器加1。当计数器等于 k 时，访问的就是链表倒数第 k 个元素。（注意计数器 i 需要<strong>传引用</strong>）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node* kthToLast(node* head, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	node* p = kthToLast(head-&gt;next, k, i);</span><br><span class="line">	i = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法三：<strong>迭代法</strong>。相比于递归，迭代法通常不太直观但效率更高。思路就是：用两个指针 p1 和 p2 指向链表中两个距离为k的结点，然后以相同速度移动这两个指针，当其中一个指针指向链表的尾结点时，另一个指针指向的就是倒数第k个结点。（<strong>“快行指针”技巧</strong>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">node* kthToLast(LinkList L, <span class="keyword">int</span> k)    <span class="comment">// 时间复杂度O(n)，空间复杂度O(1)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个指针</span></span><br><span class="line">	node* p1 = L-&gt;next;</span><br><span class="line">	node* p2 = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p2向前移动k个结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k-<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p2 == NULL)  <span class="comment">/*错误检查*/</span></span><br><span class="line">			<span class="keyword">return</span> NULL;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p2 == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动p1与p2</span></span><br><span class="line">	<span class="keyword">while</span>(p2-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>2.3</strong>  本题中，你访问不到链表的首结点，只能访问待删除结点及之后的结点。所以我们的做法是：直接将后继结点的数据复制到当前结点，然后删除这个后继结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNode</span><span class="params">(node* c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==NULL || c-&gt;next==NULL) <span class="comment">// 尾结点无法删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	node* next = c-&gt;next;</span><br><span class="line">	c-&gt;data = next-&gt;data;</span><br><span class="line">	c-&gt;next = next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.4</strong> 链表不同于数组，在用现有元素创建新的链表时，我们不必移动和交换元素，只是改变元素的 next 指针的指向。所以本题的思路也很简单：遍历链表，将小于 x 的元素连接成一个链表，将大于等于 x 的元素连接成一个链表，最后合并两个链表即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">partition</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node* biggerHead = NULL;</span><br><span class="line">	node* biggerTail = NULL;</span><br><span class="line">	node* smallerHead = NULL;</span><br><span class="line">	node* smallerTail = NULL;</span><br><span class="line"></span><br><span class="line">	node* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node* next = p-&gt;next;</span><br><span class="line">		p-&gt;next = NULL;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data &lt; x)</span><br><span class="line">		&#123;   <span class="comment">/*将比x小的结点插入smaller链表的尾部*/</span></span><br><span class="line">			<span class="keyword">if</span>(smallerHead == NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				smallerHead = p;</span><br><span class="line">				smallerTail = smallerHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				smallerTail-&gt;next = p;</span><br><span class="line">				smallerTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;   <span class="comment">/*将比x大的结点插入bigger链表的尾部*/</span></span><br><span class="line">			<span class="keyword">if</span>(biggerHead == NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				biggerHead = p;</span><br><span class="line">				biggerTail = biggerHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				biggerTail-&gt;next = p;</span><br><span class="line">				biggerTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*遍历结束，合并两个链表*/</span></span><br><span class="line">	<span class="keyword">if</span>(smallerHead == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;next = biggerHead;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	smallerTail-&gt;next = biggerHead;</span><br><span class="line">	L-&gt;next = smallerHead;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.5</strong>  本题的思路是逐个结点对应相加，然后判断是否进位。我们使用递归来模拟这个加法过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">add</span><span class="params">(LinkList L1, LinkList L2, <span class="keyword">int</span> carry)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*两个链表全部为空且进位为0，则函数返回*/</span></span><br><span class="line">	<span class="keyword">if</span>(L1==NULL &amp;&amp; L2==NULL &amp;&amp; carry==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	node* result = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> value = carry;</span><br><span class="line">	<span class="keyword">if</span>(L1!=NULL)</span><br><span class="line">		value+=L1-&gt;data;</span><br><span class="line">	<span class="keyword">if</span>(L2!=NULL)</span><br><span class="line">		value+=L2-&gt;data;</span><br><span class="line"></span><br><span class="line">	result-&gt;data = value%<span class="number">10</span>;  <span class="comment">/*取个位*/</span></span><br><span class="line"></span><br><span class="line">	node* more = add(L1==NULL?NULL:L1-&gt;next, </span><br><span class="line">    				L2==NULL?NULL:L2-&gt;next, </span><br><span class="line">                    value&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	result-&gt;next = more;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里<code>add</code>之后返回的链表没有“头指针”。</p>
<p><br><br><strong>2.6</strong> 这个问题是由经典面试题——<strong>检查链表是否存在回路</strong>——演变而来。</p>
<p><img src="http://img.blog.csdn.net/20150324231307367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，如果链表中存在回路，那么我们遍历时会陷入死循环。那么，我们如何检测链表是否存在环 以及 寻找环的入口点呢？答案是<strong>“快慢指针”</strong>。</p>
<p>① 设置两个指针（fast、slow），初始值都指向头，slow每次前进一步，fast每次前进二步。如果链表存在环，则fast必定先进入环，而slow后进入环，两个指针必定相遇。这是<strong>检测</strong>。</p>
<p>② 在fast和slow第一次相遇的时候，假定slow走了n步，环路的入口是在p步，<br>   c为fast和slow相交点距离环路入口的距离。那么，slow走的路径： p+c ＝ n；<br>   fast走的路径： p+c+k*L = 2*n（L为环路的周长，k是整数），即n = k*L<br>   显然，如果从p+c点开始，slow再走n步的话，还可以回到p+c这个点。<br>   同时，fast从头开始走，步长为1，经过n步，也会达到p+c这点。<br>   显然，在这个过程中fast和slow只有前p步骤走的路径不同。所以当p1和p2再次重合的时候，必然是在链表的环路入口点上。</p>
<p>③ 综上所述，可得出如下算法：</p>
<ul>
<li><p>创建两个指针：fast和slow</p>
</li>
<li><p>slow每走一步，fast就走两步</p>
</li>
<li><p>两者碰在一起时，将slow重新指向链表头，fast保持不变</p>
</li>
<li><p>以相同速度移动slow和fast，一次一步，然后返回新的碰撞处。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">node* findLoopEntrance(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	node* slow = L-&gt;next;</span><br><span class="line">	node* fast = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)  <span class="comment">/*碰撞*/</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fast==NULL || fast-&gt;next==NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;  <span class="comment">/*没有环路*/</span></span><br><span class="line"></span><br><span class="line">	slow = L-&gt;next;   <span class="comment">/*重新指向链表头*/</span></span><br><span class="line">	<span class="keyword">while</span>(slow!=fast)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>2.7</strong> 所谓“回文”指正向看和反向看是一样的。在链表中可以定义为 <code>0-&gt;1-&gt;2-&gt;1-&gt;0</code>。</p>
<ul>
<li><p>解法一：根据定义，先将整个链表反转，然后比较反转链表和原始链表。若两者相同，则该链表为回文。（只需比较链表的前半部分）</p>
</li>
<li><p>解法二：迭代法。先进行迭代，将链表的前半部分入栈，再继续进行迭代，与后半部分进行比较。每次迭代时，比较当前结点和栈顶元素，若完成迭代时比较结果完全相同，则该链表为回文。（在链表长度未知的情况下，可以使用<strong>“快慢指针</strong>”将前半部分入栈）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node* fast = L-&gt;next;</span><br><span class="line">	node* slow = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**将链表的前半部分入栈**/</span></span><br><span class="line">	<span class="keyword">while</span>(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		s.push(slow-&gt;data);</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**链表有奇数个元素，跳过中间元素**/</span></span><br><span class="line">	<span class="keyword">if</span>(fast!=NULL)</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**比较**/</span></span><br><span class="line">	<span class="keyword">while</span>(slow!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> top = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="keyword">if</span>(top!=slow-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1、数组与字符串">1、数组与字符串</h3><p><strong>1.1</strong> 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p>
<p><strong>1.2</strong> 用C或C++实现<code>void reverse(char* str)</code>函数，即反转一个null结尾的字符串。</p>
<p><strong>1.3</strong> 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>1.4</strong> 编写一个方法，将字符串中的空格全部替换为“%20”。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。示例：输入<code>Mr John Smith</code>，输出<code>Mr%20John%20Smith</code>。]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试题之strcpy/strlen/strcat/strcmp的实现]]></title>
    <link href="http://yoursite.com/2015/03/15/string-operating-function/"/>
    <id>http://yoursite.com/2015/03/15/string-operating-function/</id>
    <published>2015-03-15T09:15:22.000Z</published>
    <updated>2015-05-10T11:11:47.072Z</updated>
    <content type="html"><![CDATA[<p>阿里的电面要我用C/C++实现一个字符串拷贝的函数，虽然以前写过 strcpy 的函数实现，但时间过去很久了，再加上有点紧张，突然就措手不及了。最后写是写出来了，但没考虑异常的情况，面试官好像很不满意。(T_T)，写篇文章记录一下，以免日后重蹈覆辙。</p>
<h3 id="一、字符串拷贝strcpy">一、字符串拷贝strcpy</h3><p>函数<code>strcpy</code>的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">strcpy</span>(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span><br><span class="line">&#123;</span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL)); </span><br><span class="line">	<span class="keyword">char</span> *address = des;  </span><br><span class="line">	<span class="keyword">while</span>((*des++ = *src++) != <span class="string">'\0'</span>)  </span><br><span class="line">		;  </span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要知道 strcpy 会拷贝’\0’，还有要注意：</p>
<ul>
<li><p>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。</p>
</li>
<li><p>要判断源指针和目的指针为空的情况，思维要严谨，这里使用<code>assert</code>（见文末）。</p>
</li>
<li><p>要用一个临时变量保存目的串的首地址，最后返回这个首地址。</p>
</li>
<li><p>函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。</p>
</li>
</ul>
<p><br></p>
<h3 id="二、字符串长度strlen">二、字符串长度strlen</h3><p>函数<code>strlen</code>的原型是<code>size_t strlen(const char *s)</code>，其中 size_t 就是 unsigned int。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	assert(str != NULL);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((*str++) != <span class="string">'\0'</span>)</span><br><span class="line">		++len;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>strlen 与 sizeof 的区别：</p>
<ul>
<li><p>sizeof是运算符，strlen是库函数。</p>
</li>
<li><p>sizeof可以用类型、变量做参数，而strlen只能用 char* 变量做参数，且必须以<code>\0</code>结尾。</p>
</li>
<li><p>sizeof是在编译的时候计算类型或变量所占内存的大小，而strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度。</p>
</li>
<li><p>数组做sizeof的参数不退化，传递给strlen就退化为指针了。</p>
</li>
</ul>
<p><br></p>
<h3 id="三、字符串连接strcat">三、字符串连接strcat</h3><p>函数<code>strcat</code>的原型是<code>char* strcat(char* des, char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">strcat</span>(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)   <span class="comment">// const表明为输入参数 </span></span><br><span class="line">&#123;  </span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL));</span><br><span class="line">	<span class="keyword">char</span>* address = des;</span><br><span class="line">	<span class="keyword">while</span>(*des != <span class="string">'\0'</span>)  <span class="comment">// 移动到字符串末尾</span></span><br><span class="line">		++des;</span><br><span class="line">	<span class="keyword">while</span>(*des++ = *src++)</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、字符串比较strcmp">四、字符串比较strcmp</h3><p>函数<code>strcmp</code>的原型是<code>int strcmp(const char *s1,const char *s2)</code>。  </p>
<ul>
<li>若s1==s2，返回零；</li>
<li>若s1&gt;s2，返回正数；</li>
<li>若s1&lt;s2，返回负数。</li>
</ul>
<p>即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇<code>\0</code>为止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	assert((s1!=NULL) &amp;&amp; (s2!=NULL));</span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1 == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
<h3 id="附：assert()断言">附：assert()断言</h3><p><code>assert</code>是宏，而不是函数。它的原型定义在头文件 assert.h 中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>宏 assert 经常用于在函数开始处检验传入参数的合法性，可以将其看作是异常处理的一种高级形式。<strong>assert 的作用是</strong>先计算表达式expression，然后判断：</p>
<ul>
<li><p>如果表达式值为假，那么它先向stderr打印错误信息，然后通过调用 abort 来终止程序运行。</p>
</li>
<li><p>如果表达式值为真，继续运行后面的程序。</p>
</li>
</ul>
<p>注意：<code>assert</code>只在 DEBUG 下生效，在调试结束后，可以通过在<code>#include &lt;assert.h&gt;</code>语句之前插入<code>#define NDEBUG</code>来禁用assert调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阿里的电面要我用C/C++实现一个字符串拷贝的函数，虽然以前写过 strcpy 的函数实现，但时间过去很久了，再加上有点紧张，突然就措手不及了。最后写是写出来了，但没考虑异常的情况，面试官好像很不满意。(T_T)，写篇文章记录一下，以免日后重蹈覆辙。</p>
<h3 id="一、字符串拷贝strcpy">一、字符串拷贝strcpy</h3><p>函数<code>strcpy</code>的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树（BST）]]></title>
    <link href="http://yoursite.com/2015/01/13/binary-search-tree/"/>
    <id>http://yoursite.com/2015/01/13/binary-search-tree/</id>
    <published>2015-01-12T16:08:39.000Z</published>
    <updated>2015-05-10T11:02:28.213Z</updated>
    <content type="html"><![CDATA[<p><strong>二叉查找树（Binary Search Tree）</strong>又叫二叉排序树（Binary Sort Tree），它是一种数据结构，支持多种动态集合操作，如 Search、Insert、Delete、Minimum 和 Maximum 等。</p>
<p>二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。</p>
</li>
<li><p>左、右子树本身也分别是一棵二叉查找树（二叉排序树）。<a id="more"></a></p>
</li>
</ol>
<p>可以看出，二叉查找树是一个递归的数据结构，且对二叉查找树进行中序遍历，可以得到一个<strong>递增</strong>的有序序列。</p>
<p>首先，我们来定义一下 BST 的结点结构体，结点中除了 key 域，还包含域 left, right 和 parent，它们分别指向结点的左儿子、右儿子和父节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	Node* left;</span><br><span class="line">	Node* right;</span><br><span class="line">	Node* parent;</span><br><span class="line">&#125; *BSTree;</span><br></pre></td></tr></table></figure></p>
<h3 id="一、BST的插入与构造">一、BST的插入与构造</h3><p>二叉查找树作为一种动态结构，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在结点的关键字等于给定值时再进行插入。</p>
<p>由于二叉查找树是递归定义的，插入结点的过程是：若原二叉查找树为空，则直接插入；否则，若关键字 k 小于根结点关键字，则插入到左子树中，若关键字 k 大于根结点关键字，则插入到右子树中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入：将关键字k插入到二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k, Node* parent=NULL)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		T-&gt;key = k;</span><br><span class="line">		T-&gt;left = NULL;</span><br><span class="line">		T-&gt;right = NULL;</span><br><span class="line">		T-&gt;parent = parent;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 返回1表示成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 树中存在相同关键字</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;left, k, T);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;right, k, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造</strong>一棵二叉查找树就是依次输入数据元素，并将它们插入到二叉排序树中的适当位置。具体过程是：每读入一个元素，就建立一个新结点；若二叉查找树为空，则新结点作为根结点；若二叉查找树非空，则将新结点的值与根结点的值比较，如果小于根结点的值，则插入到左子树中，否则插入到右子树中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 构造：用数组arr[]创建二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T = NULL;  <span class="comment">// 初始时为空树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		BST_Insert(T, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，插入的新结点一定是某个叶结点。另外，插入操作既可以递归实现，也可以使用非递归（迭代）实现。通常来说非递归的效率会更高。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 非递归插入：将关键字k插入到二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert_NonRecur</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node* pre = NULL;  <span class="comment">// 记录上一个结点</span></span><br><span class="line">	Node* t = T;</span><br><span class="line">	<span class="keyword">while</span>(t != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		pre = t;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; t-&gt;key)</span><br><span class="line">			t = t-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; t-&gt;key)</span><br><span class="line">			t = t-&gt;right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	node-&gt;key = k;</span><br><span class="line">	node-&gt;left = NULL;</span><br><span class="line">	node-&gt;right = NULL;</span><br><span class="line">	node-&gt;parent = pre;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pre == NULL)</span><br><span class="line">		T = node;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; pre-&gt;key)</span><br><span class="line">			pre-&gt;left = node;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pre-&gt;right = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、BST的查找">二、BST的查找</h3><p>对于二叉查找树，最常见的操作就是查找树中的某个关键字。除了Search操作外，二叉查找树还能支持如 Minimum（最小值）、Maximum（最大值）、Predecessor（前驱）、Successor（后继）等查询。对于高度为 h 的树，这些操作都可以在 Θ(h) 时间内完成。</p>
<p><strong>1. 查找</strong></p>
<p>BST 的查找是从根结点开始，若二叉树非空，将给定值与根结点的关键字比较，若相等，则查找成功；若不等，则当给定值小于根结点关键字时，在根结点的左子树中查找，否则在根结点的右子树中查找。显然，这是一个递归的过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 递归查找：返回指向包含关键字k的结点的指针</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Search(BSTree T, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL || k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Search(T-&gt;left, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> BST_Search(T-&gt;right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用非递归的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 非递归查找：返回指向包含关键字k的结点的指针</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Search_NonRecur(BSTree T, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T != NULL &amp;&amp; k != T-&gt;key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">			T = T-&gt;left;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T = T-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 最大值与最小值</strong></p>
<p>由二叉查找树的性质可知，最左下结点即为关键字最小的结点，最右下结点即为关键字最大的结点。此过程无需比较，只需要沿着最左和最右的路径查找下去，直到遇到 NULL 为止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 最小值：查找二叉查找树中关键字最小的结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Minimum(BSTree T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T-&gt;left != NULL)</span><br><span class="line">		T = T-&gt;left;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 最大值：查找二叉查找树中关键字最大的结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Maximum(BSTree T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T-&gt;right != NULL)</span><br><span class="line">		T = T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 前驱与后继</strong></p>
<p>给定一个二叉查找树的结点，求出它在<strong>中序遍历</strong>中的前驱与后继。如果所有的关键字均不相同，则某结点 x 的后继是：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继就是它的右子树中关键字值最小的结点；</p>
</li>
<li><p>若结点 x 的右子树为空，为了找到其后继，从结点 x 开始向上查找，直到遇到一个祖先结点 y，它的左儿子也是结点 x 的祖先，则结点 y 就是结点 x 的后继。如下图</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150110234933625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 后继：查找给定结点在中序遍历中的后继结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Successor(Node* node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;right != NULL)</span><br><span class="line">		<span class="keyword">return</span> BST_Minimum(node-&gt;right);</span><br><span class="line">	Node* p = node-&gt;parent;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right == node)</span><br><span class="line">	&#123;</span><br><span class="line">		node = p;</span><br><span class="line">		p = p-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求前驱（predecessor）的过程对称，对于某个结点 x ，它的前驱是：</p>
<ul>
<li><p>若结点 x 的左子树不为空，则 x 的前驱是它的左子树中关键字值最大的结点；</p>
</li>
<li><p>若结点 x 的左子树为空，为了找到其前驱，从结点 x 开始向上查找，直到遇到一个祖先结点 y，它的右儿子也是结点 x 的祖先，则结点 y 就是结点 x 的前驱。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 前驱：查找给定结点在中序遍历中的前驱结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Predecessor(Node* node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;left != NULL)</span><br><span class="line">		<span class="keyword">return</span> BST_Maximum(node-&gt;left);</span><br><span class="line">	Node* p = node-&gt;parent;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;left == node)</span><br><span class="line">	&#123;</span><br><span class="line">		node = p;</span><br><span class="line">		p = p-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以在这里讨论如何求中序序列的后继，主要是为了后面讲删除操作做铺垫。</p>
<h3 id="三、BST的删除">三、BST的删除</h3><p>二叉查找树的删除操作是相对复杂一点，它要按 3 种情况来处理：</p>
<ul>
<li><p>若被删除结点 z 是叶子结点，则直接删除，不会破坏二叉排序树的性质；</p>
</li>
<li><p>若结点 z 只有左子树或只有右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置；</p>
</li>
<li><p>若结点 z 既有左子树，又有右子树，则用 z 的后继（Successor）代替 z，然后从二叉查找树中删除这个后继，这样就转换成了第一或第二种情况。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_Delete</span><span class="params">(BSTree &amp;T,Node* z)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(z-&gt;left == NULL &amp;&amp; z-&gt;right == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = NULL;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = NULL;  <span class="comment">// 只剩一个结点的情况</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;left != NULL &amp;&amp; z-&gt;right == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		z-&gt;left-&gt;parent = z-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = z-&gt;left;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = z-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = z-&gt;left;  <span class="comment">// 删除左斜单支树的根结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;left == NULL &amp;&amp; z-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		z-&gt;right-&gt;parent = z-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = z-&gt;right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = z-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = z-&gt;right;  <span class="comment">// 删除右斜单支树的根结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node* s = BST_Successor(z);</span><br><span class="line">		z-&gt;key = s-&gt;key;   <span class="comment">// s的关键字替换z的关键字</span></span><br><span class="line">		BST_Delete(T, s);  <span class="comment">// 转换为第一或第二种情况</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个高度为 h 的二叉查找树来说，删除操作和插入操作一样，都可以在 Θ(h) 时间内完成。</p>
<h3 id="四、随机构造的二叉查找树">四、随机构造的二叉查找树</h3><p>二叉查找树可以实现任何一种基本的动态集合操作，且各基本操作的运行时间都是 Θ(h)。当树的高度较低时，这些操作执行的较快；但是，当树的高度较高时，性能会变差。比如，<strong>如果各元素是按严格增长的顺序插入的，那么构造出来的树就是一个高度为 n-1 的链。</strong> 为了尽量减少这种最坏情况的出现，我们可以随机地构造二叉查找树，即随机地将各关键字插入一棵初始为空的树来构造 BST。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;ctime&gt;</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机构造二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T = NULL;  </span><br><span class="line">	<span class="comment">// 随机遍历数组，进行插入操作</span></span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">		BST_Insert(T, arr[j]);</span><br><span class="line">		swap(arr[j], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
<h3 id="附：随机遍历数组">附：随机遍历数组</h3><p>在随机构造二叉查找树时，需要解决 随机遍历数组 的问题，即随机遍历一个数组中的所有元素，既不重复也不遗漏。这里能想到的一种思路是：先随机生成<code>0...n-1</code>之间的一个数，然后与数组最后一个数交换，然后再随机生成<code>0...n-2</code>之间的一个数，与数组倒数第二个数交换，直到整个数组遍历结束。显然这个算法的时间复杂度是 O(n)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;ctime&gt;    <span class="comment">// time</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> tmp = a;  </span><br><span class="line">	a = b;  </span><br><span class="line">	b = tmp;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机遍历数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse_Random</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 输出</span></span><br><span class="line">		swap(arr[j], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	Traverse_Random(arr, <span class="number">9</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>（全文完）</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>二叉查找树（Binary Search Tree）</strong>又叫二叉排序树（Binary Sort Tree），它是一种数据结构，支持多种动态集合操作，如 Search、Insert、Delete、Minimum 和 Maximum 等。</p>
<p>二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。</p>
</li>
<li><p>左、右子树本身也分别是一棵二叉查找树（二叉排序树）。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之构造函数中的异常处理]]></title>
    <link href="http://yoursite.com/2015/01/12/cpp-exception-in-constructor/"/>
    <id>http://yoursite.com/2015/01/12/cpp-exception-in-constructor/</id>
    <published>2015-01-12T09:06:05.000Z</published>
    <updated>2015-05-10T10:59:43.206Z</updated>
    <content type="html"><![CDATA[<p>构造函数中可不可以抛出异常？当然可以。从语法上来说，是可以的；从实际情况来看，现在的软件系统日渐庞大和复杂，很难保证 Constructor 在执行过程中完全不发生一点异常。</p>
<p>那么，如果构造函数中抛出异常，会发生什么情况呢？</p>
<h3 id="一、构造函数中抛出异常将导致对象的析构函数不被执行。">一、构造函数中抛出异常将导致对象的析构函数不被执行。</h3><p>C++仅能 delete 被完全构造的对象（fully constructed objects），只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。所以如果在构造函数中抛出一个异常，这个异常将传递到创建对象的地方（程序控制权也会随之转移），这样对象就只是部分被构造，它的析构函数将不会被执行。<a id="more"></a></p>
<p>看下面的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************类定义**********************/</span></span><br><span class="line"><span class="keyword">class</span> person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str):name(str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//throw exception("测试：在构造函数中抛出一个异常");</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造一个对象！"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁一个对象！"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************测试类**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">person <span class="title">me</span><span class="params">("songlee")</span></span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(exception e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意上面的 me 是一个局部对象，所以离开<code>try{}</code>的作用域，会自动执行析构函数。运行上述代码，输出结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造一个对象！</span><br><span class="line">销毁一个对象！</span><br></pre></td></tr></table></figure></p>
<p>如果在构造函数中抛出一个异常（去掉注释），输出结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试：在构造函数中抛出一个异常</span><br></pre></td></tr></table></figure></p>
<p>可以看出，析构函数没有被自动执行。为什么<em>“构造一个对象！”</em>也没有输出呢？因为程序控制权转移了，所以在异常点以后的语句都不会被执行。</p>
<h3 id="二、构造函数抛出异常可能导致内存泄露">二、构造函数抛出异常可能导致内存泄露</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B() &#123; </span><br><span class="line">		<span class="comment">//throw exception("测试：在B的构造函数中抛出一个异常");</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造 B 对象!"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~B()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁 B 对象!"</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Tester &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address);</span><br><span class="line">	~Tester();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> theName;</span><br><span class="line">	<span class="built_in">string</span> theAddress;</span><br><span class="line">	A *a;</span><br><span class="line">	B *b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面声明了三个类（A、B、Tester）,其中Tester类的构造函数和析构函数定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tester::Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address):</span><br><span class="line">	theName(name),</span><br><span class="line">	theAddress(address)</span><br><span class="line">&#123;</span><br><span class="line">	a = <span class="keyword">new</span> A();</span><br><span class="line">	b = <span class="keyword">new</span> B();  <span class="comment">// &lt;——</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造 Tester 对象!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tester::~Tester()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁 Tester 对象!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造函数中，动态的分配了内存空间给a、b两个指针。析构函数负责删除这些指针，确保Tester对象不会发生内存泄露（C++中delete一个空指针也是安全的）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tester *tes = NULL;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		tes = <span class="keyword">new</span> Tester(<span class="string">"songlee"</span>,<span class="string">"201"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(exception e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">delete</span> tes; <span class="comment">// 删除NULL指针是安全的</span></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行输出结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造 B 对象!</span><br><span class="line">构造 Tester 对象!</span><br><span class="line">销毁 B 对象!</span><br><span class="line">销毁 Tester 对象!</span><br></pre></td></tr></table></figure></p>
<p>看上去好像一切良好，在正常情况下确实没有错。但是在有异常的情况下，恐怕就不会良好了。</p>
<p><strong>试想在 Tester 的构造函数执行时，</strong><code>b = new B()</code><strong>抛出了异常：</strong>可能是因为operator new不能给B对象分配足够的内存，也可能是因为 B 的构造函数自己抛出了一个异常。不论什么原因，在 Tester 构造函数内抛出异常，这个异常将传递到建立 Tester 对象的地方（程序控制权也会转移）。</p>
<p>在 B 的构造函数里抛出异常（去掉注释）时，程序运行结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试：在B的构造函数中抛出一个异常</span><br></pre></td></tr></table></figure></p>
<p>可以看出，C++拒绝为没有完成构造操作的对象调用析构函数，即使你使用了<code>delete</code>语句。由于 Tester 的析构函数不会执行，所以给A对象 a 动态分配（new）的空间无法释放，将造成内存泄露。</p>
<p><strong>注：</strong>不用为 Tester 对象中的非指针数据成员操心，因为它们不是new出来的，且在异常抛出之前已经构造完全，所以它们会自动逆序析构。</p>
<h3 id="三、解决上述内存泄露的方法">三、解决上述内存泄露的方法</h3><p>因为当对象在构造中抛出异常后C++不负责清除（动态分配）的对象，所以你必须重新设计构造函数以让它们自己清除。<strong>常用的方法</strong>是捕获所有的异常，然后执行一些清除代码，最后再重新抛出异常让它继续传递。</p>
<p>示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Tester::Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address):</span><br><span class="line">	theName(name),</span><br><span class="line">	theAddress(address),</span><br><span class="line">	a(NULL),   <span class="comment">// 初始化为空指针是必须的</span></span><br><span class="line">	b(NULL)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="keyword">new</span> A();</span><br><span class="line">		b = <span class="keyword">new</span> B();  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(...)   <span class="comment">// 捕获所有异常</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> a;</span><br><span class="line">		<span class="keyword">delete</span> b;</span><br><span class="line">		<span class="keyword">throw</span>;   <span class="comment">// 继续传递异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种更好的方法是使用<strong>智能指针（smart pointer）</strong>，不过关于智能指针的内容比较多，在这里就不说了。</p>
<p><br><br><br><br><br><br><strong>总结：</strong></p>
<ul>
<li><p>在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。</p>
</li>
<li><p>构造函数中抛出异常，对象的析构函数将不会被执行。</p>
</li>
<li><p>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露。</p>
</li>
<li><p>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>构造函数中可不可以抛出异常？当然可以。从语法上来说，是可以的；从实际情况来看，现在的软件系统日渐庞大和复杂，很难保证 Constructor 在执行过程中完全不发生一点异常。</p>
<p>那么，如果构造函数中抛出异常，会发生什么情况呢？</p>
<h3 id="一、构造函数中抛出异常将导致对象的析构函数不被执行。">一、构造函数中抛出异常将导致对象的析构函数不被执行。</h3><p>C++仅能 delete 被完全构造的对象（fully constructed objects），只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。所以如果在构造函数中抛出一个异常，这个异常将传递到创建对象的地方（程序控制权也会随之转移），这样对象就只是部分被构造，它的析构函数将不会被执行。]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android网络爬虫程序（基于Jsoup）]]></title>
    <link href="http://yoursite.com/2015/01/11/android-crawler/"/>
    <id>http://yoursite.com/2015/01/11/android-crawler/</id>
    <published>2015-01-11T15:53:11.000Z</published>
    <updated>2015-05-10T10:52:59.184Z</updated>
    <content type="html"><![CDATA[<p>摘要：基于 Jsoup 实现一个 Android 的网络爬虫程序，抓取网页的内容并显示出来。写这个程序的主要目的是抓取<a href="http://xjh.haitou.cc/" target="_blank" rel="external">海投网</a>的宣讲会信息（公司、时间、地点）并在移动端显示，这样就可以随时随地的浏览在学校举办的宣讲会信息了。</p>
<h3 id="一、Jsoup简介">一、Jsoup简介</h3><p><a href="http://jsoup.org/" target="_blank" rel="external">Jsoup</a> 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常方便的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>Jsoup主要有以下功能：<a id="more"></a></p>
<ul>
<li><p>从一个URL，文件或字符串中解析HTML；</p>
</li>
<li><p>使用DOM或CSS选择器来查找、取出数据；</p>
</li>
<li><p>对HTML元素、属性、文本进行操作；</p>
</li>
<li><p>清除不受信任的HTML (来防止XSS攻击)</p>
</li>
</ul>
<p>好了，下面写几段代码来说明 Jsoup 是如何优雅的进行 HTML 文档处理的。首先，我们需要去 <a href="http://jsoup.org/download" target="_blank" rel="external">Jsoup官网</a> 下载Jsoup的<code>jar</code>包，然后加入项目的依赖库中。</p>
<p><strong>1） HTML解析</strong></p>
<p>Jsoup 可以从一个字符串、文件或者一个 URL 中解析HTML，解析的目的主要是为了得到一个干净完整的解析结果，并生成 Document 对象实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a document from a String</span></span><br><span class="line">String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;神奕的博客&lt;/title&gt;&lt;/head&gt;"</span></span><br><span class="line">        +<span class="string">"&lt;body&gt;&lt;p&gt;搭个博客写学习笔记！！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">Document doc = Jsoup.parse(html);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load a Document from a File</span></span><br><span class="line">File input = <span class="keyword">new</span> File(<span class="string">"D://a.html"</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load a Document from a URL</span></span><br><span class="line">Document doc = Jsoup.connect(<span class="string">"http://example.com/"</span>).get();</span><br></pre></td></tr></table></figure></p>
<p>当加载和解析一个本地的HTML文件时，如果在加载文件的时候发生错误，将抛出 IOException，应作适当处理。</p>
<p><strong>2） 数据提取</strong></p>
<p>将HTML解析成一个<code>Document</code>之后，就可以使用传统的 DOM 方法进行数据抽取。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 海投网</span></span><br><span class="line">String url = <span class="string">"http://xjh.haitou.cc/wh/uni-1/after/hold/page-1/"</span>;</span><br><span class="line">Document doc = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line">Elements elements = doc.getElementsByTag(<span class="string">"company"</span>);</span><br><span class="line"><span class="keyword">for</span>(Element e : elements) &#123;</span><br><span class="line">    System.out.println(e.text());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Document 对象和 Elements 对象提供了一系列类似于DOM的方法来查找元素，比如 getElementById(String id)、getElementsByTag(String tag) 等等。更多方法请看《<a href="http://www.open-open.com/jsoup/dom-navigation.htm" target="_blank" rel="external">Jsoup Cookbook</a>》。</p>
<p>另外，还可以使用 Selector 选择器（类似于CSS或jQuery语法）来查找元素。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 海投网</span></span><br><span class="line">String url = <span class="string">"http://xjh.haitou.cc/wh/uni-1/after/hold/page-1/"</span>;</span><br><span class="line">Document doc = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过标签company查找元素</span></span><br><span class="line">Elements company = doc.select(<span class="string">"company"</span>);</span><br><span class="line"><span class="comment">// 带有href属性的a元素</span></span><br><span class="line">Elements links = doc.select(<span class="string">"a[href]"</span>);</span><br><span class="line"><span class="comment">// 扩展名为.png的图片</span></span><br><span class="line">Elements pngs = doc.select(<span class="string">"img[src$=.png]"</span>);</span><br><span class="line"><span class="comment">// class等于content的div标签</span></span><br><span class="line">Element content = doc.select(<span class="string">"div.content"</span>).first();</span><br></pre></td></tr></table></figure></p>
<p>选择器实现了非常强大和灵活的查找功能。<code>select</code>方法在Document、Element 或 Elements 对象中都可以使用，且是上下文相关的，因此可实现指定元素的过滤或者链式选择访问。<code>select</code>方法将返回一个Elements集合，并提供一组方法来抽取和处理结果。</p>
<p>通过 DOM 方法或者 Selector 方法查找到一些 Elements 元素之后，我们需要从这些元素中取得数据，下面是几个常用的方法：</p>
<ul>
<li><p>取得一个属性的值，可以使用<code>Node.attr(String key)</code>方法；</p>
</li>
<li><p>取得一个元素中的文本，可以使用<code>Element.text()</code>方法；</p>
</li>
<li><p>取得元素或属性中的HTML内容，可用<code>Element.html()</code>或<code>Node.outerHtml()</code>方法</p>
</li>
<li><p>取得一个元素的 id ：<code>Element.id()</code></p>
</li>
<li><p>取得一个元素的标签名：<code>Element.tagName()</code></p>
</li>
<li><p>取得一个元素的类名：<code>Element.className()</code></p>
</li>
</ul>
<p><strong>3） 数据修改</strong></p>
<p>在解析一个 Document 之后可能想修改其中的某些属性值、HTML或文本内容，然后再保存到磁盘或都输出到前台页面。例如：我们可以为文档中的所有图片增加可点击链接、修改链接地址或者是修改文本等。Jsoup 提供了很多方法用来进行修改，这里就不列举了，请移步 <a href="http://www.open-open.com/jsoup/set-attributes.htm" target="_blank" rel="external">Jsoup Cookbook</a> 。</p>
<h3 id="二、海投网的页面抓取">二、海投网的页面抓取</h3><p><a href="http://www.haitou.cc/" target="_blank" rel="external">海投网</a>是一个为高校毕业生服务的招聘信息网，创始人是华中科技大学的毕业生。现在我要抓取在华中科技大学举办的宣讲会的信息，网页如下图：</p>
<p><img src="http://img.blog.csdn.net/20150124222530359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>查看网页源代码，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150124222646938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>可以看出，公司名是在一个 company 标签内，宣讲会时间是在一个类名为 text-center 的 td 标签内，学校的具体地点则是在一个类名为 preach-tbody-addre 的 td 标签内。这么一分析，要提取华中科技大学的宣讲会信息就变得挺简单了。</p>
<p>Java代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jsoup.Connection;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String url = <span class="string">"http://xjh.haitou.cc/wh/uni-1/after/hold/page-1/"</span>;</span><br><span class="line">        Connection conn = Jsoup.connect(url);</span><br><span class="line">        <span class="comment">// 修改http包中的header,伪装成浏览器进行抓取</span></span><br><span class="line">        conn.header(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:32.0) Gecko/    20100101 Firefox/32.0"</span>);</span><br><span class="line">        Document doc = conn.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取tbody元素下的所有tr元素</span></span><br><span class="line">        Elements elements = doc.select(<span class="string">"tbody tr"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Element element : elements) &#123;</span><br><span class="line">        	String companyName = element.getElementsByTag(<span class="string">"company"</span>).text();</span><br><span class="line">        	String time = element.select(<span class="string">"td.text-center"</span>).first().text();</span><br><span class="line">        	String address = element.getElementsByClass(<span class="string">"preach-tbody-addre"</span>).text();</span><br><span class="line">        	</span><br><span class="line">        	System.out.println(<span class="string">"公司："</span>+companyName);</span><br><span class="line">        	System.out.println(<span class="string">"宣讲时间："</span>+time);</span><br><span class="line">        	System.out.println(<span class="string">"宣讲学校：华中科技大学"</span>);</span><br><span class="line">        	System.out.println(<span class="string">"具体地点："</span>+address);</span><br><span class="line">        	System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>某些网站禁止爬虫，不能抓取或者抓取一定数量后封IP。这时候我们需要<strong>伪装成浏览器</strong>进行抓取，这可以通过修改http包中的header来实现（<a href="http://www.966266.com/jishu/user-agent-chaxun.html" target="_blank" rel="external">设置User-Agent</a>）。运行上面的程序得到输出结果：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">公司：瑞声科技(常州)有限公司</span><br><span class="line">宣讲时间：2015-03-07 19:00(周六)</span><br><span class="line">宣讲学校：华中科技大学</span><br><span class="line"><span class="header">具体地点：大学生活动中心305阶梯教室</span><br><span class="line">---------------------------------</span></span><br><span class="line">公司：普联技术有限公司</span><br><span class="line">宣讲时间：2015-03-08 19:00(周日)</span><br><span class="line">宣讲学校：华中科技大学</span><br><span class="line"><span class="header">具体地点：大学生活动中心305阶梯教室</span><br><span class="line">---------------------------------</span></span><br><span class="line">公司：大联大投资控股股份有限公司</span><br><span class="line">宣讲时间：2015-03-09 09:30(周一)</span><br><span class="line">宣讲学校：华中科技大学</span><br><span class="line"><span class="header">具体地点：大学生活动中心305阶梯教室</span><br><span class="line">---------------------------------</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h3 id="三、应用到Android程序中">三、应用到Android程序中</h3><p>开发 Android 程序，你需要搭建开发环境，很简单：先安装Java的JDK（最好不低于1.6），然后去<a href="http://developer.android.com" target="_blank" rel="external">Android官网</a>下载并安装 <strong>Android Studio</strong> 就行了。</p>
<p>在Android程序中使用 Jsoup 需要注意两点：</p>
<ul>
<li><p>在AndroidManifest.xml文件中添加网络访问权限<code>android.permission.INTERNET</code></p>
</li>
<li><p>Android在4.0之后，不允许在主线程里执行网络（http）请求，也就是说 Jsoup 的代码需要写在子线程里。</p>
</li>
</ul>
<p><strong>1） 多线程</strong></p>
<p>4.0 版本以后，如果你在主线程里尝试进行网络操作，会报android.os.NetworkOnMainThreadException 的异常。所以我们需要开辟子线程进行异步加载，用到<code>Thread</code>、<code>Runnable</code>、<code>Handler</code>这三个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">this</span>.setContentView(R.layout.share_mblog_view);</span><br><span class="line">    <span class="comment">// 开辟一个线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="javadoc">/**</span><br><span class="line">         * 要执行的操作</span><br><span class="line">         */</span></span><br><span class="line">    	<span class="comment">// 执行完毕后给handler发送一个空消息</span></span><br><span class="line">        handler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="javadoc">/**</span><br><span class="line">         * 处理UI</span><br><span class="line">         */</span></span><br><span class="line">    	<span class="comment">// 当收到消息时就会执行这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2） 判断网络连接是否可用</strong></p>
<p>如果在没有可用网络的情况下执行网络爬虫程序，App将会报错。所以在每次执行之前都应该先判断网络是否可用。大致步骤如下：</p>
<p>① 获取ConnectivityManager对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Context context = activity.getApplicationContext();</span><br><span class="line"><span class="comment">// 获取手机所有连接管理对象（包括对wi-fi,net等连接的管理）</span></span><br><span class="line">ConnectivityManager cm = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br></pre></td></tr></table></figure></p>
<p>② 获取NetworkInfo对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkInfo info = cm.getActiveNetworkInfo();</span><br></pre></td></tr></table></figure></p>
<p>③ 判断网络类型，Android的网络分为两大类：WIFI 和 手机网络<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WIFI 判定条件</span></span><br><span class="line">info != <span class="keyword">null</span> &amp;&amp; info.getType() == ConnectivityManager.TYPE_WIFI</span><br><span class="line"><span class="comment">// 手机网络 判定条件</span></span><br><span class="line">info !=<span class="keyword">null</span> &amp;&amp; info.getType() ==  ConnectivityManager.TYPE_MOBILE</span><br></pre></td></tr></table></figure></p>
<p>而手机网络具体又分为很多类，比如移动3G、移动2G、联通2G等等。这里就不说了，自行Google。</p>
<p>④ 判断网络连接是否可用（包括所有网络类型）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNetworkAvailable</span><span class="params">(Activity activity)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Context context = activity.getApplicationContext();</span><br><span class="line">    ConnectivityManager cm = (ConnectivityManager) </span><br><span class="line">    		context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cm == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 获取所有NetworkInfo对象</span></span><br><span class="line">        NetworkInfo[] networkInfo = cm.getAllNetworkInfo();</span><br><span class="line">        <span class="keyword">if</span> (networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; networkInfo.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (networkInfo[i].getState() == NetworkInfo.State.CONNECTED)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 存在可用的网络连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，要在 AndroidManifest.xml 文件中添加访问网络状态的权限：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p><br><br>另外，本程序在 UI 界面开发上涉及到 Android 中的 ListView（显示）、PopupWindow（菜单）、ProgressDialog（加载）、AlertDialog（提示）等控件的使用。因为本文并不是讨论 Android 控件的使用，在这里就不赘述了。</p>
<p><img src="http://img.blog.csdn.net/20150124232559703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>源码下载：</strong><a href="https://github.com/SongLee24/android-crawler" target="_blank" rel="external">https://github.com/SongLee24/android-crawler</a></p>
<p><br><br><br><br><br><br>（全文完）<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘要：基于 Jsoup 实现一个 Android 的网络爬虫程序，抓取网页的内容并显示出来。写这个程序的主要目的是抓取<a href="http://xjh.haitou.cc/">海投网</a>的宣讲会信息（公司、时间、地点）并在移动端显示，这样就可以随时随地的浏览在学校举办的宣讲会信息了。</p>
<h3 id="一、Jsoup简介">一、Jsoup简介</h3><p><a href="http://jsoup.org/">Jsoup</a> 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常方便的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>Jsoup主要有以下功能：]]>
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="System-Android" scheme="http://yoursite.com/categories/System-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AES加密算法的C++实现]]></title>
    <link href="http://yoursite.com/2014/12/13/aes-encrypt/"/>
    <id>http://yoursite.com/2014/12/13/aes-encrypt/</id>
    <published>2014-12-13T06:47:48.000Z</published>
    <updated>2015-05-10T10:47:59.945Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要：</strong>作为新一代的加密标准，AES 旨在取代 DES（请看《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external">DES加密算法的C++实现</a>》），以适应当今分布式开放网络对数据加密安全性的要求。本文在分析了 AES 加密原理的基础上着重说明了算法实现的具体步骤，并用 C++ 实现了对文件的加密和解密。</p>
<h1 id="一、AES_介绍">一、AES 介绍</h1><p><strong>AES（高级加密标准，Advanced Encryption Standard）</strong>，在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种分组加密标准。这个标准用来替代原先的 DES，目前已经广为全世界所使用，成为对称密钥算法中最流行的算法之一。<a id="more"></a></p>
<p>在 AES 出现之前，最常用的对称密钥算法是 <a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external"><strong>DES 加密算法</strong></a>，它在 1977 年被公布成为美国政府的商用加密标准。DES 的主要问题是密钥长度较短，渐渐不适合于分布式开放网络对数据加密安全性的要求。因此，1998年美国政府决定不再继续延用 DES 作为联邦加密标准，并发起了征集 AES 候选算法的活动。征集活动对 AES 的基本要求是： 比三重DES快、至少与三重DES一样安全、数据分组长度为128比特、密钥长度为128/192/256比特。</p>
<p>经过三年多的甄选，比利时的密码学家所设计的 Rijndael 算法最终脱颖而出，成为新一代的高级加密标准，并于 2001 年由美国国家标准与技术研究院（NIST）发布于 <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf" target="_blank" rel="external">FIPS PUB 197</a>。</p>
<h1 id="二、AES_算法原理">二、AES 算法原理</h1><p>AES算法（即 Rijndael 算法）是一个对称分组密码算法。数据分组长度必须是 <strong>128 bits</strong>，使用的密钥长度为 <strong>128，192</strong> 或 <strong>256 bits</strong>。对于三种不同密钥长度的 AES 算法，分别称为<strong>“AES-128”、“AES-192”、“AES-256”</strong>。（Rijndael 的设计还可以处理其它的分组长度和密钥长度，但 AES 标准中没有采用）</p>
<p>下图是 AES 加密解密的整体流程图：</p>
<p><img src="http://img.blog.csdn.net/20141213142652421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>这里我们需要知道3个符号：<code>Nb</code>—— 状态 State 包含的列（32-bit 字）的个数，也就是说 Nb=4；<code>Nk</code>—— 密钥包含的 32-bit 字的个数，也就是说 Nk=4，6 或 8；<code>Nr</code>—— 加密的轮数，对于不同密钥长度，轮数不一样，具体如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20141213142619522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>下面分为密钥扩展、分组加密、分组解密三个部分来讲 AES 算法，我会尽可能地简明扼要，若还有不懂的，请自行 Google。</p>
<h2 id="1）密钥扩展">1）密钥扩展</h2><p>AES 算法通过密钥扩展程序（Key Expansion）将用户输入的密钥 K 扩展生成 <code>Nb(Nr+1)</code>个字，存放在一个线性数组<code>w[Nb*(Nr+1)]</code>中。具体如下：</p>
<ol>
<li><p>位置变换函数<code>RotWord()</code>，接受一个字 [a0, a1, a2, a3] 作为输入，循环左移一个字节后输出 [a1, a2, a3, a0]。</p>
</li>
<li><p>S盒变换函数<code>SubWord()</code>，接受一个字 [a0, a1, a2, a3] 作为输入。S盒是一个16x16的表，其中每一个元素是一个字节。对于输入的每一个字节，前四位组成十六进制数 x 作为行号，后四位组成的十六进制数 y 作为列号，查找表中对应的值。最后函数输出 4 个新字节组成的 32-bit 字。</p>
</li>
<li><p>轮常数<code>Rcon[]</code>，如何计算的就不说了，直接把它当做常量数组。</p>
</li>
<li><p>扩展密钥数组<code>w[]</code>的前 Nk 个元素就是外部密钥 K，以后的元素<code>w[i]</code>等于它前一个元素<code>w[i-1]</code>与前第 Nk 个元素<code>w[i-Nk]</code>的异或，即<code>w[i] = w[i-1] XOR w[i-Nk]</code>；但若 i 为 Nk 的倍数，则<code>w[i] = w[i-Nk] XOR SubWord(RotWord(w[i-1])) XOR Rcon[i/Nk-1]</code>。</p>
</li>
</ol>
<p>注意，上面的第四步说明适合于 AES-128 和 AES-192，详细的伪代码如下：</p>
<p><img src="http://img.blog.csdn.net/20141213142747609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>密钥扩展程序的 C++ 代码（AES-128）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bitset&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;8&gt; byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;32&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nr = <span class="number">10</span>;  <span class="comment">// AES-128需要 10 轮加密</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nk = <span class="number">4</span>;   <span class="comment">// Nk 表示输入密钥的 word 个数</span></span><br><span class="line"></span><br><span class="line">byte S_Box[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>,</span><br><span class="line">	 <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>, <span class="number">0x76</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, </span><br><span class="line">	 <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>, <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, </span><br><span class="line">	 <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>, <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>, </span><br><span class="line">	 <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, </span><br><span class="line">	 <span class="number">0x52</span>, <span class="number">0x3B</span>, <span class="number">0xD6</span>, <span class="number">0xB3</span>, <span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, </span><br><span class="line">	 <span class="number">0x6A</span>, <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>, <span class="number">0xCF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, </span><br><span class="line">	 <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x51</span>, <span class="number">0xA3</span>, <span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>, <span class="number">0x38</span>, <span class="number">0xF5</span>, </span><br><span class="line">	 <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, </span><br><span class="line">	 <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, </span><br><span class="line">	 <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, </span><br><span class="line">	 <span class="number">0xC2</span>, <span class="number">0xD3</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>, <span class="number">0x79</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, </span><br><span class="line">	 <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>, <span class="number">0x65</span>, <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, </span><br><span class="line">	 <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, </span><br><span class="line">	 <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE1</span>, <span class="number">0xF8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>, </span><br><span class="line">	 <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>, <span class="number">0xE6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, </span><br><span class="line">	 <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮常数，密钥扩展中用到。（AES-128只需要10轮）</span></span><br><span class="line">word Rcon[<span class="number">10</span>] = &#123;<span class="number">0x01000000</span>, <span class="number">0x02000000</span>, <span class="number">0x04000000</span>, <span class="number">0x08000000</span>, <span class="number">0x10000000</span>, </span><br><span class="line">				 <span class="number">0x20000000</span>, <span class="number">0x40000000</span>, <span class="number">0x80000000</span>, <span class="number">0x1b000000</span>, <span class="number">0x36000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将4个 byte 转换为一个 word.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">Word</span><span class="params">(byte&amp; k1, byte&amp; k2, byte&amp; k3, byte&amp; k4)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">word <span class="title">result</span><span class="params">(0x00000000)</span></span>;</span><br><span class="line">	word temp;</span><br><span class="line">	temp = k1.to_ulong();  <span class="comment">// K1</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">24</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k2.to_ulong();  <span class="comment">// K2</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k3.to_ulong();  <span class="comment">// K3</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k4.to_ulong();  <span class="comment">// K4</span></span><br><span class="line">	result |= temp;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  按字节 循环左移一位</span><br><span class="line"> *  即把[a0, a1, a2, a3]变成[a1, a2, a3, a0]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">RotWord</span><span class="params">(word&amp; rw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word high = rw &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	word low = rw &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	<span class="keyword">return</span> high | low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  对输入word中的每一个字节进行S-盒变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">SubWord</span><span class="params">(word&amp; sw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i+=<span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = sw[i+<span class="number">7</span>]*<span class="number">8</span> + sw[i+<span class="number">6</span>]*<span class="number">4</span> + sw[i+<span class="number">5</span>]*<span class="number">2</span> + sw[i+<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = sw[i+<span class="number">3</span>]*<span class="number">8</span> + sw[i+<span class="number">2</span>]*<span class="number">4</span> + sw[i+<span class="number">1</span>]*<span class="number">2</span> + sw[i];</span><br><span class="line">		byte val = S_Box[row][col];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)</span><br><span class="line">			temp[i+j] = val[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1)]</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyExpansion</span><span class="params">(byte key[4*Nk], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// w[]的前4个就是输入的key</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; Nk) </span><br><span class="line">	&#123;</span><br><span class="line">		w[i] = Word(key[<span class="number">4</span>*i], key[<span class="number">4</span>*i+<span class="number">1</span>], key[<span class="number">4</span>*i+<span class="number">2</span>], key[<span class="number">4</span>*i+<span class="number">3</span>]);</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = Nk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">4</span>*(Nr+<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		temp = w[i-<span class="number">1</span>]; <span class="comment">// 记录前一个word</span></span><br><span class="line">		<span class="keyword">if</span>(i % Nk == <span class="number">0</span>)</span><br><span class="line">			w[i] = w[i-Nk] ^ SubWord(RotWord(temp)) ^ Rcon[i/Nk-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			w[i] = w[i-Nk] ^ temp;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte key[<span class="number">16</span>] = &#123;<span class="number">0x2b</span>, <span class="number">0x7e</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, </span><br><span class="line">				    <span class="number">0x28</span>, <span class="number">0xae</span>, <span class="number">0xd2</span>, <span class="number">0xa6</span>, </span><br><span class="line">				    <span class="number">0xab</span>, <span class="number">0xf7</span>, <span class="number">0x15</span>, <span class="number">0x88</span>, </span><br><span class="line">				    <span class="number">0x09</span>, <span class="number">0xcf</span>, <span class="number">0x4f</span>, <span class="number">0x3c</span>&#125;;</span><br><span class="line"></span><br><span class="line">	word w[<span class="number">4</span>*(Nr+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"KEY IS: "</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; key[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	KeyExpansion(key, w);</span><br><span class="line">	<span class="comment">// 测试</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>*(Nr+<span class="number">1</span>); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"w["</span> &lt;&lt; dec &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; hex &lt;&lt; w[i].to_ulong() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试输出结果：</p>
<p><img src="http://img.blog.csdn.net/20141213143023031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="2）加密">2）加密</h2><p>根据 AES 加密的整体流程图（本文开头），可以得出伪代码如下：</p>
<p><img src="http://img.blog.csdn.net/20141213143008999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从伪代码描述中可以看出，AES 加密时涉及到的子程序有<code>SubBytes()</code>、<code>ShiftRows()</code>、<code>MixColumns()</code>和<code>AddRoundKey()</code>。下面我们一个一个进行介绍：</p>
<h3 id="①_S盒变换-SubBytes()">① S盒变换-SubBytes()</h3><p>在密钥扩展部分已经讲过了，S盒是一个 16 行 16 列的表，表中每个元素都是一个字节。S盒变换很简单：函数<code>SubBytes()</code>接受一个 4x4 的字节矩阵作为输入，对其中的每个字节，前四位组成十六进制数 x 作为行号，后四位组成的十六进制数 y 作为列号，查找表中对应的值替换原来位置上的字节。</p>
<h3 id="②_行变换-ShiftRows()">② 行变换-ShiftRows()</h3><p>行变换也很简单，它仅仅是将矩阵的每一行以字节为单位<strong>循环移位</strong>：第一行不变，第二行左移一位，第三行左移两位，第四行左移三位。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20141213143028998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="③_列变换-MixColumns()">③ 列变换-MixColumns()</h3><p>函数<code>MixColumns()</code>同样接受一个 4x4 的字节矩阵作为输入，并对矩阵进行逐列变换，变换方式如下：</p>
<p><img src="http://img.blog.csdn.net/20141213143045019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>注意公式中用到的乘法是<a href="http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplication" target="_blank" rel="external">伽罗华域（GF，有限域）上的乘法</a>，高级加密标准文档 <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf" target="_blank" rel="external">fips-197</a> 上有讲，如果还是不懂，请自行Google。</p>
<p><img src="http://img.blog.csdn.net/20141213143147796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="④_与扩展密钥的异或-AddRoundKey()">④ 与扩展密钥的异或-AddRoundKey()</h3><p>扩展密钥只参与了这一步。根据当前加密的轮数，用<code>w[]</code>中的 4 个扩展密钥与矩阵的 4 个列进行按位异或。如下图：</p>
<p><img src="http://img.blog.csdn.net/20141213143206703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>好了，到这里 AES 加密的各个部分就讲完了。算法实现的 C++ 源码在文章后面第三部分。</p>
<h2 id="3）解密">3）解密</h2><p>根据 AES 解密的整体流程图（本文开头），可以得出伪代码如下：</p>
<p><img src="http://img.blog.csdn.net/20141213143139307?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从伪代码可以看出，我们需要分别实现 S 盒变换、行变换和列变换的逆变换<code>InvShiftRows()</code>、<code>InvSubBytes()</code>和<code>InvMixColumns()</code>。下面就简单的讲一下这三个逆变换：</p>
<h3 id="①_逆行变换-InvShiftRows()">① 逆行变换-InvShiftRows()</h3><p>上面讲到<code>ShiftRows()</code>是对矩阵的每一行进行循环左移，所以<code>InvShiftRows()</code>是对矩阵每一行进行循环右移。</p>
<p><img src="http://img.blog.csdn.net/20141213143154611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="②_逆_S_盒变换-InvSubBytes()">② 逆 S 盒变换-InvSubBytes()</h3><p>与 S 盒变换一样，也是查表，查表的方式也一样，只不过查的是另外一个置换表（S-Box的逆表）。</p>
<h3 id="③_逆列变换-InvMixColumns()">③ 逆列变换-InvMixColumns()</h3><p>与列变换的方式一样，只不过计算公式的系数矩阵发生了变化。如下图：</p>
<p><img src="http://img.blog.csdn.net/20141213143306000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>好了，AES 解密到这里也讲完了。只要写出三个逆变换的函数，然后根据伪代码就很容易实现 AES 解密算法了。</p>
<h1 id="三、C++实现">三、C++实现</h1><p>下面我用 C++ 实现 AES 的加密和解密算法，并实现了对文件的加密和解密。这里我使用 C++ STL 的<code>bitset</code>定义了两个类型：<code>byte</code>和<code>word</code>。需要提到的是，对于有限域上的乘法，我们既可以通过查表（6个结果表），也可以写一个函数来实现。当然，查表的效率会更高，但考虑到贴代码，这里我就用一个函数来实现的。</p>
<p>下面是 AES-128 对一个 128 位数据加密和解密的源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************  </span><br><span class="line">    &gt; File Name: AES.cpp </span><br><span class="line">    &gt; Author: SongLee  </span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com  </span><br><span class="line">    &gt; Created Time: 2014年12月12日 星期五 20时15分50秒  </span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com  </span><br><span class="line"> ************************************************************************/</span> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;8&gt; byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;32&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nr = <span class="number">10</span>;  <span class="comment">// AES-128需要 10 轮加密</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nk = <span class="number">4</span>;   <span class="comment">// Nk 表示输入密钥的 word 个数</span></span><br><span class="line"></span><br><span class="line">byte S_Box[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>, </span><br><span class="line">	 <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>, <span class="number">0x76</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, </span><br><span class="line">	 <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>, <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, </span><br><span class="line">	 <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>, <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>, </span><br><span class="line">	 <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, </span><br><span class="line">	 <span class="number">0x52</span>, <span class="number">0x3B</span>, <span class="number">0xD6</span>, <span class="number">0xB3</span>, <span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, </span><br><span class="line">	 <span class="number">0x6A</span>, <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>, <span class="number">0xCF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, </span><br><span class="line">	 <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x51</span>, <span class="number">0xA3</span>, <span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>, <span class="number">0x38</span>, <span class="number">0xF5</span>, </span><br><span class="line">	 <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, </span><br><span class="line">	 <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, </span><br><span class="line">	 <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, </span><br><span class="line">	 <span class="number">0xC2</span>, <span class="number">0xD3</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>, <span class="number">0x79</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, </span><br><span class="line">	 <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>, <span class="number">0x65</span>, <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, </span><br><span class="line">	 <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, </span><br><span class="line">	 <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE1</span>, <span class="number">0xF8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>, </span><br><span class="line">	 <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>, <span class="number">0xE6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, </span><br><span class="line">	 <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">byte Inv_S_Box[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x52</span>, <span class="number">0x09</span>, <span class="number">0x6A</span>, <span class="number">0xD5</span>, <span class="number">0x30</span>, <span class="number">0x36</span>, <span class="number">0xA5</span>, <span class="number">0x38</span>, </span><br><span class="line">	 <span class="number">0xBF</span>, <span class="number">0x40</span>, <span class="number">0xA3</span>, <span class="number">0x9E</span>, <span class="number">0x81</span>, <span class="number">0xF3</span>, <span class="number">0xD7</span>, <span class="number">0xFB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x7C</span>, <span class="number">0xE3</span>, <span class="number">0x39</span>, <span class="number">0x82</span>, <span class="number">0x9B</span>, <span class="number">0x2F</span>, <span class="number">0xFF</span>, <span class="number">0x87</span>, </span><br><span class="line">	 <span class="number">0x34</span>, <span class="number">0x8E</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0xC4</span>, <span class="number">0xDE</span>, <span class="number">0xE9</span>, <span class="number">0xCB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x54</span>, <span class="number">0x7B</span>, <span class="number">0x94</span>, <span class="number">0x32</span>, <span class="number">0xA6</span>, <span class="number">0xC2</span>, <span class="number">0x23</span>, <span class="number">0x3D</span>, </span><br><span class="line">	 <span class="number">0xEE</span>, <span class="number">0x4C</span>, <span class="number">0x95</span>, <span class="number">0x0B</span>, <span class="number">0x42</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x4E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x08</span>, <span class="number">0x2E</span>, <span class="number">0xA1</span>, <span class="number">0x66</span>, <span class="number">0x28</span>, <span class="number">0xD9</span>, <span class="number">0x24</span>, <span class="number">0xB2</span>, </span><br><span class="line">	 <span class="number">0x76</span>, <span class="number">0x5B</span>, <span class="number">0xA2</span>, <span class="number">0x49</span>, <span class="number">0x6D</span>, <span class="number">0x8B</span>, <span class="number">0xD1</span>, <span class="number">0x25</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x72</span>, <span class="number">0xF8</span>, <span class="number">0xF6</span>, <span class="number">0x64</span>, <span class="number">0x86</span>, <span class="number">0x68</span>, <span class="number">0x98</span>, <span class="number">0x16</span>, </span><br><span class="line">	 <span class="number">0xD4</span>, <span class="number">0xA4</span>, <span class="number">0x5C</span>, <span class="number">0xCC</span>, <span class="number">0x5D</span>, <span class="number">0x65</span>, <span class="number">0xB6</span>, <span class="number">0x92</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x6C</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x50</span>, <span class="number">0xFD</span>, <span class="number">0xED</span>, <span class="number">0xB9</span>, <span class="number">0xDA</span>, </span><br><span class="line">	 <span class="number">0x5E</span>, <span class="number">0x15</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0xA7</span>, <span class="number">0x8D</span>, <span class="number">0x9D</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x90</span>, <span class="number">0xD8</span>, <span class="number">0xAB</span>, <span class="number">0x00</span>, <span class="number">0x8C</span>, <span class="number">0xBC</span>, <span class="number">0xD3</span>, <span class="number">0x0A</span>, </span><br><span class="line">	 <span class="number">0xF7</span>, <span class="number">0xE4</span>, <span class="number">0x58</span>, <span class="number">0x05</span>, <span class="number">0xB8</span>, <span class="number">0xB3</span>, <span class="number">0x45</span>, <span class="number">0x06</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xD0</span>, <span class="number">0x2C</span>, <span class="number">0x1E</span>, <span class="number">0x8F</span>, <span class="number">0xCA</span>, <span class="number">0x3F</span>, <span class="number">0x0F</span>, <span class="number">0x02</span>, </span><br><span class="line">	 <span class="number">0xC1</span>, <span class="number">0xAF</span>, <span class="number">0xBD</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x13</span>, <span class="number">0x8A</span>, <span class="number">0x6B</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x3A</span>, <span class="number">0x91</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0x4F</span>, <span class="number">0x67</span>, <span class="number">0xDC</span>, <span class="number">0xEA</span>, </span><br><span class="line">	 <span class="number">0x97</span>, <span class="number">0xF2</span>, <span class="number">0xCF</span>, <span class="number">0xCE</span>, <span class="number">0xF0</span>, <span class="number">0xB4</span>, <span class="number">0xE6</span>, <span class="number">0x73</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x96</span>, <span class="number">0xAC</span>, <span class="number">0x74</span>, <span class="number">0x22</span>, <span class="number">0xE7</span>, <span class="number">0xAD</span>, <span class="number">0x35</span>, <span class="number">0x85</span>, </span><br><span class="line">	 <span class="number">0xE2</span>, <span class="number">0xF9</span>, <span class="number">0x37</span>, <span class="number">0xE8</span>, <span class="number">0x1C</span>, <span class="number">0x75</span>, <span class="number">0xDF</span>, <span class="number">0x6E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x47</span>, <span class="number">0xF1</span>, <span class="number">0x1A</span>, <span class="number">0x71</span>, <span class="number">0x1D</span>, <span class="number">0x29</span>, <span class="number">0xC5</span>, <span class="number">0x89</span>, </span><br><span class="line">	 <span class="number">0x6F</span>, <span class="number">0xB7</span>, <span class="number">0x62</span>, <span class="number">0x0E</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0xBE</span>, <span class="number">0x1B</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xFC</span>, <span class="number">0x56</span>, <span class="number">0x3E</span>, <span class="number">0x4B</span>, <span class="number">0xC6</span>, <span class="number">0xD2</span>, <span class="number">0x79</span>, <span class="number">0x20</span>, </span><br><span class="line">	 <span class="number">0x9A</span>, <span class="number">0xDB</span>, <span class="number">0xC0</span>, <span class="number">0xFE</span>, <span class="number">0x78</span>, <span class="number">0xCD</span>, <span class="number">0x5A</span>, <span class="number">0xF4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x1F</span>, <span class="number">0xDD</span>, <span class="number">0xA8</span>, <span class="number">0x33</span>, <span class="number">0x88</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x31</span>, </span><br><span class="line">	 <span class="number">0xB1</span>, <span class="number">0x12</span>, <span class="number">0x10</span>, <span class="number">0x59</span>, <span class="number">0x27</span>, <span class="number">0x80</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x60</span>, <span class="number">0x51</span>, <span class="number">0x7F</span>, <span class="number">0xA9</span>, <span class="number">0x19</span>, <span class="number">0xB5</span>, <span class="number">0x4A</span>, <span class="number">0x0D</span>, </span><br><span class="line">	 <span class="number">0x2D</span>, <span class="number">0xE5</span>, <span class="number">0x7A</span>, <span class="number">0x9F</span>, <span class="number">0x93</span>, <span class="number">0xC9</span>, <span class="number">0x9C</span>, <span class="number">0xEF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xA0</span>, <span class="number">0xE0</span>, <span class="number">0x3B</span>, <span class="number">0x4D</span>, <span class="number">0xAE</span>, <span class="number">0x2A</span>, <span class="number">0xF5</span>, <span class="number">0xB0</span>, </span><br><span class="line">	 <span class="number">0xC8</span>, <span class="number">0xEB</span>, <span class="number">0xBB</span>, <span class="number">0x3C</span>, <span class="number">0x83</span>, <span class="number">0x53</span>, <span class="number">0x99</span>, <span class="number">0x61</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x17</span>, <span class="number">0x2B</span>, <span class="number">0x04</span>, <span class="number">0x7E</span>, <span class="number">0xBA</span>, <span class="number">0x77</span>, <span class="number">0xD6</span>, <span class="number">0x26</span>, </span><br><span class="line">	 <span class="number">0xE1</span>, <span class="number">0x69</span>, <span class="number">0x14</span>, <span class="number">0x63</span>, <span class="number">0x55</span>, <span class="number">0x21</span>, <span class="number">0x0C</span>, <span class="number">0x7D</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮常数，密钥扩展中用到。（AES-128只需要10轮）</span></span><br><span class="line">word Rcon[<span class="number">10</span>] = &#123;<span class="number">0x01000000</span>, <span class="number">0x02000000</span>, <span class="number">0x04000000</span>, <span class="number">0x08000000</span>, <span class="number">0x10000000</span>, </span><br><span class="line">				 <span class="number">0x20000000</span>, <span class="number">0x40000000</span>, <span class="number">0x80000000</span>, <span class="number">0x1b000000</span>, <span class="number">0x36000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/*                              AES算法实现                           */</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/**********************************************************************/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************下面是加密的变换函数**********************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  S盒变换 - 前4位为行号，后4位为列号</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SubBytes</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = mtx[i][<span class="number">7</span>]*<span class="number">8</span> + mtx[i][<span class="number">6</span>]*<span class="number">4</span> + mtx[i][<span class="number">5</span>]*<span class="number">2</span> + mtx[i][<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = mtx[i][<span class="number">3</span>]*<span class="number">8</span> + mtx[i][<span class="number">2</span>]*<span class="number">4</span> + mtx[i][<span class="number">1</span>]*<span class="number">2</span> + mtx[i][<span class="number">0</span>];</span><br><span class="line">		mtx[i] = S_Box[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  行变换 - 按字节循环移位</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShiftRows</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 第二行循环左移一位</span></span><br><span class="line">	byte temp = mtx[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		mtx[i+<span class="number">4</span>] = mtx[i+<span class="number">5</span>];</span><br><span class="line">	mtx[<span class="number">7</span>] = temp;</span><br><span class="line">	<span class="comment">// 第三行循环左移两位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = mtx[i+<span class="number">8</span>];</span><br><span class="line">		mtx[i+<span class="number">8</span>] = mtx[i+<span class="number">10</span>];</span><br><span class="line">		mtx[i+<span class="number">10</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四行循环左移三位</span></span><br><span class="line">	temp = mtx[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		mtx[i+<span class="number">12</span>] = mtx[i+<span class="number">11</span>];</span><br><span class="line">	mtx[<span class="number">12</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  有限域上的乘法 GF(2^8)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">byte <span class="title">GFMul</span><span class="params">(byte a, byte b)</span> </span>&#123; </span><br><span class="line">	byte p = <span class="number">0</span>;</span><br><span class="line">	byte hi_bit_set;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">8</span>; counter++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((b &amp; byte(<span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">			p ^= a;</span><br><span class="line">		&#125;</span><br><span class="line">		hi_bit_set = (byte) (a &amp; byte(<span class="number">0x80</span>));</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (hi_bit_set != <span class="number">0</span>) &#123;</span><br><span class="line">			a ^= <span class="number">0x1b</span>; <span class="comment">/* x^8 + x^4 + x^3 + x + 1 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  列变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MixColumns</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte arr[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)</span><br><span class="line">			arr[j] = mtx[i+j*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">		mtx[i] = GFMul(<span class="number">0x02</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x03</span>, arr[<span class="number">1</span>]) ^ arr[<span class="number">2</span>] ^ arr[<span class="number">3</span>];</span><br><span class="line">		mtx[i+<span class="number">4</span>] = arr[<span class="number">0</span>] ^ GFMul(<span class="number">0x02</span>, arr[<span class="number">1</span>]) ^ GFMul(<span class="number">0x03</span>, arr[<span class="number">2</span>]) ^ arr[<span class="number">3</span>];</span><br><span class="line">		mtx[i+<span class="number">8</span>] = arr[<span class="number">0</span>] ^ arr[<span class="number">1</span>] ^ GFMul(<span class="number">0x02</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x03</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">12</span>] = GFMul(<span class="number">0x03</span>, arr[<span class="number">0</span>]) ^ arr[<span class="number">1</span>] ^ arr[<span class="number">2</span>] ^ GFMul(<span class="number">0x02</span>, arr[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  轮密钥加变换 - 将每一列与扩展密钥进行异或</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRoundKey</span><span class="params">(byte mtx[4*4], word k[4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		word k1 = k[i] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		word k2 = (k[i] &lt;&lt; <span class="number">8</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		word k3 = (k[i] &lt;&lt; <span class="number">16</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		word k4 = (k[i] &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		</span><br><span class="line">		mtx[i] = mtx[i] ^ byte(k1.to_ulong());</span><br><span class="line">		mtx[i+<span class="number">4</span>] = mtx[i+<span class="number">4</span>] ^ byte(k2.to_ulong());</span><br><span class="line">		mtx[i+<span class="number">8</span>] = mtx[i+<span class="number">8</span>] ^ byte(k3.to_ulong());</span><br><span class="line">		mtx[i+<span class="number">12</span>] = mtx[i+<span class="number">12</span>] ^ byte(k4.to_ulong());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************下面是解密的逆变换函数***********************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  逆S盒变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvSubBytes</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = mtx[i][<span class="number">7</span>]*<span class="number">8</span> + mtx[i][<span class="number">6</span>]*<span class="number">4</span> + mtx[i][<span class="number">5</span>]*<span class="number">2</span> + mtx[i][<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = mtx[i][<span class="number">3</span>]*<span class="number">8</span> + mtx[i][<span class="number">2</span>]*<span class="number">4</span> + mtx[i][<span class="number">1</span>]*<span class="number">2</span> + mtx[i][<span class="number">0</span>];</span><br><span class="line">		mtx[i] = Inv_S_Box[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  逆行变换 - 以字节为单位循环右移</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvShiftRows</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 第二行循环右移一位</span></span><br><span class="line">	byte temp = mtx[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		mtx[i+<span class="number">4</span>] = mtx[i+<span class="number">3</span>];</span><br><span class="line">	mtx[<span class="number">4</span>] = temp;</span><br><span class="line">	<span class="comment">// 第三行循环右移两位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = mtx[i+<span class="number">8</span>];</span><br><span class="line">		mtx[i+<span class="number">8</span>] = mtx[i+<span class="number">10</span>];</span><br><span class="line">		mtx[i+<span class="number">10</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四行循环右移三位</span></span><br><span class="line">	temp = mtx[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		mtx[i+<span class="number">12</span>] = mtx[i+<span class="number">13</span>];</span><br><span class="line">	mtx[<span class="number">15</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvMixColumns</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte arr[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)</span><br><span class="line">			arr[j] = mtx[i+j*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">		mtx[i] = GFMul(<span class="number">0x0e</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x0b</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x0d</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x09</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">4</span>] = GFMul(<span class="number">0x09</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x0e</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x0b</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x0d</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">8</span>] = GFMul(<span class="number">0x0d</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x09</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x0e</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x0b</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">12</span>] = GFMul(<span class="number">0x0b</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x0d</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x09</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x0e</span>, arr[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************下面是密钥扩展部分***********************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将4个 byte 转换为一个 word.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">Word</span><span class="params">(byte&amp; k1, byte&amp; k2, byte&amp; k3, byte&amp; k4)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">word <span class="title">result</span><span class="params">(0x00000000)</span></span>;</span><br><span class="line">	word temp;</span><br><span class="line">	temp = k1.to_ulong();  <span class="comment">// K1</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">24</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k2.to_ulong();  <span class="comment">// K2</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k3.to_ulong();  <span class="comment">// K3</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k4.to_ulong();  <span class="comment">// K4</span></span><br><span class="line">	result |= temp;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  按字节 循环左移一位</span><br><span class="line"> *  即把[a0, a1, a2, a3]变成[a1, a2, a3, a0]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">RotWord</span><span class="params">(word&amp; rw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word high = rw &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	word low = rw &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	<span class="keyword">return</span> high | low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  对输入word中的每一个字节进行S-盒变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">SubWord</span><span class="params">(word&amp; sw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i+=<span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = sw[i+<span class="number">7</span>]*<span class="number">8</span> + sw[i+<span class="number">6</span>]*<span class="number">4</span> + sw[i+<span class="number">5</span>]*<span class="number">2</span> + sw[i+<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = sw[i+<span class="number">3</span>]*<span class="number">8</span> + sw[i+<span class="number">2</span>]*<span class="number">4</span> + sw[i+<span class="number">1</span>]*<span class="number">2</span> + sw[i];</span><br><span class="line">		byte val = S_Box[row][col];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)</span><br><span class="line">			temp[i+j] = val[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1)]</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyExpansion</span><span class="params">(byte key[4*Nk], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// w[]的前4个就是输入的key</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; Nk) </span><br><span class="line">	&#123;</span><br><span class="line">		w[i] = Word(key[<span class="number">4</span>*i], key[<span class="number">4</span>*i+<span class="number">1</span>], key[<span class="number">4</span>*i+<span class="number">2</span>], key[<span class="number">4</span>*i+<span class="number">3</span>]);</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = Nk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">4</span>*(Nr+<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		temp = w[i-<span class="number">1</span>]; <span class="comment">// 记录前一个word</span></span><br><span class="line">		<span class="keyword">if</span>(i % Nk == <span class="number">0</span>)</span><br><span class="line">			w[i] = w[i-Nk] ^ SubWord(RotWord(temp)) ^ Rcon[i/Nk-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			w[i] = w[i-Nk] ^ temp;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************下面是加密和解密函数**************************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  加密</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(byte in[4*4], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word key[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">1</span>; round&lt;Nr; ++round)</span><br><span class="line">	&#123;</span><br><span class="line">		SubBytes(in);</span><br><span class="line">		ShiftRows(in);</span><br><span class="line">		MixColumns(in);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">			key[i] = w[<span class="number">4</span>*round+i];</span><br><span class="line">		AddRoundKey(in, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubBytes(in);</span><br><span class="line">	ShiftRows(in);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[<span class="number">4</span>*Nr+i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  解密</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrypt</span><span class="params">(byte in[4*4], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word key[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[<span class="number">4</span>*Nr+i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=Nr-<span class="number">1</span>; round&gt;<span class="number">0</span>; --round)</span><br><span class="line">	&#123;</span><br><span class="line">		InvShiftRows(in);</span><br><span class="line">		InvSubBytes(in);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">			key[i] = w[<span class="number">4</span>*round+i];</span><br><span class="line">		AddRoundKey(in, key);</span><br><span class="line">		InvMixColumns(in);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	InvShiftRows(in);</span><br><span class="line">	InvSubBytes(in);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/*                              测试                                  */</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/**********************************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte key[<span class="number">16</span>] = &#123;<span class="number">0x2b</span>, <span class="number">0x7e</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, </span><br><span class="line">					<span class="number">0x28</span>, <span class="number">0xae</span>, <span class="number">0xd2</span>, <span class="number">0xa6</span>, </span><br><span class="line">					<span class="number">0xab</span>, <span class="number">0xf7</span>, <span class="number">0x15</span>, <span class="number">0x88</span>, </span><br><span class="line">					<span class="number">0x09</span>, <span class="number">0xcf</span>, <span class="number">0x4f</span>, <span class="number">0x3c</span>&#125;;</span><br><span class="line"></span><br><span class="line">	byte plain[<span class="number">16</span>] = &#123;<span class="number">0x32</span>, <span class="number">0x88</span>, <span class="number">0x31</span>, <span class="number">0xe0</span>, </span><br><span class="line">					<span class="number">0x43</span>, <span class="number">0x5a</span>, <span class="number">0x31</span>, <span class="number">0x37</span>,</span><br><span class="line">					<span class="number">0xf6</span>, <span class="number">0x30</span>, <span class="number">0x98</span>, <span class="number">0x07</span>,</span><br><span class="line">					<span class="number">0xa8</span>, <span class="number">0x8d</span>, <span class="number">0xa2</span>, <span class="number">0x34</span>&#125;; </span><br><span class="line">	<span class="comment">// 输出密钥</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"密钥是："</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; key[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	word w[<span class="number">4</span>*(Nr+<span class="number">1</span>)];</span><br><span class="line">	KeyExpansion(key, w);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出待加密的明文</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl &lt;&lt; <span class="string">"待加密的明文："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; plain[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加密，输出密文</span></span><br><span class="line">	encrypt(plain, w);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"加密后的密文："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; plain[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密，输出明文</span></span><br><span class="line">	decrypt(plain, w);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"解密后的明文："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; plain[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试用例如下图：</p>
<p><img src="http://img.blog.csdn.net/20141213143350269?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>测试结果截图：</p>
<p><img src="http://img.blog.csdn.net/20141213143411392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>可见，测试结果和预期输出相同，表明对数据的加密和解密成功！！！</p>
<p>下面我们来写 AES 对文件的加密和解密，在对 128 位的数据加解密成功以后，对文件的加解密就很简单了！只需要每次读 128 位，加密以后，将 128 位的密文写入另外一个文件…..如此循环，直到文件尾。下面是对一张图片进行 AES 加密和解密的测试代码（效率先不管了，有时间我再优化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;fstream&gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;8&gt; byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;32&gt; word;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  将一个char字符数组转化为二进制</span><br><span class="line"> *  存到一个 byte 数组中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charToByte</span><span class="params">(byte out[16], <span class="keyword">const</span> <span class="keyword">char</span> s[16])</span></span><br><span class="line"></span>&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)  </span><br><span class="line">			out[i][j]= ((s[i]&gt;&gt;j) &amp; <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  将连续的128位分成16组，存到一个 byte 数组中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divideToByte</span><span class="params">(byte out[16], <span class="built_in">bitset</span>&lt;128&gt;&amp; data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = (data &lt;&lt; <span class="number">8</span>*i) &gt;&gt; <span class="number">120</span>;</span><br><span class="line">		out[i] = temp.to_ulong();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  将16个 byte 合并成连续的128位</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;128&gt; mergeByte(byte in[<span class="number">16</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; res;</span><br><span class="line">	res.reset();  <span class="comment">// 置0</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = in[i].to_ulong();</span><br><span class="line">		temp &lt;&lt;= <span class="number">8</span>*(<span class="number">15</span>-i);</span><br><span class="line">		res |= temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> keyStr = <span class="string">"abcdefghijklmnop"</span>;</span><br><span class="line">	byte key[<span class="number">16</span>]; </span><br><span class="line">	charToByte(key, keyStr.c_str());</span><br><span class="line">	<span class="comment">// 密钥扩展</span></span><br><span class="line">	word w[<span class="number">4</span>*(Nr+<span class="number">1</span>)];</span><br><span class="line">	KeyExpansion(key, w);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; data;</span><br><span class="line">	byte plain[<span class="number">16</span>];</span><br><span class="line">	<span class="comment">// 将文件 flower.jpg 加密到 cipher.txt 中</span></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line">	in.open(<span class="string">"D://flower.jpg"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">	&#123;</span><br><span class="line">		divideToByte(plain, data);</span><br><span class="line">		encrypt(plain, w);</span><br><span class="line">		data = mergeByte(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">		data.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密 cipher.txt，并写入图片 flower1.jpg</span></span><br><span class="line">	in.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://flower1.jpg"</span>, ios::binary);</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">	&#123;</span><br><span class="line">		divideToByte(plain, data);</span><br><span class="line">		decrypt(plain, w);</span><br><span class="line">		data = mergeByte(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">		data.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（全文完）</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要：</strong>作为新一代的加密标准，AES 旨在取代 DES（请看《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">DES加密算法的C++实现</a>》），以适应当今分布式开放网络对数据加密安全性的要求。本文在分析了 AES 加密原理的基础上着重说明了算法实现的具体步骤，并用 C++ 实现了对文件的加密和解密。</p>
<h1 id="一、AES_介绍">一、AES 介绍</h1><p><strong>AES（高级加密标准，Advanced Encryption Standard）</strong>，在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种分组加密标准。这个标准用来替代原先的 DES，目前已经广为全世界所使用，成为对称密钥算法中最流行的算法之一。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DES加密算法的C++实现]]></title>
    <link href="http://yoursite.com/2014/12/06/des-encrypt/"/>
    <id>http://yoursite.com/2014/12/06/des-encrypt/</id>
    <published>2014-12-06T11:21:35.000Z</published>
    <updated>2015-05-10T10:38:47.474Z</updated>
    <content type="html"><![CDATA[<p>《信息安全技术》这门课又在讲 DES 加密算法了，以前用纯C写过一次，这次我用 C++ 重新写了一个，写篇文章以备后用。本文介绍了 DES 算法加密的大致步骤和整体流程。</p>
<h3 id="一、DES算法原理">一、DES算法原理</h3><p>DES算法是一种最通用的对称密钥算法，因为算法本身是公开的，所以其安全性在于密钥的安全性。基于密钥的算法通常有两类：<strong>对称算法</strong>和<strong>公开密钥算法</strong>。对称算法的对称性体现在加密密钥能够从解密密钥推算出来，反之亦然。在大多数对称算法中，加解密的密钥是相同的，DES就是这样。可见，对称密钥算法的加解密密钥都是保密的。而公开密钥算法的加密密钥是公开的，解密密钥是保密的。</p>
<p>下面是 DES 加密算法的整体流程图：<a id="more"></a></p>
<p><img src="http://img.blog.csdn.net/20141206183226328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从上面的流程图可以看出，DES加密主要由四个部分完成：</p>
<ol>
<li>初始置换 IP；</li>
<li><strong>子密钥 Ki 的获取；</strong></li>
<li><strong>密码函数 f ；</strong></li>
<li>尾置换 IP-1 ；</li>
</ol>
<p>其中，第二部分和第三部分是 DES 算法的核心。<strong>注意：</strong>DES 解密算法与加密算法完全相同，只需要将子密钥的使用顺序反过来就行了。</p>
<p>下面分别讲一下各个部分的大致思路。</p>
<h4 id="1）_初始置换IP">1） 初始置换IP</h4><p>这一部分很简单，IP（initial permutation）是一个 8x8 的置换表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> IP[] = &#123; <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">			 <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">			 <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">			 <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">			 <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line">			 <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">			 <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">			 <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>根据表中的规定，将输入的 64 位明文重新进行排序，即将第 58 位放到第 1 位，第 50 位放到第 2 位……以此类推。初始置换以后得到的是一个 64 位的输出。</p>
<h4 id="2）_子密钥_Ki_的获取">2） 子密钥 Ki 的获取</h4><p>下面是获取子密钥 Ki 的流程图：</p>
<p><img src="http://img.blog.csdn.net/20141206183416015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>流程图已经把思路很清楚的表达出来了，很简单：</p>
<ul>
<li><p>用户输出的密钥是 64 位的，根据密钥置换表<code>PC-1</code>，将 64 位变成 56 位密钥。（去掉了奇偶校验位）</p>
</li>
<li><p>将 PC-1 置换得到的 56 位密钥，分为前28位 C0 和后28位 D0，分别对它们进行<strong>循环左移</strong>，C0 左移得到 C1，D0 左移得到 D1。</p>
</li>
<li><p>将 C1 和 D1 合并成 56 位，然后通过<code>PC-2</code>表进行压缩置换，得到当前这一轮的 48 位子密钥 K1 。</p>
</li>
<li><p>然后对 C1 和 D1 进行左移和压缩置换，获取下一轮的子密钥……一共进行16轮，得到 16 个 48 位的子密钥。</p>
</li>
</ul>
<p>这部分需要用到的表 PC-1 和表 PC-2 如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 密钥置换表，将64位密钥变成56位</span></span><br><span class="line"><span class="keyword">int</span> PC_1[] = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">			   <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">			  <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">			  <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">			   <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">			  <span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩置换，将56位密钥压缩成48位子密钥</span></span><br><span class="line"><span class="keyword">int</span> PC_2[] = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line">			   <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">			  <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">			  <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">			  <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">			  <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">			  <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">			  <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每轮左移的位数</span></span><br><span class="line"><span class="keyword">int</span> shiftBits[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="3）_密码函数_f">3） 密码函数 f</h4><p>下面是密码函数<code>f(R, K)</code>的流程图：</p>
<p><img src="http://img.blog.csdn.net/20141206183524406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>密码函数<code>f(R, K)</code>接受两个输入：32 位的数据和 48 位的子密钥。然后：</p>
<ul>
<li><p>通过表 E 进行<strong>扩展置换</strong>，将输入的 32 位数据扩展为 48 位；</p>
</li>
<li><p>将扩展后的 48 位数据与 48 位的子密钥进行<strong>异或</strong>运算；</p>
</li>
<li><p>将异或得到的 48 位数据分成 8 个 6 位的块，每一个块通过对应的一个 S 表产生一个 4 位的输出。其中，每个 S 表都是 4 行 16 列。<strong>具体的置换过程如下：</strong>把 6 位输入中的第 1 位和第 6 位取出来行成一个两位的二进制数 x ，作为 Si 表中的行数（0~3）；把 6 位输入的中间 4 位构成另外一个二进制数 y，作为 Si 表的列数（0~15）；查出 Si 表中 x 行 y 列所对应的整数，将该整数转换为一个 4 位的二进制数。</p>
</li>
<li><p>把通过 S 表置换得到的 8 个 4 位连在一起，形成一个 32 位的数据。然后将该 32 位数据通过表 P 进行置换（称为P-置换），置换后得到一个仍然是 32 位的结果数据，这就是<code>f(R, K)</code>函数的输出。</p>
</li>
</ul>
<p>这部分用到了扩展置换表E，8个S表以及P-置换表，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展置换表，将 32位 扩展至 48位</span></span><br><span class="line"><span class="keyword">int</span> E[] = &#123;<span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">		    <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">		    <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">		   <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">		   <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">		   <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">		   <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S盒，每个S盒是4x16的置换表，6位 -&gt; 4位</span></span><br><span class="line"><span class="keyword">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P置换，32位 -&gt; 32位</span></span><br><span class="line"><span class="keyword">int</span> P[] = &#123;<span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">		    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">		    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">		    <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">		   <span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line">		   <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line">		   <span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="4）_尾置换IP-1">4） 尾置换IP-1</h4><p>合并 L16 和 R16 得到一个 64 位的数据，再经过尾置换后得到的就是 64 位的密文。注意：要将 L16 和 R16 合并成 R16L16（即左右互换）。尾置换表IP-1如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置换表</span></span><br><span class="line"><span class="keyword">int</span> IP_1[] = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">			  <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">			  <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">			  <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">			  <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">			  <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>OK！现在我们可以回到本文的开头，去看看 DES 算法的整体流程图，思路就已经很清楚了。</p>
<h3 id="二、C++实现">二、C++实现</h3><p>在 DES 算法的实现中，我用 C++ STL 中的<code>bitset</code>来操作二进制位，另外，这里我没有考虑时间的优化。下面是对一个 64 位数据进行加密解密的源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************* </span><br><span class="line">    &gt; File Name: Des.cpp</span><br><span class="line">    &gt; Author: SongLee </span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com </span><br><span class="line">    &gt; Created Time: 2014年12月05日 星期日 19时46分32秒 </span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com </span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; key;                <span class="comment">// 64位密钥</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;48&gt; subKey[<span class="number">16</span>];         <span class="comment">// 存放16轮子密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始置换表</span></span><br><span class="line"><span class="keyword">int</span> IP[] = &#123;<span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">			<span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">			<span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">			<span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">			<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line">			<span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">			<span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">			<span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结尾置换表</span></span><br><span class="line"><span class="keyword">int</span> IP_1[] = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">			  <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">			  <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">			  <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">			  <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">			  <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------下面是生成密钥所用表-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥置换表，将64位密钥变成56位</span></span><br><span class="line"><span class="keyword">int</span> PC_1[] = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">			   <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">			  <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">			  <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">			   <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">			  <span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩置换，将56位密钥压缩成48位子密钥</span></span><br><span class="line"><span class="keyword">int</span> PC_2[] = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line">			   <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">			  <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">			  <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">			  <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">			  <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">			  <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">			  <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每轮左移的位数</span></span><br><span class="line"><span class="keyword">int</span> shiftBits[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------下面是密码函数 f 所用表-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展置换表，将 32位 扩展至 48位</span></span><br><span class="line"><span class="keyword">int</span> E[] = &#123;<span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">		    <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">		    <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">		   <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">		   <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">		   <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">		   <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S盒，每个S盒是4x16的置换表，6位 -&gt; 4位</span></span><br><span class="line"><span class="keyword">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P置换，32位 -&gt; 32位</span></span><br><span class="line"><span class="keyword">int</span> P[] = &#123;<span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">		    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">		    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">		    <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">		   <span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line">		   <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line">		   <span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                    */</span></span><br><span class="line"><span class="comment">/*                            下面是DES算法实现                        */</span></span><br><span class="line"><span class="comment">/*                                                                    */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  密码函数f，接收32位数据和48位子密钥，产生一个32位的输出            </span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;32&gt; f(<span class="built_in">bitset</span>&lt;32&gt; R, <span class="built_in">bitset</span>&lt;48&gt; k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;48&gt; expandR;</span><br><span class="line">	<span class="comment">// 第一步：扩展置换，32 -&gt; 48</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">48</span>; ++i)</span><br><span class="line">		expandR[<span class="number">47</span>-i] = R[<span class="number">32</span>-E[i]];</span><br><span class="line">	<span class="comment">// 第二步：异或</span></span><br><span class="line">	expandR = expandR ^ k;</span><br><span class="line">	<span class="comment">// 第三步：查找S_BOX置换表</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; output;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">48</span>; i=i+<span class="number">6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = expandR[<span class="number">47</span>-i]*<span class="number">2</span> + expandR[<span class="number">47</span>-i-<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">int</span> col = expandR[<span class="number">47</span>-i-<span class="number">1</span>]*<span class="number">8</span> + expandR[<span class="number">47</span>-i-<span class="number">2</span>]*<span class="number">4</span> + expandR[<span class="number">47</span>-i-<span class="number">3</span>]*<span class="number">2</span> </span><br><span class="line">			+ expandR[<span class="number">47</span>-i-<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> num = S_BOX[i/<span class="number">6</span>][row][col];</span><br><span class="line">		<span class="built_in">bitset</span>&lt;4&gt; binary(num);</span><br><span class="line">		output[<span class="number">31</span>-x] = binary[<span class="number">3</span>];</span><br><span class="line">		output[<span class="number">31</span>-x-<span class="number">1</span>] = binary[<span class="number">2</span>];</span><br><span class="line">		output[<span class="number">31</span>-x-<span class="number">2</span>] = binary[<span class="number">1</span>];</span><br><span class="line">		output[<span class="number">31</span>-x-<span class="number">3</span>] = binary[<span class="number">0</span>];</span><br><span class="line">		x += <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四步：P-置换，32 -&gt; 32</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; tmp = output;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		output[<span class="number">31</span>-i] = tmp[<span class="number">32</span>-P[i]];</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  对56位密钥的前后部分进行左移</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;28&gt; leftShift(<span class="built_in">bitset</span>&lt;28&gt; k, <span class="keyword">int</span> shift)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;28&gt; tmp = k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">27</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i-shift&lt;<span class="number">0</span>)</span><br><span class="line">			k[i] = tmp[i-shift+<span class="number">28</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			k[i] = tmp[i-shift];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  生成16个48位的子密钥</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateKeys</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;56&gt; realKey;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;28&gt; left;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;28&gt; right;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;48&gt; compressKey;</span><br><span class="line">	<span class="comment">// 去掉奇偶标记位，将64位密钥变成56位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">56</span>; ++i)</span><br><span class="line">		realKey[<span class="number">55</span>-i] = key[<span class="number">64</span> - PC_1[i]];</span><br><span class="line">	<span class="comment">// 生成子密钥，保存在 subKeys[16] 中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 前28位与后28位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">28</span>; i&lt;<span class="number">56</span>; ++i)</span><br><span class="line">			left[i-<span class="number">28</span>] = realKey[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">28</span>; ++i)</span><br><span class="line">			right[i] = realKey[i];</span><br><span class="line">		<span class="comment">// 左移</span></span><br><span class="line">		left = leftShift(left, shiftBits[round]);</span><br><span class="line">		right = leftShift(right, shiftBits[round]);</span><br><span class="line">		<span class="comment">// 压缩置换，由56位得到48位子密钥</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">28</span>; i&lt;<span class="number">56</span>; ++i)</span><br><span class="line">			realKey[i] = left[i-<span class="number">28</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">28</span>; ++i)</span><br><span class="line">			realKey[i] = right[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">48</span>; ++i)</span><br><span class="line">			compressKey[<span class="number">47</span>-i] = realKey[<span class="number">56</span> - PC_2[i]];</span><br><span class="line">		subKey[round] = compressKey;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  工具函数：将char字符数组转为二进制</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; charToBitset(<span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">8</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; bits;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)</span><br><span class="line">			bits[i*<span class="number">8</span>+j] = ((s[i]&gt;&gt;j) &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  DES加密</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; encrypt(<span class="built_in">bitset</span>&lt;64&gt;&amp; plain)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; cipher;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; currentBits;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; left;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; right;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; newLeft;</span><br><span class="line">	<span class="comment">// 第一步：初始置换IP</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		currentBits[<span class="number">63</span>-i] = plain[<span class="number">64</span>-IP[i]];</span><br><span class="line">	<span class="comment">// 第二步：获取 Li 和 Ri</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		left[i-<span class="number">32</span>] = currentBits[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		right[i] = currentBits[i];</span><br><span class="line">	<span class="comment">// 第三步：共16轮迭代</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round)</span><br><span class="line">	&#123;</span><br><span class="line">		newLeft = right;</span><br><span class="line">		right = left ^ f(right,subKey[round]);</span><br><span class="line">		left = newLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四步：合并L16和R16，注意合并为 R16L16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		cipher[i] = left[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		cipher[i] = right[i-<span class="number">32</span>];</span><br><span class="line">	<span class="comment">// 第五步：结尾置换IP-1</span></span><br><span class="line">	currentBits = cipher;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		cipher[<span class="number">63</span>-i] = currentBits[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">	<span class="comment">// 返回密文</span></span><br><span class="line">	<span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  DES解密</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; decrypt(<span class="built_in">bitset</span>&lt;64&gt;&amp; cipher)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; plain;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; currentBits;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; left;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; right;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; newLeft;</span><br><span class="line">	<span class="comment">// 第一步：初始置换IP</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		currentBits[<span class="number">63</span>-i] = cipher[<span class="number">64</span>-IP[i]];</span><br><span class="line">	<span class="comment">// 第二步：获取 Li 和 Ri</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		left[i-<span class="number">32</span>] = currentBits[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		right[i] = currentBits[i];</span><br><span class="line">	<span class="comment">// 第三步：共16轮迭代（子密钥逆序应用）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round)</span><br><span class="line">	&#123;</span><br><span class="line">		newLeft = right;</span><br><span class="line">		right = left ^ f(right,subKey[<span class="number">15</span>-round]);</span><br><span class="line">		left = newLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四步：合并L16和R16，注意合并为 R16L16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		plain[i] = left[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		plain[i] = right[i-<span class="number">32</span>];</span><br><span class="line">	<span class="comment">// 第五步：结尾置换IP-1</span></span><br><span class="line">	currentBits = plain;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		plain[<span class="number">63</span>-i] = currentBits[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">	<span class="comment">// 返回明文</span></span><br><span class="line">	<span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* 测试：                                                             */</span></span><br><span class="line"><span class="comment">/*     1.将一个 64 位的字符串加密， 把密文写入文件 a.txt              */</span></span><br><span class="line"><span class="comment">/*     2.读取文件 a.txt 获得 64 位密文，解密之后再写入 b.txt          */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s = <span class="string">"romantic"</span>;</span><br><span class="line">	<span class="built_in">string</span> k = <span class="string">"12345678"</span>;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; plain = charToBitset(s.c_str());</span><br><span class="line">	key = charToBitset(k.c_str());</span><br><span class="line">	<span class="comment">// 生成16个子密钥</span></span><br><span class="line">	generateKeys();   </span><br><span class="line">	<span class="comment">// 密文写入 a.txt</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; cipher = encrypt(plain);</span><br><span class="line">	fstream file1;</span><br><span class="line">	file1.open(<span class="string">"D://a.txt"</span>, ios::binary | ios::out);</span><br><span class="line">	file1.write((<span class="keyword">char</span>*)&amp;cipher,<span class="keyword">sizeof</span>(cipher));</span><br><span class="line">	file1.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读文件 a.txt</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; temp;</span><br><span class="line">	file1.open(<span class="string">"D://a.txt"</span>, ios::binary | ios::in);</span><br><span class="line">	file1.read((<span class="keyword">char</span>*)&amp;temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">	file1.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密，并写入文件 b.txt</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; temp_plain = decrypt(temp);</span><br><span class="line">	file1.open(<span class="string">"D://b.txt"</span>, ios::binary | ios::out);</span><br><span class="line">	file1.write((<span class="keyword">char</span>*)&amp;temp_plain,<span class="keyword">sizeof</span>(temp_plain));</span><br><span class="line">	file1.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果（VS2012）：</p>
<p><img src="http://img.blog.csdn.net/20141206183858625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>那么，在对 64 位的数据加解密成功以后，对文件的加解密就很简单了！只需要每次读 64 位，加密以后，将 64 位的密文写入另外一个文件…..如此循环，直到文件尾。下面是对一张图片进行加密和解密的测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> k = <span class="string">"12345678"</span>;</span><br><span class="line">	key = charToBitset(k.c_str());</span><br><span class="line">	generateKeys();   <span class="comment">// 生成16个子密钥</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将文件 flower.jpg 加密到 cipher.txt 中</span></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line">	in.open(<span class="string">"D://flower.jpg"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; plain;</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;plain, <span class="keyword">sizeof</span>(plain)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bitset</span>&lt;64&gt; cipher  = encrypt(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;cipher, <span class="keyword">sizeof</span>(cipher));</span><br><span class="line">		plain.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密 cipher.txt，并写入图片 flower1.jpg</span></span><br><span class="line">	in.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://flower1.jpg"</span>, ios::binary);</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;plain, <span class="keyword">sizeof</span>(plain)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bitset</span>&lt;64&gt; temp  = decrypt(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">		plain.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（全文完）<br><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《信息安全技术》这门课又在讲 DES 加密算法了，以前用纯C写过一次，这次我用 C++ 重新写了一个，写篇文章以备后用。本文介绍了 DES 算法加密的大致步骤和整体流程。</p>
<h3 id="一、DES算法原理">一、DES算法原理</h3><p>DES算法是一种最通用的对称密钥算法，因为算法本身是公开的，所以其安全性在于密钥的安全性。基于密钥的算法通常有两类：<strong>对称算法</strong>和<strong>公开密钥算法</strong>。对称算法的对称性体现在加密密钥能够从解密密钥推算出来，反之亦然。在大多数对称算法中，加解密的密钥是相同的，DES就是这样。可见，对称密钥算法的加解密密钥都是保密的。而公开密钥算法的加密密钥是公开的，解密密钥是保密的。</p>
<p>下面是 DES 加密算法的整体流程图：]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【动态规划】输出所有的最长公共子序列]]></title>
    <link href="http://yoursite.com/2014/11/29/print-all-LCS/"/>
    <id>http://yoursite.com/2014/11/29/print-all-LCS/</id>
    <published>2014-11-29T08:48:14.000Z</published>
    <updated>2015-05-10T10:34:30.441Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/2014/11/27/dynamic-programming/" target="_blank" rel="external">&lt;&lt; 动态规划求最长公共子序列的长度</a></p>
<p>上篇讲到使用动态规划可以在 <strong>θ(mn)</strong> 的时间里求出 LCS 的长度，本文将讨论如何输出最长公共子序列。</p>
<p><strong>*问题描述：</strong>给定两个序列，例如 X = “ABCBDAB”、Y = “BDCABA”，求它们的最长公共子序列的长度。*</p>
<p>下面是求解时的动态规划表，可以看出 X 和 Y 的最长公共子序列的长度为4：<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20141127164703086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>输出一个最长公共子序列并不难（网上很多相关代码），难点在于输出所有的最长公共子序列，因为 LCS 通常不唯一。总之，我们需要在动态规划表上进行回溯 —— 从<code>table[m][n]</code>，即右下角的格子，开始进行判断：</p>
<ol>
<li><p>如果格子<code>table[i][j]</code>对应的<code>X[i-1] == Y[j-1]</code>，则把这个字符放入 LCS 中，并跳入<code>table[i-1][j-1]</code>中继续进行判断；</p>
</li>
<li><p>如果格子<code>table[i][j]</code>对应的 <code>X[i-1] ≠ Y[j-1]</code>，则比较<code>table[i-1][j]</code>和<code>table[i][j-1]</code>的值，跳入值较大的格子继续进行判断；</p>
</li>
<li><p>直到 i 或 j 小于等于零为止，倒序输出 LCS 。</p>
</li>
</ol>
<p>如果出现<code>table[i-1][j]</code>等于<code>table[i][j-1]</code>的情况，说明最长公共子序列有多个，故两边都要进行回溯（这里用到递归）。</p>
<p><img src="http://img.blog.csdn.net/20141129154238387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从上图的红色路径显示，X 和 Y 的最长公共子序列有 3 个，分别为 “BDAB”、“BCAB”、“BCBA”。</p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划求解并输出所有LCS</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> X = <span class="string">"ABCBDAB"</span>;</span><br><span class="line"><span class="built_in">string</span> Y = <span class="string">"BDCABA"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; table; <span class="comment">// 动态规划表</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; setOfLCS;      <span class="comment">// set保存所有的LCS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 字符串逆序</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> str)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> high = str.length() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> temp = str[low];</span><br><span class="line">		str[low] = str[high];</span><br><span class="line">		str[high] = temp;</span><br><span class="line">		++low;</span><br><span class="line">		--high;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 构造表，并返回X和Y的LCS的长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 表的大小为(m+1)*(n+1)</span></span><br><span class="line">	table = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 第一行和第一列置0</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">				table[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(X[i-<span class="number">1</span>] == Y[j-<span class="number">1</span>])</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				table[i][j] = max(table[i-<span class="number">1</span>][j], table[i][j-<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> table[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 求出所有的最长公共子序列，并放入set中 </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span> lcs_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (X[i-<span class="number">1</span>] == Y[j-<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			lcs_str.push_back(X[i-<span class="number">1</span>]);</span><br><span class="line">			--i;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &gt; table[i][j-<span class="number">1</span>])</span><br><span class="line">				--i;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &lt; table[i][j-<span class="number">1</span>])</span><br><span class="line">				--j;</span><br><span class="line">			<span class="keyword">else</span>   <span class="comment">// 相等的情况</span></span><br><span class="line">			&#123;</span><br><span class="line">				traceBack(i-<span class="number">1</span>, j, lcs_str);</span><br><span class="line">				traceBack(i, j-<span class="number">1</span>, lcs_str);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	setOfLCS.insert(Reverse(lcs_str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = X.length();</span><br><span class="line">	<span class="keyword">int</span> n = Y.length();</span><br><span class="line">	<span class="keyword">int</span> length = lcs(m, n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of LCS is "</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	traceBack(m, n, str);</span><br><span class="line">	<span class="comment">// 倒序输出</span></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator beg = setOfLCS.begin();</span><br><span class="line">	<span class="keyword">for</span>( ; beg!=setOfLCS.end(); ++beg)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="http://img.blog.csdn.net/20141129154444437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>Java版本的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String X;</span><br><span class="line">	<span class="keyword">private</span> String Y;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] table;  <span class="comment">// 动态规划表</span></span><br><span class="line">	<span class="keyword">private</span> TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：带参数的构造器</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(String X, String Y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.X = X;</span><br><span class="line">		<span class="keyword">this</span>.Y = Y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：求两个数中的较大者</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a&gt;b) ? a:b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：构造表，并返回X和Y的LCS的长度</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		table = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>]; <span class="comment">// 表的大小为(m+1)*(n+1)	</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">				<span class="comment">// 第一行和第一列置0</span></span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">					table[i][j] = <span class="number">0</span>;</span><br><span class="line">				<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(X.charAt(i-<span class="number">1</span>)</span> </span>== Y.charAt(j-<span class="number">1</span>))</span><br><span class="line">					table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					table[i][j] = max(table[i-<span class="number">1</span>][j], table[i][j-<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> table[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：回溯，求出所有的最长公共子序列，并放入set中</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String lcs_str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (X.charAt(i-<span class="number">1</span>) == Y.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">				lcs_str += X.charAt(i-<span class="number">1</span>);</span><br><span class="line">				--i;</span><br><span class="line">				--j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &gt; table[i][j-<span class="number">1</span>])</span><br><span class="line">					--i;</span><br><span class="line">				<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(table[i-<span class="number">1</span>][j] &lt; table[i][j-<span class="number">1</span>])</span></span><br><span class="line">					--j</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;  <span class="comment">// 相等的情况</span></span><br><span class="line">					traceBack(i-<span class="number">1</span>, j, lcs_str);</span><br><span class="line">					traceBack(i, j-<span class="number">1</span>, lcs_str);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		set.add(reverse(lcs_str));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：字符串逆序</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">reverse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		StringBuffer strBuf = <span class="keyword">new</span> StringBuffer(str).reverse();</span><br><span class="line">		<span class="keyword">return</span> strBuf.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：外部接口 —— 打印输出</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLCS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = X.length();</span><br><span class="line">		<span class="keyword">int</span> n = Y.length();</span><br><span class="line">		<span class="keyword">int</span> length = lcs(m,n);</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		traceBack(m,n,str);</span><br><span class="line">		<span class="comment">// 倒序输出</span></span><br><span class="line">		System.out.println(<span class="string">"The length of LCS is: "</span> + length);</span><br><span class="line">		<span class="keyword">for</span>(String s : set) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：main方法 —— 程序的入口</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyClass lcs = <span class="keyword">new</span> MyClass(<span class="string">"ABCBDAB"</span>,<span class="string">"BDCABA"</span>);</span><br><span class="line">		lcs.printLCS();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>转载请注明出处，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/2014/11/27/dynamic-programming/">&lt;&lt; 动态规划求最长公共子序列的长度</a></p>
<p>上篇讲到使用动态规划可以在 <strong>θ(mn)</strong> 的时间里求出 LCS 的长度，本文将讨论如何输出最长公共子序列。</p>
<p><strong>*问题描述：</strong>给定两个序列，例如 X = “ABCBDAB”、Y = “BDCABA”，求它们的最长公共子序列的长度。*</p>
<p>下面是求解时的动态规划表，可以看出 X 和 Y 的最长公共子序列的长度为4：<br>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划（Dynamic Programming）]]></title>
    <link href="http://yoursite.com/2014/11/27/dynamic-programming/"/>
    <id>http://yoursite.com/2014/11/27/dynamic-programming/</id>
    <published>2014-11-27T13:50:47.000Z</published>
    <updated>2015-05-10T10:30:16.598Z</updated>
    <content type="html"><![CDATA[<h3 id="一、动态规划">一、动态规划</h3><p><strong>动态规划（Dynamic Programming）</strong>是一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。</p>
<p><strong>基本思想：</strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。通常可以用一个<strong>表</strong>来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路。</p>
<p>采用动态规划求解的问题需要具有<strong>两个特性：</strong><a id="more"></a></p>
<ul>
<li><p><strong>最优子结构（Optimal Substructure）：</strong>问题的一个最优解中所包含的子问题的解也是最优的。</p>
</li>
<li><p><strong>重叠子问题（Overlapping Subproblems）：</strong>用递归算法对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。</p>
</li>
</ul>
<p>问题具有最优子结构性质，我们才能写出最优解的递归方程；具有重叠子问题特性，我们才能通过避免重复计算来减少运行时间。</p>
<p>综上所述，动态规划的关键是 —— 记忆，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。<br><br></p>
<h3 id="二、最长公共子序列（LCS）问题">二、最长公共子序列（LCS）问题</h3><p>下面通过一个具体的例子来学习动态规划方法 —— 最长公共子序列问题。</p>
<p><strong>*最长公共子串（Longest Common Substring）</strong>与<strong>最长公共子序列（Longest Common Subsequence）</strong>的区别： 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序，并不要求连续。*</p>
<p><strong>问题描述：</strong>给定两个序列：<code>X[1...m]</code>和<code>Y[1...n]</code>，求在两个序列中同时出现的最长子序列的长度。</p>
<p>假设 X 和 Y 的序列如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">1.</span>..m] = &#123;A, B, C, B, D, A, B&#125;</span><br><span class="line">Y[<span class="number">1.</span>..n] = &#123;B, D, C, A, B, A&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，X 和 Y 的最长公共子序列有 “BDAB”、“BCAB”、“BCBA”，即长度为4。</p>
<p><strong>1） 穷举法</strong></p>
<p>可能很多人会想到用穷举法来解决这个问题，即求出 X 中所有子序列，看 Y 中是否存在该子序列。</p>
<ul>
<li>X 有多少子序列 —— $2^m$ 个</li>
<li>检查一个子序列是否在 Y 中 —— θ(n)</li>
</ul>
<p>所以穷举法在最坏情况下的时间复杂度是 $θ(n * 2^m)$，也就是说花费的时间是指数级的，这简直太慢了。</p>
<p><strong>2） 动态规划</strong></p>
<p>首先，我们来看看 LCS 问题是否具有动态规划问题的两个特性。</p>
<p><strong>① 最优子结构</strong></p>
<p>设 <code>C[i,j] = |LCS(x[1...i],y[1...j])|</code>，即<code>C[i,j]</code>表示序列<code>X[1...i]</code>和<code>Y[1...j]</code>的最长公共子序列的长度，则 <code>C[m,n] = |LCS(x,y)|</code>就是问题的解。</p>
<p>递归推导式：</p>
<p><img src="http://img.blog.csdn.net/20141127164356104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>在这里就不证明了。从这个递归公式可以看出，问题具有最优子结构性质！</p>
<p><strong>② 重叠子问题</strong></p>
<p>根据上面的递归推导式，可以写出求LCS长度的递归伪代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LCS(x,y,<span class="built_in">i</span>,<span class="built_in">j</span>)</span><br><span class="line">	<span class="keyword">if</span> x<span class="matrix">[i]</span> = y<span class="matrix">[j]</span></span><br><span class="line">		then C<span class="matrix">[i,j]</span> ← LCS(x,y,<span class="built_in">i</span>-<span class="number">1</span>,<span class="built_in">j</span>-<span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span> C<span class="matrix">[i,j]</span> ← max<span class="cell">&#123;LCS(x,y,i-<span class="number">1</span>,j),LCS(x,y,i,j-<span class="number">1</span>)&#125;</span></span><br><span class="line">	<span class="keyword">return</span> C<span class="matrix">[i,j]</span></span><br></pre></td></tr></table></figure></p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的递归求解LCS问题</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the length of LCS for X[0...m-1] and Y[0...n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> &amp;X, <span class="built_in">string</span> &amp;Y, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (X[m-<span class="number">1</span>] == Y[n-<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">return</span> lcs(X, Y, m-<span class="number">1</span>, n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> max(lcs(X, Y, m, n-<span class="number">1</span>), lcs(X, Y, m-<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> X = <span class="string">"ABCBDAB"</span>;</span><br><span class="line">	<span class="built_in">string</span> Y = <span class="string">"BDCABA"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of LCS is "</span> &lt;&lt; lcs(X, Y, X.length(), Y.length());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像这样使用简单的递归，在最坏情况下（X 和 Y 的所有字符都不匹配，即LCS的长度为0）的时间复杂度为 <strong>θ(2^n)</strong>。这和穷举法一样还是指数级的，太慢了。</p>
<p>根据程序中 X 和 Y 的初始值，我们画出部分递归树：</p>
<p><img src="http://img.blog.csdn.net/20141127164646781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>递归树中红框标记的部分被调用了两次。如果画出完整的递归树，我们会看到很多重复的调用，所以这个问题具有重叠子问题的特性。</p>
<p><strong>③ 动态规划求解</strong></p>
<p>简单的递归之所以和穷举法一样慢，因为在递归过程中进行了大量的重复调用。而<strong>动态规划就是要解决这个问题，通过用一个表来保存子问题的结果，避免重复的计算，以空间换时间</strong>。前面我们已经证明，最长公共子序列问题具有动态规划所要求的两个特性，所以 LCS 问题可以用动态规划来求解。</p>
<p>下面是用动态规划（打表）解决LCS问题：</p>
<p><img src="http://img.blog.csdn.net/20141127164703086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>C++代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划求解LCS问题</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回X[0...m-1]和Y[0...n-1]的LCS的长度 </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> &amp;X, <span class="built_in">string</span> &amp;Y, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 动态规划表，大小(m+1)*(n+1)</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; table(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 第一行和第一列置0</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">				table[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(X[i-<span class="number">1</span>] == Y[j-<span class="number">1</span>])</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				table[i][j] = max(table[i-<span class="number">1</span>][j], table[i][j-<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> table[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> X = <span class="string">"ABCBDAB"</span>;</span><br><span class="line">	<span class="built_in">string</span> Y = <span class="string">"BDCABA"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of LCS is "</span> &lt;&lt; lcs(X, Y, X.length(), Y.length());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>容易看出，动态规划解决LCS问题的时间复杂度为 <strong>θ(mn)</strong>，这比简单的递归实现要快多了。空间复杂度是<strong>θ(mn)</strong>，因为使用了一个动态规划表。当然，空间复杂度还可以进行优化，即根据递推式我们可以只保存填下一个位置所用到的几个位置就行了。（关于如何输出LCS请看另一篇：《<a href="http://songlee24.github.io/blog/2014/11/29/printlcs/" target="_blank" rel="external">输出所有的最长公共子序列</a>》）</p>
<p><br><br><br><br></p>
<h3 id="总结：">总结：</h3><p>动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余（重复计算），这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p>
<p>从上面的例子中，我们可以总结动态规划解决最优化问题的一般步骤：</p>
<ol>
<li>分析最优解的性质，并刻划其结构特征。</li>
<li>递归地定义最优值。</li>
<li>以自底向上的方式或自顶向下的记忆化方法计算出最优值。</li>
<li>根据计算最优值时得到的信息，构造一个最优解。</li>
</ol>
<p>步骤(1)—(3)是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤(4)可以省略，若需要求出问题的一个最优解，则必须执行步骤(4)。此时，在步骤(3)中计算最优值时，通常需记录更多的信息，以便在步骤(4)中，根据所记录的信息，快速地构造出一个最优解。</p>
<p>（全文完）</p>
<p><br><br>参考：<br>[1] www.algorithmist.com/index.php/Longest_Common_Subsequence<br>[2] www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、动态规划">一、动态规划</h3><p><strong>动态规划（Dynamic Programming）</strong>是一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。</p>
<p><strong>基本思想：</strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。通常可以用一个<strong>表</strong>来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路。</p>
<p>采用动态规划求解的问题需要具有<strong>两个特性：</strong>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于MFC的一个简单计算器]]></title>
    <link href="http://yoursite.com/2014/10/13/simple-calculator/"/>
    <id>http://yoursite.com/2014/10/13/simple-calculator/</id>
    <published>2014-10-13T03:08:53.000Z</published>
    <updated>2015-05-10T10:24:00.243Z</updated>
    <content type="html"><![CDATA[<p>写一个简单的计算器并不是什么很难的事，主要目的是要通过这个程序来学习和分析其中的核心算法。这个简易计算器的<strong>核心部分</strong>就是对输入的表达式的正确性判断与求值，其中包括对表达式的解析、中缀表达式转后缀表达式、后缀表达式求值等等几个方面。</p>
<p><center><img src="http://img.blog.csdn.net/20141007151700078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></center><br><a id="more"></a><br><br></p>
<h3 id="一、封装核心代码">一、封装核心代码</h3><p>《<a href="http://songlee24.github.io/2014/10/05/arithmetic-expression-01/" target="_blank" rel="external">算术表达式的合法性判断与求值（上）</a>》和《<a href="http://songlee24.github.io/2014/10/10/arithmetic-expression-02/" target="_blank" rel="external">算术表达式的合法性判断与求值（下）</a>》这两篇文章已经对核心算法部分进行了讲解，并附有源码。在此基础上制作一个简单计算器，我们要做的仅仅是封装核心代码并加入MFC工程中。</p>
<p>下面是我封装的一个 Expression 类：</p>
<p><strong>Expression.h</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Expression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Expression(<span class="built_in">string</span> str);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">()</span></span>;         <span class="comment">// 外部接口，判断表达式是否合法</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">()</span></span>;  <span class="comment">// 外部接口，计算表达式的值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line">	<span class="built_in">string</span> expr;  <span class="comment">// 算术表达式</span></span><br><span class="line">	<span class="keyword">int</span> idx;      <span class="comment">// word下标</span></span><br><span class="line">	<span class="keyword">int</span> sym;      <span class="comment">// 单词种别编码</span></span><br><span class="line">	<span class="keyword">int</span> err;      <span class="comment">// 错误</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; , <span class="keyword">const</span> <span class="built_in">string</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">bool</span> Right;   <span class="comment">// 保存表达式test结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">// 获取运算符的优先级</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 通过 种别编码 判定是否是运算符</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; getPostfix(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp;);  <span class="comment">// 中缀转后缀</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">popTwoNumbers</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;&amp;, <span class="keyword">double</span>&amp;, <span class="keyword">double</span>&amp;)</span></span>;  <span class="comment">// 从栈中连续弹出两个操作数</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;  <span class="comment">// 把string转换为double</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">expCalculate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp;)</span></span>;  <span class="comment">// 计算后缀表达式的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Expression.cpp</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Expression.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Expression::Expression( <span class="built_in">string</span> str ):</span><br><span class="line">	expr(str),</span><br><span class="line">	idx(<span class="number">0</span>),</span><br><span class="line">	err(<span class="number">0</span>),</span><br><span class="line">	Right(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口</span></span><br><span class="line"><span class="keyword">bool</span> Expression::test()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!word.empty())  <span class="comment">// 已经test过了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">	<span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">	&#123;</span><br><span class="line">		Right = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 词法正确，进行语法分析</span></span><br><span class="line">		Next();</span><br><span class="line">		E();</span><br><span class="line">		<span class="keyword">if</span> (sym == <span class="number">0</span> &amp;&amp; err == <span class="number">0</span>)  <span class="comment">// 注意要判断两个条件</span></span><br><span class="line">			Right = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Right = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口</span></span><br><span class="line"><span class="keyword">double</span> Expression::calculate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (test())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> expCalculate(getPostfix(word));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------词法分析----------------------------*/</span></span><br><span class="line"><span class="keyword">int</span> Expression::word_analysis(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">		<span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">			|| expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp;</span><br><span class="line">			tmp.push_back(expr[i]);</span><br><span class="line">			<span class="keyword">switch</span> (expr[i])</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是数字开头</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp;</span><br><span class="line">			<span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp.push_back(expr[i]);</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++i;</span><br><span class="line">				<span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">					<span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						tmp.push_back(expr[i]);</span><br><span class="line">						++i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>  </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果以.开头</span></span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------语法分析----------------------------*/</span></span><br><span class="line"><span class="comment">// 读下一单词的种别编码</span></span><br><span class="line"><span class="keyword">void</span> Expression::Next()</span><br><span class="line">&#123;   </span><br><span class="line">	<span class="keyword">if</span>(idx &lt; word.size())</span><br><span class="line">		sym = word[idx++].second;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sym = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E → T &#123; +T | -T &#125; </span></span><br><span class="line"><span class="keyword">void</span> Expression::E()</span><br><span class="line">&#123;</span><br><span class="line">	T();</span><br><span class="line">	<span class="keyword">while</span>(sym == <span class="number">1</span> || sym == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">		T();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T → F &#123; *F | /F &#125; </span></span><br><span class="line"><span class="keyword">void</span> Expression::T()</span><br><span class="line">&#123;</span><br><span class="line">	F();</span><br><span class="line">	<span class="keyword">while</span>(sym == <span class="number">3</span> || sym == <span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">		F();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F → (E) | d</span></span><br><span class="line"><span class="keyword">void</span> Expression::F()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sym == <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">		E();</span><br><span class="line">		<span class="keyword">if</span> (sym == <span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Next();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			err = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		err = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------求值部分----------------------------*/</span></span><br><span class="line"><span class="keyword">int</span> Expression::prior(<span class="keyword">int</span> sym)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sym)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Expression::isOperator(<span class="keyword">int</span> sym)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sym)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; Expression::getPostfix( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; expr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; output;  <span class="comment">// 输出</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; s;        <span class="comment">// 操作符栈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p = expr[i];</span><br><span class="line">		<span class="keyword">if</span>(isOperator(p.second))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top().second) &amp;&amp; prior(s.top().second)&gt;=prior(p.second))</span><br><span class="line">			&#123;</span><br><span class="line">				output.push_back(s.top());</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			s.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">6</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(s.top().second != <span class="number">6</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				output.push_back(s.top());</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			output.push_back(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		output.push_back(s.top());</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Expression::popTwoNumbers( <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;&amp; s, <span class="keyword">double</span>&amp; first, <span class="keyword">double</span>&amp; second )</span><br><span class="line">&#123;</span><br><span class="line">	first = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	second = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Expression::stringToDouble( <span class="keyword">const</span> <span class="built_in">string</span>&amp; str )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="built_in">stringstream</span> ss;</span><br><span class="line">	ss &lt;&lt; str;</span><br><span class="line">	ss &gt;&gt; d;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Expression::expCalculate( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; postfix )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> first,second;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;postfix.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p = postfix[i];</span><br><span class="line">		<span class="keyword">switch</span> (p.second)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second+first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second-first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second*first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second/first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			s.push(stringToDouble(p.first));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> result = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用方法（测试）：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;	</span><br><span class="line">	<span class="function">Expression <span class="title">e</span><span class="params">("(1.5+2.5)</span>*2+0.53")</span>;</span><br><span class="line">	<span class="keyword">if</span>(e.test())   <span class="comment">// 判断表达式是否合法</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.calculate() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、加入MFC工程">二、加入MFC工程</h3><p>OK，核心代码（表达式的合法性判断与求值）已经封装到 Expression 类中，下面要做的就是新建一个 MFC 工程，并把 Expression 类加入工程里，并实现按钮的功能就行了。</p>
<p>在 MFC 对话框上添加二十个 Button 控件和一个 Edit 控件（设置Disable属性为true，只用于显示），如下图：</p>
<p><center><img src="http://img.blog.csdn.net/20141007154354143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></center><br><br><br>给 Edit 控件绑定一个变量 mEdit，然后给各个按钮添加单击响应函数，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“1”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"1"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked2()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“2”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"2"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked3()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“3”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"3"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked4()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“4”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"4"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked5()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“5”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"5"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked6()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“6”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"6"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked7()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“7”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"7"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked8()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“8”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"8"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked9()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“9”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"9"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked0()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“0”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"0"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedClear()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “清屏”按钮</span></span><br><span class="line">	mEdit.SetWindowText(_T(<span class="string">""</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedBack()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “后退”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str.Left(str.GetLength()-<span class="number">1</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedLeft()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “左括号”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"("</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedRight()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “右括号”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">")"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedDot()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// "."按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"."</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedAdd()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 加号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"+"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedSub()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 减号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"-"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedMul()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 乘号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"*"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedDiv()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 除号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"/"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedEql()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 等号，计算结果  </span></span><br><span class="line">    CString str;  </span><br><span class="line">    mEdit.GetWindowText(str);  </span><br><span class="line">    <span class="function">CT2CA <span class="title">pszConvertedAnsiString</span><span class="params">(str)</span></span>;  <span class="comment">// 将 TCHAR 转换为 LPCSTR  </span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">exp_str</span><span class="params">(pszConvertedAnsiString)</span></span>; <span class="comment">// 从 LPCSTR 构造 string  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (exp_str != <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Expression <span class="title">e</span><span class="params">(exp_str)</span></span>;  </span><br><span class="line">        <span class="keyword">if</span>(e.test())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">string</span> tmp;  </span><br><span class="line">            <span class="built_in">stringstream</span> ss;  </span><br><span class="line">            ss &lt;&lt; e.calculate();  </span><br><span class="line">            ss &gt;&gt; tmp;  </span><br><span class="line">            str = tmp.c_str();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            str = <span class="string">"输入错误"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mEdit.SetWindowText(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，一个可以计算整数和小数的四则混合运算的简单计算器就完成了。</p>
<p>虽然 Expression 类可以对所有的输入进行解析，并判断其合法性。但是考虑到用户体验，最好还是对各个 Button 的输入进行一定的限制，比如+++++++。这就需要在按钮的响应函数里添加逻辑，详细的就不多说了。</p>
<p><strong>源码下载：</strong><a href="http://download.csdn.net/detail/lisong694767315/8009467" target="_blank" rel="external">http://download.csdn.net/detail/lisong694767315/8009467</a></p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写一个简单的计算器并不是什么很难的事，主要目的是要通过这个程序来学习和分析其中的核心算法。这个简易计算器的<strong>核心部分</strong>就是对输入的表达式的正确性判断与求值，其中包括对表达式的解析、中缀表达式转后缀表达式、后缀表达式求值等等几个方面。</p>
<p><center><img src="http://img.blog.csdn.net/20141007151700078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></center><br>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算术表达式的合法性判断与求值（下）]]></title>
    <link href="http://yoursite.com/2014/10/10/arithmetic-expression-02/"/>
    <id>http://yoursite.com/2014/10/10/arithmetic-expression-02/</id>
    <published>2014-10-10T01:58:01.000Z</published>
    <updated>2015-05-10T10:18:43.177Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/2014/10/05/arithmetic-expression-01/" target="_blank" rel="external">&lt;&lt; 算术表达式的合法性判断与求值（上）</a></p>
<p>上一篇讲到，通过编译原理的方法（词法分析和语法分析）来判断字符串表示的算术表达式的合法性。这一篇，接着讲在算术表达式合法的情况下，对表达式进行求值。</p>
<ul>
<li>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。  </li>
<li>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</li>
</ul>
<h3 id="三、算术表达式的求值">三、算术表达式的求值</h3><p>表达式的求值是栈应用的一个典型范例。我们一般通过<strong>后缀表达式（逆波兰式）</strong>进行求值，<a id="more"></a>因为对后缀表达式求值比直接对中缀表达式求值简单很多。<strong>中缀表达式</strong>不仅依赖运算符的优先级，而且还要处理括号，而后缀表达式中已经考虑了运算符的优先级，且没有括号。</p>
<p>所以，这里对表达式的求值分两个步骤进行：首先，把中缀表达式转换为后缀表达式，然后，对后缀表达式求值。</p>
<p><strong>1）中缀转后缀</strong></p>
<p>在把中缀转后缀的过程中，需要考虑操作符的优先级。根据《数据结构与算法分析》一书中的描述，我们需要利用一个<strong>栈</strong>（存放操作符）和一个<strong>输出字符串Output</strong>，从左到右读入中缀表达式：</p>
<ol>
<li>如果字符是操作数，将它添加到 Output。</li>
<li>如果字符是操作符，从栈中弹出操作符，到 Output 中，直到遇到左括号 或 优先级较低的操作符（并不弹出）。然后把这个操作符 push 入栈。</li>
<li>如果字符是左括号，无理由入栈。</li>
<li>如果字符是右括号，从栈中弹出操作符，到 Output 中，直到遇到左括号。（左括号只弹出，不放入输出字符串）</li>
<li>中缀表达式读完以后，如果栈不为空，从栈中弹出所有操作符并添加到 Output 中。</li>
</ol>
<p>好了，下面直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运算符的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是运算符</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀转后缀</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getPostfix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;  <span class="comment">// 操作符栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = expr[i];</span><br><span class="line">        <span class="keyword">if</span>(isOperator(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top()) &amp;&amp; prior(s.top())&gt;=prior(c))</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.top() != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"a+b*c+(d*e+f)*g"</span>;</span><br><span class="line">    <span class="built_in">string</span> postfix = getPostfix(expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; endl &lt;&lt; postfix &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相信应该不需要我再解释什么了，请对照上面的规则看代码。</p>
<p><strong>2）后缀表达式求值</strong></p>
<p>得到了后缀表达式以后，对后缀表达式的求值就变得非常简单了。只需要使用一个栈，从左到右读入后缀表达式：</p>
<ol>
<li>如果字符是操作数，把它压入堆栈。</li>
<li>如果字符是操作符，从栈中弹出两个操作数，执行相应的运算，然后把结果压入堆栈。（如果不能连续弹出两个操作数，说明表达式不正确）</li>
<li>当表达式扫描完以后，栈中存放的就是最后的计算结果。</li>
</ol>
<p>好了，话不多说，直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getPostfix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;  <span class="comment">// 操作符栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = expr[i];</span><br><span class="line">        <span class="keyword">if</span>(isOperator(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top()) &amp;&amp; prior(s.top())&gt;=prior(c))</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.top() != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈中连续弹出两个操作数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popTwoNumbers</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&amp; s, <span class="keyword">int</span>&amp; first, <span class="keyword">int</span>&amp; second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    first = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    second = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expCalculate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; postfix)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first,second;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;postfix.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = postfix[i];</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second+first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second-first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second*first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second/first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            s.push(c-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"5+2*(6-3)-4/2"</span>;</span><br><span class="line">    <span class="built_in">string</span> postfix = getPostfix(expr);</span><br><span class="line">    <span class="keyword">int</span> result = expCalculate(postfix);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，示例中的操作数都是单个的字符（0-9），但是通常的表达式不会是这种特殊情况，这就是我们需要对表达式进行词法解析的原因。</p>
<h3 id="四、解决问题">四、解决问题</h3><p>好了，下面我们就结合上篇讲的<a href="http://songlee24.github.io/blog/2014/10/13/suan-zhu-biao-da-shi-de-qiu-zhi-shang/" target="_blank" rel="external">词法分析</a>对一个含有整数或小数的表达式进行求值。</p>
<p>因为操作数不再是单个字符（个位数），我们需要对表达式进行词法解析。这里经过解析后，将<code>(单词, 种别编码)</code>对存入到一个<code>vector&lt;pair&lt;string, int&gt;&gt;</code>中，所以我们的中缀转后缀、后缀表达式求值都是对这个<code>vector</code>结构进行遍历。</p>
<p>假设表达式已经判断为合法，求值的完整代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - * / ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运算符的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">int</span> sym)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sym)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 种别编码 判定是否是运算符</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">int</span> sym)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sym)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; getPostfix(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; expr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; s;  <span class="comment">// 操作符栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p = expr[i];</span><br><span class="line">        <span class="keyword">if</span>(isOperator(p.second))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top().second) &amp;&amp; prior(s.top().second)&gt;=prior(p.second))</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.top().second != <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈中连续弹出两个操作数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popTwoNumbers</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;&amp; s, <span class="keyword">double</span>&amp; first, <span class="keyword">double</span>&amp; second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    first = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    second = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把string转换为double</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; d;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">expCalculate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; postfix)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> first,second;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;postfix.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p = postfix[i];</span><br><span class="line">        <span class="keyword">switch</span> (p.second)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second+first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second-first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second*first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second/first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            s.push(stringToDouble(p.first));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"(1.5+2.5)*2-0.5"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> result = expCalculate(getPostfix(word));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; expr + <span class="string">" = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了防止精度的损失，不论是整数还是小数，在这里都通过<code>stringToDouble()</code>函数转为 double 浮点数。</p>
<p><br><br><br><br><br></p>
<h3 id="附：字符串转数值类型">附：字符串转数值类型</h3><p><strong>方法一：atoi、atof</strong></p>
<p>在C语言的头文件 stdlib.h 里提供了两个函数，用于将字符串转换为整数或浮点数。函数原型分别为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;          <span class="comment">// 字符串转整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;       <span class="comment">// 字符串转浮点数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：stringstream</strong></p>
<p>在C++里，可以利用 stringstream 方便的将 string 转换为 int、float、double：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d; </span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; str;    <span class="comment">// 把字符串写入字符流</span></span><br><span class="line">    ss &gt;&gt; d;      <span class="comment">// 输出到double</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">doubleToString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str; </span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; d;  </span><br><span class="line">    ss &gt;&gt; str;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 stringstream 将 string 转换为 int 或 float 与上面的方法是一样的，只需要改一下变量的类型就可以了。</p>
<p>（全文完）</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/2014/10/05/arithmetic-expression-01/">&lt;&lt; 算术表达式的合法性判断与求值（上）</a></p>
<p>上一篇讲到，通过编译原理的方法（词法分析和语法分析）来判断字符串表示的算术表达式的合法性。这一篇，接着讲在算术表达式合法的情况下，对表达式进行求值。</p>
<ul>
<li>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。  </li>
<li>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</li>
</ul>
<h3 id="三、算术表达式的求值">三、算术表达式的求值</h3><p>表达式的求值是栈应用的一个典型范例。我们一般通过<strong>后缀表达式（逆波兰式）</strong>进行求值，]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算术表达式的合法性判断与求值（上）]]></title>
    <link href="http://yoursite.com/2014/10/05/arithmetic-expression-01/"/>
    <id>http://yoursite.com/2014/10/05/arithmetic-expression-01/</id>
    <published>2014-10-05T01:49:03.000Z</published>
    <updated>2015-05-10T10:19:33.516Z</updated>
    <content type="html"><![CDATA[<p>在写一个计算器时遇到了一个问题，就是对字符串表示的<strong>算术表达式</strong>的合法性判断与求值。下面记录一下我的解决方案。</p>
<h3 id="一、问题描述">一、问题描述</h3><p>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。</p>
<p>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</p>
<h3 id="二、判断表达式的合法性">二、判断表达式的合法性</h3><a id="more"></a>
<p>相信学过《<a href="http://book.douban.com/subject/6091300/" target="_blank" rel="external">编译原理</a>》的人都知道，利用里面讲的分析方法可以对源代码进行解析。而<strong>算术表达式</strong>也是源代码的一部分，所以利用编译方法也可以很容易地判断表达式的合法性。</p>
<p>与源代码相比，算术表达式只包含有很少的字符，所以解析起来也简单很多。下面从词法分析和语法分析两个方面来说明。</p>
<p><strong>1）词法分析</strong></p>
<p>下面先定一下表达式涉及到的单词的种别编码：</p>
<p><img src="http://img.blog.csdn.net/20141006175947479?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>识别上表所列的单词的状态转换图：</p>
<p><img src="http://img.blog.csdn.net/20141006184215899?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"(1.5+5.789)*82-10/2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码将识别出的单词-种别编码对 <code>(单词, 种别编码)</code> 存入一个 <code>vector&lt;pair&lt;string, int&gt;&gt;</code> 中。</p>
<p><strong>2）语法分析</strong></p>
<p>算术表达式的文法 G[E] 如下：  </p>
<blockquote>
<p> E → E+T | E-T | T<br> T → T*F | T/F | F<br> F → (E) | d</p>
</blockquote>
<p>消去非终结符E和T的左递归后，改写 G[E] 文法如下：</p>
<blockquote>
<p>E → TE’<br>E’ → +TE’ | -TE’ | ε<br>T → FT’<br>T’ → *FT’ | /FT’ | ε<br>F → (E) | d</p>
</blockquote>
<p>可以证明上述无递归文法是 LL(1) 文法，可以使用 <strong>递归下降分析法</strong>。递归下降分析法是确定的自上而下分析法，这种分析法要求文法是 LL(1) 文法。它的<strong>基本思想</strong>是：对文法中的每一个非终结符编写一个函数（或子程序），每个函数（或子程序）的功能是识别由该非终结符所表示的语法成分。</p>
<p>构造递归下降分析程序时，每个函数名是相应的非终结符，函数体是根据规则右部符号串的结构编写：</p>
<ul>
<li><p>当遇到终结符 a 时，则编写语句<br>if（当前读来的输入符号 == a）读下一个输入符号；</p>
</li>
<li><p>当遇到非终结符 A 时，则编写语句调用 A( )；</p>
</li>
<li><p>当遇到 A-&gt;ε 规则时，则编写语句<br>if（当前读来的输入符号 不属于 FOLLOW(A)）error()；</p>
</li>
<li><p>当某个非终结符的规则有多个候选式时，按 LL(1) 文法的条件能唯一地选择一个候选式进行推导。</p>
</li>
</ul>
<p>所以我们需要求出 <strong>FOLLOW(E’)</strong> 和 <strong>FOLLOW(T’)</strong>：</p>
<p><img src="http://img.blog.csdn.net/20150510181122458" alt=""></p>
<p>好了，下面直接上代码，在词法分析的基础上进行语法分析：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line"><span class="built_in">string</span> expr = <span class="string">"(1.5+5.789)*82-10/2"</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sym;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*--------------------------------词法分析----------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------语法分析----------------------------*/</span></span><br><span class="line"><span class="comment">// 读下一单词的种别编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; word.size())</span><br><span class="line">        sym = word[idx++].second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sym = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E → TE' </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T();</span><br><span class="line">    E1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E' → +TE' | -TE' | ε </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sym == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        T();</span><br><span class="line">        E1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        T();</span><br><span class="line">        E1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym != <span class="number">7</span> &amp;&amp; sym != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T → FT' </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    F();</span><br><span class="line">    T1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T' → *FT' | /FT' | ε </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sym == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        F();</span><br><span class="line">        T1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        F();</span><br><span class="line">        T1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym != <span class="number">1</span> &amp;&amp; sym != <span class="number">2</span> &amp;&amp; sym != <span class="number">7</span> &amp;&amp; sym != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F → (E) | d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sym == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span>(sym == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            err = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; endl &lt;&lt; <span class="string">"Word Analysis:"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 测试输出</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;::iterator beg = word.begin();</span><br><span class="line">        <span class="keyword">for</span>(;beg!=word.end(); ++beg)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"   ("</span> &lt;&lt; beg-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 词法正确，进行语法分析</span></span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span> (sym == <span class="number">0</span> &amp;&amp; err == <span class="number">0</span>)  <span class="comment">// 注意要判断两个条件</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right Expression."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong Expression."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，还有一种更简单的形式，将文法 G(E) 用<strong>扩充BNF表示法</strong>进行改写：</p>
<blockquote>
<p>E → T { +T | -T }<br>T → F { *F | /F }<br>F → (E) | d</p>
</blockquote>
<p>然后对这种变形文法使用递归下降分析法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line"><span class="built_in">string</span> expr = <span class="string">"(1.5+5.789)*82-10/2"</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sym;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*--------------------------------词法分析----------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------语法分析----------------------------*/</span></span><br><span class="line"><span class="comment">// 读下一单词的种别编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; word.size())</span><br><span class="line">        sym = word[idx++].second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sym = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E → T &#123; +T | -T &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T();</span><br><span class="line">    <span class="keyword">while</span>(sym == <span class="number">1</span> || sym == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        T();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T → F &#123; *F | /F &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    F();</span><br><span class="line">    <span class="keyword">while</span>(sym == <span class="number">3</span> || sym == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        F();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F → (E) | d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sym == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span> (sym == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            err = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; endl &lt;&lt; <span class="string">"Word Analysis:"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 测试输出</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;::iterator beg = word.begin();</span><br><span class="line">        <span class="keyword">for</span>(;beg!=word.end(); ++beg)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"   ("</span> &lt;&lt; beg-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 词法正确，进行语法分析</span></span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span> (sym == <span class="number">0</span> &amp;&amp; err == <span class="number">0</span>)  <span class="comment">// 注意要判断两个条件</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right Expression."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong Expression."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于这种文法形式写程序，<strong>只需要写3个函数（因为只有3个非终结符），而且不需要求 FOLLOW 集合。</strong></p>
<p>测试结果：</p>
<p><img src="http://img.blog.csdn.net/20141006200250847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><br><br><br></p>
<p><a href="http://songlee24.github.io/2014/10/10/arithmetic-expression-02/" target="_blank" rel="external"><span style="font-size:25px">算术表达式的合法性判断与求值（下）&gt;&gt;</span></a></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写一个计算器时遇到了一个问题，就是对字符串表示的<strong>算术表达式</strong>的合法性判断与求值。下面记录一下我的解决方案。</p>
<h3 id="一、问题描述">一、问题描述</h3><p>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。</p>
<p>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</p>
<h3 id="二、判断表达式的合法性">二、判断表达式的合法性</h3>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux编程】C/C++获取目录下文件或目录]]></title>
    <link href="http://yoursite.com/2014/09/20/linux-get-directory/"/>
    <id>http://yoursite.com/2014/09/20/linux-get-directory/</id>
    <published>2014-09-20T09:04:17.000Z</published>
    <updated>2015-05-10T08:46:09.871Z</updated>
    <content type="html"><![CDATA[<p>在Unix/Linux系统中，要获取一个指定目录下所有的文件或文件夹，一般用<code>dirent.h</code>（POSIX标准定义的目录操作头文件）。</p>
<h3 id="一、数据类型">一、数据类型</h3><p>在头文件<code>&lt;dirent.h&gt;</code>中定义了两种主要的数据类型。</p>
<p><strong>DIR</strong>：代表一个目录流的结构。<a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __dirstream</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *__fd;              <span class="comment">/* 'struct hurd_fd' pointer for descriptor.*/</span></span><br><span class="line">    <span class="keyword">char</span> *__data;            <span class="comment">/* Directory block.  */</span></span><br><span class="line">    <span class="keyword">int</span> __entry_data;        <span class="comment">/* Entry number `__data' corresponds to.*/</span></span><br><span class="line">    <span class="keyword">char</span> *__ptr;             <span class="comment">/* Current pointer into the block.*/</span></span><br><span class="line">    <span class="keyword">int</span> __entry_ptr;         <span class="comment">/* Entry number `__ptr' corresponds to.*/</span></span><br><span class="line">    size_t __allocation;          <span class="comment">/* Space allocated for the block.*/</span></span><br><span class="line">    size_t __size;                <span class="comment">/* Total valid data in the block.*/</span></span><br><span class="line">    __libc_lock_define (, __lock) <span class="comment">/* Mutex lock for this structure.*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __dirstream DIR;</span><br></pre></td></tr></table></figure></p>
<p><strong>struct dirent</strong>：包含一个文件或目录信息的结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dirent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> d_ino;                 <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">    off_t d_off;                <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;       <span class="comment">/* the type of d_name 文件类型 */</span>    </span><br><span class="line">    <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>];   <span class="comment">/* file name 文件名，最长255字符 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、函数原型">二、函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DIR* opendir(<span class="keyword">const</span> <span class="keyword">char</span>* dirname);</span><br><span class="line"><span class="comment">/* 打开一个目录：</span><br><span class="line">        成功 - 返回指向DIR类型对象的指针。</span><br><span class="line">        失败 - 返回NULL    */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 关闭目录流：</span><br><span class="line">        成功 - 返回0</span><br><span class="line">        失败 - 返回-1    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *readdir(DIR *dirp);</span><br><span class="line"><span class="comment">/* 读取目录流：</span><br><span class="line">        成功 - 返回指向struct dirent对象的指针。</span><br><span class="line">        失败 - 返回NULL（出错或流末尾）  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readdir_r</span><span class="params">(DIR *dirp, <span class="keyword">struct</span> dirent *entry, <span class="keyword">struct</span> dirent **result)</span></span>;</span><br><span class="line"><span class="comment">/* 读取目录流：用 dirp 当前位置的目录初始化entry，并让 result 指向 entry。</span><br><span class="line">        成功 - 返回0</span><br><span class="line">        失败 - 返回error number   */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 重置目录流的位置到开头 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dirp, <span class="keyword">long</span> <span class="keyword">int</span> loc)</span></span>;</span><br><span class="line"><span class="comment">/* 设置目录流的位置，设置以后readdir()会读取到loc位置的目录。 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">telldir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回目录流的当前位置 */</span></span><br></pre></td></tr></table></figure>
<h3 id="三、示例代码">三、示例代码</h3><p>下面是一段 C 代码，输出指定目录下的所有文件或目录名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;dirent.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	DIR *dp;</span><br><span class="line">	<span class="keyword">struct</span> dirent *dirp;</span><br><span class="line">	<span class="keyword">char</span> dirname[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please input a directory: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,dirname);</span><br><span class="line">	<span class="keyword">if</span>((dp = opendir(dirname)) == NULL)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Can't open %s\n"</span>, dirname);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;dirent.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> dirname;</span><br><span class="line">	DIR *dp;</span><br><span class="line">	<span class="keyword">struct</span> dirent *dirp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input a directory: "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; dirname;</span><br><span class="line">	<span class="keyword">if</span>((dp = opendir(dirname.c_str())) == NULL)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't open "</span> &lt;&lt; dirname &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dirp-&gt;d_name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有些情况下，我们只要输出文件而不需要文件夹（目录），这时可以通过<code>dirent</code>结构体中的<code>d_type</code>进行过滤。<code>d_type</code>表示类型，4表示目录，8表示普通文件，0表示未知设备。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">	<span class="keyword">if</span>(dirp-&gt;d_type == <span class="number">8</span>)  <span class="comment">// 只输出文件名，不输出目录名</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dirp-&gt;d_name &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>如果需要查找指定类型（特定后缀）的文件，可以使用<strong>C++11</strong>的正则表达式进行匹配：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include&lt;regex&gt;</span></span><br><span class="line"><span class="function">regex <span class="title">reg_obj</span><span class="params">(".*\.doc", regex::icase)</span></span>;</span><br><span class="line"><span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">	<span class="keyword">if</span>(regex_match(dirp-&gt;d_name, reg_obj))  <span class="comment">// regex_match()匹配</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dirp-&gt;d_name &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>另外，Unix/linux下提供了POSIX标准的正则库<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html" target="_blank" rel="external"> regex.h </a> 。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Unix/Linux系统中，要获取一个指定目录下所有的文件或文件夹，一般用<code>dirent.h</code>（POSIX标准定义的目录操作头文件）。</p>
<h3 id="一、数据类型">一、数据类型</h3><p>在头文件<code>&lt;dirent.h&gt;</code>中定义了两种主要的数据类型。</p>
<p><strong>DIR</strong>：代表一个目录流的结构。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C/C++内存对齐]]></title>
    <link href="http://yoursite.com/2014/09/20/memory-alignment/"/>
    <id>http://yoursite.com/2014/09/20/memory-alignment/</id>
    <published>2014-09-19T17:57:06.000Z</published>
    <updated>2015-05-10T08:42:58.436Z</updated>
    <content type="html"><![CDATA[<p>下面是网易的一道笔试题：<code>struct { uint32_t m1; char m2; } varray[2];</code>以下哪些判断一定成立？（多选）</p>
<ol>
<li><code>sizeof(varray[0]) == 5</code></li>
<li><code>sizeof(varray[0]) == 8</code></li>
<li><code>(void*)&amp;(varray[0].m1) &lt; (void*)&amp;(varray[0].m2)</code></li>
<li><code>(char*)&amp;varray[0] == (char*)&amp;(varray[0].m1)</code></li>
<li><code>(char*)&amp;varray[0] + sizeof(varray[0]) == (char*)&amp;varray[1]</code></li>
<li><code>(char*)&amp;(varray[0].m2) + 1 == (char*)&amp;varray[1]</code></li>
<li><code>(char*)&amp;(varray[0].m2) + 4 == (char*)&amp;varray[1]</code></li>
</ol>
<p>这个题目考查的就是内存对齐的知识点，看完这篇文章你就知道这道题应该选什么了。<a id="more"></a></p>
<p><br></p>
<h3 id="一、什么是内存对齐">一、什么是内存对齐</h3><p><strong>内存对齐（Memory alignment）</strong>，也叫字节对齐。</p>
<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>举一个简单的例子，<code>uint32_t</code>所占内存空间为 4 bytes，<code>char</code>为 1 byte。如果把它们放在一个结构体中，则所占的内存空间应该是 4 + 1 = 5 bytes 。而事实上，在VS2012和gcc环境下，sizeof 操作的结果都是 8 bytes：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> m1;    <span class="comment">// #include&lt;stdint.h&gt;</span></span><br><span class="line">    <span class="keyword">char</span> m2;</span><br><span class="line">&#125;varray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(varray.m1));  <span class="comment">// 输出4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(varray.m2));  <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(varray));     <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示图：</p>
<p><img src="http://img.blog.csdn.net/20140921230124812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这里是以4个字节为一个对齐单位。</p>
<p><br></p>
<h3 id="二、为什么要内存对齐">二、为什么要内存对齐</h3><p>之所以要内存对齐，有两方面的原因：</p>
<ul>
<li><p><strong>平台原因</strong>：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。————- 比如，有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。</p>
</li>
<li><p><strong>性能原因</strong>：内存对齐可以提高存取效率。————- 比如，有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。</p>
</li>
</ul>
<p><br></p>
<h3 id="三、对齐的规则">三、对齐的规则</h3><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。你可以通过预编译命令<code>#pragma pack(n)</code>，n=1,2,4,8,16 来改变这一系数，其中 n 就是你要指定的“对齐系数”。</p>
<p><strong>1）概念：</strong></p>
<p><strong>有效对齐值</strong>：是 <code>#pragma pack</code>指定值 和 结构体中最长数据类型长度 中<strong>较小</strong>的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p>注意：VS、VC 默认是#pragma pack(8)，而 gcc 默认是#pragma pack(4)，并且gcc只支持1，2，4对齐。</p>
<p><strong>2）规则：</strong></p>
<ol>
<li><p>结构体变量的<strong>首地址</strong>是有效对齐值（对齐单位）的整数倍。</p>
</li>
<li><p>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
</li>
<li><p><strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
</li>
<li><p>结构体内类型相同的连续元素将在连续的空间内，和数组一样。</p>
</li>
</ol>
<p>下面给出几个例子帮助理解（测试环境为VS2012）：</p>
<p>例一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;    <span class="comment">// 4个字节</span></span><br><span class="line">    <span class="keyword">char</span> c1;  <span class="comment">// 1个字节</span></span><br><span class="line">    <span class="keyword">char</span> c2;  <span class="comment">// 1个字节</span></span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1;  <span class="comment">// 1个字节</span></span><br><span class="line">    <span class="keyword">int</span> i;    <span class="comment">// 4个字节</span></span><br><span class="line">    <span class="keyword">char</span> c2;  <span class="comment">// 1个字节</span></span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c1;  <span class="comment">// 1个字节</span></span><br><span class="line">    <span class="keyword">char</span> c2;  <span class="comment">// 1个字节</span></span><br><span class="line">    <span class="keyword">int</span> i;    <span class="comment">// 4个字节</span></span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，上面定义的三个结构体只是交换了成员声明的顺序。由于结构体中最长的数据类型为4个字节，而VS2010默认#pragma pack(8)，所以<strong>有效对齐值（对齐单位）为 4 bytes</strong>。根据前三条规则可以画出以下图：</p>
<p><img src="http://img.blog.csdn.net/20140922013948031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>例二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 4个字节</span></span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">6</span>];  <span class="comment">// 6个字节</span></span><br><span class="line">    <span class="keyword">double</span> c;   <span class="comment">// 8个字节</span></span><br><span class="line">&#125;st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(st));  <span class="comment">// 输出24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面结构体中最长的数据类型 double 为 8 个字节，而VS2012中默认#pragma pack(8)，所以<strong>有效对齐值（对齐单位）</strong>为 <strong>8 bytes</strong>。根据前三条规则可以画出以下图：</p>
<p><img src="http://img.blog.csdn.net/20140922222535500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>其中的字符数组 <code>char b[6]</code> 可以看做6个单独的 char 成员。</p>
<p><br></p>
<h3 id="四、pragma_pack(n)">四、pragma pack(n)</h3><ul>
<li><p>上面说到，不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令<code>#pragma pack(n)</code>，n=1,2,4,8,16 来改变这一对齐系数。</p>
</li>
<li><p><code>#pragma pack(n)</code>是通过改变<strong>有效对齐值</strong>来改变数据成员在内存中的布局，若你设定的 n 值没有影响或改变有效对齐值，则成员在内存中的布局不会改变。</p>
</li>
</ul>
<p>下面就看看在1、2、4字节对齐的情况下例一、例二的变化：</p>
<p><strong>1字节对齐：#pragma pack(1)</strong></p>
<p>这时的有效对齐值（对齐单位）为 1 字节，则根据对齐规则，可知成员都是连续存储的。</p>
<p>例一中的输出结果会变为 6，6，6，如下图：</p>
<p><img src="http://img.blog.csdn.net/20140922203635315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>例二中输出结果则变为 4 + 6 + 8 = 18：</p>
<p><img src="http://img.blog.csdn.net/20140922223352175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>2字节对齐：#pragma pack(2)</strong></p>
<p>这时的有效对齐值（对齐单位）为 2 字节，则根据对齐规则，可知例一的输出结果会变为 6，8，6，如下图：</p>
<p><img src="http://img.blog.csdn.net/20140922211012703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>例二结构体中最长数据类型 double 为 8 个字节，所以有效对齐值是 2 。此时输出结果还是18，如下图：</p>
<p><img src="http://img.blog.csdn.net/20140922224436503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>4字节对齐：#pragma pack(4)</strong></p>
<p>对于例一，结构体中最长的数据类型 int 是 4 个字节，所以此时的有效对齐值（对齐单位）仍为 4，没有变化，所以输出仍然是 8，12，8。</p>
<p>而在例二中，原来的有效对齐值为 8，现在变成了 4 。所以输出结果变为 20，具体如下图：</p>
<p><img src="http://img.blog.csdn.net/20140922225651156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>对于 8 字节对齐、 16 字节对齐，在这里就不举例了，相信根据对齐规则你可以很容易写出来。需要注意的是，有些编译器，比如gcc，只支持 1，2，4 对齐。</p>
<p><br><br><br><br></p>
<h3 id="附：答案">附：答案</h3><p>相信看到这里，文章开头的那个网易笔试题应该就很容易得出答案了。只需要根据内存对齐把结构体的内存布局图画出来就一目了然了：</p>
<p><img src="http://img.blog.csdn.net/20140922231621296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>所以多选答案应该是 2、4、5、7。</p>
<p>对于这种类型的题目，最好的办法就是根据对齐规则画出对齐后的内存布局图，简单清晰且不容易出错。</p>
<p>（全文完）</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面是网易的一道笔试题：<code>struct { uint32_t m1; char m2; } varray[2];</code>以下哪些判断一定成立？（多选）</p>
<ol>
<li><code>sizeof(varray[0]) == 5</code></li>
<li><code>sizeof(varray[0]) == 8</code></li>
<li><code>(void*)&amp;(varray[0].m1) &lt; (void*)&amp;(varray[0].m2)</code></li>
<li><code>(char*)&amp;varray[0] == (char*)&amp;(varray[0].m1)</code></li>
<li><code>(char*)&amp;varray[0] + sizeof(varray[0]) == (char*)&amp;varray[1]</code></li>
<li><code>(char*)&amp;(varray[0].m2) + 1 == (char*)&amp;varray[1]</code></li>
<li><code>(char*)&amp;(varray[0].m2) + 4 == (char*)&amp;varray[1]</code></li>
</ol>
<p>这个题目考查的就是内存对齐的知识点，看完这篇文章你就知道这道题应该选什么了。]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++进阶之虚函数表]]></title>
    <link href="http://yoursite.com/2014/09/02/cpp-virtual-table/"/>
    <id>http://yoursite.com/2014/09/02/cpp-virtual-table/</id>
    <published>2014-09-02T02:41:56.000Z</published>
    <updated>2015-05-10T08:48:59.540Z</updated>
    <content type="html"><![CDATA[<p>C++通过<a href="http://songlee24.github.io/2014/07/17/cpp-inheritance/" target="_blank" rel="external">继承（inheritance）</a>和<a href="http://songlee24.github.io/2014/07/17/cpp-virtual-function/" target="_blank" rel="external">虚函数（virtual function）</a>来实现多态性。所谓多态，简单地说就是，将基类的指针或引用绑定到子类的实例，然后通过基类的指针或引用调用实际子类的成员函数（虚函数）。本文将介绍单继承、多重继承下虚函数的实现机制。</p>
<p><br></p>
<h3 id="一、虚函数表">一、虚函数表</h3><p>为了支持虚函数机制，编译器为每一个拥有虚函数的类的实例创建了一个<strong>虚函数表（virtual table）</strong>，这个表中有许多的<strong>槽（slot）</strong>，每个槽中存放的是虚函数的地址。虚函数表解决了继承、覆盖、添加虚函数的问题，保证其真实反应实际的函数。<a id="more"></a></p>
<p>为了能够找到 virtual table，编译器在每个拥有虚函数的类的实例中插入了一个成员指针 vptr，指向虚函数表。下面是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::x()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line">	<span class="keyword">int</span>* vptr = (<span class="keyword">int</span>*)&amp;b;                     <span class="comment">// 虚函数表地址</span></span><br><span class="line"></span><br><span class="line">	pFun func1 = (pFun)*((<span class="keyword">int</span>*)*vptr);        <span class="comment">// 第一个函数</span></span><br><span class="line">	pFun func2 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">1</span>);      <span class="comment">// 第二个函数</span></span><br><span class="line">	pFun func3 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">2</span>);      <span class="comment">// 第三个函数</span></span><br><span class="line">	</span><br><span class="line">	func1();     <span class="comment">// 输出Base::x()</span></span><br><span class="line">	func2();     <span class="comment">// 输出Base::y()</span></span><br><span class="line">	func3();     <span class="comment">// 输出Base::z()</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面定义了一个Base类，其中有三个虚函数。我们将Base类对象取址 &amp;b 并强制转换为 int<em>，取得虚函数表的地址。然后对虚函数表的地址取值 \</em>vptr 并强转为 int*，即取得第一个虚函数的地址了。将第一个虚函数的地址加1，取得第二个虚函数的地址，再加1即取得第三个虚函数的地址。</p>
<p><strong>注意</strong>，之所以可以通过对象实例的地址得到虚函数表，是因为 vptr 指针位于对象实例的最前面（这是由编译器决定的，主要是为了保证取到虚函数表有最高的性能——如果有多层继承或是多重继承的情况下）。如图所示：</p>
<p><img src="http://img.blog.csdn.net/20140831232526064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>在VS2012中加断点进行Debug可以查看到虚函数表：</p>
<p><img src="http://img.blog.csdn.net/20140831233726598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><br></p>
<h3 id="二、单继承时的虚函数表">二、单继承时的虚函数表</h3><p><strong>1、无虚函数覆盖</strong></p>
<p>假如现有单继承关系如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::x()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::x1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::y1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::z1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个单继承的关系中，子类没有重写父类的任何方法，而是加入了三个新的虚函数。Derive类实例的虚函数表布局如图示：</p>
<p><img src="http://img.blog.csdn.net/20140901001226046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ul>
<li>Derive class 继承了 Base class 中的三个虚函数，准确的说，是该函数实体的地址被拷贝到 Derive 实例的虚函数表对应的 slot 之中。</li>
<li>新增的 虚函数 置于虚函数表的后面，并按声明顺序存放。</li>
</ul>
<p><strong>2、有虚函数覆盖</strong></p>
<p>如果在继承关系中，子类重写了父类的虚函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::x()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::x()"</span> &lt;&lt; endl; &#125;  <span class="comment">// 重写</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::y1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::z1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>则Derive类实例的虚函数表布局为：</p>
<p><img src="http://img.blog.csdn.net/20140901004001914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>相比于无覆盖的情况，只是把 <code>Derive::x()</code> 覆盖了<code>Base::x()</code>，即第一个槽的函数地址发生了变化，其他的没有变化。</p>
<p>这时，如果通过绑定了子类对象的基类指针调用函数 x()，会执行 Derive 版本的 x()，这就是多态。</p>
<p><br></p>
<h3 id="三、多重继承时的虚函数表">三、多重继承时的虚函数表</h3><p><strong>1、无虚函数覆盖</strong></p>
<p>现有如下的多重继承关系，子类没有覆盖父类的虚函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::x()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::x()"</span> &lt;&lt; endl; &#125;  </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::x1()"</span> &lt;&lt; endl; &#125;  </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::y1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于 Derive 实例 d 的虚函数表布局，如下图：</p>
<p><img src="http://img.blog.csdn.net/20140901222958703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>可以看出：</p>
<ul>
<li>每个基类子对象对应一个虚函数表。</li>
<li>派生类中新增的虚函数放到第一个虚函数表的后面。</li>
</ul>
<p>测试代码（VS2012）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Derive b;</span><br><span class="line">	<span class="keyword">int</span>** vptr = (<span class="keyword">int</span>**)&amp;b;                     <span class="comment">// 虚函数表地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// virtual table 1</span></span><br><span class="line">	pFun table1_func1 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">0</span>);         <span class="comment">// vptr[0][0]</span></span><br><span class="line">	pFun table1_func2 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">1</span>);         <span class="comment">// vptr[0][1]</span></span><br><span class="line">	pFun table1_func3 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">2</span>);         <span class="comment">// vptr[0][2]</span></span><br><span class="line">	pFun table1_func4 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">3</span>);         <span class="comment">// vptr[0][3]</span></span><br><span class="line">	pFun table1_func5 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">4</span>);         <span class="comment">// vptr[0][4]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// virtual table 2</span></span><br><span class="line">	pFun table2_func1 = (pFun)*((<span class="keyword">int</span>*)*(vptr+<span class="number">1</span>)+<span class="number">0</span>);     <span class="comment">// vptr[1][0]</span></span><br><span class="line">	pFun table2_func2 = (pFun)*((<span class="keyword">int</span>*)*(vptr+<span class="number">1</span>)+<span class="number">1</span>);     <span class="comment">// vptr[1][1]</span></span><br><span class="line">	pFun table2_func3 = (pFun)*((<span class="keyword">int</span>*)*(vptr+<span class="number">1</span>)+<span class="number">2</span>);     <span class="comment">// vptr[1][2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call</span></span><br><span class="line">	table1_func1();</span><br><span class="line">	table1_func2();</span><br><span class="line">	table1_func3();</span><br><span class="line">	table1_func4();</span><br><span class="line">	table1_func5();</span><br><span class="line"></span><br><span class="line">	table2_func1();</span><br><span class="line">	table2_func2();</span><br><span class="line">	table2_func3();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不同的编译器对 virtual table 的实现不同，经测试，在 <strong>g++</strong> 中需要这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// virtual table 1</span></span><br><span class="line">pFun table1_func1 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">0</span>);         <span class="comment">// vptr[0][0]</span></span><br><span class="line">pFun table1_func2 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">2</span>);         <span class="comment">// vptr[0][2]</span></span><br><span class="line">pFun table1_func3 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">4</span>);         <span class="comment">// vptr[0][4]</span></span><br><span class="line">pFun table1_func4 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">6</span>);         <span class="comment">// vptr[0][6]</span></span><br><span class="line">pFun table1_func5 = (pFun)*((<span class="keyword">int</span>*)*vptr+<span class="number">8</span>);         <span class="comment">// vptr[0][8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtual table 2</span></span><br><span class="line">pFun table2_func1 = (pFun)*((<span class="keyword">int</span>*)*(vptr+<span class="number">1</span>)+<span class="number">0</span>);     <span class="comment">// vptr[1][0]</span></span><br><span class="line">pFun table2_func2 = (pFun)*((<span class="keyword">int</span>*)*(vptr+<span class="number">1</span>)+<span class="number">2</span>);     <span class="comment">// vptr[1][2]</span></span><br><span class="line">pFun table2_func3 = (pFun)*((<span class="keyword">int</span>*)*(vptr+<span class="number">1</span>)+<span class="number">4</span>);     <span class="comment">// vptr[1][4]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、有虚函数覆盖</strong></p>
<p>将上面的多重继承关系稍作修改，让子类重写基类的 x() 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::x()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::x()"</span> &lt;&lt; endl; &#125;  </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::y()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::z()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::x()"</span> &lt;&lt; endl; &#125;     <span class="comment">// 重写</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::y1()"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这时 Derive 实例的虚函数表布局会变成下面这个样子：</p>
<p><img src="http://img.blog.csdn.net/20140901223514154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>相比于无覆盖的情况，只是将<code>Derive::x()</code>覆盖了<code>Base1::x()</code>和<code>Base2::x()</code>而已，你可以自己写测试代码测试一下，这里就不再赘述了。</p>
<p>注：若虚函数是 private 或 protected 的，我们照样可以通过访问虚函数表来访问这些虚函数，即上面的测试代码一样能运行。</p>
<p><br><br><br><br></p>
<h3 id="附：编译器对指针的调整">附：编译器对指针的调整</h3><p>在多重继承下，我们可以将子类实例绑定到任一父类的指针（或引用）上。以<strong>上述有覆盖的多重继承关系</strong>为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive b;</span><br><span class="line">Base1* ptr1 = &amp;b;   <span class="comment">// 指向 b 的初始地址</span></span><br><span class="line">Base2* ptr2 = &amp;b;   <span class="comment">// 指向 b 的第二个子对象</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>因为 Base1 是第一个基类，所以 ptr1 指向的是 Derive 对象的起始地址，不需要调整指针（偏移）。</li>
<li>因为 Base2 是第二个基类，所以必须对指针进行调整，即加上一个 offset，让 ptr2 指向 Base2 子对象。</li>
<li>当然，上述过程是由编译器完成的。</li>
</ul>
<p>当然，你可以在VS2012里通过Debug看出 ptr1 和 ptr2 是不同的，我们可以这样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base1* b1 = (Base1*)ptr2;  </span><br><span class="line">b1-&gt;y();                   <span class="comment">// 输出 Base2::y()</span></span><br><span class="line">Base2* b2 = (Base2*)ptr1;   </span><br><span class="line">b2-&gt;y();                   <span class="comment">// 输出 Base1::y()</span></span><br></pre></td></tr></table></figure></p>
<p>其实，通过某个类型的指针访问某个成员时，编译器只是根据类型的定义查找这个成员所在偏移量，用这个偏移量获取成员。由于 ptr2 本来就指向 Base2 子对象的起始地址，所以<code>b1-&gt;y()</code>调用到的是<code>Base2::y()</code>，而 ptr1 本来就指向 Base1 子对象的起始地址（即 Derive对象的起始地址），所以<code>b2-&gt;y()</code>调用到的是<code>Base1::y()</code>。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++通过<a href="http://songlee24.github.io/2014/07/17/cpp-inheritance/">继承（inheritance）</a>和<a href="http://songlee24.github.io/2014/07/17/cpp-virtual-function/">虚函数（virtual function）</a>来实现多态性。所谓多态，简单地说就是，将基类的指针或引用绑定到子类的实例，然后通过基类的指针或引用调用实际子类的成员函数（虚函数）。本文将介绍单继承、多重继承下虚函数的实现机制。</p>
<p><br></p>
<h3 id="一、虚函数表">一、虚函数表</h3><p>为了支持虚函数机制，编译器为每一个拥有虚函数的类的实例创建了一个<strong>虚函数表（virtual table）</strong>，这个表中有许多的<strong>槽（slot）</strong>，每个槽中存放的是虚函数的地址。虚函数表解决了继承、覆盖、添加虚函数的问题，保证其真实反应实际的函数。]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3标准库（二） re模块]]></title>
    <link href="http://yoursite.com/2014/09/01/python-library-02/"/>
    <id>http://yoursite.com/2014/09/01/python-library-02/</id>
    <published>2014-09-01T10:12:17.000Z</published>
    <updated>2015-05-10T08:19:01.626Z</updated>
    <content type="html"><![CDATA[<p><strong>正则表达式（Regular Expression）</strong>是字符串处理的常用工具，通常被用来检索、替换那些符合某个模式（Pattern）的文本。很多程序设计语言都支持正则表达式，像Perl、Java、C/C++。在 Python 中是通过标准库中的 <strong>re 模块</strong> 提供对正则的支持。</p>
<p><br></p>
<h3 id="一、正则表达式介绍">一、正则表达式介绍</h3><p><strong>1）用途</strong></p>
<p>通过使用正则表达式，可以： <a id="more"></a></p>
<ul>
<li><p>测试字符串内的模式。—— 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</p>
</li>
<li><p>替换文本。—— 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</p>
</li>
<li><p>基于模式匹配从字符串中提取子字符串。—— 可以查找文档内或输入域内特定的文本。</p>
</li>
</ul>
<p><strong>2）语法</strong></p>
<p>本文主要介绍正则的基本语法以及 re 模块的使用，不包括如何编写高效的正则表达式、如何优化正则表达式，这些主题请看其他教程。</p>
<p>下图列出了Python支持的一些正则表达式元字符和语法：</p>
<p><img src="http://img.blog.csdn.net/20140929200042391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>3）贪婪模式与非贪婪模式</strong></p>
<p>“贪婪模式”总是尝试匹配尽可能多的字符；“非贪婪模式”则相反，总是匹配尽可能少的字符。例如，用”ab<em>“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab</em>?”，将找到”a”。</p>
<p><br></p>
<h3 id="二、使用_re_模块">二、使用 re 模块</h3><p><strong>1）编译正则表达式</strong></p>
<p>re 模块提供了 <a href="https://docs.python.org/3/library/re.html#re.compile" target="_blank" rel="external">re.compile()</a> 函数将一个字符串编译成 pattern object，用于匹配或搜索。函数原型如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>re.compile() 还接受一个可选的参数 flag，用于指定正则匹配的模式。关于匹配模式，后面将会讲到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = re.compile(<span class="string">'ab*'</span>, re.IGNORECASE)</span><br></pre></td></tr></table></figure>
<p><strong>2）反斜杠的困扰</strong></p>
<p>在 python 的字符串中，\ 是被当做转义字符的。在正则表达式中，\ 也是被当做转义字符。这就导致了一个问题：如果你要匹配 \ 字符串，那么传递给 re.compile() 的字符串必须是”\\\\“。</p>
<p>由于字符串的转义，所以实际传递给 re.compile() 的是”\\“，然后再通过正则表达式的转义，”\\“ 会匹配到字符”\“。这样虽然可以正确匹配到字符 \，但是很麻烦，而且容易漏写反斜杠而导致 Bug。那么有什么好的解决方案呢？ </p>
<p><strong>原始字符串</strong>很好的解决了这个问题，通过在字符串前面添加一个r，表示原始字符串，不让字符串的反斜杠发生转义。那么就可以使用<code>r&quot;\\&quot;</code>来匹配字符 <code>\</code>了。</p>
<p><strong>3）pattern object 执行匹配</strong></p>
<p>一旦你编译得到了一个 pattern object，你就可以使用 pattern object 的方法或属性进行匹配了，下面列举几个常用的方法，更多请看<a href="https://docs.python.org/3/library/re.html#regular-expression-objects" target="_blank" rel="external">这里</a>。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.match" target="_blank" rel="external"><code>regex.match(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>匹配从 pos 到 endpos 的字符子串的开头。匹配成功返回一个 match object，不匹配返回 None。</li>
<li>pos 的默认值是0，endpos 的默认值是 len(string)，所以默认情况下是匹配整个字符串的开头。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = re.compile(<span class="string">"ar&#123;1&#125;"</span>)</span><br><span class="line">print(pattern.match(<span class="string">"army"</span>))     <span class="comment"># "ar"在开头，匹配成功</span></span><br><span class="line">print(pattern.match(<span class="string">"mary"</span>))     <span class="comment"># "ar"不在开头，匹配失败</span></span><br><span class="line">print(pattern.match(<span class="string">"mary"</span>, <span class="number">1</span>))  <span class="comment"># "ar"不在开头，但在子串的开头</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(0, 2), match='ar'&gt;</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(1, 3), match='ar'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.search" target="_blank" rel="external"><code>regex.search(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>扫描整个字符串，并返回它找到的第一个匹配（Match object）。</li>
<li>和 regex.match() 一样，可以通过 pos 和 endpos 指定范围。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">"ar&#123;1&#125;"</span>)</span><br><span class="line">match = pattern.search(<span class="string">"mary"</span>)   <span class="comment"># search</span></span><br><span class="line">print(match)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(1, 3), match='ar'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.findall" target="_blank" rel="external"><code>regex.findall(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>找到所有匹配的子串，并返回一个 list 。</li>
<li>可选参数 pos 和 endpos 和上面一样。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"\d+"</span>)</span><br><span class="line">lst = pattern.findall(<span class="string">"abc1def2rst3xyz"</span>)   <span class="comment"># findall</span></span><br><span class="line">print(lst)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># ['1', '2', '3']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.finditer" target="_blank" rel="external"><code>regex.finditer(string[, pos[, endpos]])</code></a>：</p>
<ul>
<li>找到所有匹配的子串，并返回由这些匹配结果（match object）组成的迭代器。</li>
<li>可选参数 pos 和 endpos 和上面一样。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"\d+"</span>)</span><br><span class="line">p = pattern.finditer(<span class="string">"abc1def2rst3xyz"</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(3, 4), match='1'&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(7, 8), match='2'&gt;</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(11, 12), match='3'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>4）match object 获取结果</strong></p>
<p>在上面讲到，通过 pattern object 的方法（除 findall 外）进行匹配得到的返回结果都是 <strong>match object</strong>。每一个 match object 都包含了匹配到的相关信息，比如，起始位置、匹配到的子串。那么，我们如何从 match object 中提取这些信息呢？</p>
<p>match object 提供了一些方法，下面列举几个常用的方法，更多请看<a href="https://docs.python.org/3/library/re.html#match-objects" target="_blank" rel="external">这里</a>。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.match.group" target="_blank" rel="external"><code>match.group([group1, ...])</code></a>：</p>
<ul>
<li>返回 match object 中的字符串。</li>
<li>每一个 ( ) 都是一个分组，分组编号从1开始，从左往右，每遇到一个左括号，分组编号+1。</li>
<li>组 0 总是存在的，它就是整个表达式 。</li>
<li>没有参数时，group1默认为0，这时返回整个匹配到的字符串。</li>
<li>指定一个参数（整数）时，返回该分组匹配到的字符串。</li>
<li>指定多个参数时，返回由那几个分组匹配到的字符串组成的 tuple。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m)               <span class="comment"># &lt;_sre.SRE_Match object; span=(0, 11), match='Kobe Bryant'&gt;</span></span><br><span class="line">print(m.group())       <span class="comment"># Kobe Bryant</span></span><br><span class="line">print(m.group(<span class="number">1</span>))      <span class="comment"># Kobe</span></span><br><span class="line">print(m.group(<span class="number">2</span>))      <span class="comment"># Bryant</span></span><br><span class="line">print(m.group(<span class="number">1</span>, <span class="number">2</span>))   <span class="comment"># ('Kobe', 'Bryant')</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.groups" target="_blank" rel="external"><code>match.groups()</code></a>：</p>
<ul>
<li>返回由所有分组匹配到的字符串组成的 tuple。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+)\.(\d+)"</span>, <span class="string">"24.1632"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">'24'</span>, <span class="string">'1632'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.start" target="_blank" rel="external"><code>match.start([group])</code></a>：</p>
<ul>
<li>没有参数时，返回匹配到的字符串的起始位置。</li>
<li>指定参数（整数）时，返回该分组匹配到的字符串的起始位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m.start())       <span class="comment"># 0</span></span><br><span class="line">print(m.start(<span class="number">2</span>))      <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.end" target="_blank" rel="external"><code>match.end([group])</code></a>：</p>
<ul>
<li>没有参数时，返回匹配到的字符串的结束位置。</li>
<li>指定参数（整数）时，返回该分组匹配到的字符串的结束位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m.end())       <span class="comment"># 11</span></span><br><span class="line">print(m.end(<span class="number">1</span>))      <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.match.span" target="_blank" rel="external"><code>match.span([group])</code></a>：</p>
<ul>
<li>返回一个二元 tuple 表示匹配到的字符串的范围，即 (start, end)。</li>
<li>指定参数时，返回该分组匹配到的字符串的 (start, end)。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line">print(m.span())     <span class="comment"># (0, 11)</span></span><br><span class="line">print(m.span(<span class="number">2</span>))    <span class="comment"># (5, 11)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>5）模块级别的函数</strong></p>
<p>上面讲到的函数都是<strong>对象的方法</strong>，要使用它们必须先得到相应的对象。本节将介绍一些<strong>Module-Level Functions</strong>，比如 match()，search()，findall() 等等。你不需要创建一个 pattern object 就可以直接调用这些函数。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.compile" target="_blank" rel="external"><code>re.compile(pattern, flags=0)</code></a>：上面已经介绍过。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.match" target="_blank" rel="external"><code>re.match(pattern, string, flags=0)</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.match(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"> </span><br><span class="line">m = re.match(<span class="string">r"(\w+) (\w+)"</span>,<span class="string">"Kobe Bryant, Lakers"</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/re.html#re.search" target="_blank" rel="external"><code>re.search(pattern, string, flags=0)</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"(\w+) (\w+)"</span>)</span><br><span class="line">m = pattern.search(<span class="string">"Kobe Bryant, Lakers"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"> </span><br><span class="line">m = re.search(<span class="string">r"(\w+) (\w+)"</span>,<span class="string">"Kobe Bryant, Lakers"</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/re.html#re.findall" target="_blank" rel="external"><code>re.findall(pattern, string, flags=0)</code></a>：与上面类似。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.finditer" target="_blank" rel="external"><code>re.finditer(pattern, string, flags=0)</code></a>：与上面类似。</p>
<p><strong>6）编译标志（匹配模式）</strong></p>
<p>在讲 re.compile() 函数时，曾说到该函数还接受可选的第二个参数，用以设置<strong>匹配模式</strong>。可选的匹配模式有：</p>
<ul>
<li><p><strong>re.IGNORECASE</strong>：忽略大小写，同 <strong>re.I</strong>。</p>
</li>
<li><p><strong>re.MULTILINE</strong>：多行模式，改变^和$的行为，同 <strong>re.M</strong>。</p>
</li>
<li><p><strong>re.DOTALL</strong>：点任意匹配模式，让’.’可以匹配包括’\n’在内的任意字符，同 <strong>re.S</strong>。 </p>
</li>
<li><p><strong>re.LOCALE</strong>：使预定字符类 \w \W \b \B \s \S 取决于当前区域设定， 同 <strong>re.L</strong>。</p>
</li>
<li><p><strong>re.ASCII</strong>：使 \w \W \b \B \s \S 只匹配 ASCII 字符，而不是 Unicode 字符，同 <strong>re.A</strong>。</p>
</li>
<li><p><strong>re.VERBOSE</strong>：详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。主要是为了让正则表达式更易读，同 <strong>re.X</strong>。例如，以下两个正则表达式是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = re.compile(<span class="string">r"""\d +  # the integral part</span><br><span class="line">                   \.    # the decimal point</span><br><span class="line">                   \d *  # some fractional digits"""</span>, re.X)</span><br><span class="line">b = re.compile(<span class="string">r"\d+\.\d*"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h3 id="三、修改字符串">三、修改字符串</h3><p>第二部分讲的是字符串的匹配和搜索，但是并没有改变字符串。下面就讲一下可以改变字符串的操作。</p>
<p><strong>1）分割字符串</strong></p>
<p><code>split()</code>函数<strong>在匹配的地方将字符串分割，并返回一个 list</strong>。同样的，re 模块提供了两种 split 函数，一个是 pattern object 的方法，一个是模块级的函数。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.split" target="_blank" rel="external"><code>regex.split(string, maxsplit=0)</code></a>：</p>
<ul>
<li>maxsplit用于指定最大分割次数，不指定将全部分割。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r"[A-Z]+"</span>)</span><br><span class="line">m = pattern.split(<span class="string">"abcDefgHijkLmnoPqrs"</span>)</span><br><span class="line">print(m)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># ['abc', 'efg', 'ijk', 'mno', 'qrs']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.split" target="_blank" rel="external"><code>re.split(pattern, string, maxsplit=0, flags=0)</code></a>：</p>
<ul>
<li>模块级函数，功能与 regex.split() 相同。</li>
<li>flags用于指定匹配模式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = re.split(<span class="string">r"[A-Z]+"</span>,<span class="string">"abcDefgHijkLmnoPqrs"</span>)</span><br><span class="line">print(m)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># ['abc', 'efg', 'ijk', 'mno', 'qrs']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2）搜索与替换</strong></p>
<p>另一个常用的功能是<strong>找到所有的匹配，并把它们用不同的字符串替换</strong>。re 模块提供了<code>sub()</code>和<code>subn()</code>来实现替换的功能，而它们也分别有自己两个不同版本的函数。</p>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.sub" target="_blank" rel="external"><code>regex.sub(repl, string, count=0)</code></a>：</p>
<ul>
<li>使用 repl 替换 string 中每一个匹配的子串，返回替换后的字符串。若找不到匹配，则返回原字符串。</li>
<li>repl 可以是一个字符串，也可以是一个函数。</li>
<li>当repl是一个字符串时，任何在其中的反斜杠都会被处理。</li>
<li>当repl是一个函数时，这个函数应当只接受一个参数（Match对象），并返回一个字符串用于替换。</li>
<li>count 用于指定最多替换次数，不指定时全部替换。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> m.group().upper()</span><br><span class="line"> </span><br><span class="line">pattern = re.compile(<span class="string">r"like"</span>, re.I)</span><br><span class="line">s1 = pattern.sub(<span class="string">r"love"</span>, <span class="string">"I like you, do you like me?"</span>)</span><br><span class="line">s2 = pattern.sub(fun, <span class="string">"I like you, do you like me?"</span>)</span><br><span class="line">print(s1)</span><br><span class="line">print(s2)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># I love you, do you love me?</span></span><br><span class="line"><span class="comment"># I LIKE you, do you LIKE me?</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.sub" target="_blank" rel="external"><code>re.sub(pattern, repl, string, count=0, flags=0)</code></a>：</p>
<ul>
<li>模块级函数，与 regex.sub() 函数功能相同。</li>
<li>flags 用于指定匹配模式。</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.regex.subn" target="_blank" rel="external"><code>regex.subn(repl, string, count=0)</code></a>：</p>
<ul>
<li>同 sub()，只不过返回值是一个二元 tuple，即<code>(sub函数返回值, 替换次数)</code>。</li>
</ul>
<p><a href="https://docs.python.org/3/library/re.html#re.subn" target="_blank" rel="external"><code>re.subn(pattern, repl, string, count=0, flags=0)</code></a>：</p>
<ul>
<li>同上</li>
</ul>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>正则表达式（Regular Expression）</strong>是字符串处理的常用工具，通常被用来检索、替换那些符合某个模式（Pattern）的文本。很多程序设计语言都支持正则表达式，像Perl、Java、C/C++。在 Python 中是通过标准库中的 <strong>re 模块</strong> 提供对正则的支持。</p>
<p><br></p>
<h3 id="一、正则表达式介绍">一、正则表达式介绍</h3><p><strong>1）用途</strong></p>
<p>通过使用正则表达式，可以：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3标准库（一） 内置函数]]></title>
    <link href="http://yoursite.com/2014/08/30/python-library-01/"/>
    <id>http://yoursite.com/2014/08/30/python-library-01/</id>
    <published>2014-08-30T14:35:07.000Z</published>
    <updated>2015-05-10T08:12:50.112Z</updated>
    <content type="html"><![CDATA[<p>Python中内置了很多的函数，而学习标准库我们需要事先熟悉这些内置函数，所以在这里一个个进行介绍。有些函数比较简单，只给予文字描述，而有些函数会给出示例代码帮助理解。</p>
<p><strong>1、<a href="https://docs.python.org/3.4/library/functions.html#abs" target="_blank" rel="external"><code>abs(x)</code></a>：</strong>返回一个整数或浮点数的绝对值，如果是复数，返回它的模。</p>
<p><strong>2、<a href="https://docs.python.org/3.4/library/functions.html#all" target="_blank" rel="external"><code>all(iterable)</code></a>：</strong>当 iterable 中所有元素都为 True 时（或者 iterable 为空），返回 True 。</p>
<p><strong>3、<a href="https://docs.python.org/3.4/library/functions.html#any" target="_blank" rel="external"><code>any(iterable)</code></a>：</strong>当 iterable 中有元素为 True 时，则返回 True 。如果 iterable 为空，返回 False 。<a id="more"></a></p>
<p><strong>4、<a href="https://docs.python.org/3.4/library/functions.html#ascii" target="_blank" rel="external"><code>ascii(object)</code></a>：</strong>类似于repr()，返回一个输入对象的可打印的字符串。</p>
<p><strong>5、<a href="https://docs.python.org/3.4/library/functions.html#bin" target="_blank" rel="external"><code>bin(x)</code></a>：</strong>将整数 x 转化为一个二进制字符串。当 x 不是 int 对象时，x 必须实现__index__()方法来返回一个整型数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bin(<span class="number">9</span>)</span><br><span class="line"><span class="string">'0b1001'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6、<a href="https://docs.python.org/3.4/library/functions.html#bool" target="_blank" rel="external"><code>bool(x)</code></a>：</strong>将一个值转换成一个boolean类型的值，省略 x 将返回 False。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">bool</span><span class="params">()</span></span></span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">bool</span><span class="params">(<span class="string">'fedora'</span>)</span></span></span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p><strong>7、<a href="https://docs.python.org/3.4/library/functions.html#bytearray" target="_blank" rel="external"><code>bytearray()</code></a>：</strong> bytearray的构造函数。bytearray类型是一个可变的整数序列（0 &lt;= 整数 &lt; 256），即字节数组，例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = bytearray(b<span class="string">'after'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(a)   <span class="comment"># convert a bytearray object into a list of integers</span></span><br><span class="line">[<span class="number">97</span>, <span class="number">102</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">114</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>8、<a href="https://docs.python.org/3.4/library/functions.html#bytes" target="_blank" rel="external"><code>bytes()</code></a>：</strong> 字节对象（bytes object）的构造函数。bytes是bytearray的<strong>不可变</strong>版本：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = bytes(<span class="string">'after'</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(a)   <span class="comment"># convert a bytes object into a list of integers</span></span><br><span class="line">[<span class="number">97</span>, <span class="number">102</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">114</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>9、<a href="https://docs.python.org/3.4/library/functions.html#callable" target="_blank" rel="external"><code>callable(object)</code></a>：</strong>判断一个对象是否可调用，如果一个实例的类实现了<strong>call</strong>()方法，则它是可以调用的。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; f = lambda x,y <span class="symbol">:</span> x+y</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; callable(f)   <span class="comment"># f是函数对象，可调用</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = <span class="number">10</span>   <span class="comment"># a 不可调用</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; callable(a)</span><br><span class="line"><span class="constant">False</span></span><br></pre></td></tr></table></figure></p>
<p><strong>10、<a href="https://docs.python.org/3.4/library/functions.html#chr" target="_blank" rel="external"><code>chr(i)</code></a>：</strong>返回编码值 i 对应的字符（str类型），i 的有效值为 0 到 1114111。与<code>ord()</code>正好相反。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">chr</span><span class="params">(<span class="number">97</span>)</span></span></span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>11、<a href="https://docs.python.org/3.4/library/functions.html#classmethod" target="_blank" rel="external"><code>classmethod(function)</code></a>：</strong>返回一个类方法。</p>
<p><strong>12、<a href="https://docs.python.org/3.4/library/functions.html#compile" target="_blank" rel="external"><code>compile()</code></a>：</strong>编译一个源，返回一个代码对象，该代码对象可以用来作为exec()或者eval()的参数。</p>
<p><strong>13、<a href="https://docs.python.org/3.4/library/functions.html#complex" target="_blank" rel="external"><code>complex(re, im)</code></a>：</strong>复数的构造函数，re 为返回复数对象的实数部分，im 为虚数部分。</p>
<p><strong>14、<a href="https://docs.python.org/3.4/library/functions.html#delattr" target="_blank" rel="external"><code>delattr(object, name)</code></a>：</strong>删除一个对象的属性，相当于<code>del object.name</code>。</p>
<p><strong>15、<a href="https://docs.python.org/3.4/library/functions.html#func-dict" target="_blank" rel="external"><code>dict()</code></a>：</strong>字典类型的构造函数。</p>
<p><strong>16、<a href="https://docs.python.org/3.4/library/functions.html#dir" target="_blank" rel="external"><code>dir()</code></a>：</strong>返回一个包含了 object 所有属性的列表对象，如果没有参数，则包含当前作用域的所用属性。</p>
<p><strong>17、<a href="https://docs.python.org/3.4/library/functions.html#divmod" target="_blank" rel="external"><code>divmod(a, b)</code></a>：</strong>返回一个元组<code>(a//b, a%b)</code>。</p>
<p><strong>18、<a href="https://docs.python.org/3.4/library/functions.html#enumerate" target="_blank" rel="external"><code>enumerate(iterable, start=0)</code></a>：</strong>返回一个可迭代的 enumerate object，对其使用 next() 得到的是包含索引和元素的tuple，通常用于同时遍历索引和元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> enumerate(seasons):   <span class="comment"># 遍历</span></span><br><span class="line"><span class="prompt">... </span>    print(x, end=<span class="string">' '</span>)</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">(<span class="number">0</span>, <span class="string">'Spring'</span>) (<span class="number">1</span>, <span class="string">'Summer'</span>) (<span class="number">2</span>, <span class="string">'Fall'</span>) (<span class="number">3</span>, <span class="string">'Winter'</span>)</span><br></pre></td></tr></table></figure></p>
<p>相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span><span class="params">(sequence, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>19、<a href="https://docs.python.org/3.4/library/functions.html#eval" target="_blank" rel="external"><code>eval()</code></a>：</strong>执行一段代码，返回执行的结果。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; eval(<span class="string">'x+1'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>20、<a href="https://docs.python.org/3.4/library/functions.html#exec" target="_blank" rel="external"><code>exec()</code></a>：</strong>也是执行一段代码，返回None。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; exec(<span class="string">'x += 10'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; x</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p><strong>21、<a href="https://docs.python.org/3.4/library/functions.html#filter" target="_blank" rel="external"><code>filter(function, iterable)</code></a>：</strong>过滤器，返回由使函数 function 返回True的 iterable 元素组成的迭代器。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; f = lambda <span class="symbol">x:</span> x%<span class="number">2</span>==<span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(filter(f, lst))</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>22、<a href="https://docs.python.org/3.4/library/functions.html#float" target="_blank" rel="external"><code>float(x)</code></a>：</strong>返回一个浮点型的对象，无参时返回0.0</p>
<p><strong>23、<a href="https://docs.python.org/3.4/library/functions.html#format" target="_blank" rel="external"><code>format(value[, spec])</code></a>：</strong>格式化一个值，当参数是一个自定义对象的时候，该对象需要实现__format__()方法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">format</span><span class="params">(<span class="number">3.1415926</span>, <span class="string">'7.3g'</span>)</span></span></span><br><span class="line"><span class="string">'   3.14'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>24、<a href="https://docs.python.org/3.4/library/functions.html#func-frozenset" target="_blank" rel="external"><code>frozenset()</code></a>：</strong> frozenset 的构造函数。顾名思义，frozenset是一种 set 类型，且不可改变（没有add、remove等方法）。</p>
<p><strong>25、<a href="https://docs.python.org/3.4/library/functions.html#getattr" target="_blank" rel="external"><code>getattr(object, name)</code></a>：</strong>获得对象的name属性，当该属性不存在的时候可以使用一个默认值作为返回值。</p>
<p><strong>26、<a href="https://docs.python.org/3.4/library/functions.html#globals" target="_blank" rel="external"><code>globals()</code></a>：</strong>返回一个包含当前所有<strong>全局符号</strong>和对应值的字典。</p>
<p><strong>27、<a href="https://docs.python.org/3.4/library/functions.html#hasattr" target="_blank" rel="external"><code>hasattr(object, name)</code></a>：</strong>判断对象是否有name属性。</p>
<p><strong>28、<a href="https://docs.python.org/3.4/library/functions.html#hash" target="_blank" rel="external"><code>hash(object)</code></a>：</strong>返回对象的 hash 值，object 必须是可哈希的。<br><strong>注意：</strong>所有不可变的内置类型都是 hashable 的，比如 string，tuple；所有可变的内置类型都是 unhashable 的，比如 list，dict（即没有__hash__()方法）。</p>
<p><strong>29、<a href="https://docs.python.org/3.4/library/functions.html#help" target="_blank" rel="external"><code>help()</code></a>：</strong>查看一个对象的帮助文档。</p>
<p><strong>30、<a href="https://docs.python.org/3.4/library/functions.html#hex" target="_blank" rel="external"><code>hex(x)</code></a>：</strong>将一个整数转为小写的十六进制字符串（以’0x’开头），如果不是int对象，需要定义 __index__()方法。</p>
<p><strong>31、<a href="https://docs.python.org/3.4/library/functions.html#id" target="_blank" rel="external"><code>id()</code></a>：</strong>返回一个对象的 id 身份，可以看作该对象的内存地址。</p>
<p><strong>32、<a href="https://docs.python.org/3.4/library/functions.html#input" target="_blank" rel="external"><code>input()</code></a>：</strong>读取一行输入并返回一个字符串。</p>
<p><strong>33、<a href="https://docs.python.org/3.4/library/functions.html#int" target="_blank" rel="external"><code>int(x, base=10)</code></a>：</strong>返回相应进制的 int 值。</p>
<p><strong>34、<a href="https://docs.python.org/3.4/library/functions.html#isinstance" target="_blank" rel="external"><code>isinstance(object, class)</code></a>：</strong>判断对象 object 是不是类 class 或其派生类的实例。</p>
<p><strong>35、<a href="https://docs.python.org/3.4/library/functions.html#issubclass" target="_blank" rel="external"><code>issubclass(class,baseclass)</code></a>：</strong>判断一个类是否是另一个类的子类。</p>
<p><strong>36、<a href="https://docs.python.org/3.4/library/functions.html#iter" target="_blank" rel="external"><code>iter()</code></a>：</strong>返回一个可迭代的对象。</p>
<p><strong>37、<a href="https://docs.python.org/3.4/library/functions.html#len" target="_blank" rel="external"><code>len()</code></a>：</strong>返回一个长度值，与 object 中的__len__()有关。</p>
<p><strong>38、<a href="https://docs.python.org/3.4/library/functions.html#func-list" target="_blank" rel="external"><code>list()</code></a>：</strong> list 的构造函数。</p>
<p><strong>39、<a href="https://docs.python.org/3.4/library/functions.html#locals" target="_blank" rel="external"><code>locals()</code></a>：</strong>返回一个包含当前局部符号和对应值的字典，与 <code>globals()</code> 对应。</p>
<p><strong>40、<a href="https://docs.python.org/3.4/library/functions.html#map" target="_blank" rel="external"><code>map(function, iterable)</code></a>：</strong>映射函数，将 iterable 中的每个元素应用到 function 函数，返回由所有结果组成的迭代器。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; it = <span class="function"><span class="title">map</span><span class="params">(lambda x: x*<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">list</span><span class="params">(it)</span></span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>41、<a href="https://docs.python.org/3.4/library/functions.html#max" target="_blank" rel="external"><code>max()</code></a>：</strong>最大值。</p>
<p><strong>42、<a href="https://docs.python.org/3.4/library/functions.html#min" target="_blank" rel="external"><code>min()</code></a>：</strong>最小值。</p>
<p><strong>43、<a href="https://docs.python.org/3.4/library/functions.html#func-memoryview" target="_blank" rel="external"><code>memoryview(obj)</code></a>：</strong>返回一个 memory view 对象。</p>
<p><strong>44、<a href="https://docs.python.org/3.4/library/functions.html#next" target="_blank" rel="external"><code>next(iterator)</code></a>：</strong>产生下一个生成值，与__next__()有关。</p>
<p><strong>45、<a href="https://docs.python.org/3.4/library/functions.html#object" target="_blank" rel="external"><code>object()</code></a>：</strong>略。</p>
<p><strong>46、<a href="https://docs.python.org/3.4/library/functions.html#oct" target="_blank" rel="external"><code>oct(x)</code></a>：</strong>将一个整数转为一个八进制字符串。如果不是 int 对象，需要定义__index__()方法。</p>
<p><strong>47、<a href="https://docs.python.org/3.4/library/functions.html#open" target="_blank" rel="external"><code>open()</code></a>：</strong>打开一个文件，返回对应的文件对象。</p>
<p><strong>48、<a href="https://docs.python.org/3.4/library/functions.html#ord" target="_blank" rel="external"><code>ord(c)</code></a>：</strong>返回字符 c 的编码值，与<code>chr(i)</code>相反。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">ord</span><span class="params">(<span class="string">'a'</span>)</span></span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure></p>
<p><strong>49、<a href="https://docs.python.org/3.4/library/functions.html#pow" target="_blank" rel="external"><code>pow(x, y[, z])</code></a>：</strong><code>pow(x, y)</code>相当于<code>x**y</code>，<code>pow(x, y, z)</code>相当于<code>pow(x, y) % z</code>。</p>
<p><strong>50、<a href="https://docs.python.org/3.4/library/functions.html#print" target="_blank" rel="external"><code>print()</code></a>：</strong>打印输出。</p>
<p><strong>51、<a href="https://docs.python.org/3.4/library/functions.html#property" target="_blank" rel="external"><code>property(fget=None, fset=None, fdel=None, doc=None)</code></a>：</strong>函数 property() 的作用就是把类中的方法当作属性来访问。看下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__x = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__x</span><br><span class="line">        </span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure></p>
<p>为了操作数据成员 __x，我们需要使用 getx、setx、delx 方法，很麻烦。但是如果通过 property 函数将方法绑定到成员x，那么当获取成员x的值时，就会调用getx函数；当给成员x赋值时，就会调用setx函数；当删除x时，就会调用delx函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">c</span> = <span class="type">C</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.x)    # 相当于<span class="built_in">c</span>.getx()</span><br><span class="line"><span class="built_in">c</span>.x = <span class="number">20</span>      # 相当于<span class="built_in">c</span>.setx(<span class="number">20</span>)</span><br><span class="line">del <span class="built_in">c</span>.x       # 相当于<span class="built_in">c</span>.delx()</span><br></pre></td></tr></table></figure></p>
<p>这样通过 x 间接调用方法操作 __x 就方便多了。</p>
<p><strong>52、<a href="https://docs.python.org/3.4/library/functions.html#func-range" target="_blank" rel="external"><code>range(start, stop[, step])</code></a>：</strong>返回一个序列。</p>
<p><strong>53、<a href="https://docs.python.org/3.4/library/functions.html#repr" target="_blank" rel="external"><code>repr(object)</code></a>：</strong>将对象转化为可打印的字符串。</p>
<p><strong>54、<a href="https://docs.python.org/3.4/library/functions.html#reversed" target="_blank" rel="external"><code>reversed()</code></a>：</strong>倒序序列，对象需要实现__reversed__()方法。</p>
<p><strong>55、<a href="https://docs.python.org/3.4/library/functions.html#round" target="_blank" rel="external"><code>round(number[, ndigits])</code></a>：</strong>把浮点数转变成指定小数位数的数，ndigits默认为0。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">round</span><span class="params">(<span class="number">1.75368</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="number">1.754</span></span><br></pre></td></tr></table></figure></p>
<p><strong>56、<a href="https://docs.python.org/3.4/library/functions.html#func-set" target="_blank" rel="external"><code>set()</code></a>：</strong> set 的构造函数。</p>
<p><strong>57、<a href="https://docs.python.org/3.4/library/functions.html#setattr" target="_blank" rel="external"><code>setattr(object, name, value)</code></a>：</strong>为一个对象的name属性设置一个value值。</p>
<p><strong>58、<a href="https://docs.python.org/3.4/library/functions.html#slice" target="_blank" rel="external"><code>slice(start,stop[,step])</code></a>：</strong>切片函数，分割一个可分割的对象，返回其中的一部分。</p>
<p><strong>59、<a href="https://docs.python.org/3.4/library/functions.html#sorted" target="_blank" rel="external"><code>sorted()</code></a>：</strong>排序。</p>
<p><strong>60、<a href="https://docs.python.org/3.4/library/functions.html#staticmethod" target="_blank" rel="external"><code>staticmethod(function)</code></a>：</strong>返回一个静态的方法。要知道，一个类的静态方法没有隐式的第一个 self 参数，因为静态方法是独立于实例对象的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="decorator">@staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg1, arg2, ...)</span>:</span> ...</span><br></pre></td></tr></table></figure></p>
<p><strong>61、<a href="https://docs.python.org/3.4/library/functions.html#func-str" target="_blank" rel="external"><code>str()</code></a>：</strong>字符串的构造函数。</p>
<p><strong>62、<a href="https://docs.python.org/3.4/library/functions.html#sum" target="_blank" rel="external"><code>sum()</code></a>：</strong>求和。</p>
<p><strong>63、<a href="https://docs.python.org/3.4/library/functions.html#super" target="_blank" rel="external"><code>super()</code></a>：</strong> super() 常用于继承中调用父类的方法。例如，<a href="http://blog.csdn.net/lisonglisonglisong/article/details/38719743#t0" target="_blank" rel="external">类的继承</a>中，通常需要调用父类的构造方法，以初始化父类部分，有两种方法能达到这个目的。</p>
<p><strong>方法一：</strong>调用未绑定的父类构造方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="string">'A_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b = <span class="string">'B_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        <span class="comment"># ...其他超类</span></span><br><span class="line">        self.c = <span class="string">'C_method'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：</strong>使用super函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.a = <span class="string">'A_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.b = <span class="string">'B_method'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()    <span class="comment"># 等价于super(C,self).__init__()</span></span><br><span class="line">        self.c = <span class="string">'C_method'</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，方法一更直观，但是方法二使用 super 函数可以一次初始化所有超类（但要确保所有的超类的构造方法都使用了super函数）。当继承结构很复杂时，方法二明显更适用，当然 super 不仅可以用于构造方法还可以用于其他方法。</p>
<p>使用 super 还有一个好处，就是当改变父类名时，不需要再去修改其他地方，便于代码的维护。</p>
<p><strong>64、<a href="https://docs.python.org/3.4/library/functions.html#func-tuple" target="_blank" rel="external"><code>tuple()</code></a>：</strong>元组的构造函数。</p>
<p><strong>65、<a href="https://docs.python.org/3.4/library/functions.html#type" target="_blank" rel="external"><code>type()</code></a>：</strong>返回一个对象的类型，返回值与<code>object.__class__</code>一样。</p>
<p><strong>66、<a href="https://docs.python.org/3.4/library/functions.html#vars" target="_blank" rel="external"><code>vars(object)</code></a>：</strong>返回 object 中所有属性与对应值的字典。没有参数时作用和<code>locals()</code>一样。</p>
<p><strong>67、<a href="https://docs.python.org/3.4/library/functions.html#zip" target="_blank" rel="external"><code>zip()</code></a>：</strong> zip 函数接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组）。</p>
<p><strong>68、<a href="https://docs.python.org/3.4/library/functions.html#__import__" target="_blank" rel="external"><code>__import__()</code></a>：</strong>通过import语句调用。</p>
<p><br><br><br><br></p>
<h3 id="附：reduce函数">附：reduce函数</h3><p>在Python 3里，<a href="https://docs.python.org/3.4/library/functools.html#functools.reduce" target="_blank" rel="external"><code>reduce()</code></a>函数已经被从全局名字空间里移除了，它现在被放置在<code>functools</code>模块里。函数原型如下：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="function"><span class="keyword">function</span>, <span class="title">iterable</span><span class="params">[, initializer]</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>function 必须是二元函数，<strong>在省略第三个参数的情况下</strong>，函数先对 iterable 中的第1，2个数据进行操作，得到的结果再与第三个数据用 function() 函数运算……依次类推，最后得到一个结果。<strong>如果初始值 initializer 给定</strong>，第一次调用会是 initializer 和第一个元素而不是序列的头两个元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">10</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>map用于映射，reduce用于归并。</p>
<p>（全文完）<br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中内置了很多的函数，而学习标准库我们需要事先熟悉这些内置函数，所以在这里一个个进行介绍。有些函数比较简单，只给予文字描述，而有些函数会给出示例代码帮助理解。</p>
<p><strong>1、<a href="https://docs.python.org/3.4/library/functions.html#abs"><code>abs(x)</code></a>：</strong>返回一个整数或浮点数的绝对值，如果是复数，返回它的模。</p>
<p><strong>2、<a href="https://docs.python.org/3.4/library/functions.html#all"><code>all(iterable)</code></a>：</strong>当 iterable 中所有元素都为 True 时（或者 iterable 为空），返回 True 。</p>
<p><strong>3、<a href="https://docs.python.org/3.4/library/functions.html#any"><code>any(iterable)</code></a>：</strong>当 iterable 中有元素为 True 时，则返回 True 。如果 iterable 为空，返回 False 。]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（十二） 学习总结·附PDF]]></title>
    <link href="http://yoursite.com/2014/08/24/python-basic-12/"/>
    <id>http://yoursite.com/2014/08/24/python-basic-12/</id>
    <published>2014-08-24T07:32:32.000Z</published>
    <updated>2015-05-10T08:09:44.167Z</updated>
    <content type="html"><![CDATA[<p>Python是一门强大的解释型、面向对象的高级程序设计语言，它优雅、简单、可移植、易扩展，可用于桌面应用、系统编程、数据库编程、网络编程、web开发、图像处理、人工智能、数学应用、文本处理等等。</p>
<p>在学习Python的过程中，我做了一个比较详细、比较系统的学习笔记，适合Python的初学者用以快速入门。它讲解了Python 3.x的基本语法和高级特性，从基本数据类型、运算符、流程控制、函数、文件IO到模块、异常处理和面向对象，并且附上了很多经过测试的代码帮助读者去理解。</p>
<p>如果你是一个Python初学者，希望这个学习笔记能够对你有所帮助。相信如果你看完这个学习笔记，你会对Python有一个整体的了解。<a id="more"></a></p>
<p>Python3基础学习笔记：</p>
<ul>
<li><a href="http://songlee24.github.io/2014/08/08/python-basic-01/" target="_blank" rel="external">Python3基础（一） Hello World </a></li>
<li><a href="http://songlee24.github.io/2014/08/08/python-basic-02/" target="_blank" rel="external">Python3基础（二） 基本数据类型 </a></li>
<li><a href="http://songlee24.github.io/2014/08/08/python-basic-03/" target="_blank" rel="external">Python3基础（三） 运算符 </a></li>
<li><a href="http://songlee24.github.io/2014/08/09/python-basic-04/" target="_blank" rel="external">Python3基础（四） 条件与循环控制</a></li>
<li><a href="http://songlee24.github.io/2014/08/09/python-basic-05/" target="_blank" rel="external">Python3基础（五） 函数</a></li>
<li><a href="http://songlee24.github.io/2014/08/13/python-basic-06/" target="_blank" rel="external">Python3基础（六） 深入list列表</a></li>
<li><a href="http://songlee24.github.io/2014/08/14/python-basic-07/" target="_blank" rel="external">Python3基础（七） 输入和输出</a></li>
<li><a href="http://songlee24.github.io/2014/08/18/python-basic-08/" target="_blank" rel="external">Python3基础（八） 模块</a></li>
<li><a href="http://songlee24.github.io/2014/08/19/python-basic-09/" target="_blank" rel="external">Python3基础（九） 错误和异常</a></li>
<li><a href="http://songlee24.github.io/2014/08/20/python-basic-10/" target="_blank" rel="external">Python3基础（十） 类的初印象</a></li>
<li><a href="http://songlee24.github.io/2014/08/21/python-basic-11/" target="_blank" rel="external">Python3基础（十一） 类的拓展 </a></li>
<li><a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/" target="_blank" rel="external">Python FAQ1：传值，还是传引用？</a></li>
<li><a href="http://songlee24.github.io/2014/08/15/python-FAQ-02/" target="_blank" rel="external">Python FAQ2：赋值、浅拷贝、深拷贝的区别？</a></li>
</ul>
<p><strong>为了方便大家离线阅读，我把上面所有的学习笔记用 markdown 排版制作了一个精良的PDF，供大家下载。</strong></p>
<p><strong>下载地址：</strong><a href="http://download.csdn.net/detail/lisong694767315/7807405" target="_blank" rel="external">http://download.csdn.net/detail/lisong694767315/7807405</a></p>
<p><br><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python是一门强大的解释型、面向对象的高级程序设计语言，它优雅、简单、可移植、易扩展，可用于桌面应用、系统编程、数据库编程、网络编程、web开发、图像处理、人工智能、数学应用、文本处理等等。</p>
<p>在学习Python的过程中，我做了一个比较详细、比较系统的学习笔记，适合Python的初学者用以快速入门。它讲解了Python 3.x的基本语法和高级特性，从基本数据类型、运算符、流程控制、函数、文件IO到模块、异常处理和面向对象，并且附上了很多经过测试的代码帮助读者去理解。</p>
<p>如果你是一个Python初学者，希望这个学习笔记能够对你有所帮助。相信如果你看完这个学习笔记，你会对Python有一个整体的了解。]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
</feed>