<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[神奕的博客]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-23T12:38:45.204Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[基于Scribe的奇虎360日志收集系统架构]]></title>
    <link href="http://yoursite.com/2016/02/23/log-collection-system-arch/"/>
    <id>http://yoursite.com/2016/02/23/log-collection-system-arch/</id>
    <published>2016-02-23T12:27:52.000Z</published>
    <updated>2016-02-23T12:38:45.204Z</updated>
    <content type="html"><![CDATA[<blockquote>
<h2 id="前言">前言</h2><p><strong>日志收集是大数据的基石。</strong>许多公司的业务平台每天都会产生大量的日志数据。收集业务日志数据，供离线和在线的分析系统使用，正是日志收集系统的要做的事情。高可用性，高可靠性和可扩展性是日志收集系统所具有的基本特征。</p>
</blockquote>
<h2 id="一、Scribe简介">一、Scribe简介</h2><p>目前在互联网公司比较常见日志收集系统有<strong>Flume</strong>和<strong>Scribe</strong>。</p>
<p>Scribe是Facebook开源的一个基于thrift的日志收集框架，它为日志收集提供了一种容错且可扩展的方案。scribe可以从不同数据源，不同机器上收集日志，然后将它们存入一个中央存储系统，以便集中统计分析处理。<strong>奇虎360</strong>就是用的Scribe来收集业务日志，但是在原生的基础上他们做了很多定制：zookeeper负载均衡、支持写HDFS、支持写Kestrel队列、支持写QBus/Kafka等。</p>
<p>当然，我并不推荐使用Scribe，因为Facebook已经不再更新和维护Scribe，而且原生Scribe有很多功能不完善。如果现在来进行技术选型，我推荐使用<strong>Flume</strong>。（Flume作为Apache的孵化项目，文档丰富，功能完善，高可靠、高可用、易扩展）。</p>
<h2 id="二、开源日志收集框架对比">二、开源日志收集框架对比</h2><p>下面对Flume和Scribe进行了对比。对比中Flume将主要采用Flume-NG为参考对象，Scribe则采用<strong><a href="https://github.com/facebookarchive/scribe" target="_blank" rel="external">原生的Scribe</a></strong>。同时，分为三层（Agent层，Collector层和Store层）来进行对比。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Flume-NG</th>
<th>Scribe</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用语言</td>
<td>Java</td>
<td>c/c++</td>
</tr>
<tr>
<td>容错性</td>
<td>Agent和Collector间，Collector和Store间都有容错性，且提供三种级别的可靠性保证；</td>
<td>Agent和Collector间, Collector和Store之间有容错性；</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Agent和Collector间，Collector和Store间有LoadBalance和Failover两种模式</td>
<td>无</td>
</tr>
<tr>
<td>可扩展性</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>Agent丰富程度</td>
<td>提供丰富的Agent，包括avro/thrift socket, text, tail等</td>
<td>主要是thrift端口</td>
</tr>
<tr>
<td>Store丰富程度</td>
<td>可以直接写hdfs, text, console, tcp；写hdfs时支持对text和sequence的压缩；</td>
<td>提供buffer, network, file(hdfs, text)等</td>
</tr>
<tr>
<td>代码结构</td>
<td>系统框架好，模块分明，易于开发</td>
<td>代码简单</td>
</tr>
</tbody>
</table>
<h2 id="三、奇虎360日志收集系统架构">三、奇虎360日志收集系统架构</h2><p>日志收集大致有两种应用场景：</p>
<ul>
<li>离线计算：日志—-&gt;Scribe—-&gt;离线计算（如HDFS+MapReduce）</li>
<li>实时计算：日志—-&gt;Scribe—-&gt;实时计算（如Kafka+Storm）</li>
</ul>
<p>下面是日志收集系统的整体架构图：</p>
<p><img src="http://img.blog.csdn.net/20160223203624132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从架构图可以看出，日志收集系统主要分为三层：</p>
<ol>
<li><p>日志服务器：为了收集日志，每一台日志服务器上都会部署一个scribe客户端，它包含两个模块：agent 和 local_server。其中<strong>agent</strong>的作用就是以 tail 的方式读取本地目录下的日志文件，并将数据写到本地的 local_server，然后<strong>local_server</strong>通过zookeeper定位到center_server，并将数据发送给远端的center_server。</p>
</li>
<li><p>中心服务器：<strong>center_server</strong>其实和local_server是同一套程序，只是配置文件不一样，它们通过 thrift 进行通信。center_server收到数据后，根据配置将各个category的数据发向不同的方向，比如写到HDFS、发到Kafka集群、发到Kestrel队列等等。</p>
</li>
<li><p>存储服务器：日志被收集到存储服务器以后，就可以进行离线/实时的统计分析了。比如，HDFS是用来永久存储日志，并给MapReduce提供离线数据的；Kafka/Kestrel则是给Storm集群提供实时数据流，以实时地统计分析。</p>
</li>
</ol>
<p>在Scribe中传输的每个基本数据单元都包含一个category和一个message，category作为message的标识符，用于给message分类，以避免数据在传输过程中混淆在一起。</p>
<hr>
<p>以上介绍了日志的基本流动路线，但是也存在一些复杂的日志收集。比如，有时候日志存储到Kafka并经过Storm实时处理之后，还不算结束，还需要把Storm的处理结果存到HDFS上 —— 这时只需要在Storm程序里调用 thrift 接口将输出结果往center_server里写，并配置该category保存到HDFS上即可。</p>
<p><img src="http://img.blog.csdn.net/20160223203739614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>注：scribe各模块之间的通信都是通过 <strong>thrift</strong> 接口。</p>
<h2 id="四、系统的基本特性">四、系统的基本特性</h2><h3 id="4-1_可用性">4.1 可用性</h3><ul>
<li><strong>agent挂掉</strong>：在所有日志服务器上部署了监控脚本，只要发现agent进程挂了，立即重启，以提供服务。重启失败则报警！</li>
<li><strong>local server挂掉</strong>：同上，日志服务器上的监控脚本只要发现local_server进程挂了，会立即重启，保证服务可用。重启失败则报警！</li>
<li><strong>center server挂掉</strong>：在所有中央服务器上部署了监控脚本，只要发现center_server进程挂了，立即重启。重启失败则报警！</li>
</ul>
<h3 id="4-2_可靠性">4.2 可靠性</h3><p>Scribe系统设计成能容错：</p>
<ul>
<li>当网络或者机器出现故障时，如果客户端上的一个local_server不能发送消息到center_server，它会将消息保存到本地磁盘（堆积到一定量会报警）。当center_server或者网络故障恢复后，重新发送。</li>
<li>为了避免center_server重启时负载过重，重新发送者会等待一个随机事件，再发送。如果center_server接近其处理极限返回TRY_LATER，这就告诉resender间隔几分钟后再试。</li>
</ul>
<p>以下情况数据可能会丢失：</p>
<ul>
<li>一个center_server异常退出，内存中的消息会丢失。</li>
<li>local_server不能连接到center_server，本地磁盘溢出，消息会丢失。</li>
<li>超时，导致存在重复的消息。</li>
</ul>
<h3 id="4-3_可扩展性">4.3 可扩展性</h3><ul>
<li><p><strong>日志服务器</strong>：每个机器部署一个Scribe客户端，可以水平扩展，不受限制。Scribe收集日志的能力受限于机器的带宽，正常情况下单机千兆网卡就足够了。</p>
</li>
<li><p><strong>中央服务器</strong>：从local_server到center_server是通过zookeeper自动负载均衡的，并且每台center_server提供无差别服务，所以可以线性扩展。通常中央服务器只有几台，当日志服务器不断增加导致中央服务器带宽打满时，就需要加机器了。</p>
</li>
<li><p><strong>存储服务器</strong>：不论是hadoop集群还是kafka集群都是可以线性扩展的.</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<h2 id="前言">前言</h2><p><strong>日志收集是大数据的基石。</strong>许多公司的业务平台每天都会产生大量的日志数据。收集业务日志数据，供离线和在线的分析系统使用，正是日志收集系统的要做的事情。高可用性，高可靠性和可扩展性是]]>
    </summary>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="Scribe" scheme="http://yoursite.com/tags/Scribe/"/>
    
      <category term="Storm" scheme="http://yoursite.com/tags/Storm/"/>
    
      <category term="大数据-Scribe" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Scribe/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用linux系统监控命令]]></title>
    <link href="http://yoursite.com/2015/09/05/linux-monitor-tools/"/>
    <id>http://yoursite.com/2015/09/05/linux-monitor-tools/</id>
    <published>2015-09-05T15:49:40.000Z</published>
    <updated>2015-09-05T16:28:51.793Z</updated>
    <content type="html"><![CDATA[<h1 id="一、内存监控">一、内存监控</h1><p>监控内存的使用状态是非常重要的，通过监控有助于了解内存的使用状态，比如内存占用是否正常，内存是否紧缺等等，监控内存最常使用的命令有free、vmstat、top等</p>
<h2 id="1-1_free">1.1 free</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="string">Mem:</span>      <span class="number">32872632</span>   <span class="number">12393128</span>   <span class="number">20479504</span>          <span class="number">0</span>      <span class="number">23308</span>    <span class="number">7496048</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="string">cache:</span>    <span class="number">4873772</span>   <span class="number">27998860</span></span><br><span class="line"><span class="string">Swap:</span>            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第一行（Mem）：<a id="more"></a></p>
<ul>
<li><strong>total</strong>：内存总数 32872632 KB</li>
<li><strong>used</strong>：已使用的内存数 12393128 KB</li>
<li><strong>free</strong>：空闲的内存数 20479504 KB</li>
<li><strong>shared</strong>：多个进程共享的内存，总是0</li>
<li><strong>buffers</strong>：缓存内存数 23308 KB</li>
<li><strong>cached</strong>：缓存内存数 7496048 KB</li>
</ul>
<p>第二行（-/+ buffers/cache）：</p>
<ul>
<li><strong>used</strong>：第一行Mem中的 <strong>used - buffers - cached</strong> = 12393128 - 23308 - 7496048 = <strong>4873772</strong> KB</li>
<li><strong>free</strong>：第一行Mem中的 <strong>free + buffers + cached</strong> = 20479504 + 23308 + 7496048 = <strong>27998860</strong> KB</li>
<li>可见这一行【used-buffers/cache】反映的是被程序实实在在吃掉的内存，【used+buffers/cache】反映的是可以挪用的内存总数。</li>
</ul>
<p>第三行（Swap）：表示交换分区的内存使用状态。</p>
<blockquote>
<p>第一行内存状态是对于<strong>操作系统</strong>来说的，buffers/cached 都是属于被使用。</p>
<p>第二行内存状态是对于<strong>应用程序</strong>来说的，对于应用程序来说，buffers/cached占有的内存是可用的，因为buffers/cached是为了提高程序执行的性能，当应用程序需要用到内存的时候buffers/cached会很快地被回收，以供应用程序使用。</p>
<p>通常我们是从应用的角度来看的，所以只看第二行就行了。</p>
</blockquote>
<p>另外，我们可以使用参数<code>-m</code>、<code>-g</code>来以<code>MB</code>、<code>GB</code>单位显示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="string">Mem:</span>         <span class="number">32102</span>      <span class="number">12104</span>      <span class="number">19998</span>          <span class="number">0</span>         <span class="number">22</span>       <span class="number">7320</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="string">cache:</span>       <span class="number">4760</span>      <span class="number">27341</span></span><br><span class="line"><span class="string">Swap:</span>            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-2_vmstat">1.2 vmstat</h2><p><strong>vmstat（Virtual Meomory Statistics，虚拟内存统计）</strong>是对系统的整体情况进行统计，包括内核进程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vmstat <span class="number">2</span> <span class="number">100</span>      <span class="comment"># 2表示刷新间隔，100表示输出次数</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">procs</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">memory</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">swap</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">io</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">system</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">cpu</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"> <span class="comment">r</span>  <span class="comment">b</span>   <span class="comment">swpd</span>   <span class="comment">free</span>   <span class="comment">buff</span>  <span class="comment">cache</span>   <span class="comment">si</span>   <span class="comment">so</span>    <span class="comment">bi</span>    <span class="comment">bo</span>   <span class="comment">in</span>   <span class="comment">cs</span> <span class="comment">us</span> <span class="comment">sy</span> <span class="comment">id</span> <span class="comment">wa</span> <span class="comment">st</span></span><br><span class="line"> <span class="comment">2</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192532</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">2</span>     <span class="comment">1</span>   <span class="comment">20</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">31</span>   <span class="comment">35</span>  <span class="comment">0</span>  <span class="comment">1</span> <span class="comment">99</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">23</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">22</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">22</span>   <span class="comment">31</span>  <span class="comment">0</span>  <span class="comment">1</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">21</span>   <span class="comment">29</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">21</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">21</span>   <span class="comment">28</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1）procs</strong></p>
<ul>
<li><strong>r列</strong>表示运行和等待CPU时间片的进程数，这个值如果长期大于系统CPU个数，就说明CPU资源不足，可以考虑增加CPU；</li>
<li><strong>b列</strong>表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</li>
</ul>
<p><strong>2）memory</strong></p>
<ul>
<li><strong>swpd列</strong>表示切换到内存交换区的内存数量（以KB为单位）。如果swpd的值不为0或者比较大，而且si、so的值长期为0，那么这种情况一般不用担心，不会影响系统性能；</li>
<li><strong>free列</strong>表示当前空闲的物理内存数量（以KB为单位）；</li>
<li><strong>buff列</strong>表示buffers cache的内存数量，一般对块设备的读写才需要缓冲；</li>
<li><strong>cache列</strong>表示page cached的内存数量，一般作文件系统的cached，频繁访问的文件都会被cached。如果cached值较大，就说明cached文件数较多。如果此时IO中的bi比较小，就说明文件系统效率比较好。</li>
</ul>
<p><strong>3）swap</strong></p>
<ul>
<li><strong>si列</strong>表示由磁盘调入内存，也就是内存进入内存交换区的数量；</li>
<li><strong>so列</strong>表示由内存调入磁盘，也就是内存交换区进入内存的数量</li>
<li>一般情况下，si、so的值都为0，如果si、so的值长期不为0，则表示系统内存不足，需要考虑是否增加系统内存。</li>
</ul>
<p><strong>4）IO</strong></p>
<ul>
<li><strong>bi列</strong>表示从块设备读入的数据总量（即读磁盘，单位KB/秒）</li>
<li><strong>bo列</strong>表示写入到块设备的数据总量（即写磁盘，单位KB/秒）<br>这里设置的bi+bo参考值为1000，如果超过1000，而且wa值比较大，则表示系统磁盘IO性能瓶颈。</li>
</ul>
<p><strong>5）system</strong></p>
<ul>
<li><strong>in列</strong>表示在某一时间间隔中观察到的每秒设备中断数；</li>
<li><strong>cs列</strong>表示每秒产生的上下文切换次数。<br>上面这两个值越大，会看到内核消耗的CPU时间就越多。</li>
</ul>
<p><strong>6）CPU</strong></p>
<ul>
<li><strong>us列</strong>显示了用户进程消耗CPU的时间百分比。us的值比较高时，说明用户进程消耗的CPU时间多，如果长期大于50%，需要考虑优化程序啥的。</li>
<li><strong>sy列</strong>显示了内核进程消耗CPU的时间百分比。sy的值比较高时，说明内核消耗的CPU时间多；如果us+sy超过80%，就说明CPU的资源存在不足。</li>
<li><strong>id列</strong>显示了CPU处在空闲状态的时间百分比；</li>
<li><strong>wa列</strong>表示IO等待所占的CPU时间百分比。wa值越高，说明IO等待越严重。如果wa值超过20%，说明IO等待严重。</li>
<li><strong>st列</strong>一般不关注，虚拟机占用的时间百分比。</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat -s      <span class="comment"># 查看内存使用的详细信息</span></span><br><span class="line"></span><br><span class="line">     <span class="number">32872632</span>  total memory</span><br><span class="line">     <span class="number">25946240</span>  used memory</span><br><span class="line">     <span class="number">21298968</span>  active memory</span><br><span class="line">      <span class="number">3228124</span>  inactive memory</span><br><span class="line">      <span class="number">6926392</span>  free memory</span><br><span class="line">        <span class="number">79764</span>  buffer memory</span><br><span class="line">      <span class="number">6767888</span>  swap cache</span><br><span class="line">            <span class="number">0</span>  total swap</span><br><span class="line">            <span class="number">0</span>  used swap</span><br><span class="line">            <span class="number">0</span>  free swap</span><br><span class="line">   <span class="number">5625247020</span> non-nice user cpu <span class="built_in">ticks</span></span><br><span class="line">        <span class="number">75476</span> nice user cpu <span class="built_in">ticks</span></span><br><span class="line">   <span class="number">3961269668</span> <span class="keyword">system</span> cpu <span class="built_in">ticks</span></span><br><span class="line"> <span class="number">228172341381</span> idle cpu <span class="built_in">ticks</span></span><br><span class="line">   <span class="number">1685706618</span> IO-<span class="built_in">wait</span> cpu <span class="built_in">ticks</span></span><br><span class="line">        <span class="number">11227</span> IRQ cpu <span class="built_in">ticks</span></span><br><span class="line">    <span class="number">537233093</span> softirq cpu <span class="built_in">ticks</span></span><br><span class="line">            <span class="number">0</span> stolen cpu <span class="built_in">ticks</span></span><br><span class="line"> <span class="number">817859502644</span> pages paged <span class="operator">in</span></span><br><span class="line"> <span class="number">874791545051</span> pages paged out</span><br><span class="line">            <span class="number">0</span> pages swapped <span class="operator">in</span></span><br><span class="line">            <span class="number">0</span> pages swapped out</span><br><span class="line">   <span class="number">1845948435</span> interrupts</span><br><span class="line">   <span class="number">2656703667</span> CPU context switches</span><br><span class="line">   <span class="number">1341191961</span> boot <span class="built_in">time</span></span><br><span class="line">   <span class="number">1691075642</span> forks</span><br></pre></td></tr></table></figure>
<p>上面的信息主要来自于<code>/proc/meminfo</code>，<code>/proc/stat</code>和<code>/proc/vmstat</code>。</p>
<p><br></p>
<h1 id="二、CPU监控">二、CPU监控</h1><h2 id="2-1_top">2.1 top</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况及总体状况，类似于Windows的任务管理器。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">20</span>:<span class="number">32</span>:<span class="number">28</span> up <span class="number">1149</span> days, <span class="number">11</span>:<span class="number">13</span>,  <span class="number">2</span> users,  load average: <span class="number">2.97</span>, <span class="number">2.42</span>, <span class="number">1.67</span></span><br><span class="line">Tasks: <span class="number">671</span> total,   <span class="number">1</span> running, <span class="number">669</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">1</span> zombie</span><br><span class="line">Cpu(s):  <span class="number">0.2</span><span class="variable">%us</span>,  <span class="number">0.1</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Mem:  <span class="number">32872632</span>k total, <span class="number">12336240</span>k used, <span class="number">20536392</span>k free,    <span class="number">23064</span>k buffers</span><br><span class="line">Swap:        <span class="number">0</span>k total,        <span class="number">0</span>k used,        <span class="number">0</span>k free,  <span class="number">7441684</span>k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S <span class="variable">%CPU</span> <span class="variable">%MEM</span>    TIME+  COMMAND</span><br><span class="line"> <span class="number">2543</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">9204</span>  <span class="number">636</span>  <span class="number">396</span> S  <span class="number">0.7</span>  <span class="number">0.0</span> <span class="number">614</span>:<span class="number">57.76</span> irqbalance</span><br><span class="line"> <span class="number">4279</span> work      <span class="number">20</span>   <span class="number">0</span> <span class="number">15.8</span>g <span class="number">1.4</span>g  <span class="number">10</span>m S  <span class="number">0.7</span>  <span class="number">4.6</span> <span class="number">121</span>:<span class="number">19.27</span> java  </span><br><span class="line"><span class="number">11761</span> work      <span class="number">20</span>   <span class="number">0</span>  <span class="number">153</span>m <span class="number">7192</span> <span class="number">1080</span> S  <span class="number">0.7</span>  <span class="number">0.0</span> <span class="number">642</span>:<span class="number">26.65</span> <span class="keyword">python</span></span><br></pre></td></tr></table></figure>
<p>第一行：</p>
<ul>
<li><strong>20:32:28</strong>： 当前时间</li>
<li><strong>up 1149 days, 11:13</strong>：系统运行时间，系统已经运行了1149天11小时13分钟了。</li>
<li><strong>2 users</strong>：当前登录用户数</li>
<li><strong>load average</strong>：系统负载，即任务队列的平均长度。三个数值分别为最近1分钟、最近5分钟、最近15分钟的平均负载 —— 超过N（CPU核数）说明系统满负荷运行。也可以通过<code>$w</code>或<code>$uptime</code>命令查看load average。</li>
</ul>
<p>第二行：</p>
<ul>
<li>显示进程总数、正在运行的进程数、休眠的进程数、停止的进程数、僵尸进程数</li>
</ul>
<p>第三行：</p>
<ul>
<li><strong>%us</strong>：用户进程消耗的CPU百分比</li>
<li><strong>%sy</strong>：内核进程消耗的CPU百分比</li>
<li><strong>%ni</strong>：改变过优先级的进程占用CPU的百分比</li>
<li><strong>%id</strong>：空闲CPU的百分比</li>
<li><strong>%wa</strong>：IO等待消耗的CPU百分比</li>
</ul>
<p>按”1”查看单个CPU的状况：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">20</span>:<span class="number">32</span>:<span class="number">49</span> up <span class="number">1149</span> days, <span class="number">11</span>:<span class="number">13</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks: <span class="number">671</span> total,   <span class="number">1</span> running, <span class="number">669</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">1</span> zombie</span><br><span class="line">Cpu0  :  <span class="number">1.0</span><span class="variable">%us</span>,  <span class="number">0.7</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">98.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu1  :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu2  :  <span class="number">0.7</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu3  :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu4  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu5  :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu6  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu7  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu8  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu9  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu10 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu11 :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu12 :  <span class="number">1.0</span><span class="variable">%us</span>,  <span class="number">0.3</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">98.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu13 :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu14 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu15 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu16 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu17 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu18 :  <span class="number">0.7</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu19 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu20 :  <span class="number">0.7</span><span class="variable">%us</span>,  <span class="number">1.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">98.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu21 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu22 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu23 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Mem:  <span class="number">32872632</span>k total, <span class="number">12336360</span>k used, <span class="number">20536272</span>k free,    <span class="number">23080</span>k buffers</span><br><span class="line">Swap:        <span class="number">0</span>k total,        <span class="number">0</span>k used,        <span class="number">0</span>k free,  <span class="number">7441976</span>k cached</span><br></pre></td></tr></table></figure></p>
<p>另外，下面的命令可以查看CPU的核数：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep 'model name' /<span class="keyword">proc</span>/cpuinfo | wc -l</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-2_mpstat">2.2 mpstat</h2><p><strong>mpstat（Multiprocessor Statistics，多处理器统计）</strong>是实时系统监控工具，它会报告与CPU相关的统计信息，这些信息存放在/proc/stat文件中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mpstat -<span class="constant">P ALL </span><span class="number">2</span>        <span class="comment"># ALL表示显示所有CPUs，也可以指定某个CPU；2表示刷新间隔</span></span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Linux <span class="number">2.6</span>.32-<span class="number">2.0</span>.0.1 (localhost) 	<span class="number">2015</span>年<span class="number">09</span>月<span class="number">05</span>日 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">35</span>秒  CPU    <span class="variable">%usr</span>   <span class="variable">%nice</span>    <span class="variable">%sys</span> <span class="variable">%iowait</span>    <span class="variable">%irq</span>   <span class="variable">%soft</span>  <span class="variable">%steal</span>  <span class="variable">%guest</span>   <span class="variable">%idle</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒  all    <span class="number">0.23</span>    <span class="number">0.00</span>    <span class="number">0.12</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.65</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">0</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">1</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">2</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">3</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">4</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">5</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">6</span>    <span class="number">1.01</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">98.99</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">7</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">8</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">9</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">10</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">11</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">12</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">13</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">14</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">15</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">16</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">17</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">18</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">19</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">20</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">21</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">1.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">98.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">22</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">23</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br></pre></td></tr></table></figure>
<p>至于各百分比的含义前面已经介绍过了，这里就不再赘述。</p>
<p><br></p>
<h1 id="三、网络监控">三、网络监控</h1><h2 id="3-1_ethtool">3.1 ethtool</h2><p>使用<code>ethtool</code>查看网卡带宽，需要root权限：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># ethtool eth0</span><br><span class="line">Settings <span class="keyword">for</span> <span class="string">eth0:</span></span><br><span class="line">	Supported <span class="string">ports:</span> [ TP ]</span><br><span class="line">	Supported link <span class="string">modes:</span>   <span class="number">10</span>baseT<span class="regexp">/Half 10baseT/</span>Full </span><br><span class="line">	                        <span class="number">100</span>baseT<span class="regexp">/Half 100baseT/</span>Full </span><br><span class="line">	                        <span class="number">1000</span>baseT/Full </span><br><span class="line">	Supports auto-<span class="string">negotiation:</span> Yes</span><br><span class="line">	Advertised link <span class="string">modes:</span>  <span class="number">10</span>baseT<span class="regexp">/Half 10baseT/</span>Full </span><br><span class="line">	                        <span class="number">100</span>baseT<span class="regexp">/Half 100baseT/</span>Full </span><br><span class="line">	                        <span class="number">1000</span>baseT/Full </span><br><span class="line">	Advertised pause frame <span class="string">use:</span> No</span><br><span class="line">	Advertised auto-<span class="string">negotiation:</span> Yes</span><br><span class="line"><span class="label">	Speed:</span> <span class="number">1000</span>Mb/s</span><br><span class="line"><span class="label">	Duplex:</span> Full</span><br><span class="line"><span class="label">	Port:</span> Twisted Pair</span><br><span class="line"><span class="label">	PHYAD:</span> <span class="number">1</span></span><br><span class="line"><span class="label">	Transceiver:</span> internal</span><br><span class="line">	Auto-<span class="string">negotiation:</span> on</span><br><span class="line">	MDI-<span class="string">X:</span> Unknown</span><br><span class="line">	Supports Wake-<span class="string">on:</span> pumbg</span><br><span class="line">	Wake-<span class="string">on:</span> g</span><br><span class="line">	Current message <span class="string">level:</span> <span class="number">0x00000003</span> (<span class="number">3</span>)</span><br><span class="line">	Link <span class="string">detected:</span> yes</span><br></pre></td></tr></table></figure></p>
<p>可以看出网卡<code>eth0</code>的带宽为1000Mbps（兆比特每秒），所以理论上的网速极限为<strong>1000÷8 = 125MB/s</strong>。</p>
<h2 id="3-2_sar">3.2 sar</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sar -n <span class="constant">DEV </span><span class="number">3</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV <span class="number">3</span> <span class="number">100</span></span><br><span class="line">Linux <span class="number">2.6</span>.32-<span class="number">2.0</span>.0.1 (localhost) 	<span class="number">08</span><span class="regexp">/25/</span><span class="number">2015</span> 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"><span class="label"></span><br><span class="line">08:</span><span class="number">37</span>:<span class="number">55</span> PM     IFACE   rxpck<span class="regexp">/s   txpck/</span>s    rxkB<span class="regexp">/s    txkB/</span>s   rxcmp<span class="regexp">/s   txcmp/</span>s  rxmcst/s</span><br><span class="line"><span class="number">08</span>:<span class="number">37</span>:<span class="number">58</span> PM        lo      <span class="number">2.01</span>      <span class="number">2.01</span>      <span class="number">0.44</span>      <span class="number">0.44</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">37</span>:<span class="number">58</span> PM      eth0      <span class="number">5.35</span>      <span class="number">0.00</span>      <span class="number">0.49</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">37</span>:<span class="number">58</span> PM      eth1     <span class="number">12.04</span>      <span class="number">3.01</span>      <span class="number">0.95</span>      <span class="number">0.86</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="label"></span><br><span class="line">08:</span><span class="number">37</span>:<span class="number">58</span> PM     IFACE   rxpck<span class="regexp">/s   txpck/</span>s    rxkB<span class="regexp">/s    txkB/</span>s   rxcmp<span class="regexp">/s   txcmp/</span>s  rxmcst/s</span><br><span class="line"><span class="number">08</span>:<span class="number">38</span>:<span class="number">01</span> PM        lo      <span class="number">9.00</span>      <span class="number">9.00</span>      <span class="number">2.52</span>      <span class="number">2.52</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">38</span>:<span class="number">01</span> PM      eth0     <span class="number">17.33</span>      <span class="number">0.00</span>      <span class="number">1.02</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">38</span>:<span class="number">01</span> PM      eth1     <span class="number">24.33</span>     <span class="number">12.67</span>      <span class="number">3.04</span>      <span class="number">6.48</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<ul>
<li>IFACE：网络设备的名称</li>
<li>rxpck/s：每秒钟接收到的包数目</li>
<li>txpck/s：每秒钟发送出去的包数目</li>
<li>rxkB/s：每秒钟接收到的字节数</li>
<li>txkB/s：每秒钟发送出去的字节数</li>
</ul>
<h2 id="3-3_netstat">3.3 netstat</h2><p><code>netstat</code>命令一般用于检验本机各端口的网络连接情况，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据。</p>
<p>部分选项如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a, --all, --listening     显示所有连接中的<span class="constant">Socket</span>。</span><br><span class="line"></span>-<span class="ruby">n, --numeric              以数字形式显示地址和端口号。</span><br><span class="line"></span>-<span class="ruby">t, -–tcp                  显示<span class="constant">TCP</span>传输协议的连线状况。</span><br><span class="line"></span>-<span class="ruby">u, -–udp                  显示<span class="constant">UDP</span>传输协议的连线状况。</span><br><span class="line"></span>-<span class="ruby">p, --programs             显示正在使用socket的程序名/进程<span class="constant">ID</span></span><br><span class="line"></span>-<span class="ruby">l, --listening            显示监控中的服务器的<span class="constant">Socket</span>。</span><br><span class="line"></span>-<span class="ruby">o, --timers               显示计时器。</span><br><span class="line"></span>-<span class="ruby">s, --statistics           显示每个网络协议的统计信息(比如<span class="constant">SNMP</span>)</span><br><span class="line"></span>-<span class="ruby">i, --interfaces           显示网络界面信息表单（网卡列表）</span><br><span class="line"></span>-<span class="ruby">r, --route                显示路由表</span></span><br></pre></td></tr></table></figure></p>
<p>常用的几种：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -aup        <span class="comment"># 输出所有UDP连接状况</span></span><br><span class="line"><span class="variable">$ </span>netstat -atp        <span class="comment"># 输出所有TCP连接状况</span></span><br><span class="line"><span class="variable">$ </span>netstat -s          <span class="comment"># 显示各个协议的网络统计信息</span></span><br><span class="line"><span class="variable">$ </span>netstat -i          <span class="comment"># 显示网卡列表</span></span><br><span class="line"><span class="variable">$ </span>netstat -r          <span class="comment"># 显示路由表信息</span></span><br></pre></td></tr></table></figure></p>
<p>找出程序运行的端口：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ap <span class="string">| grep ssh</span></span><br></pre></td></tr></table></figure></p>
<p>找出运行在指定端口的进程：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -anp <span class="string">| grep 60010</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="四、磁盘监控">四、磁盘监控</h1><h2 id="4-1_df">4.1 df</h2><p><code>df</code>命令的功能是用来检查linux的文件系统的磁盘空间占用情况。如果没有文件名被指定，则显示当前所有被挂载的文件系统，默认以 KB 为单位。</p>
<p>常用选项如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a  全部文件系统列表</span><br><span class="line"></span>-<span class="ruby">h  以方便阅读的方式显示</span><br><span class="line"></span>-<span class="ruby">i  显示inode信息</span><br><span class="line"></span>-<span class="ruby"><span class="constant">T</span>  显示文件系统类型</span><br><span class="line"></span>-<span class="ruby">l  只显示本地文件系统</span><br><span class="line"></span>-<span class="ruby">k  以<span class="constant">KB</span>为单位</span><br><span class="line"></span>-<span class="ruby">m  以<span class="constant">MB</span>为单位</span></span><br></pre></td></tr></table></figure></p>
<p>最常用的就是<code>$ df -h</code>。</p>
<h2 id="4-2_iostat">4.2 iostat</h2><p>上面在介绍CPU监控时，就可以看到<code>%wa</code>或<code>%iowait</code>这一项，它表示I/O等待所占用CPU的百分比。为了得到关于磁盘IO更详细的状态信息，可以使用 <strong>iostat（I/O statistics，输入输出统计）</strong>命令：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">c 显示<span class="constant">CPU</span>使用情况</span><br><span class="line"></span>-<span class="ruby">d 显示磁盘使用情况</span><br><span class="line"></span>-<span class="ruby">k 以 <span class="constant">KB</span> 为单位显示</span><br><span class="line"></span>-<span class="ruby">m 以 <span class="constant">M</span> 为单位显示</span><br><span class="line"></span>-<span class="ruby">x 显示详细信息</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ iostat -<span class="keyword">x</span> -k <span class="number">2</span> <span class="number">100</span>        <span class="comment"># 2表示刷新间隔，100表示刷新次数</span></span><br><span class="line"></span><br><span class="line">Linux <span class="number">2.6</span>.<span class="number">32</span>-<span class="number">2.0</span>.<span class="number">0</span>.<span class="number">1</span> (localhost) 	<span class="number">2015</span>年09月<span class="number">05</span>日 	_x86_64<span class="number">_</span>	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  <span class="variable">%user</span>   <span class="variable">%nice</span> <span class="variable">%system</span> <span class="variable">%iowait</span>  <span class="variable">%steal</span>   <span class="variable">%idle</span></span><br><span class="line">           <span class="number">2.34</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">1.87</span>    <span class="number">0</span>.<span class="number">70</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">95.08</span></span><br><span class="line"></span><br><span class="line">Device:         rrqm/<span class="keyword">s</span>   wrqm/<span class="keyword">s</span>     r/<span class="keyword">s</span>     w/<span class="keyword">s</span>    rkB/<span class="keyword">s</span>    wkB/<span class="keyword">s</span> avgrq-sz avgqu-sz   await  svctm  <span class="variable">%util</span></span><br><span class="line">sdj               <span class="number">0</span>.<span class="number">06</span>     <span class="number">0</span>.<span class="number">13</span>    <span class="number">6.18</span>    <span class="number">2.20</span>   <span class="number">708.94</span>   <span class="number">740.47</span>   <span class="number">345.95</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">5.32</span>   <span class="number">2.63</span>   <span class="number">2.20</span></span><br><span class="line">sdd               <span class="number">0</span>.<span class="number">06</span>     <span class="number">0</span>.<span class="number">13</span>    <span class="number">6.34</span>    <span class="number">2.15</span>   <span class="number">716.75</span>   <span class="number">722.91</span>   <span class="number">339.00</span>     <span class="number">0</span>.<span class="number">02</span>    <span class="number">2.07</span>   <span class="number">2.73</span>   <span class="number">2.32</span></span><br><span class="line">sdb               <span class="number">0</span>.<span class="number">05</span>     <span class="number">0</span>.<span class="number">12</span>    <span class="number">3.01</span>    <span class="number">1.68</span>   <span class="number">365.89</span>   <span class="number">581.01</span>   <span class="number">404.05</span>     <span class="number">0</span>.<span class="number">02</span>    <span class="number">3.26</span>   <span class="number">2.19</span>   <span class="number">1.03</span></span><br><span class="line">sdf               <span class="number">0</span>.<span class="number">06</span>     <span class="number">0</span>.<span class="number">14</span>    <span class="number">6.25</span>    <span class="number">2.21</span>   <span class="number">712.99</span>   <span class="number">741.76</span>   <span class="number">343.92</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">5.20</span>   <span class="number">2.62</span>   <span class="number">2.22</span></span><br><span class="line">sda               <span class="number">0</span>.<span class="number">30</span>     <span class="number">1.86</span>    <span class="number">9.34</span>    <span class="number">5.54</span>   <span class="number">705.95</span>   <span class="number">766.81</span>   <span class="number">197.98</span>     <span class="number">0</span>.<span class="number">03</span>    <span class="number">1.88</span>   <span class="number">2.72</span>   <span class="number">4.05</span></span><br></pre></td></tr></table></figure>
<p><code>iostat</code>主要是用来监控磁盘I/O，首先输出了CPUs的平均数据（avg-cpu），我们可以看<code>%iowait</code>这一项，除此之外iostat还提供了一些更详细的I/O状态数据，比如</p>
<ul>
<li>r/s:           每秒完成的读 I/O 设备次数。</li>
<li>w/s:         每秒完成的写 I/O 设备次数。</li>
<li>rkB/s:      每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节。</li>
<li>wkB/s:    每秒写K字节数.是 wsect/s 的一半。</li>
<li>avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。</li>
<li>avgqu-sz: 平均I/O队列长度。</li>
<li>await:    平均每次设备I/O操作的等待时间 (毫秒)。</li>
<li>svctm:   平均每次设备I/O操作的服务时间 (毫秒)。</li>
<li>%util:      一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的。</li>
</ul>
<p><br></p>
<h1 id="五、进程监控">五、进程监控</h1><h2 id="5-1_top">5.1 top</h2><p>前面介绍过的top命令中可以对进程进行监控，其中一行就输出了进程的总体情况：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Tasks</span>: <span class="string">661 total,   1 running, 659 sleeping,   0 stopped,   1 zombie</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，top按照CPU使用率对各个进程进行排序。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">PID</span> <span class="tag">USER</span>      <span class="tag">PR</span>  <span class="tag">NI</span>  <span class="tag">VIRT</span>  <span class="tag">RES</span>  <span class="tag">SHR</span> <span class="tag">S</span> %<span class="tag">CPU</span> %<span class="tag">MEM</span>    <span class="tag">TIME</span>+  <span class="tag">COMMAND</span></span><br><span class="line"> 2543 <span class="tag">root</span>      20   0  9204  636  396 <span class="tag">S</span>  0<span class="class">.7</span>  0<span class="class">.0</span> 614<span class="pseudo">:57</span><span class="class">.76</span> <span class="tag">irqbalance</span></span><br><span class="line"> 4279 <span class="tag">work</span>      20   0 15<span class="class">.8g</span> 1<span class="class">.4g</span>  10<span class="tag">m</span> <span class="tag">S</span>  0<span class="class">.7</span>  4<span class="class">.6</span> 121<span class="pseudo">:19</span><span class="class">.27</span> <span class="tag">java</span></span><br><span class="line">11761 <span class="tag">work</span>      20   0  153<span class="tag">m</span> 7192 1080 <span class="tag">S</span>  0<span class="class">.7</span>  0<span class="class">.0</span> 642<span class="pseudo">:26</span><span class="class">.65</span> <span class="tag">python</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>RES</strong>：进程使用的物理内存大小</li>
<li><strong>SHR</strong>：进程共享内存大小</li>
<li><strong>S</strong>：进程状态（R表示运行 ，S表示睡眠，Z表示僵死，D表示不可中断的睡眠）</li>
</ul>
<p>在top运行状态下，输入<code>M</code>按内存使用率排序、输入<code>P</code>按CPU占用率排序、输入<code>T</code>按累计时间排序、输入<code>c</code>显示进程的启动命令，输入<code>u</code>显示指定用户的进程。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">top</span> -<span class="tag">p</span> &lt;pid&gt;</span><br></pre></td></tr></table></figure></p>
<p>动态显示进程号为pid的进程的状态。</p>
<h2 id="5-2_ps">5.2 ps</h2><p><strong>ps（Process Status，进程状态）</strong>命令是最基本同时也是非常强大的进程查看命令，最常用的命令就是<code>ps aux</code>——显示当前所有进程<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ps</span> aux | grep <span class="literal">root</span>       <span class="comment"># 输出root用户的所有进程</span></span><br><span class="line">$ <span class="built_in">ps</span> -p &lt;pid&gt; -<span class="constant">L</span>            <span class="comment"># 显示进程&lt;pid&gt;的所有线程</span></span><br><span class="line">$ <span class="built_in">ps</span> -e -o pid,uname,pcpu,pmem,comm  <span class="comment"># 定制显示的列</span></span><br><span class="line">$ <span class="built_in">ps</span> -o lstart &lt;pid&gt;        <span class="comment"># 显示进程的启动时间</span></span><br></pre></td></tr></table></figure></p>
<p>ps命令的输出可以按任意某一列进行排序，通过使用内部排序键（列的别名），例如：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux --<span class="keyword">sort</span>=+rss         <span class="comment"># 按内存升序排列</span></span><br><span class="line">$ ps aux --<span class="keyword">sort</span>=-rss        <span class="comment"># 按内存降序排列</span></span><br><span class="line">$ ps aux --<span class="keyword">sort</span>=+<span class="variable">%cpu</span>        <span class="comment"># 按cpu升序排列</span></span><br><span class="line">$ ps aux --<span class="keyword">sort</span>=-<span class="variable">%cpu</span>       <span class="comment"># 按cpu降序排列</span></span><br></pre></td></tr></table></figure></p>
<p><code>ps</code>命令的用法太多了，掌握一些常用的用法就好。如需了解更多的可选项，可以查看man手册。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、内存监控">一、内存监控</h1><p>监控内存的使用状态是非常重要的，通过监控有助于了解内存的使用状态，比如内存占用是否正常，内存是否紧缺等等，监控内存最常使用的命令有free、vmstat、top等</p>
<h2 id="1-1_free">1.1 free</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="string">Mem:</span>      <span class="number">32872632</span>   <span class="number">12393128</span>   <span class="number">20479504</span>          <span class="number">0</span>      <span class="number">23308</span>    <span class="number">7496048</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="string">cache:</span>    <span class="number">4873772</span>   <span class="number">27998860</span></span><br><span class="line"><span class="string">Swap:</span>            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第一行（Mem）：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[-ROOT-表和.META.表结构详解]]></title>
    <link href="http://yoursite.com/2015/08/15/root-and-meta-table-structure/"/>
    <id>http://yoursite.com/2015/08/15/root-and-meta-table-structure/</id>
    <published>2015-08-15T14:29:27.000Z</published>
    <updated>2015-08-15T14:36:10.792Z</updated>
    <content type="html"><![CDATA[<p>在《<a href="http://songlee24.github.io/2015/07/24/hbase-introduction/" target="_blank" rel="external">HBase技术简介</a>》中我们知道，HBase中有两个特殊的表：<code>-ROOT-</code>和<code>.META.</code>。</p>
<p>由于HBase中的表可能非常大，故HBase会将表按行分成多个region，然后分配到多台RegionServer上。数据访问的整个流程如下图所示：<a id="more"></a></p>
<center><br><img src="http://img.blog.csdn.net/20150815181211282" alt=""><br></center>

<p>注意两点：</p>
<ol>
<li>Client端在访问数据的过程中并没有涉及到Master节点，也就是说HBase日常的数据操作并不需要Master，不会造成Master的负担。</li>
<li>并不是每次数据访问都要执行上面的整个流程，因为很多数据都会被Cache起来。</li>
</ol>
<hr>
<p>从存储结构和操作方法的角度来说，<code>-ROOT-</code>、<code>.META.</code>与其他表没有任何区别。它们与众不同的地方是HBase用它们来存贮一个重要的系统信息：</p>
<ul>
<li>-ROOT-：记录.META.表的Region信息。</li>
<li>.META.：记录用户表的Region信息。</li>
</ul>
<p>其中-ROOT-表本身只会有一个region，这样保证了只需要三次跳转，就能定位到任意region，</p>
<p><br></p>
<h1 id="一、META表结构">一、META表结构</h1><p>在 HBase Shell 里对<code>.META.</code>表进行 scan 和 describe ：</p>
<p><img src="http://img.blog.csdn.net/20150812143409121" alt=""></p>
<p>可以看出，<code>.META.</code>表的结构如下：</p>
<p><img src="http://img.blog.csdn.net/20150812121857591" alt=""></p>
<p><code>.META.</code>表中每一行记录了一个Region的信息。</p>
<p><strong>1)  RowKey</strong></p>
<p>RowKey就是Region Name，它的命名形式是<code>TableName,StartKey,TimeStamp.Encoded.</code>。</p>
<p>其中 Encoded 是<code>TableName,StartKey,TimeStamp</code>的md5值。</p>
<p>例如：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mytable,,<span class="number">1438832261249</span>.ea2b47e1eba6dd9a7121315cdf0e4f67.</span><br></pre></td></tr></table></figure></p>
<p>表名是<code>mytable</code>，StartKey为空，时间戳是<code>1438832261249</code>，前面三部分的md5是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"mytable,,1438832261249"</span> | md5sum   <span class="comment"># -n选项表示不输出换行符</span></span><br><span class="line">ea2b47e1eba6dd9a7121315cdf0e4f67  -</span><br></pre></td></tr></table></figure></p>
<p><strong>2)  Column Family</strong></p>
<p><code>.META.</code>表有两个Column Family：<code>info</code> 和 <code>historian</code>。</p>
<p>其中<code>info</code>包含了三个Column：</p>
<ul>
<li><code>regioninfo</code>：region的详细信息，包括StartKey、EndKey以及Table信息等等。</li>
<li><code>server</code>：管理该region的 RegionServer 的地址。</li>
<li><code>serverstartcode</code>：RegionServer 开始托管该region的时间。</li>
</ul>
<p>至于<code>historian</code>：</p>
<blockquote>
<p>That was a family used to keep track of region operations like open,<br>close, compact, etc. It proved to be more troublesome than handy so we<br>disabled this feature until coming up with a better solution. The<br>family stayed for backward compatibility.</p>
</blockquote>
<p>大致的意思是：这个Column Family是用来追踪一些region操作的，例如open、close、compact等。事实证明这非常的麻烦，所以在想出一个更好的解决方案之前我们禁用了此功能。这个列族会保持向后兼容。</p>
<p><strong>综上所述</strong>，<code>.META.</code>表中保存了所有用户表的region信息，在进行数据访问时，它是必不可少的一个环节。当Region被拆分、合并或者重新分配的时候，都需要来修改这张表的内容 来保证访问数据时能够正确地定位region。</p>
<p><br></p>
<h1 id="二、ROOT表结构">二、ROOT表结构</h1><p>当用户表特别大时，用户表的region也会非常多。<code>.META.</code>表存储了这些region信息，也变得非常大，这时<code>.META.</code>自己也需要划分成多个Region，托管到多个RegionServer上。</p>
<p>这时就出现了一个问题：<strong>当<code>.META.</code>被托管在多个RegionServer上，如何去定位<code>.META.</code>呢？</strong> HBase的做法是用另外一个表来记录<code>.META.</code>的Region信息，就和<code>.META.</code>记录用户表的Region信息一样，这个表就是<strong><code>-ROOT-</code></strong>表。</p>
<p>在 HBase Shell 里对<code>-ROOT-</code>表进行 scan 和 describe ：</p>
<p><img src="http://img.blog.csdn.net/20150815194826244" alt=""></p>
<p><code>-ROOT-</code>表的结构如下：</p>
<p><img src="http://img.blog.csdn.net/20150815200306658" alt=""></p>
<p>可以看出，除了没有<code>historian</code>列族之外，<code>-ROOT-</code>表的结构与<code>.META.</code>表的结构是一样的。另外，<code>-ROOT-</code>表的 RowKey 没有采用时间戳，也没有Encoded值，而是直接指定一个数字。</p>
<p><code>-ROOT-</code>表永远只有一个Region，也就只会存放在一台RegionServer上。—— 在进行数据访问时，需要知道管理<code>-ROOT-</code>表的RegionServer的地址。这个地址被存在 <strong>ZooKeeper</strong> 中。</p>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
<hr>
<p>参考：www.greatwqs.iteye.com/blog/1838904</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在《<a href="http://songlee24.github.io/2015/07/24/hbase-introduction/">HBase技术简介</a>》中我们知道，HBase中有两个特殊的表：<code>-ROOT-</code>和<code>.META.</code>。</p>
<p>由于HBase中的表可能非常大，故HBase会将表按行分成多个region，然后分配到多台RegionServer上。数据访问的整个流程如下图所示：]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MapReduce将HDFS文本数据导入HBase中]]></title>
    <link href="http://yoursite.com/2015/08/13/hdfs-import-to-hbase/"/>
    <id>http://yoursite.com/2015/08/13/hdfs-import-to-hbase/</id>
    <published>2015-08-12T23:40:33.000Z</published>
    <updated>2015-08-12T23:42:57.706Z</updated>
    <content type="html"><![CDATA[<p>HBase本身提供了很多种数据导入的方式，通常有两种常用方式：</p>
<ol>
<li>使用HBase提供的TableOutputFormat，原理是通过一个Mapreduce作业将数据导入HBase</li>
<li>另一种方式就是使用HBase原生Client API</li>
</ol>
<p>本文就是示范如何通过MapReduce作业从一个文件读取数据并写入到HBase中。</p>
<p>首先启动Hadoop与HBase，然后创建一个空表，用于后面导入数据：<a id="more"></a><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">006</span>:<span class="number">0</span>&gt; create <span class="string">'mytable'</span>,<span class="string">'cf'</span></span><br><span class="line"><span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">10.8310</span> seconds</span><br><span class="line"></span><br><span class="line">=&gt; Hbase::Table - mytable</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">007</span>:<span class="number">0</span>&gt; list</span><br><span class="line">TABLE                                                                                                   </span><br><span class="line">mytable                                                                                                 </span><br><span class="line"><span class="number">1</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.1220</span> seconds</span><br><span class="line"></span><br><span class="line">=&gt; [<span class="string">"mytable"</span>]</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">008</span>:<span class="number">0</span>&gt; scan <span class="string">'mytable'</span></span><br><span class="line">ROW                         COLUMN+CELL                                                                 </span><br><span class="line"><span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.2130</span> seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="一、示例程序">一、示例程序</h1><p>下面的示例程序通过<code>TableOutputFormat</code>将HDFS上具有一定格式的文本数据导入到HBase中。</p>
<p>首先创建MapReduce作业，目录结构如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hdfs2HBase/</span><br><span class="line">├── classes</span><br><span class="line">└── src</span><br><span class="line">    ├── Hdfs2HBase<span class="class">.java</span></span><br><span class="line">    ├── Hdfs2HBaseMapper<span class="class">.java</span></span><br><span class="line">    └── Hdfs2HBaseReducer.java</span><br></pre></td></tr></table></figure></p>
<p><strong>Hdfs2HBaseMapper.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBaseMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text line, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">                String lineStr = line.toString();</span><br><span class="line">                <span class="keyword">int</span> index = lineStr.indexOf(<span class="string">":"</span>);</span><br><span class="line">                String rowkey = lineStr.substring(<span class="number">0</span>, index);</span><br><span class="line">                String left = lineStr.substring(index+<span class="number">1</span>);</span><br><span class="line">                context.write(<span class="keyword">new</span> Text(rowkey), <span class="keyword">new</span> Text(left));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hdfs2HBaseReducer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBaseReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">Put</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text rowkey, Iterable&lt;Text&gt; value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">                String k = rowkey.toString();</span><br><span class="line">                <span class="keyword">for</span>(Text val : value) &#123;</span><br><span class="line">                        Put put = <span class="keyword">new</span> Put(k.getBytes());</span><br><span class="line">                        String[] strs = val.toString().split(<span class="string">":"</span>);</span><br><span class="line">                        String family = strs[<span class="number">0</span>];</span><br><span class="line">                        String qualifier = strs[<span class="number">1</span>];</span><br><span class="line">                        String v = strs[<span class="number">2</span>];</span><br><span class="line">                        put.add(family.getBytes(), qualifier.getBytes(), v.getBytes());</span><br><span class="line">                        context.write(<span class="keyword">new</span> ImmutableBytesWritable(k.getBytes()), put);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hdfs2HBase.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBase</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;infile&gt; &lt;table&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"hdfs2hbase"</span>);</span><br><span class="line">		job.setJarByClass(Hdfs2HBase.class);</span><br><span class="line">		job.setMapperClass(Hdfs2HBaseMapper.class);</span><br><span class="line">		job.setReducerClass(Hdfs2HBaseReducer.class);</span><br><span class="line">		</span><br><span class="line">		job.setOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">		job.setOutputValueClass(Put.class);</span><br><span class="line">		</span><br><span class="line">		job.setOutputFormatClass(TableOutputFormat.class);</span><br><span class="line">		</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, otherArgs[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置<code>javac</code>编译依赖环境：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar</span><br></pre></td></tr></table></figure>
<p>这里要操作HBase，故除了上面三个jar包，还需要<code>$HBASE_HOME/lib</code>目录下的jar包。为了方便，我们在<code>/etc/profile</code>的<strong><code>CLASSPATH</code></strong>里包含所有的依赖包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEMP=`ls /home/hadoop/hbase/lib/*.jar`</span><br><span class="line">HBASE_JARS=`<span class="built_in">echo</span> <span class="variable">$TEMP</span> | sed <span class="string">'s/ /:/g'</span>`</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:/home/hadoop/hadoop/share/hadoop/common/hadoop-common-<span class="number">2.6</span>.<span class="number">0</span>.jar:/home/hadoop/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.6</span>.<span class="number">0</span>.jar:/home/hadoop/hadoop/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar:<span class="variable">$HBASE_JARS</span></span><br></pre></td></tr></table></figure></p>
<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac <span class="operator">-d</span> classes/ src/*.java</span><br></pre></td></tr></table></figure>
<p><strong>打包</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar -cvf hdfs2hbase<span class="class">.jar</span> classes</span><br></pre></td></tr></table></figure>
<p><strong>运行</strong></p>
<p>创建一个<code>data.txt</code>文件，内容如下（列族是建表时创建的列族<code>cf</code>）：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">r1</span><span class="pseudo">:cf</span><span class="pseudo">:c1</span><span class="pseudo">:value1</span> </span><br><span class="line"><span class="tag">r2</span><span class="pseudo">:cf</span><span class="pseudo">:c2</span><span class="pseudo">:value2</span> </span><br><span class="line"><span class="tag">r3</span><span class="pseudo">:cf</span><span class="pseudo">:c3</span><span class="pseudo">:value3</span></span><br></pre></td></tr></table></figure></p>
<p>将文件复制到hdfs上：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop fs -put <span class="typedef"><span class="keyword">data</span>.txt /hbase</span></span><br></pre></td></tr></table></figure></p>
<p>运行MapReduce作业：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar Hdfs2HBase/hdfs2hbase<span class="class">.jar</span> com<span class="class">.lisong</span><span class="class">.hdfs2hbase</span><span class="class">.Hdfs2HBase</span> /hbase/data<span class="class">.txt</span> mytable</span><br></pre></td></tr></table></figure></p>
<p>报错<code>NoClassDefFoundError</code>找不到类定义：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="class">.lang</span><span class="class">.NoClassDefFoundError</span>: org/apache/hadoop/hbase/io/ImmutableBytesWritable</span><br><span class="line">	at com<span class="class">.lisong</span><span class="class">.hdfs2hbase</span><span class="class">.Hdfs2HBase</span><span class="class">.main</span>(Hdfs2HBase<span class="class">.java</span>:<span class="number">30</span>)</span><br><span class="line">	at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke0</span>(Native Method)</span><br><span class="line">	...</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.util</span><span class="class">.RunJar</span><span class="class">.run</span>(RunJar<span class="class">.java</span>:<span class="number">221</span>)</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.util</span><span class="class">.RunJar</span><span class="class">.main</span>(RunJar<span class="class">.java</span>:<span class="number">136</span>)</span><br><span class="line">Caused by: java<span class="class">.lang</span><span class="class">.ClassNotFoundException</span>: org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.hbase</span><span class="class">.io</span><span class="class">.ImmutableBytesWritable</span></span><br><span class="line">	at java<span class="class">.net</span><span class="class">.URLClassLoader</span><span class="class">.findClass</span>(URLClassLoader<span class="class">.java</span>:<span class="number">381</span>)</span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.ClassLoader</span><span class="class">.loadClass</span>(ClassLoader<span class="class">.java</span>:<span class="number">424</span>)</span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.ClassLoader</span><span class="class">.loadClass</span>(ClassLoader<span class="class">.java</span>:<span class="number">357</span>)</span><br><span class="line">	... <span class="number">7</span> more</span><br></pre></td></tr></table></figure></p>
<p>原因是我没有把HBase的jar包加到<code>hadoop-env.sh</code>中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEMP=`ls /home/hadoop/hbase/lib/*.jar`</span><br><span class="line">HBASE_JARS=`<span class="built_in">echo</span> <span class="variable">$TEMP</span> | sed <span class="string">'s/ /:/g'</span>`</span><br><span class="line">HADOOP_CLASSPATH=<span class="variable">$HBASE_JARS</span></span><br></pre></td></tr></table></figure></p>
<p>再次运行发现又报了<code>Unable to initialize MapOutputCollector</code>的错误：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> WARN mapred<span class="class">.MapTask</span>: Unable to initialize MapOutputCollector org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="variable">$MapOutputBuffer</span></span><br><span class="line">java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="variable">$MapOutputBuffer</span>.<span class="function"><span class="title">init</span><span class="params">(MapTask.java:<span class="number">1008</span>)</span></span></span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="class">.createSortingCollector</span>(MapTask<span class="class">.java</span>:<span class="number">401</span>)</span><br><span class="line">	...</span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> INFO mapred<span class="class">.LocalJobRunner</span>: map task executor complete.</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> WARN mapred<span class="class">.LocalJobRunner</span>: job_local2138114942_0001</span><br><span class="line">java<span class="class">.lang</span><span class="class">.Exception</span>: java<span class="class">.io</span><span class="class">.IOException</span>: Unable to initialize any output collector</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.LocalJobRunner</span><span class="variable">$Job</span>.<span class="function"><span class="title">runTasks</span><span class="params">(LocalJobRunner.java:<span class="number">462</span>)</span></span></span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.LocalJobRunner</span><span class="variable">$Job</span>.<span class="function"><span class="title">run</span><span class="params">(LocalJobRunner.java:<span class="number">522</span>)</span></span></span><br><span class="line">Caused by: java<span class="class">.io</span><span class="class">.IOException</span>: Unable to initialize any output collector</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="class">.createSortingCollector</span>(MapTask<span class="class">.java</span>:<span class="number">412</span>)</span><br><span class="line">	...</span><br><span class="line">	at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadPoolExecutor.java:<span class="number">617</span>)</span></span></span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> INFO mapreduce<span class="class">.Job</span>: Job job_local2138114942_0001 failed with state FAILED due to: NA</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">45</span> INFO mapreduce<span class="class">.Job</span>: Counters: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>原因是我没有指明Map输出的Key/Value类型，在<code>Hdfs2HBase.java</code>中添加以下两句：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.setMapOutputKeyClass(<span class="keyword">Text</span>.<span class="keyword">class</span>);</span><br><span class="line">job.setMapOutputValueClass(<span class="keyword">Text</span>.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果没有专门定义Mapper输出类型的话，<code>job.setOutputKeyClass</code>和<code>job.setOutputValueClass</code>设置的是Mapper和Reducer两个的输出类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.setOutputKeyClass(ImmutableBytesWritable.<span class="keyword">class</span>);</span><br><span class="line">job.setOutputValueClass(Put.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>而Hdfs2HBaseMapper输出类型是Text/Text，所以这里需要单独指定。</p>
<hr>
<p><strong>修改Hdfs2HBase.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBase</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;infile&gt; &lt;table&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"hdfs2hbase"</span>);</span><br><span class="line">		job.setJarByClass(Hdfs2HBase.class);</span><br><span class="line">		job.setMapperClass(Hdfs2HBaseMapper.class);</span><br><span class="line">		job.setReducerClass(Hdfs2HBaseReducer.class);</span><br><span class="line">		</span><br><span class="line">		job.setMapOutputKeyClass(Text.class);    <span class="comment">// +</span></span><br><span class="line">		job.setMapOutputValueClass(Text.class);  <span class="comment">// +</span></span><br><span class="line">	</span><br><span class="line">		job.setOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">		job.setOutputValueClass(Put.class);</span><br><span class="line">		</span><br><span class="line">		job.setOutputFormatClass(TableOutputFormat.class);</span><br><span class="line">		</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, otherArgs[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次编译、打包，然后运行成功！</p>
<p>查询HBase表，验证数据是否已导入：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt; scan 'mytable'</span><br><span class="line">ROW                         COLUMN+CELL                                                                 </span><br><span class="line"> r1                         <span class="variable">column=</span>cf:c1, <span class="variable">timestamp=</span><span class="number">1439223857492</span>, <span class="variable">value=</span>value1                         </span><br><span class="line"> r2                         <span class="variable">column=</span>cf:c2, <span class="variable">timestamp=</span><span class="number">1439223857492</span>, <span class="variable">value=</span>value2                         </span><br><span class="line"> r3                         <span class="variable">column=</span>cf:c3, <span class="variable">timestamp=</span><span class="number">1439223857492</span>, <span class="variable">value=</span>value3                         </span><br><span class="line"><span class="number">3</span> row(s) <span class="keyword">in</span> <span class="number">1.3820</span> seconds</span><br></pre></td></tr></table></figure></p>
<p>可以看到，数据导入成功！</p>
<p>由于需要频繁的与存储数据的RegionServer通信，占用资源较大，一次性入库大量数据时，TableOutputFormat效率并不好。</p>
<p><br></p>
<h1 id="二、拓展-TableReducer">二、拓展-TableReducer</h1><p>我们可以将<code>Hdfs2HBaseReducer.java</code>代码改成下面这样，作用是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBaseReducer</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text rowkey, Iterable&lt;Text&gt; value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		String k = rowkey.toString();</span><br><span class="line">		<span class="keyword">for</span>(Text val : value) &#123;</span><br><span class="line">			Put put = <span class="keyword">new</span> Put(k.getBytes());</span><br><span class="line">			String[] strs = val.toString().split(<span class="string">":"</span>);</span><br><span class="line">			String family = strs[<span class="number">0</span>];</span><br><span class="line">			String qualifier = strs[<span class="number">1</span>];</span><br><span class="line">			String v = strs[<span class="number">2</span>];</span><br><span class="line">			put.add(family.getBytes(), qualifier.getBytes(), v.getBytes());</span><br><span class="line">			context.write(<span class="keyword">new</span> ImmutableBytesWritable(k.getBytes()), put);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接继承了<code>TableReducer</code>，<code>TableReducer</code>是部分特例化的<code>Reducer</code>，它只有三个类型参数：输入Key/Value是对应Mapper的输出，输出Key可以是任意的类型，但是输出Value必须是一个<code>Put</code>或<code>Delete</code>实例。</p>
<p><img src="http://img.blog.csdn.net/20150812105912587" alt=""></p>
<p>编译打包运行，结果与前面的一样！</p>
<p><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HBase本身提供了很多种数据导入的方式，通常有两种常用方式：</p>
<ol>
<li>使用HBase提供的TableOutputFormat，原理是通过一个Mapreduce作业将数据导入HBase</li>
<li>另一种方式就是使用HBase原生Client API</li>
</ol>
<p>本文就是示范如何通过MapReduce作业从一个文件读取数据并写入到HBase中。</p>
<p>首先启动Hadoop与HBase，然后创建一个空表，用于后面导入数据：]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一个MapReduce程序——WordCount]]></title>
    <link href="http://yoursite.com/2015/07/29/mapreduce-word-count/"/>
    <id>http://yoursite.com/2015/07/29/mapreduce-word-count/</id>
    <published>2015-07-29T13:34:39.000Z</published>
    <updated>2015-07-29T13:42:18.298Z</updated>
    <content type="html"><![CDATA[<p>通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个程序就是词频统计<code>WordCount</code>程序。</p>
<h1 id="一、MapReduce简介">一、MapReduce简介</h1><h2 id="1-1_MapReduce编程模型">1.1 MapReduce编程模型</h2><p>MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。</p>
<p>在Hadoop中，用于执行MapReduce任务的机器角色有两个：<a id="more"></a></p>
<ul>
<li>JobTracker用于调度工作的，一个Hadoop集群中只有一个JobTracker，位于master。</li>
<li>TaskTracker用于执行工作，位于各slave上。</li>
</ul>
<p>在分布式计算中，MapReduce框架负责处理了并行编程中分布式存储、工作调度、负载均衡、容错均衡、容错处理以及网络通信等复杂问题，把处理过程高度抽象为两个函数：map和reduce，map负责把任务分解成多个任务，reduce负责把分解后多任务处理的结果汇总起来。</p>
<p>需要注意的是，用MapReduce来处理的数据集（或任务）必须具备这样的特点：待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理。</p>
<h2 id="1-2_MapReduce处理过程">1.2 MapReduce处理过程</h2><p>在Hadoop中，每个MapReduce任务都被初始化为一个Job，每个Job又可以分为两种阶段：map阶段和reduce阶段。</p>
<ul>
<li>map：<code>(K1, V1)</code> ——&gt; <code>list(K2, V2)</code></li>
<li>reduce：<code>(K2, list(V2))</code> ——&gt; <code>list(K3, V3)</code></li>
</ul>
<p>如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150728184403091" alt=""></p>
<p><br></p>
<h1 id="二、运行WordCount程序">二、运行WordCount程序</h1><p>在运行程序之前，需要先搭建好Hadoop集群环境，参考《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/46974723" target="_blank" rel="external">Hadoop+HBase+ZooKeeper分布式集群环境搭建</a>》。</p>
<h2 id="2-1_源代码">2.1 源代码</h2><p>WordCount可以说是最简单的MapReduce程序了，只包含三个文件：一个 Map 的 Java 文件，一个 Reduce 的 Java 文件，一个负责调用的主程序 Java 文件。</p>
<p>我们在当前用户的主文件夹下创建<code>wordcount_01/</code>目录，在该目录下再创建<code>src/</code>和<code>classes/</code>。 src 目录存放 Java 的源代码，classes 目录存放编译结果。</p>
<p><strong>TokenizerMapper.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">	Text word = <span class="keyword">new</span> Text();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">		<span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">			word.set(itr.nextToken());</span><br><span class="line">			context.write(word, one);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IntSumReducer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(IntWritable val:values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WordCount.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"wordcount"</span>);</span><br><span class="line">		job.setJarByClass(WordCount.class);</span><br><span class="line">		job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">		job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">		job.setReducerClass(IntSumReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个.java源文件均置于 src 目录下。</p>
<h2 id="2-2_编译">2.2 编译</h2><p>Hadoop 2.x 版本中jar不再集中在一个 hadoop-core-*.jar 中，而是分成多个 jar。编译WordCount程序需要如下三个 jar：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar</span><br></pre></td></tr></table></figure></p>
<p>使用<code>javac</code>命令进行编译：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd wordcount_01</span><br><span class="line"></span><br><span class="line">$ javac -<span class="keyword">classpath</span> <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop/</span>share<span class="regexp">/hadoop/</span>common<span class="regexp">/hadoop-common-2.6.0.jar:/</span>home<span class="regexp">/hadoop/</span>hadoop<span class="regexp">/share/</span>hadoop<span class="regexp">/mapreduce/</span>hadoop-mapreduce-client-core-<span class="number">2.6</span>.<span class="number">0</span>.jar:<span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop/</span>share<span class="regexp">/hadoop/</span>common<span class="regexp">/lib/</span>commons-cli-<span class="number">1.2</span>.jar -d classes<span class="regexp">/ src/</span>*.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-classpath，设置源代码里使用的各种类库所在的路径，多个路径用<code>&quot;:&quot;</code>隔开。</li>
<li>-d，设置编译后的 class 文件保存的路径。</li>
<li>src/*.java，待编译的源文件。</li>
</ul>
<h2 id="2-3_打包">2.3 打包</h2><p>将编译好的 class 文件打包成 Jar 包，jar 命令是 JDK 的打包命令行工具。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar -cvf wordcount<span class="class">.jar</span> classes</span><br></pre></td></tr></table></figure>
<p>打包结果是 wordcount.jar 文件，放在当前目录下。</p>
<h2 id="2-4_执行">2.4 执行</h2><p>执行hadoop程序的时候，输入文件必须先放入hdfs文件系统中，不能是本地文件。</p>
<p><strong>1 . 先查看hdfs文件系统的根目录：</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop<span class="regexp">/bin/hadoop fs -ls /</span></span><br><span class="line">Found <span class="number">1</span> items</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          <span class="number">0</span> <span class="number">2015</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">14</span>:<span class="number">38</span> /hbase</span><br></pre></td></tr></table></figure></p>
<p>可以看出，hdfs的根目录是一个叫<code>/hbase</code>的目录。</p>
<p><strong>2 . 然后利用<code>put</code>将输入文件（多个输入文件位于<code>input</code>文件夹下）复制到hdfs文件系统中：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop fs -put <span class="tag">input</span> /hbase</span><br></pre></td></tr></table></figure></p>
<p><strong>3 . 运行wordcount程序</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount_01/wordcount<span class="class">.jar</span> WordCount /hbase/<span class="tag">input</span> /hbase/output</span><br></pre></td></tr></table></figure>
<p>提示找不到 WordCount 类：<code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: WordCount</code>…</p>
<p>因为程序中声明了 package ，所以在命令中也要 com.lisong.hadoop.WordCount 写完整：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount_01/wordcount<span class="class">.jar</span> com<span class="class">.lisong</span><span class="class">.hadoop</span><span class="class">.WordCount</span> /hbase/<span class="tag">input</span> /hbase/output</span><br></pre></td></tr></table></figure></p>
<p>其中 “jar” 参数是指定 jar 包的位置，com.lisong.hadoop.WordCount 是主类。运行程序处理 input 目录下的多个文件，将结果写入 /hbase/output 目录。</p>
<p><strong>4 . 查看运行结果</strong></p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">hadoop/bin/hadoop</span> <span class="comment">fs</span> <span class="literal">-</span><span class="comment">ls</span> <span class="comment">/hbase/output</span></span><br><span class="line"><span class="comment">Found</span> <span class="comment">2</span> <span class="comment">items</span></span><br><span class="line"><span class="literal">-</span><span class="comment">rw</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span>   <span class="comment">3</span> <span class="comment">hadoop</span> <span class="comment">supergroup</span>          <span class="comment">0</span> <span class="comment">2015</span><span class="literal">-</span><span class="comment">07</span><span class="literal">-</span><span class="comment">28</span> <span class="comment">18:05</span> <span class="comment">/hbase/output/_SUCCESS</span></span><br><span class="line"><span class="literal">-</span><span class="comment">rw</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span>   <span class="comment">3</span> <span class="comment">hadoop</span> <span class="comment">supergroup</span>         <span class="comment">33</span> <span class="comment">2015</span><span class="literal">-</span><span class="comment">07</span><span class="literal">-</span><span class="comment">28</span> <span class="comment">18:05</span> <span class="comment">/hbase/output/part</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="comment">00000</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>/hbase/output/</code>目录下有两个文件，结果就存在<code>part-r-00000</code>中：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop<span class="regexp">/bin/</span>hadoop fs -cat <span class="regexp">/hbase/</span>output/part-r-<span class="number">00000</span></span><br><span class="line">Google	<span class="number">6</span></span><br><span class="line">Java	<span class="number">2</span></span><br><span class="line">baidu	<span class="number">3</span></span><br><span class="line">hadoop	<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="三、WordCount程序分析">三、WordCount程序分析</h1><h2 id="3-1_Hadoop数据类型">3.1 Hadoop数据类型</h2><p>Hadoop MapReduce操作的是键值对，但这些键值对并不是Integer、String等标准的Java类型。为了让键值对可以在集群上移动，Hadoop提供了一些实现了<code>WritableComparable</code>接口的基本数据类型，以便用这些类型定义的数据可以被<strong>序列化</strong>进行网络传输、文件存储与大小比较。</p>
<ul>
<li>值：仅会被简单的传递，必须实现<code>Writable</code>或<code>WritableComparable</code>接口。</li>
<li>键：在Reduce阶段排序时需要进行比较，故只能实现<code>WritableComparable</code>接口。</li>
</ul>
<p>下面是8个预定义的Hadoop基本数据类型，它们均实现了<code>WritableComparable</code>接口：</p>
<table>
<thead>
<tr>
<th>类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BooleanWritable</td>
<td style="text-align:left">标准布尔型数值</td>
</tr>
<tr>
<td>ByteWritable</td>
<td style="text-align:left">单字节数值</td>
</tr>
<tr>
<td>DoubleWritable</td>
<td style="text-align:left">双字节数</td>
</tr>
<tr>
<td>FloatWritable</td>
<td style="text-align:left">浮点数</td>
</tr>
<tr>
<td>IntWritable</td>
<td style="text-align:left">整型数</td>
</tr>
<tr>
<td>LongWritable</td>
<td style="text-align:left">长整型数</td>
</tr>
<tr>
<td>Text</td>
<td style="text-align:left">使用UTF8格式存储的文本</td>
</tr>
<tr>
<td>NullWritable</td>
<td style="text-align:left">当<code>&lt;key,value&gt;</code>中的key或value为空时使用</td>
</tr>
</tbody>
</table>
<h2 id="3-2_源代码分析">3.2 源代码分析</h2><p><strong>3.2.1 Map过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">	Text word = <span class="keyword">new</span> Text();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">		<span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">			word.set(itr.nextToken());</span><br><span class="line">			context.write(word, one);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map过程需要继承<code>org.apache.hadoop.mapreduce</code>包中 Mapper 类，并<strong>重写</strong>其map方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的模板参数：第一个Object表示输入key的类型；第二个Text表示输入value的类型；第三个Text表示表示输出键的类型；第四个IntWritable表示输出值的类型。</p>
<p>作为map方法输入的键值对，其value值存储的是文本文件中的一行（以回车符为行结束标记），而key值为该行的首字母相对于文本文件的首地址的偏移量。然后StringTokenizer类将每一行拆分成为一个个的单词，并将<code>&lt;word,1&gt;</code>作为map方法的结果输出，其余的工作都交有 MapReduce框架 处理。</p>
<p><strong>注：</strong><code>StringTokenizer</code>是Java工具包中的一个类，用于将字符串进行拆分——默认情况下使用空格作为分隔符进行分割。</p>
<p><strong>3.2.2 Reduce过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(IntWritable val:values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reduce过程需要继承<code>org.apache.hadoop.mapreduce</code>包中 Reducer 类，并 <strong>重写</strong> reduce方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中模板参数同Map一样，依次表示是输入键类型，输入值类型，输出键类型，输出值类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span></span></span><br></pre></td></tr></table></figure>
<p>reduce 方法的输入参数 key 为单个单词，而 values 是由各Mapper上对应单词的计数值所组成的列表（一个实现了 Iterable 接口的变量，可以理解成 values 里包含若干个 IntWritable 整数，可以通过迭代的方式遍历所有的值），所以只要遍历 values 并求和，即可得到某个单词出现的总次数。</p>
<p><strong>3.2.3 执行作业</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"wordcount"</span>);</span><br><span class="line">		job.setJarByClass(WordCount.class);</span><br><span class="line">		job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">		job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">		job.setReducerClass(IntSumReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MapReduce中，由Job对象负责管理和运行一个计算任务，并通过Job的一些方法对任务的参数进行相关的设置，此处：</p>
<ul>
<li>设置了使用<code>TokenizerMapper.class</code>完成Map过程中的处理，使用<code>IntSumReducer.class</code>完成Combine和Reduce过程中的处理。</li>
<li>还设置了Map过程和Reduce过程的输出类型：key的类型为Text，value的类型为IntWritable。</li>
<li><p>任务的输出和输入路径则由命令行参数指定，并由FileInputFormat和FileOutputFormat分别设定。</p>
<ol>
<li>FileInputFormat类的很重要的作用就是将文件进行切分 split，并将 split 进一步拆分成key/value对</li>
<li>FileOutputFormat类的作用是将处理结果写入输出文件。</li>
</ol>
</li>
<li><p>完成相应任务的参数设定后，即可调用 <code>job.waitForCompletion()</code> 方法执行任务。</p>
</li>
</ul>
<p><strong>3.2.4 WordCount流程</strong></p>
<p>1）将文件拆分成splits，由于测试用的文件较小，所以每个文件为一个split，并将文件按行分割形成<code>&lt;key,value&gt;</code>对，key为偏移量（包括了回车符），value为文本行。这一步由MapReduce框架自动完成，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729173938301" alt=""></p>
<p>2）将分割好的<code>&lt;key,value&gt;</code>对交给用户定义的map方法进行处理，生成新的<code>&lt;key,value&gt;</code>对，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150729174039812" alt=""></p>
<p>3）得到map方法输出的<code>&lt;key,value&gt;</code>对后，Mapper会将它们按照key值进行排序，并执行Combine过程，将key值相同的value值累加，得到Mapper的最终输出结果。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729174057622" alt=""></p>
<p>4）Reducer先对从Mapper接收的数据进行排序，再交由用户自定义的reduce方法进行处理，得到新的<code>&lt;key,value&gt;</code>对，并作为WordCount的输出结果，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729174400615" alt=""></p>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<hr>
<p>参考： 实战Hadoop：开启通向云计算的捷径</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个程序就是词频统计<code>WordCount</code>程序。</p>
<h1 id="一、MapReduce简介">一、MapReduce简介</h1><h2 id="1-1_MapReduce编程模型">1.1 MapReduce编程模型</h2><p>MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。</p>
<p>在Hadoop中，用于执行MapReduce任务的机器角色有两个：]]>
    
    </summary>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
      <category term="大数据-Hadoop" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase技术简介]]></title>
    <link href="http://yoursite.com/2015/07/24/hbase-introduction/"/>
    <id>http://yoursite.com/2015/07/24/hbase-introduction/</id>
    <published>2015-07-23T16:49:08.000Z</published>
    <updated>2016-02-23T12:32:28.981Z</updated>
    <content type="html"><![CDATA[<h1 id="一、HBase简介">一、HBase简介</h1><p>HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，类似Google BigTable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。<a id="more"></a></p>
<p><img src="http://img.blog.csdn.net/20150723155042611" alt=""></p>
<p>上图描述了Hadoop EcoSystem中的各层系统，其中HBase位于结构化存储层，Hadoop HDFS为HBase提供了高可靠性的底层存储支持，Hadoop MapReduce为HBase提供了高性能的计算能力，Zookeeper为HBase提供了稳定服务和failover机制。</p>
<p>此外，Pig和Hive还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单。 Sqoop则为HBase提供了方便的RDBMS数据导入功能，使得传统数据库数据向HBase中迁移变的非常方便。</p>
<p><br></p>
<h1 id="二、HBase访问接口">二、HBase访问接口</h1><ol>
<li><p>Native Java API，最常规和高效的访问方式，适合Hadoop MapReduce Job并行批处理HBase表数据</p>
</li>
<li><p>HBase Shell，HBase的命令行工具，最简单的接口，适合HBase管理使用</p>
</li>
<li><p>Thrift Gateway，利用Thrift序列化技术，支持C++，PHP，Python等多种语言，适合其他异构系统在线访问HBase表数据</p>
</li>
<li><p>REST Gateway，支持REST 风格的Http API访问HBase, 解除了语言限制</p>
</li>
<li><p>Pig，可以使用Pig Latin流式编程语言来操作HBase中的数据，和Hive类似，本质最终也是编译成MapReduce Job来处理HBase表数据，适合做数据统计</p>
</li>
<li><p>Hive，当前Hive的Release版本尚没有加入对HBase的支持，但在下一个版本Hive 0.7.0中将会支持HBase，可以使用类似SQL语言来访问HBase。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、HBase数据模型">三、HBase数据模型</h1><h2 id="3-1_Table_&amp;_Column_Family">3.1 Table &amp; Column Family</h2><p><img src="http://img.blog.csdn.net/20150724005727007" alt=""></p>
<p><strong>Row Key：</strong> </p>
<p>行键，Table的主键，用来检索记录。访问HBase table中的行，只有三种方式：</p>
<ul>
<li>通过单个row key访问</li>
<li>通过row key的range</li>
<li>全表扫描</li>
</ul>
<p>row key可以是任意字符串（最大长度是 64KB，实际应用中长度一般为 10-100bytes左右），在HBase内部，row key保存为字节数组。数据按照row key的字典序（byte order）排序存储，因此设计key时要充分排序存储这个特性，将经常一起读取的行存储放到一起。</p>
<p>HBase支持单行事务，行的一次读写是原子操作 （不论一次读写多少列），这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。</p>
<p><strong>Column Family</strong>：</p>
<p>列簇，Table在水平方向有一个或者多个Column Family组成，一个Column Family中可以由任意多个Column组成，即Column Family支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。</p>
<p>列名都以列族作为前缀。例如’courses:history’，’courses:math’，都属于courses 这个列族。<br>访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族上的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</p>
<p><strong>Timestamp</strong>: </p>
<p>时间戳，每次数据操作对应的时间戳，可以看作是数据的version number。时间戳的类型是 64位整型。时间戳可以由HBase在数据写入时自动赋值，此时时间戳是精确到毫秒的当前系统时间；时间戳也可以由客户显式赋值，如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。</p>
<p>为了避免数据存在过多版本造成的的管理 （包括存储和索引）负担，HBase提供了两种数据版本回收方式：一是保存数据的最后n个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<p><strong>Cell：</strong></p>
<p>由 {<code>row key</code>, <code>column family</code>, <code>column qualifier</code>, <code>version</code>} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存贮。</p>
<h2 id="3-2_Table_&amp;_Region">3.2 Table &amp; Region</h2><p>当Table随着记录数不断增加而变大后，会逐渐分裂成多份splits，成为regions，一个region由[startkey,endkey)表示，不同的region会被Master分配给相应的RegionServer进行管理：</p>
<p><img src="http://img.blog.csdn.net/20150723171646985" alt=""></p>
<h2 id="3-3_-ROOT-_&amp;&amp;_-META-_Table">3.3 -ROOT- &amp;&amp; .META. Table</h2><p>HBase中有两张特殊的Table，-ROOT-和.META.</p>
<ul>
<li><p>.META.：记录了用户表的Region信息，.META.可以有多个regoin</p>
</li>
<li><p>-ROOT-：记录了.META.表的Region信息，-ROOT-只有一个region</p>
</li>
<li><p>Zookeeper中记录了-ROOT-表的location</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150723172102610" alt=""></p>
<p>Client访问用户数据之前需要首先访问zookeeper，然后访问-ROOT-表，接着访问.META.表，最后才能找到User Table的位置去访问，中间需要多次网络操作，不过Client端会做cache缓存。</p>
<p><br></p>
<h1 id="四、HBase系统架构">四、HBase系统架构</h1><p><img src="http://img.blog.csdn.net/20150723173041385" alt=""></p>
<p><strong>Client</strong></p>
<p>HBase Client使用HBase的RPC机制与HMaster和HRegionServer进行通信，对于管理类操作，Client与HMaster进行RPC；对于数据读写类操作，Client与HRegionServer进行RPC</p>
<p><strong>Zookeeper</strong></p>
<p>Zookeeper Quorum中除了存储了-ROOT-表的地址和HMaster的地址，HRegionServer也会把自己以Ephemeral方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的健康状态。此外，Zookeeper也避免了HMaster的单点问题，见下文描述。</p>
<p><strong>HMaster</strong></p>
<p>HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行，HMaster在功能上主要负责Table和Region的管理工作：</p>
<ol>
<li><p>管理用户对Table的增、删、改、查操作</p>
</li>
<li><p>管理HRegionServer的负载均衡，调整Region分布</p>
</li>
<li><p>在Region Split后，负责新Region的分配</p>
</li>
<li><p>在HRegionServer停机后，负责失效HRegionServer 上的Regions迁移</p>
</li>
<li><p>HDFS的垃圾文件回收 </p>
</li>
</ol>
<p>注意：Client访问HBase上数据的过程并不需要HMaster参与（寻址访问Zookeeper和HRegionServer，数据读写访问HRegioneServer），HMaster仅仅维护者table和region的元数据信息，负载很低。</p>
<p><strong>HRegionServer</strong></p>
<p>HRegionServer主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。</p>
<p><img src="http://img.blog.csdn.net/20150723174212472" alt=""></p>
<p><strong>注意，每个HRegsionServer维护一个HLog文件</strong></p>
<p>HRegionServer内部管理了一系列HRegion对象，每个HRegion对应了Table中的一个Region，HRegion中由多个HStore组成。每个HStore对应了Table中的一个Column Family的存储，可以看出每个Column Family其实就是一个集中的存储单元，因此最好将具备共同IO特性的column放在一个Column Family中，这样最高效。</p>
<p><strong>HStore</strong></p>
<p>HStore 是HBase存储的核心，其中由两部分组成：</p>
<ul>
<li>MemStore</li>
<li>StoreFiles。</li>
</ul>
<p>MemStore是Sorted Memory Buffer，用户写入的数据首先会放入MemStore，当MemStore满了以后会Flush成一个StoreFile（底层实现是HFile）。</p>
<p>Compaction：当StoreFile文件数量增长到一定阈值，会触发Compact合并操作，将多个StoreFiles合并成一个StoreFile，合并过程中会进行版本合并和数据删除，因此可以看出HBase其实只有增加数据，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的写操作只要进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
<p>Split：当StoreFiles Compact后，会逐步形成越来越大的StoreFile，当单个StoreFile大小超过一定阈值后，会触发Split操作，同时把当前Region Split成2个Region，父Region会下线，新Split出的2个孩子Region会被HMaster分配到相应的HRegionServer上，使得原先1个Region的压力得以分流到2个Region上。下图描述了Compaction和Split的过程：</p>
<p><img src="http://img.blog.csdn.net/20150723175721133" alt=""></p>
<p><strong>HLog</strong></p>
<p>在理解了上述HStore的基本原理后，还必须了解一下HLog的功能，因为上述的HStore在系统正常工作的前提下是没有问题的，但是在分布式系统环境中，无法避免系统出错或者宕机，因此一旦HRegionServer意外退出，MemStore中的内存数据将会丢失，这就需要引入HLog了。</p>
<p>每个HRegionServer中都有一个HLog对象，HLog是一个实现Write Ahead Log的类，在每次用户操作写入MemStore的同时，也会写一份数据到HLog文件中（HLog文件格式见后续），HLog文件定期会滚动出新的，并删除旧的文件（已持久化到StoreFile中的数据）。当HRegionServer意外终止后，HMaster会通过Zookeeper感知到，HMaster首先会处理遗留的 HLog文件，将其中不同Region的Log数据进行拆分，分别放到相应region的目录下，然后再将失效的region重新分配，领取 到这些region的HRegionServer在Load Region的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后flush到StoreFiles，完成数据恢复。</p>
<p><br></p>
<h1 id="五、HBase存储格式">五、HBase存储格式</h1><p>HBase中的所有数据文件都存储在Hadoop HDFS文件系统上，主要包括上述提出的两种文件类型：</p>
<ol>
<li><p>HFile， HBase中KeyValue数据的存储格式，HFile是Hadoop的二进制格式文件，实际上StoreFile就是对HFile做了轻量级包装，即StoreFile底层就是HFile</p>
</li>
<li><p>HLog File，HBase中WAL（Write Ahead Log） 的存储格式，物理上是Hadoop的Sequence File</p>
</li>
</ol>
<p><strong>HFile</strong></p>
<p>下图是HFile V2的存储格式：</p>
<p><img src="http://img.blog.csdn.net/20150724000300134" alt=""></p>
<p>HFile的组成分成四部分，分别是Scanned Block（数据block）、Non-Scanned block（元数据block）、Load-on-open（在hbase运行时，HFile需要加载到内存中的索引、bloom filter和文件信息）以及trailer（文件尾）。</p>
<p>在HFile中根据一个key搜索一个data的过程： </p>
<ol>
<li><p>先内存中对HFile的root index进行二分查找。如果支持多级索引的话，则定位到的是leaf/intermediate index，如果是单级索引，则定位到的是data block</p>
</li>
<li><p>如果支持多级索引，则会从缓存/hdfs（分布式文件系统）中读取leaf/intermediate index chunk，在leaf/intermediate chunk根据key值进行二分查找（leaf/intermediate index chunk支持二分查找），找到对应的data block。</p>
</li>
<li><p>从缓存/hdfs中读取data block。</p>
</li>
<li><p>在data block中遍历查找key。</p>
</li>
</ol>
<p>Data Block是HBase I/O的基本单元，为了提高效率，HRegionServer中有基于LRU的 Block Cache 机制。每个Data块的大小可以在创建一个Table的时候通过参数指定（默认64K），大号的Block有利于顺序Scan，小号Block利于随机查询。在DataBlock中存储的是一系列KeyValue，在KeyValue后面跟一个timestamp，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150724000710687" alt=""></p>
<p>HFile里面的每个KeyValue对就是一个简单的byte数组。但是这个byte数组里面包含了很多项，并且有固定的结构。KV结构图如下：</p>
<p><img src="http://img.blog.csdn.net/20150724000728042" alt=""></p>
<p>可以看出KeyValue格式分为四个部分：KeyLength、ValueLength、Key、Value。</p>
<p>其中KeyLength和ValueLength都是整型，表示长度。Key有固定的格式，KeyType有四种类型，分别是Put、Delete、 DeleteColumn和DeleteFamily。Value部分没有这么复杂的结构，就是纯粹的二进制数据了。</p>
<p><strong>HLogFile</strong></p>
<p><img src="http://img.blog.csdn.net/20150724000757602" alt=""></p>
<p>上图中示意了HLog文件的结构，其实HLog文件就是一个普通的Hadoop Sequence File，Sequence File 的Key是HLogKey对象，HLogKey中记录了写入数据的归属信息，除了table和region名字外，同时还包括 sequence number和timestamp，timestamp是“写入时间”，sequence number的起始值为0，或者是最近一次存入文件系统中sequence number。</p>
<p>HLog Sequece File的Value是HBase的KeyValue对象，即对应HFile中的KeyValue，可参见上文描述。</p>
<p><br></p>
<h1 id="六、关键流程">六、关键流程</h1><h2 id="6-1_region定位">6.1 region定位</h2><p>HBase如何找到某个row key （或者某个row key的range）所在的region？使用三层类似B+树的结构来保存region位置：</p>
<ul>
<li>第一层：Zookeeper保存了-ROOT-表的位置。</li>
<li>第二层：-ROOT- 表保存了.META.表所有region的位置，通过-ROOT-表，可以访问.META.表的数据。</li>
<li>第三层：.META.是一个特殊的表，保存了HBase中所有数据表的region位置信息。</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li>-ROOT-表永远不会被split，保证了只需要三次跳转，就能定位到任意region</li>
<li>META.表每行保存一个region的位置信息，row key采用表名+表的最后一行编码而成</li>
<li>为了加快访问，.META.表的全部region都保存在内存中</li>
<li>Client会将查询过的位置信息保存缓存起来，缓存不会主动失效</li>
</ol>
<h2 id="6-2_region分配">6.2 region分配</h2><p>任何时刻，一个region只能分配给一个HRegionServer。HMaster记录了当前有哪些可用的HRegionServer。以及当前哪些region分配给了哪些HRegionServer，哪些region还没有分配。当存在未分配的region，并且有一个HRegionServer上有可用空间时，HMaster就给这个HRegionServer发送一个装载请求，把region分配给这个HRegionServer。HRegionServer得到请求后，就开始对此region提供服务。</p>
<h2 id="6-3_写请求处理">6.3 写请求处理</h2><p>数据在更新时首先写入Log（WAL log）和内存（MemStore）中，MemStore中的数据是排序的，当MemStore累计到一定阈值时，就会创建一个新的MemStore，并且将老的MemStore添加到flush队列，由单独的线程flush到磁盘上，成为一个StoreFile。与此同时，系统会在Zookeeper中记录一个redo point，表示这个时刻之前的变更已经持久化了。</p>
<p>当系统出现意外时，可能导致内存（MemStore）中的数据丢失，此时使用Log（WAL log）来恢复checkpoint之后的数据。</p>
<p>前面提到过StoreFile是只读的，一旦创建后就不可以再修改。因此HBase的更新其实是不断追加的操作，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的写操作只要 进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
<h2 id="6-4_读请求处理">6.4 读请求处理</h2><p>如果想快速读取数据，通用的原则是数据保持有序 并 尽可能保存在内存里。HBase实现了这两个目标。</p>
<ol>
<li>HBase提供三维有序存储，首先以rowkey字典序，然后以column family + column qualifier字典序，最后单元格是以timestamp时间戳降序排序。</li>
<li>HBase读操作使用了LRU缓存技术，这种缓存叫做BlockCache，用来保存从HFile里读入内存的频繁访问的数据。</li>
</ol>
<p>从HBase读数据，会依次访问三个地方：首先检查MemStore，然后检查BlockCache，最后才会访问硬盘上的对应HFile。</p>
<h2 id="6-5_Compact/Split">6.5 Compact/Split</h2><p>上文已经讲到，当StoreFile文件数量达到一定阈值，会触发compaction；当单个StoreFile大小超过一定阈值后，会触发split。</p>
<p>Compaction分为两种：major compaction（大合并）和 minor compaction（小合并）</p>
<ol>
<li><p>minor compaction把多个小HFile合并成一个大HFile，主要是为了提高读效率（因为一个row可能散布在多个HFile文件中）。minor compaction不做任何删除数据、过期数据的清理工作。</p>
</li>
<li><p>major compaction是把给定region的一个列族的所有HFile合并成一个文件，major compaction会丢弃有删除标记的或过期的内容，释放占用的空间。</p>
</li>
<li><p>minor合并是轻量级的，可以频繁发生；major合并相当耗资源，不要经常使用，且通常需要手工触发。</p>
</li>
</ol>
<p>Split操作过程完成的非常快，因为原始的数据文件并不会被改变，系统只是简单的创建两个Reference文件指向原始的数据文件，每个Reference文件管理原始文件一半的数据。Reference文件名字是一个ID，它使用被参考的region的名字的hash作为前缀，例如：1278437856009925445.3323223323。Reference文件只含有非常少量的信息，这些信息包括被分割的原始region的key以及这个文件管理前半段还是后半段。只有当系统做compaction的时候原始数据文件才会被分割成两个独立的文件并放到相应的region目录下面，同时原始数据文件和那些Reference文件也会被清除。</p>
<h2 id="6-6_HRegionServer上线和下线">6.6 HRegionServer上线和下线</h2><p>HMaster使用Zookeeper来跟踪HRegionServer状态。当某个HRegionServer启动时，会首先在Zookeeper上的server目录下建立代表自己的文件，并获得该文件的独占锁。由于HMaster订阅了server目录上的变更消息，当server目录下的文件出现新增或删除操作时，HMaster可以得到来自Zookeeper的实时通知。因此一旦HRegionServer上线，HMaster能马上得到消息。</p>
<p>当HRegionServer下线时，它和Zookeeper的会话断开，Zookeeper自动释放代表这台server的文件上的独占锁。而HMaster不断轮询server目录下文件的锁状态，如果发现某个HRegionServer丢失了它自己的独占锁（或者HMaster连续几次和HRegionServer通信都无法成功），HMaster就会去尝试获取代表这个HRegionServer的读写锁，一旦获取成功，就可以确定：</p>
<ul>
<li>可能性一：HRegionServer和Zookeeper之间的网络断开了;</li>
<li>可能性二：HRegionServer挂了;</li>
</ul>
<p>的其中一种情况发生了，无论哪种情况，HRegionServer都无法继续为它的region提供服务了，此时HMaster会删除server目录下代表这台HRegionServer的文件，并将这台HRegionServer的region分配给其它还活着的HRegionServer。</p>
<p>如果网络短暂出现问题导致HRegionServer丢失了它的锁，那么HRegionServer重新连接到Zookeeper之后，只要代表它的文件还在，它就会不断尝试获取这个文件上的锁，一旦获取到了，就可以继续提供服务。</p>
<h2 id="6-7_HMaster上线和下线">6.7 HMaster上线和下线</h2><p>HMaster启动会依次进行以下步骤:</p>
<ol>
<li>从Zookeeper上获取唯一一个master的锁，用来阻止其它HMaster成为工作HMaster。</li>
<li>扫描Zookeeper上的server目录，获得当前可用的HRegionServer列表。</li>
<li>和2中的每个HRegionServer通信，获得当前已分配的region和HRegionServer的对应关系。</li>
<li>扫描.META.中region的集合，计算得到当前还未分配的region，将他们放入待分配region列表。</li>
</ol>
<p>由于HMaster只维护表和region的元数据，而不参与表数据IO的过程，因此HMaster下线仅导致所有元数据的修改被冻结（无法创建删除表，无法修改表的schema，无法进行region的负载均衡，无法处理region上下线，无法进行region的合并，唯一例外的是region的split可以正常进行，因为只有HRegionServer参与），表的数据读写还可以正常进行。因此HMaster下线短时间内对整个HBase集群没有影响。</p>
<p>从上线过程可以看到，HMaster保存的信息全是可以冗余信息（都可以从系统其它地方收集到或者计算出来），因此，一般HBase集群中总是有一个HMaster在提供服务，还有一个以上的HMaster在等待时机抢占它的位置。</p>
<p><br></p>
<h1 id="七、结束">七、结束</h1><p>本文对HBase技术在功能和设计上进行了大致的介绍，由于篇幅有限，本文没有过多深入地描述HBase的一些细节技术。</p>
<p><br><br><br><br><br></p>
<hr>
<p>转自：</p>
<p>[1] www.searchtb.com/2011/01/understanding-hbase.html<br>[2] blog.csdn.net/john_f_lau/article/category/1832241<br>[3] my.oschina.net/zhengyang841117/blog/188723</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、HBase简介">一、HBase简介</h1><p>HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，类似Google BigTable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop+HBase+ZooKeeper分布式集群环境搭建]]></title>
    <link href="http://yoursite.com/2015/07/20/hadoop-hbase-zookeeper-distributed-mode/"/>
    <id>http://yoursite.com/2015/07/20/hadoop-hbase-zookeeper-distributed-mode/</id>
    <published>2015-07-20T14:52:53.000Z</published>
    <updated>2015-07-21T14:28:56.535Z</updated>
    <content type="html"><![CDATA[<h2 id="一、环境说明">一、环境说明</h2><p>集群环境至少需要3个节点（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通，下面举例说明，配置节点IP分配如下：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">User</th>
<th style="text-align:left">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td style="text-align:left">192.168.59.133</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave1</td>
<td style="text-align:left">192.168.59.134</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave2</td>
<td style="text-align:left">192.168.59.135</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
</tbody>
</table>
<a id="more"></a>三个节点均使用<code>CentOS 6.5</code>系统，为了便于维护，集群环境配置项最好使用相同用户名、用户密码、相同hadoop、hbase、zookeeper目录结构。<br><br><strong>注：</strong> 可以通过编辑<code>/etc/sysconfig/network</code>文件来修改 hostname 。<br><br>##二、准备工作<br><br>###2.1 安装JDK<br><br>在三台机器上配置JDK环境，下载 <code>jdk-8u51-linux-x64.rpm</code> 文件直接安装：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh jdk-<span class="number">8u</span>51-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p>修改配置文件 <code>vim /etc/profile</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.<span class="number">8.0</span>_51</span><br><span class="line">export PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">export CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/<span class="tag">dt</span><span class="class">.jar</span>:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>然后重新加载配置文件使之生效：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2_添加Hosts映射关系">2.2 添加Hosts映射关系</h3><p>分别在三个节点上添加hosts映射关系：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vim /etc/hosts</span><br></pre></td></tr></table></figure></p>
<p>添加的内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.59.133 master</span><br><span class="line">192.168.59.134 slave1</span><br><span class="line">192.168.59.135 slave2</span><br></pre></td></tr></table></figure>
<h3 id="2-3_集群之间SSH无密码登陆">2.3 集群之间SSH无密码登陆</h3><p>CentOS默认安装了ssh，如果没有你需要先安装ssh 。</p>
<p>集群环境的使用必须通过ssh无密码登陆来执行，本机登陆本机必须无密码登陆，主机与从机之间必须可以双向无密码登陆，从机与从机之间无限制。</p>
<p><strong>2.3.1 设置master无密码自登陆</strong></p>
<p>主要有三步：①生成公钥和私钥、②导入公钥到认证文件、③更改权限<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="prompt">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">700</span> ~<span class="regexp">/.ssh &amp;&amp; chmod 600 ~/</span>.ssh/*</span><br></pre></td></tr></table></figure></p>
<p>测试，第一次登录可能需要yes确认，之后就可以直接登录了：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br><span class="line">Last login: Sat Jul <span class="number">18</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">44</span> <span class="number">2015</span> <span class="keyword">from</span> localhost</span><br></pre></td></tr></table></figure></p>
<p>对于 slave1 和 slave2，进行无密码自登陆设置，操作同上。</p>
<p><strong>2.3.2 设置主机-&gt;从机的无密码登录</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@slave1</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@slave2</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>ssh hadoop<span class="variable">@slave1</span></span><br><span class="line"><span class="constant">Last </span><span class="symbol">login:</span> <span class="constant">Sat Jul </span><span class="number">18</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">41</span> <span class="number">2015</span> from master</span><br><span class="line"></span><br><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>ssh hadoop<span class="variable">@slave2</span></span><br><span class="line"><span class="constant">Last </span><span class="symbol">login:</span> <span class="constant">Sat Jul </span><span class="number">18</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">14</span> <span class="number">2015</span> from master</span><br></pre></td></tr></table></figure></p>
<p><strong>2.3.3 设置从机-&gt;主机的无密码登录</strong></p>
<p>分别在slave1、slave2上执行：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@master</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="三、Hadoop集群安装配置">三、Hadoop集群安装配置</h2><p>这里会将hadoop、hbase、zookeeper的安装包都解压到<code>/home/hadoop/</code>个人主文件夹下，并重命名为hadoop、hbase、zookeeper。</p>
<h3 id="3-1_修改hadoop配置">3.1 修改hadoop配置</h3><p>配置文件都在<code>~/hadoop/etc/</code>目录下</p>
<p><strong>3.1.1 core-site.xml</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;configuration&gt;</span></span><br><span class="line">	<span class="variable">&lt;property&gt;</span></span><br><span class="line">		<span class="variable">&lt;name&gt;</span>fs.<span class="keyword">default</span>.name<span class="variable">&lt;/name&gt;</span></span><br><span class="line">		<span class="variable">&lt;value&gt;</span>hdfs://master:<span class="number">9000</span><span class="variable">&lt;/value&gt;</span></span><br><span class="line">	<span class="variable">&lt;/property&gt;</span></span><br><span class="line"><span class="variable">&lt;/configuration&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.2 hadoop-env.sh</strong></p>
<p>添加JDK路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>
<p><strong>3.1.3 hdfs-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hadoop/name<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hadoop/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>3<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.4 mapred-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.5 修改masters文件</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master</span><br></pre></td></tr></table></figure>
<p><strong>3.1.6 修改slaves文件</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave1</span></span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
<p>注意：三台机器上都进行相同的配置，都放在相同的路径下。</p>
<p>使用<code>scp</code>命令进行从本地到远程（或远程到本地）的文件拷贝操作：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop     slave1:/</span>home/hadoop</span><br><span class="line">scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop     slave2:/</span>home/hadoop</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2_启动hadoop集群">3.2 启动hadoop集群</h3><p>进入master的<code>~/hadoop</code>目录，执行以下操作：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hadoop namenode -<span class="built_in">format</span></span><br></pre></td></tr></table></figure></p>
<p>格式化namenode，第一次启动服务前执行的操作，以后不需要执行。</p>
<p>然后启动hadoop：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sbin/<span class="operator"><span class="keyword">start</span>-<span class="keyword">all</span>.sh</span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>jps</code>命令能看到除jps外有5个进程：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>jps</span><br><span class="line"><span class="number">4866</span> <span class="constant">NodeManager</span></span><br><span class="line"><span class="number">4370</span> <span class="constant">NameNode</span></span><br><span class="line"><span class="number">4899</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">4648</span> <span class="constant">SecondaryNameNode</span></span><br><span class="line"><span class="number">4779</span> <span class="constant">ResourceManager</span></span><br><span class="line"><span class="number">4460</span> <span class="constant">DataNode</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="四、ZooKeeper集群安装配置">四、ZooKeeper集群安装配置</h2><p>解压zookeeper-3.3.2.tar.gz并重命名为zookeeper。</p>
<h3 id="4-1_修改配置文件zoo-cfg">4.1 修改配置文件zoo.cfg</h3><p>进入<code>~/zookeeper/conf</code>目录：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp zoo_sample<span class="class">.cfg</span> zoo.cfg</span><br></pre></td></tr></table></figure></p>
<p>拷贝<code>zoo_sample.cfg</code>文件为<code>zoo.cfg</code>，并编辑如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/hadoop/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span>.1=<span class="number">192.168</span>.59.133:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="keyword">server</span>.2=<span class="number">192.168</span>.59.134:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="keyword">server</span>.3=<span class="number">192.168</span>.59.135:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-2_新建并编辑myid文件">4.2 新建并编辑myid文件</h3><p>在dataDir目录下新建myid文件，输入一个数字（master为<code>1</code>，slave1为<code>2</code>，slave2为<code>3</code>）：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir /home/hadoop/zookeeper/data</span><br><span class="line"><span class="variable">$ </span>echo <span class="string">"1"</span> &gt; <span class="regexp">/home/hadoop</span><span class="regexp">/zookeeper/data</span><span class="regexp">/myid</span></span><br></pre></td></tr></table></figure></p>
<p>同样使用<code>scp</code>命令进行远程复制，只不过要修改每个节点上<code>myid</code>文件中的数字。</p>
<h3 id="4-3_启动ZooKeeper集群">4.3 启动ZooKeeper集群</h3><p>在ZooKeeper集群的每个结点上，执行启动ZooKeeper服务的脚本：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>~<span class="regexp">/zookeeper/bin</span><span class="regexp">/zkServer.sh start</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果启动报类似异常:QuorumCnxManager@384] - Cannot open channel to 2 at election address slave-02/192.168.0.178:3888 是可以忽略的,因为该服务启动时会尝试连接所有节点,而其他节点尚未启动。通过后面部分可以看到，集群在选出一个Leader后，最后稳定 了。其他结点可能也出现类似问题，属于正常。</p>
</li>
<li><p>关闭防火墙。在hadoop集群环境(linux系统)中最好关闭防火墙，不然会出现很多问题，例如namenode找不到datanode等。如果不关闭防火墙，客户端使用API操作HDFS以及ZooKeeper，可能就会出现下面常见的两种异常：</p>
<ul>
<li>使用API操作HDFS时会出现异常：java.net.NoRouteToHostException: No route to host</li>
<li>使用API操作ZK时会出现异常：org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss for xxxx</li>
</ul>
</li>
<li><p>使用root权限登陆后，输入关闭防火墙命令：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/iptables <span class="literal">stop</span></span><br><span class="line">$ <span class="keyword">service</span> iptables <span class="literal">stop</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改禁用selinux：     /etc/selinux/config文件，设置<code>&quot;SELINUX=disabled&quot;</code></p>
</li>
</ol>
<p><br></p>
<h2 id="五、HBase集群安装配置">五、HBase集群安装配置</h2><p>解压hbase-1.0.1.1-bin.tar.gz并重命名为hbase。</p>
<h3 id="5-1_hbase-env-sh">5.1 hbase-env.sh</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1.8.0_51</span><br><span class="line"><span class="keyword">export</span> HBASE_CLASSPATH=<span class="regexp">/home/</span>hadoop/hadoop/etc/hadoop/</span><br><span class="line"><span class="keyword">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2_hbase-site-xml">5.2 hbase-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.master<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master,slave1,slave2<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>zookeeper.session.timeout<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.support.append<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3_更改_regionservers">5.3 更改 regionservers</h3><p>在 regionservers 文件中添加slave列表：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave1</span></span><br><span class="line">slave2</span><br></pre></td></tr></table></figure></p>
<p><strong>5.4 分发并同步安装包</strong></p>
<p>将整个hbase安装目录都拷贝到所有slave服务器：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hbase  slave1:/</span>home/hadoop</span><br><span class="line">$ scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hbase  slave2:/</span>home/hadoop</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="六、启动集群">六、启动集群</h3><p> <strong>1. 启动ZooKeeper</strong></p>
<p>~/zookeeper/bin/zkServer.sh start</p>
<p><strong>2. 启动hadoop</strong></p>
<p>~/hadoop/sbin/start-all.sh</p>
<p><strong>3. 启动hbase</strong></p>
<p>~/hbase/bin/start-base.sh</p>
<p><strong>4. 启动后，master上进程和slave进程列表</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>jps</span><br><span class="line"><span class="number">6225</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">2897</span> <span class="constant">SecondaryNameNode </span>  <span class="comment"># hadoop进程</span></span><br><span class="line"><span class="number">2710</span> <span class="constant">NameNode </span>           <span class="comment"># hadoop master进程</span></span><br><span class="line"><span class="number">3035</span> <span class="constant">ResourceManager </span>    <span class="comment"># hadoop进程</span></span><br><span class="line"><span class="number">5471</span> <span class="constant">HMaster </span>            <span class="comment"># hbase master进程</span></span><br><span class="line"><span class="number">2543</span> <span class="constant">QuorumPeerMain </span>     <span class="comment"># zookeeper进程</span></span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@slave1</span> ~]<span class="variable">$ </span>jps</span><br><span class="line"><span class="number">4689</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">2533</span> <span class="constant">QuorumPeerMain </span>      <span class="comment"># zookeeper进程</span></span><br><span class="line"><span class="number">2589</span> <span class="constant">DataNode </span>            <span class="comment"># hadoop slave进程</span></span><br><span class="line"><span class="number">4143</span> <span class="constant">HRegionServer </span>       <span class="comment"># hbase slave进程</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 进入hbase shell进行验证</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>hbase/bin/hbase shell</span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">42</span><span class="symbol">:</span><span class="number">11</span>,<span class="number">725</span> <span class="constant">WARN</span>  [main] util.<span class="constant">NativeCodeLoader</span><span class="symbol">:</span> <span class="constant">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="constant">HBase</span> <span class="constant">Shell</span>; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.</span><br><span class="line"><span class="constant">Type</span> <span class="string">"exit&lt;RETURN&gt;"</span> to leave the <span class="constant">HBase</span> <span class="constant">Shell</span></span><br><span class="line"><span class="constant">Version</span> <span class="number">1.0</span>.<span class="number">1.1</span>, re1dbf4df30d214fca14908df71d038081577ea46, <span class="constant">Sun</span> <span class="constant">May</span> <span class="number">17</span> <span class="number">12</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">26</span> <span class="constant">PDT</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">hbase(main):001:0&gt;</span> list</span><br><span class="line"><span class="constant">TABLE</span>                                                                                </span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.6950</span> seconds</span><br><span class="line"><span class="status"></span><br><span class="line">=&gt;</span> []</span><br><span class="line"><span class="prompt">hbase(main):002:0&gt;</span> status</span><br><span class="line"><span class="number">2</span> servers, <span class="number">0</span> dead, <span class="number">1.0000</span> average load</span><br><span class="line"></span><br><span class="line"><span class="prompt">hbase(main):003:0&gt;</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br></p>
<hr>
<p>参考：<br>[1] www.smalldeng.blog.51cto.com/1038075/1329290<br>[2] www.marysee.blog.51cto.com/1000292/629405<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、环境说明">一、环境说明</h2><p>集群环境至少需要3个节点（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通，下面举例说明，配置节点IP分配如下：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">User</th>
<th style="text-align:left">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td style="text-align:left">192.168.59.133</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave1</td>
<td style="text-align:left">192.168.59.134</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave2</td>
<td style="text-align:left">192.168.59.135</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-Hadoop" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase单机环境搭建]]></title>
    <link href="http://yoursite.com/2015/07/20/hbase-standalone-mode/"/>
    <id>http://yoursite.com/2015/07/20/hbase-standalone-mode/</id>
    <published>2015-07-20T14:37:48.000Z</published>
    <updated>2015-07-20T14:44:41.307Z</updated>
    <content type="html"><![CDATA[<p>在搭建HBase单机环境之前，首先你要保证你已经搭建好Java环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version&#10;java version &#34;1.8.0_51&#34;&#10;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)&#10;Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p><code>JAVA_HOME</code>路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME&#10;/usr/java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>在单机模式中，HBase并不使用 HDFS，仅使用本地文件系统 —— ZooKeeper程序与HBase程序运行在同一个JVM进程中。<br><br>#一、下载HBase<br><br>虚拟机：VMware-workstation-11.1.0<br>操作系统：CentOS 6.5<br>JDK：jdk1.8.0_51<br>HBase：hbase-1.0.1.1<br><br>1、 下载的是HBase最新稳定版<code>hbase-1.0.1.1-bin.tar.gz</code>，地址 <a href="http://apache.fayea.com/hbase/" target="_blank" rel="external">http://apache.fayea.com/hbase/</a><br><br>2、 解压到个人主目录下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxf hbase-1.0.1.1-bin.tar.gz&#10;$ cd hbase-1.0.1.1</span><br></pre></td></tr></table></figure>
<h1 id="二、配置HBase">二、配置HBase</h1><p>需要配置两个文件。</p>
<p>1、hbase-env.sh</p>
<p>编辑文件<code>vim conf/hbase-env.sh</code>，去掉#注释，<code>JAVA_HOME</code>改成jdk对应的路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_51&#10;export HBASE_MANAGES_ZK=true</span><br></pre></td></tr></table></figure></p>
<p>Hbase依赖于zookeeper，所有的节点和客户端都必须能够访问zookeeper。</p>
<p>HBase的安装包里面有自带的ZooKeeper，<code>HBASE_MANAGES_ZK</code>环境变量用来设置是使用HBase默认自带的 Zookeeper还是使用独立的ZooKeeper。</p>
<ul>
<li><code>HBASE_MANAGES_ZK</code>为 false 时使用独立的.</li>
<li><code>HBASE_MANAGES_ZK</code>为 true 时表示使用默认自带的，让Hbase启动的时候同时也启动自带的ZooKeeper。</li>
</ul>
<p>2、hbase-site.xml</p>
<p>编辑文件<code>vim conf/hbase-site.xml</code>，设置数据保存的目录：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:///home/songlee/hbase-1.0.1.1/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下Hbase是写到/tmp的，在重启的时候/tmp会被清空，数据就会丢失。</p>
<h1 id="三、启动HBase">三、启动HBase</h1><p>使用HBase提供的脚本启动HBase：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/start-hbase.sh &#10;starting master, logging to /home/songlee/hbase-1.0.1.1/bin/../logs/hbase-songlee-master-songlee.out</span><br></pre></td></tr></table></figure></p>
<p>查看Java进程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps&#10;5464 HMaster&#10;5561 Jps</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>HMaster</code>进程已经启动了。</p>
<h1 id="四、HBase_Shell交互">四、HBase Shell交互</h1><p>HBase Shell是一个封装了Java API的JRuby应用软件，通过它可以与HBase集群进行交互。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hbase <span class="built_in">shell</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">07</span>,<span class="number">171</span> WARN  [main] util.NativeCodeLoader: Unable <span class="built_in">to</span> <span class="built_in">load</span> native-hadoop library <span class="keyword">for</span> your <span class="built_in">platform</span>... <span class="keyword">using</span> builtin-java classes where applicable</span><br><span class="line">HBase Shell; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list <span class="operator">of</span> supported commands.</span><br><span class="line">Type <span class="string">"exit&lt;RETURN&gt;"</span> <span class="built_in">to</span> leave <span class="operator">the</span> HBase Shell</span><br><span class="line">Version <span class="number">1.0</span>.1.1, re1dbf4df30d214fca14908df71d038081577ea46, Sun May <span class="number">17</span> <span class="number">12</span>:<span class="number">34</span>:<span class="number">26</span> PDT <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>建表：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):006:0&#62; create &#39;mytable&#39;,&#39;cf&#39;&#10;0 row(s) in 0.3090 seconds</span><br></pre></td></tr></table></figure></p>
<p>添加数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):008:0&#62; put &#39;mytable&#39;,&#39;first&#39;,&#39;cf:message&#39;,&#39;hello HBase!&#39;&#10;0 row(s) in 0.1420 seconds&#10;&#10;hbase(main):009:0&#62; put &#39;mytable&#39;,&#39;second&#39;,&#39;cf:foo&#39;,0x0&#10;0 row(s) in 0.0220 seconds&#10;&#10;hbase(main):010:0&#62; put &#39;mytable&#39;,&#39;third&#39;,&#39;cf:bar&#39;,3.14159&#10;0 row(s) in 0.0180 seconds</span><br></pre></td></tr></table></figure></p>
<p>获取数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):011:0&#62; get &#39;mytable&#39;,&#39;first&#39;&#10;COLUMN                          CELL                                                                                      &#10; cf:message                     timestamp=1437015412793, value=hello HBase!                                               &#10;1 row(s) in 0.0540 seconds</span><br></pre></td></tr></table></figure></p>
<p>扫描表：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):012:0&#62; scan &#39;mytable&#39;&#10;ROW                             COLUMN+CELL                                                                               &#10; first                          column=cf:message, timestamp=1437015412793, value=hello HBase!                            &#10; second                         column=cf:foo, timestamp=1437015468629, value=0                                           &#10; third                          column=cf:bar, timestamp=1437015511565, value=3.14159                                     &#10;3 row(s) in 0.0650 seconds</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在搭建HBase单机环境之前，首先你要保证你已经搭建好Java环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version&#10;java version &#34;1.8.0_51&#34;&#10;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)&#10;Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p><code>JAVA_HOME</code>路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME&#10;/usr/java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015实习生求职季总结]]></title>
    <link href="http://yoursite.com/2015/05/23/intern-seeking-experience/"/>
    <id>http://yoursite.com/2015/05/23/intern-seeking-experience/</id>
    <published>2015-05-23T01:40:05.000Z</published>
    <updated>2015-05-23T07:14:57.577Z</updated>
    <content type="html"><![CDATA[<p style="font-size:15pt;font-weight:bold">一、实习季Timeline</p>

<p>从2015年4月开始找实习，前后历时两个月，参加了很多的笔试/面试。这是一个焦虑又美好的学期，我在这段时间里学到了很多东西。</p>
<iframe src="http://timelinejs.sinaapp.com/" width="100%" height="500" frameborder="0"></iframe>

<a id="more"></a>
<p>这一个学期就这么磕磕绊绊的过了一半了，决定去360实习以后，也终于能安下心来。因为等待（笔试/面试通知）真的是很痛苦的一件事。</p>
<p>参加的笔试/面试越多，越发现自己有很多的不足。求职难免碰壁，这两个月我被虐了好几次，导致我的自信心直线下降。但现在来看，我觉得被虐反而更好，它让我不断总结和反思：哪一块的知识不知道就补哪一块，然后不断地提高自己。</p>
<p><br></p>
<p style="font-size:15pt;font-weight:bold">二、经验之谈</p>

<p>我在本科时就决定要进互联网行业，在做过的项目中是C++开发居多，所以也自然而然的走向了服务端开发方向。从这两个月的笔试/面试经历来看，其实做后台服务端开发主要就是要掌握5个方面的基础知识，而且需要较深入。</p>
<ol>
<li><p><strong>语言：</strong>编程语言必然要掌握一门的，而且需要熟练的掌握。从笔试/面试的情况来看，基本就是 C/C++/Java 熟练掌握一门，最好还会一门脚本语言（Perl/Python/Shell）。因为我是C++党，所以这里推荐一下学习C++要看的书：</p>
<ul>
<li>《C++ Primer》不用多说，入门必看。</li>
<li>《Effective C++》《More Effective C++》《深度探索C++对象模型》进阶。</li>
<li>《Effective STL》《STL源码剖析》了解C++ STL。</li>
</ul>
</li>
<li><p><strong>算法与数据结构：</strong>这个就不用多说，不管什么岗位都要有算法基础的。</p>
<ul>
<li>《算法导论》最经典，但有人说上面讲的太繁琐，其实我也觉得，可能是水平还不够。</li>
<li>《程序员面试金典》《编程之美》《剑指offer》</li>
<li>刷题：LeetCode</li>
</ul>
</li>
<li><p><strong>操作系统：</strong>做服务端开发，对操作系统一定要很了解。通常考的最多的是进程线程、内存管理、I/O管理。</p>
<ul>
<li>《现代操作系统》《深入理解计算机系统》这是原理方面的。</li>
<li>《UNIX环境高级编程》服务端是比较偏Unix/Linux的。</li>
<li>如果你还要了解Linux内核的话…</li>
</ul>
</li>
<li><p><strong>网络：</strong>主要是指TCP/IP，做服务端必须熟练掌握TCP/IP，这点不需要解释什么。</p>
<ul>
<li>《TCP/IP协议详解》卷1，必看网络协议经典书籍。</li>
<li>《计算机网络：自顶向下方法》也是讲原理的。</li>
<li>《Unix网络编程》了解了原理，需要实战一下。</li>
</ul>
</li>
<li><p><strong>数据库：</strong>不论什么样的应用，都需要数据库的支持，数据库无处不在。而现在主流的还是关系型数据库，建议学MySQL。</p>
<ul>
<li>《数据库系统概念》了解数据库。</li>
<li>《SQL Cookbook》《SQL入门经典》了解SQL结构化查询语言。</li>
<li>《高性能MySQL》《MySQL技术内幕》学习MySQL本身。</li>
</ul>
</li>
</ol>
<p>当然，上面推荐的书籍是各领域评分较高的书籍，我目前也就看了一部分（要是都看完了，我就不是这个水平了）。除了打好基础，你还可以了解某一些领域的知识，比如《Linux高性能服务器编程》帮你从整体上了解服务端开发，《分布式系统原理与范型》了解分布式，或者看一些经典的论文，比如Google三大论文，或者学习Hadoop/Spark分布式计算框架等等。</p>
<p>下面是百度公司分享的一个技术能力模型：</p>
<center><br><img src="http://img.blog.csdn.net/20150523134332379" alt=""><br></center>

<p>对于基础知识，必然是要全部掌握的；而对于技术领域，可以择其一而攻之。</p>
<p><br></p>
<p style="font-size:15pt;font-weight:bold">三、计划和展望</p>

<p>这个实习生招聘季，经过多个<code>笔试-&gt;总结-&gt;面试-&gt;总结</code>的循环，我学到了很多，提高了很多。同时，也更加明确了自己将来要做什么，要往哪个方向走。</p>
<p>我会记住并保持这段时间的这种心态，在接下来一年的实习时间里，看完还没看完的书，了解并学习一些新的领域，完成给自己制定的<code>To-Do-List</code>。相信在一年后的毕业招聘季中，我能更加地得心应手。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p style="font-size:15pt;font-weight:bold">一、实习季Timeline</p>

<p>从2015年4月开始找实习，前后历时两个月，参加了很多的笔试/面试。这是一个焦虑又美好的学期，我在这段时间里学到了很多东西。</p>
<iframe src='http://timelinejs.sinaapp.com/' width='100%' height='500' frameborder='0'></iframe>]]>
    
    </summary>
    
      <category term="非技术-杂谈" scheme="http://yoursite.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF-%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求最长回文子串]]></title>
    <link href="http://yoursite.com/2015/05/12/longest-palindromic-substring/"/>
    <id>http://yoursite.com/2015/05/12/longest-palindromic-substring/</id>
    <published>2015-05-12T12:53:19.000Z</published>
    <updated>2015-05-12T13:11:43.312Z</updated>
    <content type="html"><![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。<a id="more"></a></p>
<h3 id="解法二：动态规划法$O(n^2)$">解法二：动态规划法$O(n^2)$</h3><p>动态规划法是在暴力解法上进行的优化。通过记录一些我们需要的东西，来避免暴力解法中很多重复的判断。</p>
<p>假设 $dp[i][j]$ 表示子串 $s[i…j]$ 是否是回文，那么对于动态规划表 $dp$ 的打表方式如下：</p>
<ul>
<li><p>初始化：<br>$$\begin{cases}<br>dp[i][i] = true  &amp; \text{(0 &lt;= i &lt;= n-1)}\\<br>dp[i][i-1] = true &amp; \text{(1 &lt;= i &lt;= n-1) }\\<br>others = fasle<br>\end{cases}$$</p>
</li>
<li><p>动态规划的状态转移方程：<br>$$<br>dp[i][j] =<br>\begin{cases}<br>dp[i+1][j-1], &amp; \text{if s[i] == s[j]} \\<br>false, &amp; \text{if s[i] ≠ s[j]}<br>\end{cases}<br>$$</p>
</li>
</ul>
<p>C++代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="comment">// 动态规划表，全部初始化为true</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=len; ++k) &#123;    <span class="comment">// 枚举子串的长度</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-k; ++i) &#123;  <span class="comment">// 枚举子串起始位置</span></span><br><span class="line">			<span class="keyword">int</span> j = i+k-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">				start = i;      <span class="comment">// 记录回文子串的起点和长度</span></span><br><span class="line">				maxlen = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解法三：中心扩展法$O(n^2)$">解法三：中心扩展法$O(n^2)$</h3><p>这个算法思想其实很简单，就是对给定的字符串S，分别以该字符串S中的每一个字符 c 为中心，向两边扩展，记录下以字符 c 为中心的回文子串的长度。时间复杂度为$O(n^2)$，空间复杂度仅为$O(1)$。</p>
<p>但有一点需要注意的是，回文的情况可能是 a b a，也可能是 a b b a。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别向左右扩展，返回扩展后的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right]) </span><br><span class="line">	&#123;</span><br><span class="line">		left--;</span><br><span class="line">		right++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substr(left+<span class="number">1</span>, right-left-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最长回文子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> longest;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> p1 = expand(s, i, i);  <span class="comment">// 奇数</span></span><br><span class="line">		<span class="keyword">if</span> (p1.size() &gt; longest.size())</span><br><span class="line">			longest = p1;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">string</span> p2 = expand(s, i, i+<span class="number">1</span>);  <span class="comment">// 偶数</span></span><br><span class="line">		<span class="keyword">if</span> (p2.size() &gt; longest.size())</span><br><span class="line">			longest = p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br>另外，据说还有一个很巧妙的算法，叫Manacher算法，可以在 $O(n)$ 的时间复杂度里求出最长回文子串。由于这个算法我没有研究过，在这里就不介绍了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计并实现一个LRU Cache]]></title>
    <link href="http://yoursite.com/2015/05/10/design-LRU-Cache/"/>
    <id>http://yoursite.com/2015/05/10/design-LRU-Cache/</id>
    <published>2015-05-10T12:33:13.000Z</published>
    <updated>2015-05-10T13:23:03.702Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。<a id="more"></a></p>
<h4 id="2_原理">2 原理</h4><p>Cache 技术所依赖的原理是”程序执行与数据访问的<strong>局部性原理</strong>“，这种局部性表现在两个方面：</p>
<ol>
<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令或数据通常是顺序存放的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到Cache中实现。空间局部性通常是使用较大的高速缓存，并将 预取机制 集成到高速缓存控制逻辑中来实现。</p>
<h4 id="3_替换策略">3 替换策略</h4><p>Cache的容量是有限的，当Cache的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。常用的替换策略有以下几种：</p>
<ol>
<li><p><strong>随机算法（Rand）</strong>：随机法是随机地确定替换的存储块。设置一个随机数产生器，依据所产生的随机数，确定替换块。这种方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p><strong>先进先出算法（FIFO, First In First Out）</strong>：先进先出法是选择那个最先调入的那个块进行替换。当最先调入并被多次命中的块，很可能被优先替换，因而不符合局部性规律。这种方法的命中率比随机法好些，但还不满足要求。</p>
</li>
<li><p><strong>最久未使用算法（LRU, Least Recently Used）</strong>：LRU法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。</p>
</li>
<li><p><strong>最不经常使用算法（LFU, Least Frequently Used）</strong>：将最近一段时期内，访问次数最少的块替换出Cache。</p>
</li>
</ol>
<h4 id="4_概念的扩充">4 概念的扩充</h4><p>如今高速缓存的概念已被扩充，不仅在CPU和主内存之间有Cache，而且在内存和硬盘之间也有Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的Cache──称为Internet临时文件夹或网络内容缓存等。<strong>凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。</strong></p>
<p><br></p>
<h3 id="二、LRU_Cache的实现">二、LRU Cache的实现</h3><p><strong>Google的一道面试题：</strong></p>
<p>Design an LRU cache with all the operations to be done in $O(1)$ .</p>
<h4 id="1_思路分析">1 思路分析</h4><p>对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。</p>
<p>为了能够快速删除最久没有访问的数据项和插入最新的数据项，我们使用 <strong>双向链表</strong> 连接Cache中的数据项，并且保证链表维持数据项从最近访问到最旧访问的顺序。</p>
<ul>
<li><p><strong>插入</strong>：当Cache未满时，新的数据项只需插到双链表头部即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>替换</strong>：当Cache已满时，将新的数据项插到双链表头部，并删除双链表的尾结点即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>查找</strong>：每次数据项被查询到时，都将此数据项移动到链表头部。</p>
</li>
</ul>
<p>经过分析，我们知道使用双向链表可以保证插入和替换的时间复杂度是$O(1)$，但查询的时间复杂度是$O(n)$，因为需要对双链表进行遍历。为了让查找效率也达到$O(1)$，很自然的会想到使用 <strong>hash table</strong> 。</p>
<h4 id="2_代码实现">2 代码实现</h4><p>从上述分析可知，我们需要使用两种数据结构：</p>
<ol>
<li><strong>双向链表（Doubly Linked List）</strong></li>
<li><strong>哈希表（Hash Table）</strong></li>
</ol>
<p>下面是LRU Cache的 C++ 实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的节点结构</span></span><br><span class="line"><span class="keyword">struct</span> LRUCacheNode &#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	LRUCacheNode* prev;</span><br><span class="line">	LRUCacheNode* next;</span><br><span class="line">	LRUCacheNode():key(<span class="number">0</span>),value(<span class="number">0</span>),prev(NULL),next(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LRUCache</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, LRUCacheNode*&gt; m;  <span class="comment">// 代替hash_map</span></span><br><span class="line">	LRUCacheNode* head;     <span class="comment">// 指向双链表的头结点</span></span><br><span class="line">	LRUCacheNode* tail;     <span class="comment">// 指向双链表的尾结点</span></span><br><span class="line">	<span class="keyword">int</span> capacity;           <span class="comment">// Cache的容量</span></span><br><span class="line">	<span class="keyword">int</span> count;              <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> capacity);       <span class="comment">// 构造函数</span></span><br><span class="line">	~LRUCache();                  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;             <span class="comment">// 查询数据项</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>; <span class="comment">// 未满时插入,已满时替换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeLRUNode</span><span class="params">()</span></span>;                 <span class="comment">// 删除尾结点（最久未使用）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">detachNode</span><span class="params">(LRUCacheNode* node)</span></span>;    <span class="comment">// 分离当前结点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertToFront</span><span class="params">(LRUCacheNode* node)</span></span>; <span class="comment">// 节点插入到头部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LRUCache::LRUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	<span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">	head = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	tail = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	head-&gt;prev = NULL;</span><br><span class="line">	head-&gt;next = tail;</span><br><span class="line">	tail-&gt;prev = head;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~LRUCache()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">	<span class="keyword">delete</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LRUCache::get(<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);      <span class="comment">// 命中，移至头部 </span></span><br><span class="line">		insertToFront(node);</span><br><span class="line">		<span class="keyword">return</span> node-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::<span class="built_in">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">		<span class="keyword">if</span>(count == capacity)   <span class="comment">// Cache已满</span></span><br><span class="line">			removeLRUNode();</span><br><span class="line"></span><br><span class="line">		node-&gt;key = key;</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		m[key] = node;          <span class="comment">// 插入哈希表</span></span><br><span class="line">		insertToFront(node);    <span class="comment">// 插入链表头部</span></span><br><span class="line">		++count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		insertToFront(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::removeLRUNode()</span><br><span class="line">&#123;</span><br><span class="line">	LRUCacheNode* node = tail-&gt;prev;</span><br><span class="line">	detachNode(node);</span><br><span class="line">	m.erase(node-&gt;key);</span><br><span class="line">	--count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::detachNode(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">	node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::insertToFront(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = head-&gt;next;</span><br><span class="line">	node-&gt;prev = head;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">	node-&gt;next-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trie树|前缀树的介绍与实现]]></title>
    <link href="http://yoursite.com/2015/05/09/prefix-tree/"/>
    <id>http://yoursite.com/2015/05/09/prefix-tree/</id>
    <published>2015-05-09T12:17:12.000Z</published>
    <updated>2015-05-10T12:30:30.917Z</updated>
    <content type="html"><![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center><a id="more"></a></p>
<p>上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li>
<li>从根节点到<strong>某一个节点</strong>，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符互不相同。</li>
</ol>
<p>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p>
<p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做<strong>前缀树（Prefix Tree）</strong>。</p>
<p><br></p>
<h1 id="二、Trie树的优缺点">二、Trie树的优缺点</h1><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p>
<h2 id="优点">优点</h2><ol>
<li><p>插入和查询的效率很高，都为$O(m)$，其中 $m$ 是待插入/查询的字符串的长度。</p>
<ul>
<li>关于查询，会有人说 hash 表时间复杂度是$O(1)$不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。</li>
</ul>
</li>
<li><p>Trie树中不同的关键字不会产生冲突。</p>
</li>
<li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p>
</li>
<li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p>
</li>
<li><p>Trie树可以对关键字按<strong>字典序</strong>排序。</p>
</li>
</ol>
<h2 id="缺点">缺点</h2><ol>
<li><p>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</p>
</li>
<li><p>空间消耗比较大。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、Trie树的应用">三、Trie树的应用</h1><h2 id="1、字符串检索">1、字符串检索</h2><p>检索/查询功能是Trie树最原始的功能。<strong>思路</strong>就是从根节点开始一个一个字符进行比较：</p>
<ul>
<li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li>
<li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、词频统计">2、词频统计</h2><p>Trie树常被搜索引擎系统用于文本词频统计    。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量<code>count</code>来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后<code>count</code>置1。</p>
<p><strong>注意：第一、第二种应用也都可以用 hash table 来做。</strong></p>
<h2 id="3、字符串排序">3、字符串排序</h2><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p>
<h2 id="4、前缀匹配">4、前缀匹配</h2><p>例如：找出一个字符串集合中所有以<code>ab</code>开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以<code>a-&gt;b-&gt;</code>开头的路径上的关键字即可。</p>
<p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h2 id="5、作为其他数据结构和算法的辅助结构">5、作为其他数据结构和算法的辅助结构</h2><p>如后缀树，AC自动机等。</p>
<p><br></p>
<h1 id="四、Trie树的实现">四、Trie树的实现</h1><p>这里为了方便，我们假设所有的关键字都由 a-z 的字母组成。下面是 trie 树的一种典型实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ALPHABET_SIZE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">	trie_node *children[ALPHABET_SIZE]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;*trie;</span><br><span class="line"></span><br><span class="line">trie_node* create_trie_node()</span><br><span class="line">&#123;</span><br><span class="line">	trie_node* pNode = <span class="keyword">new</span> trie_node();</span><br><span class="line">	pNode-&gt;count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ALPHABET_SIZE; ++i)</span><br><span class="line">		pNode-&gt;children[i] = NULL;</span><br><span class="line">	<span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trie_insert</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;children[*p-<span class="string">'a'</span>] == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;children[*p-<span class="string">'a'</span>] = create_trie_node();</span><br><span class="line">		&#125;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 查询：不存在返回0，存在返回出现的次数</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trie_search</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p &amp;&amp; node!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(node == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 关键字集合</span></span><br><span class="line">	<span class="keyword">char</span> keys[][<span class="number">8</span>] = &#123;<span class="string">"the"</span>, <span class="string">"a"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>, <span class="string">"any"</span>, <span class="string">"by"</span>, <span class="string">"bye"</span>, <span class="string">"their"</span>&#125;;</span><br><span class="line">	trie root = create_trie_node();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建trie树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		trie_insert(root, keys[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检索字符串</span></span><br><span class="line">	<span class="keyword">char</span> s[][<span class="number">32</span>] = &#123;<span class="string">"Present in trie"</span>, <span class="string">"Not present in trie"</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"the"</span>, trie_search(root, <span class="string">"the"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"these"</span>, trie_search(root, <span class="string">"these"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"their"</span>, trie_search(root, <span class="string">"their"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"thaw"</span>, trie_search(root, <span class="string">"thaw"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于Trie树，我们一般只需要插入和搜索操作。上面这段代码实现了一棵Trie树，该Trie树可以用来检索单词和统计词频。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center>]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑排序（Topological Sorting）]]></title>
    <link href="http://yoursite.com/2015/05/07/topological-sorting/"/>
    <id>http://yoursite.com/2015/05/07/topological-sorting/</id>
    <published>2015-05-07T15:23:52.000Z</published>
    <updated>2015-05-10T12:13:59.727Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。<a id="more"></a></p>
<p>例如，下面这个图：</p>
<center><br><img src="http://img.blog.csdn.net/20150507001028284" alt=""><br></center>

<p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环。</li>
</ol>
<center><br><img src="http://img.blog.csdn.net/20150507001759702" alt=""><br></center>

<p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p>
<p>通常，一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</p>
<p><br></p>
<h3 id="二、拓扑排序的应用">二、拓扑排序的应用</h3><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p>
<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 <a, b=""> 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</a,></p>
<p><br></p>
<h3 id="三、拓扑排序的实现">三、拓扑排序的实现</h3><p>根据上面讲的方法，我们关键是要<strong>维护一个入度为0的顶点的集合</strong>。</p>
<p>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用<strong>邻接表</strong>来存储图，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类声明************************/</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;             <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;    <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;      <span class="comment">// 维护一个入度为0的顶点的集合</span></span><br><span class="line">	<span class="keyword">int</span>* indegree;     <span class="comment">// 记录每个顶点的入度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                   <span class="comment">// 构造函数</span></span><br><span class="line">	~Graph();                       <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;     <span class="comment">// 添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">topological_sort</span><span class="params">()</span></span>;        <span class="comment">// 拓扑排序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类定义************************/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line"></span><br><span class="line">	indegree = <span class="keyword">new</span> <span class="keyword">int</span>[V];  <span class="comment">// 入度全部初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		indegree[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph::~Graph()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] adj;</span><br><span class="line">	<span class="keyword">delete</span> [] indegree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w); </span><br><span class="line">	++indegree[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Graph::topological_sort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">			q.push(i);         <span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;             <span class="comment">// 计数，记录当前已经输出的顶点数 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = q.front();      <span class="comment">// 从队列中取出一个顶点</span></span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;      <span class="comment">// 输出该顶点</span></span><br><span class="line">		++count;</span><br><span class="line">		<span class="comment">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class="line">		<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator beg = adj[v].begin();</span><br><span class="line">		<span class="keyword">for</span>( ; beg!=adj[v].end(); ++beg)</span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[*beg]))</span><br><span class="line">				q.push(*beg);   <span class="comment">// 若入度为0，则入栈</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(count &lt; V)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;           <span class="comment">// 没有输出全部顶点，有向图中有回路</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;            <span class="comment">// 拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下DAG图：</p>
<p><img src="http://img.blog.csdn.net/20150507013500102" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(6)</span></span>;   <span class="comment">// 创建图</span></span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	g.topological_sort();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>
<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的<code>queue</code>。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为$O(V+E)$。</p>
<p><br><br><br><br><br><br><br><br><br>另外，拓扑排序还可以采用 <a href="http://songlee24.github.io/2014/07/04/depth-first-search/" target="_blank" rel="external">深度优先搜索（DFS）</a>的思想来实现，详见《<a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank" rel="external">topological sorting via DFS</a>》。</p>
<p><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解公钥与私钥]]></title>
    <link href="http://yoursite.com/2015/05/03/public-key-and-private-key/"/>
    <id>http://yoursite.com/2015/05/03/public-key-and-private-key/</id>
    <published>2015-05-03T05:05:36.000Z</published>
    <updated>2015-05-10T12:08:33.440Z</updated>
    <content type="html"><![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/" target="_blank" rel="external">AES加密算法</a>》。<a id="more"></a></p>
<p><strong>2、公钥算法</strong></p>
<p><strong>公钥加密算法</strong>，也就是 <strong>非对称加密算法</strong>，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥：</p>
<ul>
<li>公钥和私钥成对出现</li>
<li>公开的密钥叫公钥，只有自己知道的叫私钥</li>
<li>用公钥加密的数据只有对应的私钥可以解密</li>
<li>用私钥加密的数据只有对应的公钥可以解密</li>
<li>如果可以用公钥解密，则必然是对应的私钥加的密</li>
<li>如果可以用私钥解密，则必然是对应的公钥加的密</li>
</ul>
<p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p>
<p><br></p>
<h3 id="二、实现数据的安全传输">二、实现数据的安全传输</h3><p>要实现数据的安全传输，当然就要对数据进行加密了。</p>
<p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用<strong>非对称算法</strong>，过程如下：</p>
<ol>
<li>首先 接收方 生成一对密钥，即私钥和公钥；</li>
<li>然后，接收方 将公钥发送给 发送方；</li>
<li>发送方用收到的公钥对数据加密，再发送给接收方；</li>
<li>接收方收到数据后，使用自己的私钥解密。</li>
</ol>
<p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p>
<p><img src="http://img.blog.csdn.net/20150502122610368" alt=""></p>
<p><br></p>
<h3 id="三、对信息进行数字签名">三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常<strong>“数字签名”</strong>是用来验证发送方的身份并帮助保护数据的完整性。</p>
<p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p>
<ol>
<li>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</li>
<li>保证信息自签发后到收到为止未曾作过任何修改。</li>
</ol>
<p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p>
<p><br></p>
<h3 id="四、公钥算法的缺点">四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是<strong>效率非常低</strong>，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p>
<ol>
<li>首先，发送方使用对称算法对原始信息进行加密。</li>
<li>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</li>
<li>接收方 将公钥发送给 发送方。</li>
<li>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</li>
<li>接收方用私钥进行解密得到对称算法的密钥。</li>
<li>发送方再把已加密的原始信息发送给接收方。</li>
<li>接收方使用对称算法的密钥进行解密。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150502122733376" alt=""></p>
<p><br><br><br><br><br><strong>总结：</strong></p>
<ol>
<li><p>每个用户都有一对私钥和公钥。  </p>
<ul>
<li>私钥用来进行解密和签名，是给自己用的。</li>
<li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li>
</ul>
</li>
<li><p>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。  </p>
</li>
<li><p>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。</p>
</li>
</ol>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<p>图片来源：www.cnblogs.com/chnking/archive/2007/08/30/875947.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/">AES加密算法</a>》。]]>
    
    </summary>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字节序：Big Endian 和 Little Endian]]></title>
    <link href="http://yoursite.com/2015/05/02/endianess/"/>
    <id>http://yoursite.com/2015/05/02/endianess/</id>
    <published>2015-05-02T04:56:43.000Z</published>
    <updated>2015-05-10T12:03:45.446Z</updated>
    <content type="html"><![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：<a id="more"></a></p>
<ul>
<li><p>Motorola 6800，PowerPC 970，SPARC（除V9外）等处理器采用 Big Endian方式存储数据；</p>
</li>
<li><p>x86系列，VAX，PDP-11等处理器采用Little Endian方式存储数据。</p>
</li>
</ul>
<p>另外，还有一些处理器像ARM, DEC Alpha的字节序是可配置的。</p>
<p><br></p>
<h3 id="二、大端与小端">二、大端与小端</h3><p>那么，到底什么是大端，什么是小端？ 如下图：</p>
<center><br><img src="http://img.blog.csdn.net/20150501200116979" alt=""><br></center>

<p>我相信上面的图已经够直观了。也就是说：</p>
<ul>
<li>Big Endian 是指低地址端 存放 高位字节。</li>
<li>Little Endian 是指低地址端 存放 低位字节。</li>
</ul>
<p><strong>各自的优势：</strong></p>
<ol>
<li>Big Endian：符号位的判定固定为第一个字节，容易判断正负。</li>
<li>Little Endian：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。</li>
</ol>
<p><br></p>
<h3 id="三、为什么要注意字节序">三、为什么要注意字节序</h3><p>如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。</p>
<p>但是，如果你的程序要跟别人的程序产生交互呢？ 比如，当一个 C/C++ 的程序要与一个 Java 程序交互时：</p>
<ul>
<li><p>C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的 x86 处理器是 Little Endian</p>
</li>
<li><p>JAVA编写的程序则唯一采用 Big Endian 方式来存储数据</p>
</li>
</ul>
<p>试想，如果你的C/C++程序将变量 <code>a = 0x12345678</code> 的首地址传递给了Java程序，由于Java采取 Big Endian 方式存储数据，很自然的它会将你的数据翻译为 <code>0x78563412</code>。显然，问题就出现了！！！</p>
<p>另外，网络传输一般采用 Big Endian，也被称之为<strong>网络字节序</strong>，或<strong>网络序</strong>。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p>
<p><br></p>
<h3 id="四、判断机器的字节序">四、判断机器的字节序</h3><p>由于 C/C++ 存储数据时的字节序依赖所在平台的CPU，所以我们可以通过C/C++程序判定机器的端序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Endianness</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span>( *((<span class="keyword">char</span>*)&amp;a) == <span class="number">0x12</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Big Endian"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Little Endian"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="五、网络序和主机序">五、网络序和主机序</h3><p><strong>网络字节序</strong>：TCP/IP各层协议将字节序定义为 Big Endian，因此TCP/IP协议中使用的字节序是大端序。</p>
<p><strong>主机字节序</strong>：整数在内存中存储的顺序，现在 Little Endian 比较普遍。（不同的 CPU 有不同的字节序）</p>
<p>在进行网络通信时 通常需要调用相应的函数进行主机序和网络序的转换。Berkeley socket API 定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】三个经典同步问题]]></title>
    <link href="http://yoursite.com/2015/04/30/linux-three-syn-problems/"/>
    <id>http://yoursite.com/2015/04/30/linux-three-syn-problems/</id>
    <published>2015-04-30T13:37:46.000Z</published>
    <updated>2015-05-10T11:58:29.924Z</updated>
    <content type="html"><![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/" target="_blank" rel="external">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。<a id="more"></a></p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。</p>
</li>
<li><p>整理思路：这里比较简单，只有生产者和消费者两个进程，且这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步的PV操作的位置。</p>
</li>
<li><p>信号量设置：信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量<code>full</code>用于记录当前缓冲池中“满”缓冲区数，初值为 0；信号量<code>empty</code>用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
</li>
</ol>
<p><strong>代码示例：</strong>（semaphore类的封装见下文）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;           <span class="comment">// 临界区互斥信号量</span></span><br><span class="line"><span class="function">semaphore <span class="title">empty</span><span class="params">("/home", N)</span></span>;       <span class="comment">// 记录空缓冲区数，初值为N</span></span><br><span class="line"><span class="function">semaphore <span class="title">full</span><span class="params">("/home/songlee",0)</span></span>; <span class="comment">// 记录满缓冲区数，初值为0</span></span><br><span class="line"><span class="keyword">int</span> buffer[N];                     <span class="comment">// 缓冲区，大小为N</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* producer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	empty.P();                 <span class="comment">// empty减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	buffer[i] = <span class="number">10</span> + rand() % <span class="number">90</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Producer %d write Buffer[%d]: %d\n"</span>,arg,i+<span class="number">1</span>,buffer[i]);</span><br><span class="line">	i = (i+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	full.V();                  <span class="comment">// full加1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* consumer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	full.P();                  <span class="comment">// full减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"                               \033[1;31m"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Consumer %d read Buffer[%d]: %d\n"</span>,arg,j+<span class="number">1</span>,buffer[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\033[0m"</span>);</span><br><span class="line">	j = (j+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	empty.V();                 <span class="comment">// empty加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开10个生产者线程，10个消费者线程</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, producer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, consumer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行输出结果：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Producer <span class="number">1</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">2</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">Producer <span class="number">3</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">Producer <span class="number">5</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">4</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">1</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">6</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">2</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">                               Consumer <span class="number">3</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">                               Consumer <span class="number">4</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">5</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">6</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">7</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">Producer <span class="number">8</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">10</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">9</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">                               Consumer <span class="number">10</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">9</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br><span class="line">                               Consumer <span class="number">7</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">8</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、读者-写者问题">二、读者-写者问题</h3><p><strong>问题描述：</strong></p>
<p>有读者和写者两组并发线程，共享一个文件，当两个或以上的读线程同时访问共享数据时不会产生副作用，但若某个写线程和其他线程（读线程或写线程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：由题目分析可知，读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
</li>
<li><p>整理思路：写者是比较简单的，它与任何线程互斥，用互斥信号量的 PV 操作即可解决。读者的问题比较复杂，它必须实现与写者的互斥，多个读者还可以同时读。所以，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时，不同的读者对计数器的访问也应该是互斥的。</p>
</li>
<li><p>信号量设置：首先设置一个计数器<code>count</code>，用来记录当前的读者数量，初值为0；设置互斥信号量<code>mutex</code>，用于保护更新 count 变量时的互斥；设置互斥信号量<code>rw</code>用于保证读者和写者的互斥访问。</p>
</li>
</ol>
<p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;           <span class="comment">// 记录当前的读者数量</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/",1)</span></span>;  <span class="comment">// 用于保护更新count变量时的互斥</span></span><br><span class="line"><span class="function">semaphore <span class="title">rw</span><span class="params">("/home",1)</span></span>; <span class="comment">// 用于保证读者和写者的互斥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* writer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	rw.P();              <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d start writing...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d finish writing...\n"</span>, arg);</span><br><span class="line">	</span><br><span class="line">	rw.V();              <span class="comment">// 释放共享文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* reader(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当第一个读线程读文件时</span></span><br><span class="line">		rw.P();          <span class="comment">// 阻止写线程写</span></span><br><span class="line">	++count;             <span class="comment">// 读者计数器加1</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d start reading...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d finish reading...\n"</span>, arg);</span><br><span class="line"></span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	--count;             <span class="comment">// 读者计数器减1</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当最后一个读线程读完文件</span></span><br><span class="line">		rw.V();          <span class="comment">// 允许写线程写</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">8</span>];     <span class="comment">// 开6个读线程，2个写线程</span></span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">2</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">3</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">4</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">3</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">5</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">4</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">6</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">5</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">7</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Reader</span> <span class="number">2</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">2</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> finish reading...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> finish writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> finish writing...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> finish reading...</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、哲学家进餐问题">三、哲学家进餐问题</h3><p><strong>问题描述：</strong></p>
<p>一张圆桌上坐着 5 名哲学家，桌子上每两个哲学家之间摆了<strong>一根</strong>筷子，桌子的中间是一碗米饭，如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150430145440864" alt=""></p>
<p>哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li><p>整理思路：显然这里有 5 个线程，那么要如何让一个哲学家拿到左右两个筷子而不造成死锁或饥饿现象？解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或死锁现象的发生。</p>
</li>
<li><p>信号量设置：定义互斥信号量数组<code>chopstick[5] = {1,1,1,1,1}</code>用于对 5 根筷子的互斥访问。</p>
</li>
</ol>
<p><strong>示例代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;  <span class="comment">// 信号量数组</span></span><br><span class="line">Pi()                                  <span class="comment">// i号哲学家的线程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		P(chopstick[i]);              <span class="comment">// 取左边筷子</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 取右边筷子</span></span><br><span class="line">		eat;                          <span class="comment">// 进餐</span></span><br><span class="line">		V(chopstick[i]);              <span class="comment">// 放回左边筷子</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 放回右边筷子</span></span><br><span class="line">		think;                        <span class="comment">// 思考</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的伪代码存在一个问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完<code>P(chopstick[i])</code>），筷子已经被拿光了，等到他们再想拿右边的筷子的时候，就全被阻塞了，这就出现了死锁。</p>
<p>为了防止死锁的发生，可以对哲学家线程施加一些限制条件，比如：</p>
<ul>
<li>至多允许四个哲学家同时进餐；</li>
<li>仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子；</li>
<li>对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再抓他右边的筷子，而偶数号哲学家刚好相反。</li>
</ul>
<p>这里，我们采用第二种方法来改进上面的算法，即当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;semaphore*&gt; chopstick;   <span class="comment">// 信号量数组</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;  <span class="comment">// 设置取左右筷子的信号量 &lt;-- 关键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P1(<span class="keyword">void</span>* arg)  <span class="comment">// 第1个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 1 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P2(<span class="keyword">void</span>* arg)  <span class="comment">// 第2个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 2 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P3(<span class="keyword">void</span>* arg)  <span class="comment">// 第3个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 3 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P4(<span class="keyword">void</span>* arg)  <span class="comment">// 第4个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 4 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P5(<span class="keyword">void</span>* arg)  <span class="comment">// 第5个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 5 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	semaphore *sem1 = <span class="keyword">new</span> semaphore(<span class="string">"/home"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem2 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem3 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/java"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem4 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/ADT"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem5 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/Test"</span>, <span class="number">1</span>);</span><br><span class="line">	chopstick.push_back(sem1);</span><br><span class="line">	chopstick.push_back(sem2);</span><br><span class="line">	chopstick.push_back(sem3);</span><br><span class="line">	chopstick.push_back(sem4);</span><br><span class="line">	chopstick.push_back(sem5);</span><br><span class="line"></span><br><span class="line">	pthread_t id;</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id, NULL, P1, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P2, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P3, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P4, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P5, NULL);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">delete</span> sem1;</span><br><span class="line">	<span class="keyword">delete</span> sem2;</span><br><span class="line">	<span class="keyword">delete</span> sem3;</span><br><span class="line">	<span class="keyword">delete</span> sem4;</span><br><span class="line">	<span class="keyword">delete</span> sem5;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Philosopher</span> <span class="number">2</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">1</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">3</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">4</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">5</span> eat.</span><br></pre></td></tr></table></figure></p>
<p>注意：创建信号量时的 路径参数 请改成你的系统中存在的路径！！！</p>
<p><br><br><br><br></p>
<h3 id="附：semaphore类的封装">附：semaphore类的封装</h3><p>上面的代码中都使用了这个<code>semaphore</code>类，实现如下：</p>
<ul>
<li><strong>semaphore.h</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> semaphore &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	semaphore(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>); <span class="comment">/*构造函数*/</span></span><br><span class="line">	~semaphore();                <span class="comment">/*析构函数*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>;                    <span class="comment">/*P操作*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>;                    <span class="comment">/*V操作*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>semaphore.cpp</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"></span><br><span class="line">semaphore::semaphore(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">semaphore::~semaphore()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::P()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::V()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">int</span> semaphore::init_sem(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，要创建不同的信号量，必须传递不同的路径参数（这样获取的 key 值才会不一样）。</p>
<p>注意，本文的关注点并不在于 linux 下如何创建信号量以及如何封装起来才更方便，而是通过几个经典的同步实例，了解在多线程环境下如何解决这类线程同步问题。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】同步与互斥的区别]]></title>
    <link href="http://yoursite.com/2015/04/29/linux-syn-mut-difference/"/>
    <id>http://yoursite.com/2015/04/29/linux-syn-mut-difference/</id>
    <published>2015-04-29T15:45:11.000Z</published>
    <updated>2015-05-10T11:56:23.819Z</updated>
    <content type="html"><![CDATA[<p>同步与互斥这两个概念经常被混淆，所以在这里说一下它们的区别。</p>
<h3 id="一、同步与互斥的区别">一、同步与互斥的区别</h3><h4 id="1-_同步">1. 同步</h4><p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。</p>
<p>例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;   <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">T1() &#123;</span><br><span class="line">	...</span><br><span class="line">	x;           <span class="comment">// 语句x</span></span><br><span class="line">	V(S);        <span class="comment">// 告诉线程T2，语句x已经完成</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);        <span class="comment">// 检查语句x是否运行完成</span></span><br><span class="line">	y;           <span class="comment">// 检查无误，运行y语句</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-_互斥">2. 互斥</h4><p><strong>互斥</strong>，又称<strong>间接制约关系</strong>，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。</p>
<p>例如，打印机就是一种临界资源，而访问打印机的代码片段称为临界区，故每次只允许一个线程进入临界区。—— 我们同样可以使用信号量解决互斥问题，只需把临界区置于 P(S) 和 V(S) 之间，即可实现两线程对临界资源的互斥访问。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">1</span>;   <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">T1() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	线程T1的临界区;  <span class="comment">// 访问临界资源</span></span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	线程T2的临界区;  <span class="comment">// 访问临界资源</span></span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、一个同步的例子">二、一个同步的例子</h3><p>如下图，为了求出 1 到 n 的平均值，需要三个线程协调它们的工作次序来完成，这就是同步：</p>
<p><img src="http://img.blog.csdn.net/20150429225128423" alt=""></p>
<p>为了使多个线程按顺序正确执行，应设置若干个初始值为 0 的信号量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.hpp"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sem1, sem2;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;  <span class="comment">/*1...n的平均值*/</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> average = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* t1(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		sum += i;</span><br><span class="line">	sem_v(sem1);  <span class="comment">/*V操作，通知t2求和已完成*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* t2(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	sem_p(sem1);  <span class="comment">/*P操作，等待t1完成*/</span>	</span><br><span class="line">	average = (<span class="keyword">double</span>)sum/n;</span><br><span class="line">	sem_v(sem2);  <span class="comment">/*V操作，通知main求平均已完成*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	sem1 = creat_sem(<span class="string">"/"</span> , <span class="number">0</span>); <span class="comment">/*创建信号量*/</span></span><br><span class="line">	sem2 = creat_sem(<span class="string">"/home"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	pthread_t id[<span class="number">2</span>];</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, t1, NULL);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, t2, NULL);</span><br><span class="line"></span><br><span class="line">	sem_p(sem2);  <span class="comment">/*P操作，等待t2完成*/</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is: "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The average is: "</span> &lt;&lt; average &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	del_sem(sem1); <span class="comment">/*删除信号量*/</span></span><br><span class="line">	del_sem(sem2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是信号量的相关函数，详见《<a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">信号量</a>》。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semaphore.hpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建信号量，返回其ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">/*信号量集ID*/</span></span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(sem_id, value);</span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程 t2 需要等待线程 t1 （求和）完成以后才能够执行；主线程 main 需要等待线程 t2 （求平均）完成以后才能够执行输出。编译运行结果如下：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -lpthread -o <span class="keyword">synchronized</span> <span class="keyword">synchronized</span>.cpp </span><br><span class="line">$ ./<span class="keyword">synchronized</span> </span><br><span class="line">The sum <span class="keyword">is</span>: <span class="number">55</span></span><br><span class="line">The average <span class="keyword">is</span>: <span class="number">5.5</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<p><strong>总结：</strong></p>
<ol>
<li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li>
<li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li>
<li>互斥是一种特殊的同步。</li>
</ol>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>同步与互斥这两个概念经常被混淆，所以在这里说一下它们的区别。</p>
<h3 id="一、同步与互斥的区别">一、同步与互斥的区别</h3><h4 id="1-_同步">1. 同步</h4><p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。</p>
<p>例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux编程】进程间通信（IPC）]]></title>
    <link href="http://yoursite.com/2015/04/21/linux-IPC/"/>
    <id>http://yoursite.com/2015/04/21/linux-IPC/</id>
    <published>2015-04-21T12:51:21.000Z</published>
    <updated>2015-05-10T11:50:29.559Z</updated>
    <content type="html"><![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。<a id="more"></a></p>
<h3 id="1、特点：">1、特点：</h3><ol>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ol>
<h3 id="2、原型：">2、原型：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[2])</span></span>;    <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150419222058628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>要关闭管道只需将这两个文件描述符关闭即可。</p>
<h3 id="3、例子">3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150419223853807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">		read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="二、FIFO">二、FIFO</h2><p><strong>FIFO</strong>，也称为命名管道，它是一种文件类型。</p>
<h3 id="1、特点">1、特点</h3><ol>
<li><p>FIFO可以在无关的进程之间交换数据，与无名管道不同。</p>
</li>
<li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
</li>
</ol>
<h3 id="2、原型">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p>
<p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p>
<ul>
<li><p>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p>
</li>
<li><p>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p>
</li>
</ul>
<h3 id="3、例子-1">3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</p>
<ul>
<li><p><strong>write_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;   <span class="comment">// exit</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;    <span class="comment">// O_WRONLY</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;time.h&gt;     <span class="comment">// time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	time_t tp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO </span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">		n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">		<span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">		perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./write_fifo </span><br><span class="line">I am <span class="number">5954</span> <span class="keyword">process</span>.</span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./read_fifo </span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p><br><br><br>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p>
<p><img src="http://img.blog.csdn.net/20150420131002360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><br></p>
<h2 id="三、消息队列">三、消息队列</h2><p><strong>消息队列</strong>，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<h3 id="1、特点-1">1、特点</h3><ol>
<li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ol>
<h3 id="2、原型-1">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(key_t key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p>
<ul>
<li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li>
<li>key参数为<code>IPC_PRIVATE</code>。</li>
</ul>
<p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p>
<ul>
<li><code>type == 0</code>，返回队列中的第一个消息；</li>
<li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li>
<li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li>
</ul>
<p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p>
<h3 id="3、例子-2">3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p>
<ul>
<li><p><strong>msg_server.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环读取消息</span></span><br><span class="line">	<span class="keyword">for</span>(;;) </span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">		msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">		<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">		msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msg_client.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加消息，类型为888</span></span><br><span class="line">	msg.mtype = <span class="number">888</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">	msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取类型为777的消息</span></span><br><span class="line">	msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="四、信号量">四、信号量</h2><p><strong>信号量（semaphore）</strong>与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<h3 id="1、特点-2">1、特点</h3><ol>
<li><p>信号量用于进程间同步，若要在进程间传递数据需要结合<em>共享内存</em>。</p>
</li>
<li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p>
</li>
<li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
</li>
<li><p>支持信号量组。</p>
</li>
</ol>
<h3 id="2、原型-2">2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做<strong>二值信号量（Binary Semaphore）</strong>。而可以取多个正整数的信号量被称为通用信号量。</p>
<p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(key_t key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], size_t numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 。</p>
<p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sembuf </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 sem_op 是一次操作中的信号量的改变量：</p>
<ul>
<li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们。</p>
</li>
<li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p>
<ul>
<li>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</li>
<li>当相应的资源数不能满足请求时，这个操作与<code>sem_flg</code>有关。<ul>
<li>sem_flg 指定<code>IPC_NOWAIT</code>，则semop函数出错返回<code>EAGAIN</code>。</li>
<li>sem_flg 没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p>
<ul>
<li>当信号量已经为0，函数立即返回。</li>
<li>如果信号量的值不为0，则依据<code>sem_flg</code>决定函数动作：<ul>
<li>sem_flg指定<code>IPC_NOWAIT</code>，则出错返回<code>EAGAIN</code>。</li>
<li>sem_flg没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR  </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p>
<ul>
<li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li>
<li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li>
</ul>
<h3 id="3、例子-3">3、例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">	<span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	tmp.val = value;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//	若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//	若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//	释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//	如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">	key_t key;  </span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">	init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">		del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p>
<p><br></p>
<h2 id="五、共享内存">五、共享内存</h2><p><strong>共享内存（Shared Memory）</strong>，指两个或多个进程共享一个给定的存储区。</p>
<h3 id="1、特点-3">1、特点</h3><ol>
<li><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>
</li>
<li><p>因为多个进程可以同时操作，所以需要进行同步。</p>
</li>
<li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p>
</li>
</ol>
<h3 id="2、原型-3">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(key_t key, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="keyword">void</span> *shmat(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag);</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p>
<p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p>
<p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p>
<p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p>
<h3 id="3、例子-4">3、例子</h3><p>下面这个例子，使用了<strong>【共享内存+信号量+消息队列】</strong>的组合来实现服务器进程与客户进程间的通信。</p>
<ul>
<li>共享内存用来传递数据；</li>
<li>信号量用来同步；</li>
<li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li>
</ul>
<p><strong>Server.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(key_t key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">	<span class="keyword">struct</span> shmid_ds buf1;  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">	<span class="keyword">struct</span> msqid_ds buf2;  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量</span></span><br><span class="line">	semid = creat_sem(key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span> </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			sem_p(semid);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">			sem_v(semid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">	shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">	msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">	del_sem(semid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Client.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取信号量</span></span><br><span class="line">	<span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 写数据</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">		<span class="keyword">switch</span>(c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">				sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">				sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">				msg.mtype = <span class="number">888</span>;  </span><br><span class="line">				msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">				msg.mtype = <span class="number">888</span>;</span><br><span class="line">				msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br></pre></td></tr></table></figure></p>
<p>注释已经很详细了，所以代码的其他部分我就不解释了，下面是运行结果截图：</p>
<p><img src="http://img.blog.csdn.net/20150421203538923" alt=""></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可利用空间表（Free List）]]></title>
    <link href="http://yoursite.com/2015/04/08/free-list/"/>
    <id>http://yoursite.com/2015/04/08/free-list/</id>
    <published>2015-04-08T03:11:00.000Z</published>
    <updated>2015-05-10T11:47:00.859Z</updated>
    <content type="html"><![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br><a id="more"></a><br>为了避免频繁的new/delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从free list中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p>
<p>要求：</p>
<ol>
<li>实现一个对固定大小内存块进行管理的通用FreeList类，给出定义和实现。要求不能使用STL中的容器类。定义类的接口和实现时注意通用性、健壮性和可测试性。</li>
<li>如果该类的对象可能会被多个thread同时访问，请描述如何怎样保证线程安全。有没有办法在保证线程安全的同时尽可能增大并发度？如果有也请描述你的思路。</li>
</ol>
</blockquote>
<p><br></p>
<h3 id="一、介绍">一、介绍</h3><p>“可利用空间表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即<strong>可利用空间表（free list）</strong>。</p>
<p>当用户请求分配时，系统从可利用空间表中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到可利用空间表中，因此，可利用空间表亦称为“存储池”。</p>
<p>可利用空间表有三种结点结构：</p>
<ol>
<li><p><strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。</p>
</li>
<li><p><strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。</p>
</li>
<li><p><strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即可利用空间表中只有一个大小为整个存储区的结点。随着分配和回收的进行，可利用空间表的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是可利用空间表中的任一结点都能满足，而需要按照申请的长度在可利用空间表中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略：</p>
<ul>
<li><p><strong>首次适配法</strong>：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）</p>
</li>
<li><p><strong>最佳适配法</strong>：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）</p>
</li>
<li><p><strong>最差适配法</strong>：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）</p>
</li>
</ul>
</li>
</ol>
<p>三种分配策略适合于不同的情况，<code>首次适配法</code>的优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足 —— 这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。<code>最佳适配法</code>的优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统。<code>最差适配法</code>的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</p>
<p><br></p>
<h3 id="二、C++实现">二、C++实现</h3><p>根据题目要求，实现一个对固定大小内存块进行管理的通用FreeList类，即结点大小相同。其实这是最简单的一种实现，注意几个实现要点：</p>
<ul>
<li><p>一个静态成员指针static FreeList* freelist，用来指向可利用空间表。</p>
</li>
<li><p>重载 new 和 delete。</p>
</li>
</ul>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">class</span> FreeList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> FreeList&lt;Elem&gt; *freelist;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Elem element;</span><br><span class="line">	FreeList *next;</span><br><span class="line">	FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next=NULL);</span><br><span class="line">	FreeList(FreeList* next=NULL);</span><br><span class="line">	<span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>;    <span class="comment">// 重载new</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;   <span class="comment">// 重载delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;* FreeList&lt;Elem&gt;::freelist = NULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;element = elem;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span>* FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*freelist没有可用空间，就从系统分配*/</span></span><br><span class="line">	<span class="keyword">if</span>(freelist == NULL)  </span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">new</span> FreeList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*否则，从freelist表头摘取结点*/</span></span><br><span class="line">	FreeList&lt;Elem&gt;* temp = freelist;</span><br><span class="line">	freelist = freelist-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span> FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*把要释放的结点空间加入到freelist中*/</span></span><br><span class="line">	((FreeList&lt;Elem&gt;*)ptr)-&gt;next = freelist;</span><br><span class="line">	freelist = (FreeList&lt;Elem&gt;*)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>至于线程安全的问题，在多线程的环境下，线程同步的方式有多种：临界区、事件、互斥量、信号量。比如，我们可以把访问该类对象的代码段设置为 Critical Section，这样同一时间就只有一个线程可以执行这段代码。为了尽可能增大并发度，更好的方式是将代码改造成对临界数据的保护而不是对临界代码的保护，这样就可以令不会同时访问相同临界数据的线程完全并行地执行。</p>
<p>这是我个人的观点，如果你有更好的想法，欢迎交流和指正！</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br>]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2051-最小的K个数（Top K问题）]]></title>
    <link href="http://yoursite.com/2015/03/21/hua-wei-OJ2051/"/>
    <id>http://yoursite.com/2015/03/21/hua-wei-OJ2051/</id>
    <published>2015-03-21T11:36:34.000Z</published>
    <updated>2015-05-10T11:39:10.276Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组<a id="more"></a></li>
</ol>
<p><strong>输出：</strong></p>
<p>输出一个整数数组</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 5 7 2</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、Top_K问题">二、Top K问题</h1><p>对于 Top K 问题有很多种解法。</p>
<h2 id="解法一：排序">解法一：排序</h2><p>相信很多人会首先想到这种方法，先把数组按升序/降序进行排序，然后输出 K 个最小/最大的数。</p>
<ul>
<li>常规的排序方法时间复杂度至少是$Θ(nlog_2n)$。（<a href="http://songlee24.github.io/2014/04/03/implementation-of-internal-sortings/" target="_blank" rel="external">快排或堆排序</a>）</li>
<li>可能你会说，我们可以使用<a href="http://songlee24.github.io/2014/06/22/linear-sorting-algorithms/" target="_blank" rel="external">线性时间的排序算法</a>。当然可以，但通常它们对输入的数组有一定的要求。比如计数排序要求 n 个数都是正整数，且它们的取值范围不太大。</li>
</ul>
<h2 id="解法二：部分排序_$O(n*k)$">解法二：部分排序 $O(n*k)$</h2><p>由于我们只需要找出最小/最大的 k 个数，所以我们可以进行部分排序，比如<strong>简单选择排序</strong> 和 <strong>冒泡排序</strong>，它们每一趟都能把一个最小/最大元素放在最终位置上，所以进行 k 趟就能把 n 个数中的前 k 个排序出来。</p>
<p>部分简单选择排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123; <span class="comment">// k趟</span></span><br><span class="line">		<span class="keyword">int</span> Min = i;         <span class="comment">// 记录最小元素的位置</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[Min])</span><br><span class="line">				Min = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Min != i)  <span class="comment">// 与A[i]交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[Min];</span><br><span class="line">			A[Min] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>部分冒泡排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)  <span class="comment">// k趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j)  <span class="comment">// 一趟冒泡过程</span></span><br><span class="line">			<span class="keyword">if</span>(A[j-<span class="number">1</span>] &gt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = A[j-<span class="number">1</span>];</span><br><span class="line">				A[j-<span class="number">1</span>] = A[j];</span><br><span class="line">				A[j] = tmp;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="keyword">false</span>)  <span class="comment">// 已经有序</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，$O(nlog_2n)$ 与 $O(n*k)$ 哪一个更好呢？这取决于 k 的大小。在 k 较小的情况下，即 $k &lt;= log_2n$，可以选择部分排序。</p>
<h2 id="解法三：快排划分_$O(n*log_2k)$">解法三：快排划分 $O(n*log_2k)$</h2><p>根据基于快排<code>partition</code>操作的《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/33419201" target="_blank" rel="external">第k顺序统计量的求解</a>》，我们知道，当我们求出第 k 顺序统计量时，位于它前面的元素都比它小，位于它后面的元素都比它大。这时，数组的前 k 个数就是最小的 k 个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[high]&gt;=pivot)</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[low]&lt;=pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(low == high)</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = partition(A, low, high);</span><br><span class="line">	<span class="keyword">int</span> i = pos - low + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">		<span class="keyword">return</span> pos;  <span class="comment">// 返回前k个数的</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; k)</span><br><span class="line">		<span class="keyword">return</span> topK(A, low, pos, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> topK(A, pos+<span class="number">1</span>, high, k-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们说这个算法的平均时间复杂度是线性的，更准确地说，是 $O(n∗log_2k)$。另外，为了避免特殊数据下的算法退化，最好使用随机化版本的划分操作。</p>
<h2 id="解法四：大根堆_$O(n∗log_2k)$">解法四：大根堆 $O(n∗log_2k)$</h2><p>参见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/24846247" target="_blank" rel="external">堆排序</a>》，可以用大小为 k 的大根堆来存储最小的 k 个数。大根堆的堆顶元素就是最小 k 个数中最大的一个。每次新考虑一个数 X：</p>
<ul>
<li><p>如果 X 比堆顶的元素 Y 大，则不需要改变原来的堆，因为这个元素比最小的 k 个数都大。</p>
</li>
<li><p>如果 X 比堆顶元素 Y 小，那么用 X 替换堆顶的元素 Y。在 X 替换堆顶元素 Y 之后，大根堆的结构可能被破坏，需要进行向下调整。调整过程的时间复杂度是 $O(log_2k)$ 。</p>
</li>
</ul>
<p>遍历完成以后，数组的前 k 个数就是最小的 k 个数，但是它们并非有序，而是以堆的形式存在。C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> temp = A[i];  <span class="comment">// 暂存A[i]  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])  </span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大  </span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])  </span><br><span class="line">		&#123;  </span><br><span class="line">			A[i] = A[largest];  </span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置  </span></span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 维护 A[0...k-1] 这个大根堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, k);  <span class="comment">// 先用前面的k个数建大根堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i] &lt; A[<span class="number">0</span>])  <span class="comment">// 如果小于堆顶元素，替换之</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[<span class="number">0</span>];</span><br><span class="line">			A[<span class="number">0</span>] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">			AdjustDown(A, <span class="number">0</span>, k);  <span class="comment">// 向下调整</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：找最小的 $k$ 个数，就维护一个大根堆；找最大的 $k$ 个数，就维护一个小根堆。</p>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>第二部分已经讲解地很清楚了，几种解法都可以，只要注意输入输出的格式就行了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
</feed>