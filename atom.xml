<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Man]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-09T18:24:03.618Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++学习之动态数组类的封装]]></title>
    <link href="http://yoursite.com/2014/07/28/cpp-dynamic-array/"/>
    <id>http://yoursite.com/2014/07/28/cpp-dynamic-array/</id>
    <published>2014-07-27T17:52:34.000Z</published>
    <updated>2015-05-09T18:24:03.618Z</updated>
    <content type="html"><![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/" target="_blank" rel="external">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3><a id="more"></a>
<p>当用new为一个动态数组申请一块内存时，数组中的元素是<strong>连续存储</strong>的，例如 vector和string。当向一个动态数组添加元素时，如果没有空间容纳新元素，不可能简单地将新元素添加到内存中的其他位置——因为元素必须连续存储。所以<strong>必须重新分配一块更大的内存空间，将原来的元素从旧位置移动到新空间中，然后添加新元素，释放旧的内存空间</strong>。如果我们每添加一个新元素，就执行一次这样的内存分配和释放操作，效率将会慢到不行。</p>
<p>为了避免上述的代价，必须减少内存重新分配的次数。所以我们采取的策略是：<strong>在不得不分配新的内存空间时，分配比新的空间需求更大的内存空间（通常为2倍）</strong>。这样，在相当一段时间内，添加元素时就不用重新申请内存空间。注意，只有当迫不得已时才可以分配新的内存空间。</p>
<h3 id="类的四大函数">类的四大函数</h3><p>一个C++类一般至少有四大函数，即构造函数、拷贝构造函数、拷贝赋值运算符、析构函数。如果类未自己定义上述函数，C++编译器将为其合成4个默认的版本。但是往往编译器合成的并不是我们所期望的，为此我们有必要自己定义它们。</p>
<p><strong>构造函数</strong></p>
<p>类的<strong>构造函数（constructor）</strong>用来初始化类对象的非static数据成员，无论何时只要类的对象被创建，就会执行构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();  <span class="comment">// 构造函数</span></span><br><span class="line">	Foo(<span class="built_in">string</span> &amp;s);  <span class="comment">// 接受一个参数的构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数的名字和类名相同，没有返回类型。类可以包含多个构造函数（重载），它们之间在参数数量或类型上需要有所区别。<strong>构造函数有一个初始化部分和一个函数体</strong>，成员的初始化是在函数体执行之前完成的。</p>
<p><strong>拷贝构造函数</strong></p>
<p>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数（copy constructor）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝构造函数定义了如何用一个对象<strong>初始化</strong>另一个同类型的对象。拷贝初始化通常使用拷贝构造函数来完成。<strong>拷贝初始化</strong>发生在下列情况中：</p>
<ul>
<li>使用等号（=）初始化一个变量</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素</li>
</ul>
<p><strong>拷贝赋值运算符</strong></p>
<p>类的<strong>拷贝赋值运算符（copy-assignment operator）</strong>是一个名为<code>operator=</code>的函数。类似于其他任何函数，它也有一个返回类型和一个参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝赋值运算符定义了如何将一个对象<strong>赋值</strong>给另一个同类型的对象。赋值运算符是一个成员函数也是一个二元运算符，其左侧运算对象就绑定到隐式的this指针，右侧运算对象作为显式参数传递。<strong>注意</strong>：为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>
<p><strong>析构函数</strong></p>
<p>类的<strong>析构函数（destructor）</strong>用来释放类对象使用的资源并销毁类对象的非static数据成员，无论何时只要一个对象被销毁，就会自动执行析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~Foo();  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>析构函数的名字由波浪号（~）加类名构成，也没有返回类型。由于析构函数不接受参数，因此它不能被重载。<strong>析构函数有一个函数体和一个析构部分</strong>，销毁一个对象时，首先执行析构函数体，然后按初始化顺序的逆序销毁成员。</p>
<h3 id="运算符的重载">运算符的重载</h3><p>重载的运算符是具有特殊名字的函数：<strong>它们的名字由关键字<code>operator</code>和其后要定义的运算符号共同组成</strong>。和其他函数一样，重载的运算符也包含返回类型、参数列表、函数体，比如拷贝赋值运算符。</p>
<p>当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。有些运算符必须作为成员，而另一些运算符作为普通函数比作为成员更好：</p>
<ul>
<li>赋值（=）、下标（[ ]）、调用（( )）和成员访问箭头（-&gt;）运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常应该是成员。</li>
<li>具有<strong>对称性</strong>的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
<p>当然，除了赋值运算符之外，我们还需要为动态数组定义<strong>下标运算符operator []</strong>。下标运算符必须是成员函数。为了让下标可以出现在赋值运算符的任意一端，下标运算符函数通常返回所访问元素的引用。</p>
<h3 id="动态数组类的封装">动态数组类的封装</h3><p>下面给出了动态数组DArray类的接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DArray</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> *m_Data;  <span class="comment">// 存放数组的动态内存指针</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;      <span class="comment">// 数组的元素个数</span></span><br><span class="line">	<span class="keyword">int</span> m_Max;       <span class="comment">// 预留给动态数组的内存大小</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;     <span class="comment">// 初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">()</span></span>;     <span class="comment">// 释放动态内存</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">InvalidateIndex</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 判断下标的合法性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DArray();        <span class="comment">// 默认构造函数</span></span><br><span class="line">	DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue = <span class="number">0</span>);  <span class="comment">// 构造函数，设置数组大小，默认值为dValue</span></span><br><span class="line">	DArray(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	DArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	~DArray();       <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;    <span class="comment">// 输出显式所有数组元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;   <span class="comment">// 获取数组的大小（元素个数）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetSize</span><span class="params">(<span class="keyword">int</span> nSize)</span></span>;  <span class="comment">// 重新设置数组的大小</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 获取指定位置元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetAt</span><span class="params">(<span class="keyword">int</span> nIndex,<span class="keyword">double</span> dValue)</span></span>; <span class="comment">// 重置指定元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;     <span class="comment">// 删除指定位置地元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertAt</span><span class="params">(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 插入一个新的元素到数组中</span></span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span>;      <span class="comment">// 重载下标运算符[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是我的实现：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DArray::Init()</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = <span class="number">0</span>;   <span class="comment">// 默认情况下数组不包含元素</span></span><br><span class="line">	m_Max = <span class="number">1</span>;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DArray::Free()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DArray::InvalidateIndex(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&gt;=<span class="number">0</span> &amp;&amp; nIndex&lt;m_Size)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">DArray::DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize == <span class="number">0</span>)</span><br><span class="line">		Init();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Size = nSize;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i]=dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = arr.m_Size;  <span class="comment">/*复制常规成员*/</span></span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];   <span class="comment">/*复制指针指向的内容*/</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_Data, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">DArray&amp; DArray::<span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;arr)  <span class="comment">/*自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	m_Size = arr.m_Size;</span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	<span class="comment">/* 先将右侧对象拷贝到临时对象中，然后再销毁左侧对象*/</span> </span><br><span class="line">	<span class="keyword">double</span> *m_Temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">	<span class="built_in">memcpy</span>(m_Temp, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">	m_Data = m_Temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">DArray::~DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Free();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> DArray::Print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: The empty array can't be Printed."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m_Size; ++i)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m_Data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组大小</span></span><br><span class="line"><span class="keyword">int</span> DArray::GetSize()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组大小</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetSize(<span class="keyword">int</span> nSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize &lt; m_Size)   <span class="comment">/*截断*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nSize; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m_Size&lt;=nSize &amp;&amp; nSize&lt;=m_Max)  <span class="comment">/*新增元素置0*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nSize &gt; m_Max)   <span class="comment">/*需要重新分配空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span> *temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			temp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	m_Size = nSize; <span class="comment">/*设置数组大小*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素</span></span><br><span class="line"><span class="keyword">double</span> DArray::GetAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of GetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置指定位置元素的值</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of SetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line"><span class="keyword">void</span> DArray::PushBack(<span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/*数组大小加1*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除一个元素</span></span><br><span class="line"><span class="keyword">void</span> DArray::DeleteAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of DeleteAt is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nIndex; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = m_Data[i+<span class="number">1</span>];</span><br><span class="line">		m_Data[m_Size-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		--m_Size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个新元素到指定位置</span></span><br><span class="line"><span class="keyword">void</span> DArray::InsertAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of InsertAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)  <span class="comment">/* 未满，插入 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>               <span class="comment">/* 重新分配空间 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/* 数组大小加1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载下标运算符[]</span></span><br><span class="line"><span class="keyword">double</span> DArray::<span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;=m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index in [] is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过简单的测试，暂时还没有发现Bug。可能测试并不全面，如果你发现了问题，希望你能在评论里告诉我，万分感谢！！！<br><br><br><br></p>
<h3 id="附：String类的实现">附：String类的实现</h3><p>C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能要求具备 std::string 的功能，但至少要求能正确管理资源。</p>
<p>如果你弄懂了上面DArray类的写法，那么实现String类应该就不难了。因为面试官一般只是想考查你能不能正确地写出构造函数、析构函数、拷贝构造函数、拷贝赋值运算符以及+、[ ]、&lt;&lt;、&gt;&gt;运算符重载等等。下面给出一个String类的接口，你可以自己试试手实现一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;  </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp;,String&amp;); <span class="comment">//重载&lt;&lt;运算符  </span></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp;,String&amp;); <span class="comment">//重载&gt;&gt;运算符  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    String();   <span class="comment">// 默认构造函数</span></span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* str);       <span class="comment">// 带参构造函数  </span></span><br><span class="line">    String(<span class="keyword">const</span> String&amp; rhs);        <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs);   <span class="comment">// 拷贝赋值运算符  </span></span><br><span class="line">    String <span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span>;  <span class="comment">//operator+  </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator!=   </span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span>);              <span class="comment">//operator[]  </span></span><br><span class="line">    <span class="function">size_t <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_str() <span class="keyword">const</span>;</span><br><span class="line">    ~String();    <span class="comment">// 析构函数 </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是String类的实现，注意一些得分点：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::String()</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	m_data[<span class="number">0</span>] = <span class="string">'\0'</span>;  <span class="comment">/*得分点：空字符串存放结束标志'\0'*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参的构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)  <span class="comment">/*得分点：自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">	<span class="keyword">delete</span> [] m_data; <span class="comment">/*得分点：释放左侧对象资源*/</span></span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator+</span></span><br><span class="line">String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	String newStr;</span><br><span class="line">	newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data)+<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(newStr.m_data, m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator==</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(m_data, rhs.m_data) == <span class="number">0</span>) <span class="comment">/*相等返回0*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator!=</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;<span class="built_in">strlen</span>(m_data))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_data[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of [] is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String大小</span></span><br><span class="line">size_t String::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取C风格字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* String::c_str() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str.m_data;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&gt;&gt;运算符</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">255</span>];</span><br><span class="line">	is &gt;&gt; temp;</span><br><span class="line">	str = temp;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之new与delete、malloc与free]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-new-malloc/"/>
    <id>http://yoursite.com/2014/07/25/cpp-new-malloc/</id>
    <published>2014-07-25T14:06:45.000Z</published>
    <updated>2015-05-09T18:20:44.204Z</updated>
    <content type="html"><![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br><a id="more"></a><br>标准库定义了operator new函数的几个重载版本，没有使用<code>noexcept</code>说明的版本在内存分配失败时可能会抛出bad_alloc异常，而使用了的不会抛出异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t )</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t );	</span><br><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用new表达式时，实际执行了三步操作：</p>
<ul>
<li>new表达式调用上面的<strong>operator new</strong>（或者<strong>operator new[]</strong>）的标准库函数，函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</li>
<li>编译器运行相应的<strong>构造函数</strong>以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ul>
<p>对于operator new函数或者operator new[]函数来说，它的返回类型必须是void*，第一个形参的类型必须是size_t且该形参不能含有默认实参。当编译器调用operator new或者operator new[]函数时，会把存储指定对象或者指定对象的数组所需的字节数传给size_t形参。</p>
<p><strong>delete表达式</strong></p>
<p>标准库也定义了operator delete函数的几个重载版本，<code>noexcept</code>说明符表示在内存分配失败时返回空指针而不是抛出bad_alloc异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用delete表达式时，实际执行了两步操作：</p>
<ul>
<li>对指针所指的对象或者所指的数组中的元素执行对应的<strong>析构函数</strong>。</li>
<li>编译器调用<strong>operator delete</strong>（或者<strong>operator delete[]</strong>）的标准库函数释放内存空间。</li>
</ul>
<p>对于operator delete函数或者operator delete[]函数来说，它们的返回类型必须是void，第一个形参的类型必须是void*。执行一条delete表达式将调用相应的operator函数，并用指向待释放内存的指针来初始化void*形参。<br><br></p>
<h3 id="malloc和free">malloc和free</h3><p>malloc和free是C/C++中的<strong>标准库函数</strong>，也是用于申请动态内存和释放内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="built_in">malloc</span>( size_t size );</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">free</span><span class="params">( <span class="keyword">void</span>* ptr )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>malloc函数</strong>接受一个表示待分配字节数的size_t，返回指向分配空间的指针；如果分配失败，则返回空指针。<strong>free函数</strong>接受一个void<em>，它是malloc返回的指针的副本，free将相关内存返还给系统。<em>*注意</em></em>：malloc函数并不会调用构造函数来初始化内存，free函数也不会自动调用析构函数。<br><br></p>
<h3 id="new和malloc、delete和free的区别">new和malloc、delete和free的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;     <span class="comment">// 没有初始化列表， 所以没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();   <span class="comment">// 空初始化列表， 执行zero初始化,  所以初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);  <span class="comment">// 非空初始化列表， 执行值初始化， 所以初始化为3</span></span><br><span class="line"><span class="comment">// 注：对于没有构造函数的内置类型，new会不会初始化在于有没有初始列表（空列表“()”也算）</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];     <span class="comment">// 分配大小为sizeof(int)*100;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p5 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"><span class="keyword">double</span> *p6 = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p><strong>new和malloc的区别：</strong></p>
<ol>
<li><p>new是一个运算符，malloc()是一个库函数。</p>
</li>
<li><p>new会调用构造函数，而malloc()不会。</p>
</li>
<li><p>new返回指定类型的指针，而malloc()返回void*。</p>
</li>
<li><p>new会自动计算需要分配的空间，而malloc()需要手工计算字节数。</p>
</li>
<li><p>new可以被重载，而malloc()不能。<br><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> [] p2;</span><br><span class="line"><span class="built_in">free</span>(p3);</span><br><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>delete和free的区别：</strong></p>
<ol>
<li><p>delete是一个运算符，free()是一个库函数。</p>
</li>
<li><p>delete会调用析构函数，而free()不会。</p>
</li>
<li><p>delete可以被重载，而free()不能。</p>
</li>
</ol>
<p><br><br><br><br></p>
<h3 id="总结：">总结：</h3><p>malloc和free是C/C++中的标准库函数，new和delete是C++的运算符。对于非内置数据类型的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之命名空间]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-namespace/"/>
    <id>http://yoursite.com/2014/07/25/cpp-namespace/</id>
    <published>2014-07-25T10:34:52.000Z</published>
    <updated>2015-05-09T18:17:13.366Z</updated>
    <content type="html"><![CDATA[<p>在C++中，<strong>命名空间（namespace）</strong>的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个<strong>全局命名空间（global namespace）</strong>，全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用<code>::member</code>的形式表示）。</p>
<h3 id="定义命名空间">定义命名空间</h3><p><strong>1、每个命名空间都是一个作用域</strong><br><a id="more"></a><br>和其他作用域类似，在命名空间中的每个名字必须表示唯一实体，而在不同命名空间中，可以有相同名字的成员。</p>
<p><strong>2、命名空间可以是不连续的</strong></p>
<p>命名空间可以定义在几个不同的部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;</span><br><span class="line">    <span class="comment">/* …… */</span></span><br><span class="line">&#125;   <span class="comment">// 命名空间作用域后面无须分号</span></span><br></pre></td></tr></table></figure></p>
<p>如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间添加一些新的成员。</p>
<p><strong>3、命名空间是可以嵌套的</strong></p>
<p>嵌套的命名空间是指定义在其他命名空间中的命名空间。嵌套的命名空间是一个嵌套的作用域，内层命名空间声明的名字将隐藏外层命名空间声明的同名成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">namespace</span> outer &#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> inner &#123;</span><br><span class="line">		<span class="keyword">int</span> z = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; outer::inner::z;  <span class="comment">// 输出10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，通常我们不把#include头文件放在命名空间内部。</p>
<p><strong>4、未命名的命名空间</strong></p>
<p><strong>未命名的命名空间（unnamed namespace）</strong>是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。在标准C++引入命名空间的概念之前，程序需要将名字声明成<code>static</code>以使其对于整个文件有效，但是，现在在文件中进行静态声明的做法已经被C++标准取消了，取而代之的是使用<strong>未命名的命名空间</strong>。</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。也就是说，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。<em>另外，由于未命名的命名空间它没有名字，所以其中定义的名字的作用域与该命名空间所在的作用域相同</em>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;   <span class="comment">// i的全局声明</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">10</span>;  <span class="comment">// 错误，二义性</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> local &#123;</span><br><span class="line">    <span class="keyword">namespace</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">local::i = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="使用命名空间">使用命名空间</h3><p>对命名空间中成员的引用，需要使用命名空间的作用域运算符<strong>(::)</strong>。但是，像<code>namespace_name::member_name</code>这样使用命名空间的成员非常烦琐，我们需要使用一些其他的更简便的方法。</p>
<p><strong>1、命名空间的别名</strong></p>
<p>有些命名空间的名字很长或者命名空间嵌套了很多层，我们可以为其设定一个较短的同义词，也就是别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cln = cpluslus_learning_namespace;</span><br><span class="line"><span class="keyword">namespace</span> Qlib = outer::inner::QueryLib;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、using声明</strong></p>
<p>一条<strong>using声明（using declaration）</strong>语句一次只引入命名空间的一个成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::[命名空间名::……]成员名;   <span class="comment">// 例如 using OLib::List;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3、using指示</strong></p>
<p><strong>using指示（using directive）</strong>和using声明不同的地方是，我们无法控制哪些名字是可见的，因为using指示会使得某个特定的命名空间中所有的名字都可见：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   <span class="comment">// 引入命名空间std</span></span><br></pre></td></tr></table></figure></p>
<p>使用命名空间主要是为了防止名字冲突，如果随意使用using指示注入命名空间的所有名字，将重新引入名字冲突的问题。另外，<strong>using声明和using指示在作用域上有区别</strong>：using声明是将一个成员引入当前命名空间作用域内；using指示是将所有成员引入当前和上一层命名空间作用域内：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;    <span class="comment">// 命名空间</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">16</span>, j=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;   <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> nsp;   <span class="comment">// 如果使用j，将在::j和nsp::j之间产生冲突</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; j;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将using指示<code>using namespace nsp;</code>改成using声明<code>using nsp::j;</code>则会正确输出15。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C++中，<strong>命名空间（namespace）</strong>的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个<strong>全局命名空间（global namespace）</strong>，全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用<code>::member</code>的形式表示）。</p>
<h3 id="定义命名空间">定义命名空间</h3><p><strong>1、每个命名空间都是一个作用域</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之模板特例化]]></title>
    <link href="http://yoursite.com/2014/07/23/cpp-template-specialization/"/>
    <id>http://yoursite.com/2014/07/23/cpp-template-specialization/</id>
    <published>2014-07-22T16:19:13.000Z</published>
    <updated>2015-05-09T18:14:35.042Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/blog/2014/07/18/c-plus-plus-xue-xi-zhi-han-shu-mo-ban-yu-lei-mo-ban/" target="_blank" rel="external">模板</a>是C++中一个很重要的特性，写一份代码能用于多种数据类型（包括用户自定义类型）。例如，STL的sort()函数可以用于多种数据类型的排序，类stack可以用作多种数据类型的栈。但是，<strong>如果我们想对特定的数据类型执行不同的代码（而不是通用模板）呢？</strong>这种情况下就可以使用<strong>模板特例化（template specialization）</strong>。</p>
<h3 id="函数模板特例化">函数模板特例化</h3><a id="more"></a>
<p>当特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。使用关键字template后跟一个空尖括号&lt;&gt;，即<code>template &lt;&gt;</code>，以指出我们正在特例化一个模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The main template fun(): "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;   <span class="comment">// 对int型特例化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Specialized template for int type: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	fun&lt;<span class="keyword">char</span>&gt;(<span class="string">'a'</span>);</span><br><span class="line">	fun&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">	fun&lt;<span class="keyword">float</span>&gt;(<span class="number">9.15</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">The</span> main <span class="keyword">template</span> fun(): a</span><br><span class="line"><span class="type">Specialized</span> <span class="keyword">template</span> <span class="keyword">for</span> <span class="type">int</span> <span class="keyword">type</span>: <span class="number">10</span></span><br><span class="line"><span class="type">The</span> main <span class="keyword">template</span> fun(): <span class="number">9</span>.<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<p>对于除int型外的其他数据类型，都会调用通用版本的函数模板<code>fun(T a)</code>；对于int型，则会调用特例化版本的<code>fun(int a)</code>。注意，<strong>一个特例化版本的本质是一个实例</strong>，而非函数的重载。因此，特例化不影响函数匹配。</p>
<h3 id="类模板特例化">类模板特例化</h3><p>除了特例化函数模板，我们还可以<strong>特例化类模板</strong>。下面是一个简单的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"General template object"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">// 对int型特例化</span></span><br><span class="line"><span class="keyword">class</span> Test&lt;<span class="keyword">int</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Specialized template object"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Test&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	Test&lt;<span class="keyword">char</span>&gt; b;</span><br><span class="line">	Test&lt;<span class="keyword">float</span>&gt; c;</span><br><span class="line">	a.print();</span><br><span class="line">	b.print();</span><br><span class="line">	c.print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Specialized</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br><span class="line"><span class="type">General</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br><span class="line"><span class="type">General</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br></pre></td></tr></table></figure></p>
<p>另外，与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，这种叫做类模板的<strong>偏特化</strong> 或 <strong>部分特例化（partial specialization）</strong>。例如，C++标准库中的类vector的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Allocator&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在vector这个例子中，一个参数被绑定到bool类型，而另一个参数仍未绑定需要由用户指定。注意，一个类模板的部分特例化版本仍然是一个模板，因为使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/blog/2014/07/18/c-plus-plus-xue-xi-zhi-han-shu-mo-ban-yu-lei-mo-ban/">模板</a>是C++中一个很重要的特性，写一份代码能用于多种数据类型（包括用户自定义类型）。例如，STL的sort()函数可以用于多种数据类型的排序，类stack可以用作多种数据类型的栈。但是，<strong>如果我们想对特定的数据类型执行不同的代码（而不是通用模板）呢？</strong>这种情况下就可以使用<strong>模板特例化（template specialization）</strong>。</p>
<h3 id="函数模板特例化">函数模板特例化</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之可变参数的函数与模板]]></title>
    <link href="http://yoursite.com/2014/07/22/cpp-changeable-parameter/"/>
    <id>http://yoursite.com/2014/07/22/cpp-changeable-parameter/</id>
    <published>2014-07-22T08:12:24.000Z</published>
    <updated>2015-05-09T18:10:49.174Z</updated>
    <content type="html"><![CDATA[<p>所谓<strong>可变参数</strong>指的是函数的参数个数可变，参数类型不定的函数。为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，我们可以编写<strong>可变参数模板</strong>。另外，C++还有一种特殊的<strong>省略符形参</strong>，可以用它传递可变数量的实参，不过这种一般只用于与C函数交互的接口程序。</p>
<h3 id="可变参数函数">可变参数函数</h3><a id="more"></a>
<p> <strong>1、initializer_list形参</strong></p>
<p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参（C++11新标准）。和vector一样，initializer_list也是一种模板类型。下面看看initializer_list提供的一些操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;initializer_list&gt;  <span class="comment">// 头文件</span></span></span><br><span class="line">initializer_list&lt;T&gt; lst;    <span class="comment">// 默认初始化，T类型元素的空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;; <span class="comment">// 初始化为初始值列表的副本</span></span><br><span class="line">lst2(lst)     <span class="comment">// 拷贝或赋值不会拷贝列表中的元素；拷贝后，</span></span><br><span class="line">lst2 = lst    <span class="comment">// 原始列表和副本共享元素</span></span><br><span class="line">lst.size()    <span class="comment">// 列表中的元素数量</span></span><br><span class="line">lst.begin()   <span class="comment">// 返回指向lst中首元素的指针</span></span><br><span class="line">lst.end()     <span class="comment">// 返回指向lst中尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure></p>
<p>下面给出一个例子，需要注意的是，含有initializer_list形参的函数也可以同时拥有其他形参。另外，如果想给initializer_list形参传递一个实参的序列，必须把序列<strong>放在一对花括号内</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="built_in">string</span>&gt; li)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">("")</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> beg=li.begin(); beg!=li.end(); ++beg)</span><br><span class="line">		str += *beg;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; func(&#123;<span class="string">"This"</span>,<span class="string">" "</span>,<span class="string">"is"</span>,<span class="string">" "</span>,<span class="string">"C++"</span>&#125;) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>2、省略符形参</strong></p>
<p>函数可以用省略符形参”…”表示不定参数部分，省略符形参只能出现在形参列表的最后一个位置，它的形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="comment">// 典型例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>省略符形参应该仅仅用于C和C++通用的类型</strong>，因为大多数类类型的对象在传递给省略符形参时都无法正确拷贝。下面是<strong>&lt; cstdarg &gt;</strong>头文件中的几个宏定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdarg&gt;  <span class="comment">// C中是&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// va_list是一种数据类型，args用于持有可变参数。</span></span><br><span class="line"><span class="comment">// 定义typedef char* va_list;</span></span><br><span class="line">va_list args;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用va_start并传入两个参数：第一个参数为va_list类型的变量</span></span><br><span class="line"><span class="comment">// 第二个参数为"..."前最后一个参数名</span></span><br><span class="line"><span class="comment">// 将args初始化为指向第一个参数（可变参数列表）</span></span><br><span class="line">va_start(args, paramN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索参数，va_arg的第一个参数是va_list变量，第二个参数指定返回值的类型</span></span><br><span class="line"><span class="comment">// 每一次调用va_arg会获取当前的参数，并自动更新指向下一个可变参数。</span></span><br><span class="line">va_arg(args,type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放va_list变量</span></span><br><span class="line">va_end(args);</span><br></pre></td></tr></table></figure></p>
<p>下面给出一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_nums</span><span class="params">(<span class="keyword">int</span> count,...)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	va_list args;</span><br><span class="line">	va_start(args, count);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; ++i)</span><br><span class="line">		result += va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; add_nums(<span class="number">4</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器是将参数压入栈中进行传递的。传递实参的时候，编译器会从实参列表中，按从右到左的顺序将参数入栈，对于add_nums(4, 25, 25, 50, 50)的调用，则入栈的顺序是 50, 50, 25, 25, 4 (注意没有可变参数与不可变参数之分)。由于栈的地址是从高到低的，所以在知道了第一个参数地址和参数的类型之后，就可以获取各个参数的地址。<br><br></p>
<h3 id="可变参数模板">可变参数模板</h3><p>一个<strong>可变参数模板（variadic template）</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包（parameter packet）</strong>。存在两种参数包：<strong>模板参数包</strong>（表示零个或多个模板参数）和<strong>函数参数包</strong>（表示零个或多个函数参数）。</p>
<p>上述说到我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数，但是所有实参必须具有相同的类型。当我们既不知道要处理的实参数目也不知道它们的类型时，我们就需要使用可变参数的函数模板了。我们用一个<strong>省略号</strong>来指出一个模板参数或函数参数表示一个包：<em>在一个模板参数列表中，<code>class...</code>或<code>typename...</code>指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;...rest)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可变参数函数模板通常是递归的。第一步调用处理包中的第一个实参，然后用剩余的实参调用自身。<strong>为了终止递归，我们还需要定义一个非可变参数的函数模板</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并处理包中最后一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;...rest)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;     <span class="comment">// 打印第一个实参</span></span><br><span class="line">	print(rest...);       <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	print(<span class="string">"string1"</span>, <span class="number">2</span>, <span class="number">3.14f</span>, <span class="string">"string2"</span>, <span class="number">42</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非可变参数版本的<code>print</code>负责终止递归并打印初始调用中的最后一个实参。对于最后一次递归调用<code>print(42)</code>，两个<code>print</code>版本都是可行的。但是，非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。<br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓<strong>可变参数</strong>指的是函数的参数个数可变，参数类型不定的函数。为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，我们可以编写<strong>可变参数模板</strong>。另外，C++还有一种特殊的<strong>省略符形参</strong>，可以用它传递可变数量的实参，不过这种一般只用于与C函数交互的接口程序。</p>
<h3 id="可变参数函数">可变参数函数</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之函数模板与类模板]]></title>
    <link href="http://yoursite.com/2014/07/18/cpp-template/"/>
    <id>http://yoursite.com/2014/07/18/cpp-template/</id>
    <published>2014-07-18T10:58:57.000Z</published>
    <updated>2015-05-09T18:06:44.265Z</updated>
    <content type="html"><![CDATA[<p><strong>泛型编程（Generic Programming）</strong>是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。</p>
<p><strong>模板（template）</strong>是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。<br><a id="more"></a></p>
<h3 id="函数模板">函数模板</h3><p>一个通用的<strong>函数模板（function template）</strong>就是一个公式，可用来生成针对特定类型或特定值的函数版本。模板定义以<strong>关键字template</strong>开始，后面跟一个<strong>模板参数列表</strong>，列表中的多个<strong>模板参数（template parameter）</strong>以逗号分隔。模板参数表示在类或函数定义中用到的类型或值。</p>
<p><strong>1、类型参数</strong></p>
<p>一个模板<strong>类型参数（type parameter）</strong>表示的是一种类型。我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数前必须使用关键字<strong>class</strong> 或 <strong>typename</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// typename和class一样的</span></span><br><span class="line"><span class="function">T <span class="title">function</span><span class="params">(T* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T tmp = *p;   <span class="comment">// 临时变量类型为T</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;   <span class="comment">// 返回值类型为T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键字typename和class是一样的作用，但显然typename比class更为直观，它更清楚地指出随后的名字是一个类型名。</p>
<p>编译器用模板类型实参为我们<strong>实例化（instantiate）</strong>特定版本的函数，一个版本称做模板的一个<strong>实例（instantiation）</strong>。当我们调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参。当然如果函数没有模板类型的参数，则我们需要特别指出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; function(&amp;a) &lt;&lt; endl;     <span class="comment">// 编译器根据函数实参推断模板实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; function&lt;<span class="keyword">int</span>&gt;(&amp;a) &lt;&lt; endl;   <span class="comment">// &lt;int&gt;指出模板参数为int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、非类型参数</strong></p>
<p>在模板中还可以定义<strong>非类型参数（nontype parameter）</strong>，一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> M, <span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; M+N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>* C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; C &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">char</span> (&amp;R)[<span class="number">9</span>]&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">void</span> (*f)(<span class="keyword">const</span> <span class="keyword">char</span>*)&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	f(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">9</span>] = <span class="string">"template"</span>;   <span class="comment">// 全局变量，具有静态生存期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	add&lt;<span class="number">10</span>, <span class="number">20</span>&gt;();</span><br><span class="line">	func1&lt;arr&gt;(<span class="string">"pointer"</span>);</span><br><span class="line">	func2&lt;arr&gt;(<span class="string">"reference"</span>);</span><br><span class="line">	func3&lt;print&gt;(<span class="string">"template function pointer"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代。一个非类型参数可以是一个整型，或者是一个指向对象或函数的指针或引用：绑定到整形（非类型参数）的实参必须是一个<strong>常量表达式</strong>，绑定到指针或引用（非类型参数）的实参必须具有<strong>静态的生存期</strong>（比如全局变量），不能把<strong>普通局部变量</strong> 或 <strong>动态对象</strong>绑定到指针或引用的非类型形参。<br><br></p>
<h3 id="类模板">类模板</h3><p>相应的，<strong>类模板（class template）</strong>是用来生成类的蓝图。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，所以我们必须<strong>显式</strong>的提供模板实参。与函数模板一样，类模板参数可以是<strong>类型参数</strong>，也可以是<strong>非类型参数</strong>，这里就不再赘述了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Array(T arr[], <span class="keyword">int</span> s);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *ptr;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板外部定义成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::Array(T arr[], <span class="keyword">int</span> s)</span><br><span class="line">&#123;</span><br><span class="line">	ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">	size = s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">		ptr[i]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; *(ptr+i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">5</span>] = &#123;<span class="string">'J'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>&#125;;</span><br><span class="line">	Array&lt;<span class="keyword">char</span>&gt; charArr(a, <span class="number">5</span>);</span><br><span class="line">	charArr.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArr(b, <span class="number">5</span>);</span><br><span class="line">	intArr.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板的成员函数</strong></p>
<p>与其他类一样，我们既可以在类模板内部，也可以在类模板外部定义其成员函数。定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">return_type class_name&lt;T&gt;::member_name(parm-<span class="built_in">list</span>) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，对于一个实例化了的类模板，其成员函数只有在使用时才被实例化。如果一个成员函数没有被使用，则它不会被实例化。</p>
<p><strong>类模板和友元</strong></p>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板的友元，则友元被授权可以访问所有模板的实例。如果友元自身是模板，类可以授权给所有友元模板的实例，也可以只授权给特定实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Pal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;C&gt;;  <span class="comment">// 用类C实例化的Pal是C的一个友元</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; <span class="comment">//Pal2所有实例都是C的友元;无须前置声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> C2 &#123;</span><br><span class="line">	<span class="comment">// C2的每个实例将用相同类型实例化的Pal声明为友元,一对一关系</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;T&gt;;</span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; </span><br><span class="line">	<span class="comment">// Pal3是普通非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板的static成员</strong></p>
<p>类模板可以声明static成员。<strong>类模板的每一个实例都有其自己独有的static成员对象</strong>，对于给定的类型X，所有class_name&lt; X &gt;类型的对象共享相同的一份static成员实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//...其他操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i;  <span class="comment">// 静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Foo&lt;T&gt;::i = <span class="number">10</span>;  <span class="comment">// 初始化为10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Foo&lt;<span class="keyword">int</span>&gt; f1;</span><br><span class="line">	Foo&lt;<span class="keyword">int</span>&gt; f2;</span><br><span class="line">	Foo&lt;<span class="keyword">float</span>&gt; f3;</span><br><span class="line">	f1.print();   <span class="comment">// 输出11</span></span><br><span class="line">	f2.print();   <span class="comment">// 输出12</span></span><br><span class="line">	f3.print();   <span class="comment">// 输出11</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过类类型对象来访问一个类模板的static对象，也可以使用作用域运算符（::）直接访问静态成员。类似模板类的其他成员函数，一个static成员函数也只有在使用时才会实例化。</p>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>泛型编程（Generic Programming）</strong>是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。</p>
<p><strong>模板（template）</strong>是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之多重继承与虚继承]]></title>
    <link href="http://yoursite.com/2014/07/17/cpp-inheritance/"/>
    <id>http://yoursite.com/2014/07/17/cpp-inheritance/</id>
    <published>2014-07-17T12:22:31.000Z</published>
    <updated>2015-05-09T18:03:42.863Z</updated>
    <content type="html"><![CDATA[<h3 id="多重继承">多重继承</h3><p>我们知道，在单继承中，派生类的对象中包含了<strong>基类部分</strong> 和 <strong>派生类自定义部分</strong>。同样的，在<strong>多重继承（multiple inheritance）</strong>关系中，派生类的对象包含了每个基类的子对象和自定义成员的子对象。下面是一个多重继承关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> B&#123; <span class="comment">/*  */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C继承了A，派生类D又继承了B和C，如图所示，一个D对象中含有一个B部分、一个C部分（其中又含有一个A部分）以及在D中声明的非静态数据成员：<a id="more"></a><br><img src="http://img.blog.csdn.net/20140717181313546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>构造与析构：</strong></p>
<p>构造一个派生类对象将首先构造它的所有基类子对象，其中基类的构造顺序与派生列表中基类的出现顺序保持一致，即B -&gt; A -&gt; C -&gt; D。<br>销毁一个派生类对象的顺序正好与其创建的顺序相反，即析构函数的调用顺序正好与构造函数相反，即D -&gt; C -&gt; A -&gt; B。注意派生类的析构函数只负责清除派生类本身分配的资源（析构函数体），派生类的成员及基类都是<strong>自动销毁</strong>的（隐式析构阶段）。</p>
<p><strong>类型转换：</strong></p>
<p>在多重继承的情况下，可以令某个可访问基类的指针或引用直接指向一个派生类对象。编译器不会在派生类向基类的几种转换中进行比较和选择，在它看来转换到任意一种基类都一样好。<br><br></p>
<h3 id="虚继承">虚继承</h3><p>尽管在派生列表中不允许同一个基类出现两次，但实际上派生类可以多次继承同一个类。<br><img src="http://img.blog.csdn.net/20140717200257421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>派生类通常会含有继承链上每个类对应的子部分。<strong>在上面的两种情况中，class D都间接地继承了class A两次，那么意味着class D中包含了class A的两份拷贝。所以在一个class D的对象中将含有2组class A的成员，此时若不加前缀限定符直接使用某个成员将引发“二义性”错误</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():str(<span class="string">"name"</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	d.str = <span class="string">"songlee"</span>;  <span class="comment">// 错误：对成员‘str’的请求有歧义</span></span><br><span class="line">	d.print();  <span class="comment">// 错误：对成员‘print’的请求有歧义</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然你可以使用作用域<code>d.B::str = &quot;songlee&quot;;</code>和<code>d.B::print();</code>来规避“二义性”错误，但这并没有从根本上解决问题。</p>
<p>为了解决上述问题，C++提供了<strong>虚继承（virtual inheritance）</strong>的机制。虚继承的目的是令某个类作出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>。在这种机制下，不论虚基类在继承体系中出现多少次，在派生类中都只包含唯一一个共享的虚基类子对象。<strong>我们指定虚基类的方式是在派生列表中添加关键字virtual：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():str(<span class="string">"name"</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;   <span class="comment">// 虚继承，A为虚基类</span></span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;   <span class="comment">// 关键字public和virtual的顺序随意</span></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	d.str = <span class="string">"songlee"</span>;   <span class="comment">// 正确</span></span><br><span class="line">	d.print();           <span class="comment">// 正确</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在派生列表中添加virtual（关键字public和virtual的顺序随意）指定A为虚基类，B和C将共享A的同一份实例，这样在D的对象中也将只有A的唯一一份实例，所以A的成员可以被直接访问，并且不会产生二义性。</p>
<p>虚继承最典型的应用是iostream继承于istream和ostream，而istream和ostream虚继承于ios：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> istream : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> ostream : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> iostream : <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><strong>注意：</strong></p>
<ol>
<li>支持向基类的常规类型转换。也就是说即使基类是虚基类，也能通过基类的指针或引用操作派生类的对象。</li>
<li>虚继承只是解决了一个派生类对象中存在同一个基类的多份拷贝的问题，并没有解决多个基类存在同名成员的二义性问题。</li>
<li>在虚继承中，虚基类是由最低层的派生类负责初始化的。如上例中，当创建一个D对象时，D位于派生的最低层并由它负责初始化共享的A基类部分。</li>
<li>含有虚基类的对象的构造顺序与一般的多重继承的构造顺序稍有区别：先初始化虚基类子对象（最低层派生类负责），然后按派生列表中的顺序依次对直接基类（非虚）进行初始化。</li>
<li>析构的顺序与构造的顺序正好相反。</li>
</ol>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多重继承">多重继承</h3><p>我们知道，在单继承中，派生类的对象中包含了<strong>基类部分</strong> 和 <strong>派生类自定义部分</strong>。同样的，在<strong>多重继承（multiple inheritance）</strong>关系中，派生类的对象包含了每个基类的子对象和自定义成员的子对象。下面是一个多重继承关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> B&#123; <span class="comment">/*  */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C继承了A，派生类D又继承了B和C，如图所示，一个D对象中含有一个B部分、一个C部分（其中又含有一个A部分）以及在D中声明的非静态数据成员：]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之虚函数与纯虚函数]]></title>
    <link href="http://yoursite.com/2014/07/17/cpp-virtual-function/"/>
    <id>http://yoursite.com/2014/07/17/cpp-virtual-function/</id>
    <published>2014-07-16T16:15:07.000Z</published>
    <updated>2015-05-09T17:58:56.994Z</updated>
    <content type="html"><![CDATA[<p>面向对象程序设计（object-oriented programming）的核心思想是<strong><em>数据抽象、继承、动态绑定。</em></strong>通过数据抽象，可以使类的接口与实现分离，使用继承，可以更容易地定义与其他类相似但不完全相同的新类，使用动态绑定，可以在一定程度上忽略相似类的区别，而以统一的方式使用它们的对象。</p>
<p><strong>虚函数</strong>的作用是实现<strong>多态性（Polymorphism）</strong>，多态性是将接口与实现进行分离，采用共同的方法，但因个体差异而采用不同的策略。<strong>纯虚函数</strong>则是一种特殊的虚函数。<em>虚函数联系到多态，多态联系到继承。所以本文中都是在继承层次上做文章。没了继承，什么都没得谈。</em><br><a id="more"></a></p>
<h3 id="虚函数">虚函数</h3><p>1 . <strong>定义</strong></p>
<p>在C++中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通过在函数之前加上virtual关键字将其定义为<strong>虚函数（virtual）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base&#123;  <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive_Class : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;  <span class="comment">// 默认也为虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当我们在派生类中覆盖某个函数时，可以在函数前加virtual关键字。然而这不是必须的，<strong>因为一旦某个函数被声明成虚函数，则所有派生类中它都是虚函数</strong>。任何构造函数之外的非静态函数都可以是虚函数。派生类经常（但不总是）覆盖它继承的虚函数，如果派生类没有覆盖其基类中某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>2 . <strong>动态绑定</strong></p>
<p> 当我们使用基类的引用（或指针）调用一个虚函数时将发生<strong>动态绑定（dynamic binding）</strong>。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，可能是基类中的版本也可能是派生类中的版本，判断的依据是引用（或指针）所绑定的对象的真实类型。与非虚函数在编译时绑定不同，虚函数是在运行时选择函数的版本，所以动态绑定也叫<strong>运行时绑定（run-time binding）</strong>。</p>
<p>3 . <strong>静态类型与动态类型</strong></p>
<p> <strong>静态类型</strong>指的是变量声明时的类型或表达式生成的类型，它在编译时总是已知的；<strong>动态类型</strong>指的是变量或表达式表示的内存中的对象的类型，它直到运行时才可知。当且仅当通过基类的指针或引用调用虚函数时，才会在运行时解析该调用，<strong>也只有在这种情况下对象的动态类型才有可能与静态类型不同</strong>。如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>4 . <strong>final和override</strong></p>
<p> 派生类中如果定义了一个函数与基类中虚函数同名但形参列表不同，编译器会认为这是派生类新定义的函数。如果我们的意图本是覆盖虚函数，则这种错误很难发现。通过在派生类中的虚函数最后加<strong>override关键字</strong>使得意图更加清晰。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报错。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base&#123;  <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive_Class : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> override</span>;  <span class="comment">// 报错，没有覆盖虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果我们定义一个类，并不希望它被继承。或者希望某个函数不被覆盖，则可以把类或者函数指定为<strong>final</strong>，则之后任何尝试继承该类或覆盖该函数的操作将引发错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base final &#123; <span class="comment">/*   */</span> &#125;;     <span class="comment">// 基类不能被继承</span></span><br><span class="line"><span class="keyword">class</span> Derive_Class : <span class="keyword">public</span> Base &#123; <span class="comment">/*  */</span> &#125;;     <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;   <span class="comment">// 不允许后续的其他类覆盖func(int)</span></span><br></pre></td></tr></table></figure></p>
<p>5 . <strong>回避虚函数的机制</strong></p>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。可以使用<strong>作用域运算符</strong>实现这一目的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强行调用基类中定义的函数版本而不管baseP的动态类型是什么</span></span><br><span class="line"><span class="keyword">int</span> a = baseP-&gt;Base::func(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<p> 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。</p>
<h3 id="纯虚函数">纯虚函数</h3><p>1 . <strong>定义</strong></p>
<p>为了方便使用多态特性，我们常常需要在基类中定义虚函数。在许多情况下，在基类中不能对虚函数给出有意义的实现。为了让虚函数在基类什么也不做，引进了“纯虚函数”的概念，使函数无须定义。<em>我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为<strong>纯虚函数（pure virtual）</strong>。</em>其中，=0只能出现在类内部的虚函数声明语句处：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base&#123;  <span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。</p>
<p>2 . <strong>抽象基类</strong></p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类叫<strong>抽象基类（abstract base class）</strong>。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象基类。因为抽象基类含有纯虚函数（没有定义），所以<strong>我们不能创建一个抽象基类的对象</strong>，但可以声明指向抽象基类的指针或引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base base;   <span class="comment">// 错误，不能实例化抽象基类</span></span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h3 id="总结：">总结：</h3><ol>
<li>虚函数必须实现，不实现编译器会报错。</li>
<li>父类和子类都有各自的虚函数版本。由多态方式在运行时动态绑定。</li>
<li>通过作用域运算符可以强行调用指定的虚函数版本。</li>
<li>纯虚函数声明如下：<code>virtual void funtion()=0;</code> 纯虚函数无需定义。包含纯虚函数的类是抽象基类，抽象基类不能创建对象，但可以声明指向抽象基类的指针或引用。</li>
<li>派生类实现了纯虚函数以后，该纯虚函数在派生类中就变成了虚函数，其子类可以再对该函数进行覆盖。</li>
<li>析构函数通常应该是虚函数，这样就能确保在析构时调用正确的析构函数版本。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象程序设计（object-oriented programming）的核心思想是<strong><em>数据抽象、继承、动态绑定。</em></strong>通过数据抽象，可以使类的接口与实现分离，使用继承，可以更容易地定义与其他类相似但不完全相同的新类，使用动态绑定，可以在一定程度上忽略相似类的区别，而以统一的方式使用它们的对象。</p>
<p><strong>虚函数</strong>的作用是实现<strong>多态性（Polymorphism）</strong>，多态性是将接口与实现进行分离，采用共同的方法，但因个体差异而采用不同的策略。<strong>纯虚函数</strong>则是一种特殊的虚函数。<em>虚函数联系到多态，多态联系到继承。所以本文中都是在继承层次上做文章。没了继承，什么都没得谈。</em><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之继承中的访问控制]]></title>
    <link href="http://yoursite.com/2014/07/16/cpp-access-control/"/>
    <id>http://yoursite.com/2014/07/16/cpp-access-control/</id>
    <published>2014-07-16T05:16:59.000Z</published>
    <updated>2015-05-09T17:57:02.013Z</updated>
    <content type="html"><![CDATA[<p>我们通常认为一个类有两种不同的用户：<strong>普通用户</strong> 和 <strong>类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。如果进一步考虑继承的话就会出现第三种用户，即<strong>派生类</strong>。派生类可以访问基类的公有（public）成员和受保护（protected）成员，但不能访问基类的私有（private）成员。<br><a id="more"></a><br>继承相关点：</p>
<ul>
<li>大多数类都只继承自一个类，这种形式的继承叫做<strong>“单继承”</strong>。本文主要讲的是单继承。</li>
<li>一个派生类的对象中，包含继承自基类的部分和派生类自定义的部分。正因为派生类含有基类部分，所以可以进行<strong>派生类到基类的类型转换</strong>，这种转换是隐式的。</li>
<li>不存在从基类向派生类的隐式类型转换。</li>
<li>派生类向基类的自动类型转换只对指针或引用有效，对象之间不存在类型转换。</li>
<li>如果基类定义了静态成员，则不论派生出多少个派生类，每个静态成员都只存在唯一实例。</li>
<li>防止一个类被继承可以使用关键字final，这时C++11新标准中提供的。</li>
<li>继承中的<a href="http://songlee24.github.io/blog/2014/07/16/c-plus-plus-xue-xi-zhi-xu-han-shu-yu-chun-xu-han-shu/" target="_blank" rel="external">虚函数与纯虚函数</a>（见文章）。<br><br><br></li>
</ul>
<h3 id="公有、私有和受保护成员">公有、私有和受保护成员</h3><p><strong>1 . 访问说明符</strong></p>
<p>在C++中通过使用访问说明符<strong>public、protected、private</strong>来对类的成员进行访问控制，控制成员对于普通用户或派生类来说是否可访问：</p>
<ul>
<li><p><strong>public</strong>：定义为public的成员对普通用户、类的实现者、派生类都是可访问的。public通常用于定义类的外部接口。</p>
</li>
<li><p><strong>protected</strong>：定义protected成员的目的是让派生类可以访问而禁止其他用户访问。所以类的实现者和派生类可以访问，而普通用户不能访问。</p>
</li>
<li><p><strong>private</strong>：定义为private的成员只能被类的实现者（成员和友元）访问。private部分通常用于封装（即隐藏）类的实现细节。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> People&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(Student &amp;s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(People &amp;p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，可以通过派生类对象访问基类的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Student &amp;s)</span></span>&#123; s.name=<span class="string">"Songlee"</span>; <span class="built_in">cout</span>&lt;&lt; s.name &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// 错误，不能通过基类对象访问基类的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(People &amp;p)</span></span>&#123; p.name=<span class="string">"Songlee"</span>; <span class="built_in">cout</span>&lt;&lt; p.name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，派生类的成员或友元只能通过<strong>派生类对象</strong>来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p><strong>2 . 改变成员的可访问性</strong></p>
<p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using</strong>声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> People&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> People::name;  <span class="comment">// 将继承来的name成员的访问权限改为public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Student me;</span><br><span class="line">	me.name = <span class="string">"SongLee"</span>;     <span class="comment">// 可以访问name了</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; me.name &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何<strong>可访问成员</strong>（非私有成员）标记出来，改变其访问权限。</p>
<h3 id="公有、私有和受保护继承">公有、私有和受保护继承</h3><p>我们注意到，在类的<strong>派生列表</strong>中用到了访问说明符public、protected和private，它们分别表示不同的继承方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> B &#123; <span class="comment">/*  */</span> &#125;;     <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">private</span> B &#123; <span class="comment">/*  */</span> &#125;;    <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">protected</span> B &#123; <span class="comment">/*  */</span> &#125;;  <span class="comment">// 受保护继承</span></span><br></pre></td></tr></table></figure></p>
<p>派生类的派生列表中的访问说明符<strong>对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响</strong>。派生类的成员（及友元）对基类成员的访问权限只与基类中的访问说明符有关。</p>
<p>那么派生列表中的访问说明符有什么作用呢？<br><strong>派生列表中访问说明符的作用</strong>是<em>控制派生类<strong>用户</strong>对于基类成员的访问权限</em>，注意是派生类的用户。下面给出不同的继承方式导致的访问权限的变化：</p>
<ul>
<li><p><strong>public继承</strong>：如果继承是公有的，则成员将遵循其原有的访问说明符。父类中的public、protected和private属性在子类中不发生改变。</p>
</li>
<li><p><strong>protected继承</strong>：比protected级别高的访问权限会变成protected。即父类中的public属性在子类中变为protected，父类中的protected和private属性在子类中不变。</p>
</li>
<li><p><strong>private继承</strong>：比private级别高的访问权限会变成private。即父类中的三种访问属性在子类中都会变成private。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;   <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> A_public;      <span class="comment">// 公有成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> A_protected;   <span class="comment">// 受保护成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">private</span> A &#123;    <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123; A_public=<span class="string">"public"</span>; A_protected=<span class="string">"protected"</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	B b;   <span class="comment">// 通过B的对象访问</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.A_public &lt;&lt;<span class="string">" "</span>&lt;&lt; b.A_protected &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在派生列表中不使用访问说明符，则struct关键字默认的是公有继承，class关键字默认的是私有继承。不过建议在继承时最好显式地将访问说明符写出来。<br><br><br><br>另外，不同的继承方式也会影响派生类向基类的转换，假定Derive继承自Base：</p>
<ul>
<li><p>只有当Derive公有地继承自Base时，用户代码才能使用派生类向基类的转换；如果Derive继承Base的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>
</li>
<li><p>不论Derive以什么方式继承Base，Derive的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</p>
</li>
<li><p>如果Derive继承Base的方式是公有的或者受保护的，则Derive的派生类的成员和友元可以使用Derive向Base的类型转换；反之，如果Derive继承Base的方式是私有的，则不能使用。<br><br><br></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们通常认为一个类有两种不同的用户：<strong>普通用户</strong> 和 <strong>类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。如果进一步考虑继承的话就会出现第三种用户，即<strong>派生类</strong>。派生类可以访问基类的公有（public）成员和受保护（protected）成员，但不能访问基类的私有（private）成员。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++与C的那些差异]]></title>
    <link href="http://yoursite.com/2014/07/06/difference-between-c-and-cpp/"/>
    <id>http://yoursite.com/2014/07/06/difference-between-c-and-cpp/</id>
    <published>2014-07-06T10:27:21.000Z</published>
    <updated>2015-05-09T17:52:03.555Z</updated>
    <content type="html"><![CDATA[<p>虽说C++是向后兼容C的，但C++与C还是存在许多差异。这里举了几个例子，也是我们很容易忽略的地方。如果你还知道其他的更多的Differences，或者发现什么错误，可以评论告诉我，大家一起学习进步。另外，随着学习的进行，本文会持续更新……</p>
<p><strong>C编译通过但C++编译不通过</strong><br><a id="more"></a><br><strong>1、C++中编译器不允许在一个函数声明之前调用它，但C中编译器是允许的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   foo();     <span class="comment">// foo()在它的声明/定义之前被调用</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、C++中不能用一个普通指针指向一个常量，但C中可以。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> j = <span class="number">20</span>;  </span><br><span class="line">    <span class="comment">/* C++编译会报错，C中编译会有warning，但可以通过 */</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;j; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*ptr: %d\n"</span>, *ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、在C语言中，void指针可以直接赋给其他类型的指针，如int*, char*等。但在C++中，void指针必须要明确地进行类型转换。（malloc函数返回值为void *类型）</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vptr;</span><br><span class="line">    <span class="keyword">int</span> *iptr = vptr; <span class="comment">// C++中必须用int *iptr = (int *)vptr;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>C和C++输出结果不相同</strong></p>
<p><strong>4、字符常量在C和C++被当作不同地类型看待：在C中，字符常量如’a’,’b’被当作int型，而在C++中被当作char型。所以，在C中sizeof(‘A’)相当于sizeof(int)，输出为4；在C++中sizeof(‘A’)仍相当于sizeof(char)，输出为1。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(<span class="string">'a'</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5、在C中定义结构体必须使用<code>struct</code>关键字，但在C++中可以省略。在C++中局部变量会覆盖同名的全局变量，但在C中却不会。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> T &#123; <span class="keyword">double</span> x; &#125;; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(T));  <span class="comment">// C输出4，C++输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>6、布尔结果在C++和C中的表示是不同的。因为C语言不直接支持布尔型，所以其实返回的是int型，而C++则返回的是bool类型。所以</strong>sizeof(1==1)<strong>在C中是sizeof(int)，在C++中是sizeof(bool)。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="number">1</span>==<span class="number">1</span>));  <span class="comment">// C输出4，C++输出1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽说C++是向后兼容C的，但C++与C还是存在许多差异。这里举了几个例子，也是我们很容易忽略的地方。如果你还知道其他的更多的Differences，或者发现什么错误，可以评论告诉我，大家一起学习进步。另外，随着学习的进行，本文会持续更新……</p>
<p><strong>C编译通过但C++编译不通过</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之extern关键字]]></title>
    <link href="http://yoursite.com/2014/07/05/C-extern-C/"/>
    <id>http://yoursite.com/2014/07/05/C-extern-C/</id>
    <published>2014-07-05T14:08:05.000Z</published>
    <updated>2015-05-09T17:45:24.885Z</updated>
    <content type="html"><![CDATA[<p>我们知道，extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。另外，extern还可以与”C”连用，作为链接指示。</p>
<h3 id="C++名字修饰（Name_Mangling）">C++名字修饰（Name Mangling）</h3><a id="more"></a>
<p>这就要从C++的重载说起了，在C++中<strong>函数重载</strong>指的是几个函数的函数名相同，参数列表不同。那么当生成obj中间文件/目标文件的时候，C++编译器如何区分这几个重载函数呢？——<strong>通过把原函数名与参数信息结合，产生一个独特的内部名字</strong>，这种技术叫做<a href="http://zh.wikipedia.org/zh/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">名字修饰</a>（Name Mangling）。名字修饰规则没有一个标准，所以不同的编译器的名字修饰规则也不一样。</p>
<p>下面是一组函数，其中f()函数重载了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">f</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">f</span> <span class="params">(<span class="keyword">int</span>)</span>  </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">int</span> i = f(), j = f(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>f(void)和f(int)是不同的函数，除了函数名相同以外没有任何关系。当生成obj目标文件时，为了区分它们，C++编译器根据参数信息进行了名字修饰：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  __f_v (<span class="keyword">void</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">int</span>  __f_i (<span class="keyword">int</span>)  &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> __g_v (<span class="keyword">void</span>) &#123; <span class="keyword">int</span> i = __f_v(), j = __f_i(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意g()也被名字修饰了，虽然没有任何名字冲突。名字修饰应用于C++的任何符号。</p>
<h3 id="为什么要使用extern_“C”？">为什么要使用extern “C”？</h3><p>C语言中没有名字修饰，因为C语言不支持函数重载。但是如果C++中含有C代码，在编译时C++编译器对C代码的函数也会进行名字修饰，函数名变了以后，将导致在C运行库中找不到对应函数，发生链接错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下面的代码保存为.cpp文件，并用C++编译器编译</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GeeksforGeeks"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccQBO9Im.o：在函数‘main’中：</span><br><span class="line">test<span class="class">.cpp</span>:(.text+<span class="number">0</span>xf)：对‘<span class="function"><span class="title">printf</span><span class="params">(char const*, ...)</span></span>’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>为了防止C++编译器对C代码进行名字修饰，我们将C代码用<strong>extern “C”</strong>进行链接指定，<strong>告诉编译器，在生成中间文件时，不要对这部分代码进行名字修饰，而是生成符合C规则的中间符号名。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello!"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加了extern “C”链接指示后，上面的代码就能够正常运行了。<br><br><br><br><br><strong>附</strong>：所有的C风格的头文件（stdio.h, string.h, … 等等）都有在extern “C”下声明，形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Declarations of this file */</span></span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们知道，extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。另外，extern还可以与”C”连用，作为链接指示。</p>
<h3 id="C++名字修饰（Name_Mangling）">C++名字修饰（Name Mangling）</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深度优先搜索的实现]]></title>
    <link href="http://yoursite.com/2014/07/04/depth-first-search/"/>
    <id>http://yoursite.com/2014/07/04/depth-first-search/</id>
    <published>2014-07-04T03:53:09.000Z</published>
    <updated>2015-05-09T17:41:24.830Z</updated>
    <content type="html"><![CDATA[<p>图的遍历是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：广度优先搜索（Breadth-First-Search）和深度优先搜索（Depth-First-Search）。</p>
<h3 id="深度优先搜索（DFS）的算法思想">深度优先搜索（DFS）的算法思想</h3><a id="more"></a>
<p>深度优先搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。它的基本思想就是：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<p><img src="http://img.blog.csdn.net/20140704111631015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，从顶点2开始深度优先遍历图，结果为：2，0，1，3。</p>
<h3 id="DFS算法实现">DFS算法实现</h3><p>和<a href="http://songlee24.github.io/2014/07/03/breadth-first-search/" target="_blank" rel="external">广度优先搜索</a>一样，为了防止顶点被多次访问，需要使用一个访问标记数组visited[]来标记顶点是否已经被访问过。</p>
<p>这里使用邻接表表示图。对于一个<strong>有向图</strong>，<strong>假设从给定顶点可以访问到图的所有其他顶点</strong>，则DFS递归算法的C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: DFS.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年07月04日 星期五 10时38分26秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图 */</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;                               <span class="comment">// 顶点数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                      <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>; <span class="comment">// 从顶点v深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                        <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;          <span class="comment">// 向图中添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;                     <span class="comment">// 从v开始深度优先遍历图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);                 <span class="comment">// 将w添加到v的链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从v开始深度优先遍历 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::DFSUtil(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 访问顶点v并输出</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=adj[v].begin(); i!=adj[v].end(); ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[*i])              <span class="comment">// 若邻接点尚未访问</span></span><br><span class="line">			DFSUtil(*i, visited);     <span class="comment">// 递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对图进行深度优先遍历，调用递归函数DFSUtil() */</span></span><br><span class="line"><span class="keyword">void</span> Graph::DFS(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设从给定顶点v可以到达图的所有顶点</span></span><br><span class="line">	DFSUtil(v, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(4)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Depth First Traversal (starting from vertex 2) \n"</span>;</span><br><span class="line">	g.DFS(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是假设从给定顶点可以访问到图的所有其他顶点。<strong>如果没有这个假设，为了对图作一个完整的深度优先遍历，我们需要对每个顶点调用DFSUtil()</strong>。当然那之前需要先检查顶点是否已经访问过。所以我们只需要修改<strong>DFS()</strong>函数部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::DFS()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对每个顶点调用DFSUtil()，从0开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			DFSUtil(i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<strong>无向图</strong>的深度优先搜索，只是邻接表不一样，其他的都是一样的。我们只需要修改addEdge(v, w)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">  adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">  adj[w].push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：图的邻接矩阵表示是唯一的，但对于邻接表来说，如果边的输入次序不同，生成的邻接表也不同。因此，对于同一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。</p>
<h3 id="DFS算法性能分析">DFS算法性能分析</h3><p>1 . <strong>空间复杂度</strong></p>
<p>DFS算法是一个递归算法，需要借助一个递归工作栈，故它的空间复杂度为O(|V|)。</p>
<p>2 . <strong>时间复杂度</strong></p>
<ul>
<li><p>当以<strong>邻接表</strong>存储时，时间复杂度为<strong>O(|V|+|E|)</strong>。</p>
</li>
<li><p>当以<strong>邻接矩阵</strong>存储时，时间复杂度为<strong>O(|V|^2)</strong>。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>图的遍历是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：广度优先搜索（Breadth-First-Search）和深度优先搜索（Depth-First-Search）。</p>
<h3 id="深度优先搜索（DFS）的算法思想">深度优先搜索（DFS）的算法思想</h3>]]>
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广度优先搜索的实现]]></title>
    <link href="http://yoursite.com/2014/07/03/breadth-first-search/"/>
    <id>http://yoursite.com/2014/07/03/breadth-first-search/</id>
    <published>2014-07-03T13:20:36.000Z</published>
    <updated>2015-05-09T17:36:47.414Z</updated>
    <content type="html"><![CDATA[<p><strong>图的遍历</strong>是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：<strong>广度优先搜索</strong>（Breadth-First-Search）和<strong>深度优先搜索</strong>（Depth-First-Search）。</p>
<h3 id="广度优先搜索（BFS）的算法思想">广度优先搜索（BFS）的算法思想</h3><a id="more"></a>
<p>广度优先搜索类似于二叉树的<strong>层序遍历</strong>，它的基本思想就是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，…，wi，然后再依次访问w1，w2，…，wi的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点……依次类推，直到图中所有顶点都被访问过为止。</p>
<p>广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此<strong>它不是一个递归的算法</strong>。为了实现逐层的访问，算法必须借助一个辅助队列，以记录正在访问的顶点的下一层顶点。</p>
<p><img src="http://img.blog.csdn.net/20140703195044578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，为一个有向图，从顶点2开始广度优先遍历整个图，可知结果为2，0，3，1。</p>
<h3 id="BFS算法实现">BFS算法实现</h3><p>与树相比，图的不同之处在于<strong>它存在回路/环</strong>，因此在遍历时一个顶点可能被访问多次。为了防止这种情况出现，我们使用一个访问标记数组visited[]来标记顶点是否已经被访问过。</p>
<p>在广度优先搜索一个图之前，我们首先要构造一个图，<strong>图的存储方式</strong>主要有两种：<strong>邻接矩阵、邻接表</strong>。这里我们使用邻接表来存储图：</p>
<p><img src="http://img.blog.csdn.net/20140703201818812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>简单起见，我们先假设从起始顶点可以达到其他所有顶点。</strong>以有向图为例，C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BFS.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年07月03日 星期四 18时37分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表存储有向图 */</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;                       <span class="comment">// 顶点的数量</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;              <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;  <span class="comment">// 向图中添加一条边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;             <span class="comment">// BFS遍历</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 构造函数 *****/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];      <span class="comment">// 初始化V条链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从顶点v出发广度优先搜索 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::BFSUtil(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// BFS辅助队列</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">queue</span>.push_back(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 出队</span></span><br><span class="line">		v = <span class="built_in">queue</span>.front();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测已出队的顶点s的所有邻接顶点</span></span><br><span class="line">		<span class="comment">// 若存在尚未访问的邻接点，访问它并压入队列</span></span><br><span class="line">		<span class="keyword">for</span>(i = adj[v].begin(); i!=adj[v].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 广度优先搜索 **/</span></span><br><span class="line"><span class="keyword">void</span> Graph::BFS(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化访问标记数组</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 假设从给定顶点可以到达图的所有顶点</span></span><br><span class="line">	BFSUtil(v, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建图</span></span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(4)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Following is BFS Traversal (starting from vertex 2) \n"</span>;</span><br><span class="line">	g.BFS(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是假设从起始顶点开始能够到达图的所有顶点。如果不能到达所有顶点，即存在多个连通分量呢？那么<strong>我们就要对每个连通分量都进行一次广度优先搜索</strong>。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEXT_NUM];   <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G)</span>        <span class="comment">// 设访问函数为visit()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;      <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)    <span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[i])          <span class="comment">// 对每个连通分量调用一次BFS</span></span><br><span class="line">			BFS(G,i);            <span class="comment">// Vi未访问过，从Vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSUtil</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	visit(v);                    <span class="comment">// 访问初始顶点</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;           <span class="comment">// v已访问</span></span><br><span class="line">	Enqueue(Q, v);               <span class="comment">// 顶点v入队列</span></span><br><span class="line">	<span class="keyword">while</span>(!isEmpty(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		Dequeue(Q, v);           <span class="comment">// 顶点v出队列</span></span><br><span class="line">		<span class="keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,v))</span><br><span class="line">			<span class="keyword">if</span>(!visited[w])      <span class="comment">// 检测v的所有邻接点</span></span><br><span class="line">			&#123;</span><br><span class="line">				visit(w);        <span class="comment">// 若w未访问，访问之</span></span><br><span class="line">				visited[w]=<span class="keyword">true</span>; <span class="comment">// 标记</span></span><br><span class="line">				Enqueue(Q, w);   <span class="comment">// 顶点w入队列</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据伪代码，相信不难写出对于多个连通分量的图的广度优先搜索，我们只需要修改<strong>BFS()</strong>函数部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::BFS()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化访问标记数组</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对每个连通分量调用一次BFSUtil()，从0号顶点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			BFSUtil(i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<strong>无向图</strong>的广度优先搜索，只是邻接表不一样，其他的都是一样的。我们只需要修改addEdge(v, w)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">	adj[w].push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BFS算法性能分析">BFS算法性能分析</h3><p>1 . <strong>空间复杂度</strong></p>
<p>无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点都需要入队一次，在最坏的情况下，空间复杂度为<strong>O(|V|)</strong>。</p>
<p>2 . <strong>时间复杂度</strong></p>
<ul>
<li><p>当采用<strong>邻接表</strong>存储时，每个顶点均需搜索一次，故时间复杂度为O(|V|)，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(|E|)，算法总的时间复杂度为<strong>O(|V|+|E|)</strong>。</p>
</li>
<li><p>当采用<strong>邻接矩阵</strong>存储时，查找每个顶点的邻接点所需的时间为O(|V|)，故算法总的时间复杂度为<strong>O(|V|^2)</strong>。</p>
</li>
</ul>
<p> <br><br><br><br><br><strong>注</strong>：广度优先搜索（BFS）算法思想有很多应用，比如Dijkstra单源最短路径算法和Prim最小生成树算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>图的遍历</strong>是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：<strong>广度优先搜索</strong>（Breadth-First-Search）和<strong>深度优先搜索</strong>（Depth-First-Search）。</p>
<h3 id="广度优先搜索（BFS）的算法思想">广度优先搜索（BFS）的算法思想</h3>]]>
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos2d-JS入门之2048游戏]]></title>
    <link href="http://yoursite.com/2014/06/30/cocos2d-js-2048/"/>
    <id>http://yoursite.com/2014/06/30/cocos2d-js-2048/</id>
    <published>2014-06-30T11:47:41.000Z</published>
    <updated>2015-05-09T17:28:30.194Z</updated>
    <content type="html"><![CDATA[<h3 id="介绍">介绍</h3><p><strong>Cocos2d-JS</strong>是Cocos2d-x的Javascript版本，它的前身是<strong>Cocos2d-html5</strong>。在3.0版本以前叫做Cocos2d-html5，从3.0版本开始叫做Cocos2d-JS。我们知道Cocos2d-x支持使用C++、Lua、Javascript来进行程序开发，其所内置的是一个Javascript引擎，通过用C++解析Javascript去执行；而Cocos2d-html5是使用Javascript进行开发，最终运行在浏览器里的。那么在v3.0的时候，Cocos2d-html5和Cocos2d-x JSBinding被合到了一起，称作<strong>Cocos2d-JS</strong>。<a id="more"></a></p>
<p><strong>和Cocos2d-html5不同的是</strong>，Cocos2d-JS开发的程序不仅可以运行在浏览器里，还可以编译运行在Mac OSX, Windows, iOS, Android的原生平台上，真正做到“一次开发，全平台运行”。Cocos2d-JS支持Cocos2d-x的所有特性并提供更简单易用的Javascript风格API，它还自带了Cocos Console，一个用于简化项目创建和不同目标平台编译发布流程的终端工具。</p>
<h3 id="Cocos2d-html5目录结构">Cocos2d-html5目录结构</h3><p>为了快速入门，所以决定开发一个最近比较热门的2048小游戏。当然，首先需要去<a href="http://www.cocos2d-x.org/download" target="_blank" rel="external">Cocos2d-x官网</a>下载Cocos2d-html5-v2.2.3引擎，下载后解压就行了。Cocos2d-html5的目录结构如下：</p>
<p><img src="http://img.blog.csdn.net/20140630200715781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ul>
<li>cocos2d：游戏引擎的主要文件</li>
<li>extensions：包含一些扩展的功能，且支持自定义扩展</li>
<li>external：包含box2d和chipmunk这两个物理引擎</li>
<li>HelloHTML5World：一个最简单的HelloWorld项目</li>
<li>samples：官网例子和几款小游戏</li>
<li>template：项目模板</li>
</ul>
<p>我们可以通过拷贝 HelloHTML5World 或 template中的项目模板，然后基于它编写自己的代码程序。</p>
<p>这里使用<strong>WebStorm</strong>作为IDE进行游戏开发，WebStorm有非常强大的智能补全功能，提高了开发效率。还能与 Google Chrome 浏览器配合，完成实时编辑和调试。只需要下载WebStorm然后载入引擎目录稍微配置一下就可以了，不知道怎么做的可以看看<a href="http://www.tairan.com/archives/4857" target="_blank" rel="external">快速搭建 Cocos2d-HTML5 开发调试环境</a>这篇博文。</p>
<h3 id="2048游戏开发">2048游戏开发</h3><p><strong>1、创建项目</strong></p>
<p>Cocos2d-html5中创建项目很简单，只需要拷贝HelloHTML5World项目（当然你也可以复制template下的文件夹），然后重命名就行了。</p>
<ul>
<li>res：资源文件夹（图片、音频等）</li>
<li>src：js脚本存放目录(我们自己的项目源码目录)</li>
<li>index.html：主页面</li>
<li>build.xml：文件的引用，包括引擎库文件和自己写的文件</li>
<li>cocos2d.js：定义了程序运行需要的一些参数，如 是否显示FPS，是否加载扩展库等</li>
<li>main.js：定义程序的入口，初始化导演类等等。</li>
</ul>
<p>我们需要在src文件夹里编写我们自己的代码，首先我们删除<strong>myApp.js</strong>中的所有代码，开始写我们自己的2048游戏。</p>
<p><strong>2、创建游戏场景</strong></p>
<p>由于2048游戏很简单，它只需要一个场景，下面我们来创建一个场景：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层</span></span><br><span class="line"><span class="keyword">var</span> Helloworld = cc.Layer.extend(&#123;</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景</span></span><br><span class="line"><span class="keyword">var</span> HelloWorldScene = cc.Scene.extend(&#123;</span><br><span class="line">    onEnter:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="keyword">var</span> layer = <span class="keyword">new</span> Helloworld();</span><br><span class="line">        layer.init();</span><br><span class="line">        <span class="keyword">this</span>.addChild(layer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>很简单吧！我们只需要创建一个<strong>Layer</strong>类，然后将它的一个实例加入<strong>Scene</strong>中，程序运行时main.js会创建一个Scene的实例作为程序入口。</p>
<p><strong>3、创建卡片类</strong></p>
<p>我们把2048游戏中的每一个方格看作一个卡片，上面的数字是它的属性。也就是说我们需要4x4=16个卡片类的对象。新建一个CardSprite.js文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CardSprite = cc.Layer.extend(&#123;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    number:<span class="number">0</span>,</span><br><span class="line">    labelCardNumber:<span class="literal">null</span>,</span><br><span class="line">    cardColorBG:<span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ctor:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 初始化卡牌</span></span><br><span class="line">    initCard:<span class="function"><span class="keyword">function</span><span class="params">(num, width, height, positionX, positionY)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = num;</span><br><span class="line">        <span class="comment">// 背景层，也就是一个小正方形</span></span><br><span class="line">        <span class="keyword">this</span>.cardColorBG = cc.LayerColor.create(<span class="keyword">new</span> cc.Color4B(<span class="number">200</span>, <span class="number">190</span>, <span class="number">180</span>, <span class="number">255</span>), width-<span class="number">15</span>, height-<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">this</span>.cardColorBG.setPosition(positionX, positionY);</span><br><span class="line">        <span class="comment">// 添加数字，大于0显示，否则不显示</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber = cc.LabelTTF.create(<span class="keyword">this</span>.number,<span class="string">"Arial"</span>, <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setPosition(<span class="keyword">this</span>.cardColorBG.getContentSize().width/<span class="number">2</span>, <span class="keyword">this</span>.cardColorBG.getContentSize().height/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setTag(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">this</span>.cardColorBG.addChild(<span class="keyword">this</span>.labelCardNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber = cc.LabelTTF.create(<span class="string">""</span>,<span class="string">"Arial"</span>, <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setPosition(<span class="keyword">this</span>.cardColorBG.getContentSize().width/<span class="number">2</span>, <span class="keyword">this</span>.cardColorBG.getContentSize().height/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setTag(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">this</span>.cardColorBG.addChild(<span class="keyword">this</span>.labelCardNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">this</span>.cardColorBG);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取数字</span></span><br><span class="line">    getNumber:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 重置卡片数字</span></span><br><span class="line">    setNumber:<span class="function"><span class="keyword">function</span><span class="params">(num)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = num;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setString(<span class="keyword">this</span>.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setString(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line">CardSprite.createCardSprite = <span class="function"><span class="keyword">function</span><span class="params">(num, width, height, positionX, positionY)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> card = <span class="keyword">new</span> CardSprite();</span><br><span class="line">    <span class="keyword">if</span>(card)</span><br><span class="line">    &#123;</span><br><span class="line">        card.initCard(num, width, height, positionX, positionY);</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将CardSprite类继承自Layer，然后初始化卡片背景和上面的数字，还定义了number的set/get方法。这里需要注意几点：</p>
<ul>
<li>新建.js文件以后需要在build.xml和cocos2d.js相关位置添加文件路径。</li>
<li>继承都需要有 <code>this._super();</code>，一般写在构造函数<code>ctor:function()</code>中。</li>
<li>注意静态函数的写法，<code>类名.函数名 = function(){}</code>。</li>
</ul>
<p><strong>4、初始化界面</strong></p>
<p>下面我们来初始化游戏界面，主要是在Layer的init()函数中初始化，我们使用一个4x4的二维组来放置在主界面创建16个卡片：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Helloworld = cc.Layer.extend(&#123;</span><br><span class="line">    cardArr:<span class="literal">null</span>,  <span class="comment">// 存放4x4=16个卡片</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    init:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="keyword">var</span> size = cc.Director.getInstance().getWinSize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主界面背景层-&gt;设置颜色</span></span><br><span class="line">        <span class="keyword">var</span> lazyLayer = cc.LayerColor.create(<span class="keyword">new</span> cc.Color4B(<span class="number">180</span>, <span class="number">170</span>, <span class="number">160</span>, <span class="number">255</span>) , <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.addChild(lazyLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建卡片数组</span></span><br><span class="line">        <span class="keyword">this</span>.cardArr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cardArr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化所有卡片，数字为0，不显示</span></span><br><span class="line">        <span class="keyword">this</span>.createCards(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始的时候，随机生成两个数字</span></span><br><span class="line">        <span class="keyword">this</span>.autoCreateCardNumber();</span><br><span class="line">        <span class="keyword">this</span>.autoCreateCardNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化卡片数组*******************************</span></span><br><span class="line">    createCards:<span class="function"><span class="keyword">function</span><span class="params">(size)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> unitSize = (size.height - <span class="number">80</span>)/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">var</span> card = CardSprite.createCardSprite(<span class="number">0</span>, unitSize, unitSize, unitSize*i + <span class="number">210</span>, unitSize*j + <span class="number">30</span>);</span><br><span class="line">                <span class="keyword">this</span>.cardArr[i][j] = card;</span><br><span class="line">                <span class="keyword">this</span>.addChild(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成新的2或4的卡片****************</span></span><br><span class="line">    autoCreateCardNumber:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">4</span>);  <span class="comment">// 随机生成0～3</span></span><br><span class="line">            <span class="keyword">var</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[i][j].getNumber() == <span class="number">0</span>) &#123;   </span><br><span class="line">                <span class="comment">// 4与2生成的概率比为1:9</span></span><br><span class="line">                <span class="keyword">this</span>.cardArr[i][j].setNumber(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) &lt; <span class="number">1</span> ? <span class="number">4</span> : <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.shouldCreateCardNumber()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否还有空位******************</span></span><br><span class="line">    shouldCreateCardNumber:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> should = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[i][j].getNumber() == <span class="number">0</span>) &#123;</span><br><span class="line">                    should = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> should;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>通过调用<code>this.createCards(size);</code>初始化所有16个卡片，由于0不显示，所以卡片上都没有数字。然后调用<code>this.autoCreateCardNumber();</code>在随机的两个卡片上生成数字，在随机生成的时候我们应该<strong>先判断还有没有空位</strong>，否则有可能会陷入死循环。<br>初始化的界面如下图：<br><img src="http://img.blog.csdn.net/20140701125010750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>5、定义手势动作</strong></p>
<p>我们需要通过触摸滑动来操作游戏，所以就需要定义上下左右的手势动作。这就要用到引擎的触摸响应机制，Cocos2d-html5与Cocos2d-x一样，有<strong>多点触控</strong> 和 <strong>单点触控</strong>。默认情况下是多点触控，要使用单点触控，我们要使用<code>addTargetedDelegate()</code>方法设置代理。<br>那么如何判断上下左右呢？当然是根据起始触摸点和结束触摸点的坐标变化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Helloworld = cc.Layer.extend(&#123;</span><br><span class="line">    firstX:<span class="literal">null</span>,</span><br><span class="line">    firstY:<span class="literal">null</span>,</span><br><span class="line">    cardArr:<span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    init:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="comment">// 设置单点触摸</span></span><br><span class="line">        cc.Director.getInstance().getTouchDispatcher()._addTargetedDelegate(<span class="keyword">this</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 打开触摸</span></span><br><span class="line">        <span class="keyword">this</span>.setTouchEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// onTouchBegan函数，需要返回true</span></span><br><span class="line">    onTouchBegan:<span class="function"><span class="keyword">function</span> <span class="params">(touch, event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> touchPoint = touch.getLocation();</span><br><span class="line">        <span class="keyword">this</span>.firstX = touchPoint.x;</span><br><span class="line">        <span class="keyword">this</span>.firstY = touchPoint.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// onTouchEnded函数</span></span><br><span class="line">    onTouchEnded:<span class="function"><span class="keyword">function</span> <span class="params">(touch, event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> touchPoint = touch.getLocation();</span><br><span class="line">        <span class="keyword">var</span> offsetX = <span class="keyword">this</span>.firstX - touchPoint.x;</span><br><span class="line">        <span class="keyword">var</span> offsetY = <span class="keyword">this</span>.firstY - touchPoint.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(offsetX) &gt; <span class="built_in">Math</span>.abs(offsetY)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(offsetX &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doLeft();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(offsetX &lt; -<span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doRight();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(offsetY &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doDown();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(offsetY &lt; -<span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doUp();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...other methods</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>6、卡片合并</strong></p>
<p>游戏2048主要玩法就是通过合并相同数字的卡片以达到2048。通过手势动作往一个方向进行合并。我们的思路就是根据手势方向，遍历每一行或每一列，将在这个方向上相邻（中间没有其他数字）且数字相同的卡片合并加倍。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上***************************************</span></span><br><span class="line">doUp:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y=<span class="number">3</span>; y&gt;=<span class="number">0</span>; --y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y1=y-<span class="number">1</span>; y1&gt;=<span class="number">0</span>; --y1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y1].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y1].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    ++y;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y1].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber(); </span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向下***************************************</span></span><br><span class="line">doDown:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y=<span class="number">0</span>; y&lt;<span class="number">4</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y1=y+<span class="number">1</span>; y1&lt;<span class="number">4</span>; ++y1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y1].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y1].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    --y;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y1].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber(); </span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向左***************************************</span></span><br><span class="line">doLeft:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> y=<span class="number">0</span>; y&lt;<span class="number">4</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x1=x+<span class="number">1</span>; x1&lt;<span class="number">4</span>; ++x1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x1][y].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x1][y].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    --x;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x1][y].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber();</span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向右***************************************</span></span><br><span class="line">doRight:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">3</span>; x &gt;= <span class="number">0</span>; --x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x1 = x - <span class="number">1</span>; x1 &gt;= <span class="number">0</span>; --x1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x1][y].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x1][y].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    ++x;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x1][y].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber(); </span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>7、添加分数</strong></p>
<p>添加两个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score:<span class="number">0</span>,  <span class="comment">// 分数</span></span><br><span class="line">scoreLabel:<span class="literal">null</span>,  <span class="comment">// 显示分数的控件</span></span><br></pre></td></tr></table></figure></p>
<p>然后初始化分数显示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示分数</span></span><br><span class="line"><span class="keyword">var</span> label = cc.LabelTTF.create(<span class="string">"Score : "</span>, <span class="string">"Arial"</span>, <span class="number">20</span>);</span><br><span class="line">label.setAnchorPoint(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">label.setPosition(size.width/<span class="number">2</span> - <span class="number">50</span>, size.height-<span class="number">50</span>);</span><br><span class="line"><span class="keyword">this</span>.addChild(label);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.scoreLabel = cc.LabelTTF.create(<span class="string">"0"</span>, <span class="string">"Arial"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">this</span>.scoreLabel.setAnchorPoint(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.scoreLabel.setPosition(size.width/<span class="number">2</span> + <span class="number">20</span>, size.height-<span class="number">50</span>);</span><br><span class="line"><span class="keyword">this</span>.addChild(<span class="keyword">this</span>.scoreLabel);</span><br></pre></td></tr></table></figure></p>
<p>卡片合并的时候要增加分数，然后更新分数显示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新分数 -&gt; this.setScore(this.score);</span></span><br><span class="line">setScore:<span class="function"><span class="keyword">function</span><span class="params">(s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.scoreLabel.setString(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>8、判断游戏结束和胜利</strong></p>
<p>每一次卡片合并操作后，我们都需要判断游戏是否胜利或者结束。利用五个条件判断游戏是否还能够继续：（1）还有空卡片 （2）还可以向右滑 （3）还可以向左滑 （4）还可以向上滑 （5）还可以向下滑。只要以上条件满足一个，游戏就可以再继续。否则，游戏不能再继续了。判断胜利则是看卡片中有没有数字达到2048。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断游戏是否结束*******************************</span></span><br><span class="line">doCheckGameOver:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> size = cc.Director.getInstance().getWinSize();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> isGameOver = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> y=<span class="number">0</span>; y&lt;<span class="number">4</span>; ++y)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="number">0</span> ||</span><br><span class="line">		    (x&gt;<span class="number">0</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x-<span class="number">1</span>][y].getNumber())) ||</span><br><span class="line">		    (x&lt;<span class="number">3</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x+<span class="number">1</span>][y].getNumber())) ||</span><br><span class="line">		    (y&gt;<span class="number">0</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y-<span class="number">1</span>].getNumber())) ||</span><br><span class="line">		    (y&lt;<span class="number">3</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y+<span class="number">1</span>].getNumber())))</span><br><span class="line">		&#123;</span><br><span class="line">		    isGameOver = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isGameOver)  &#123;     <span class="comment">// if the game is over</span></span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"The Game Is Over!"</span>);</span><br><span class="line">	    cc.Director.getInstance().replaceScene(cc.TransitionFade.create(<span class="number">1</span>, <span class="keyword">new</span> HelloWorldScene()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="keyword">this</span>.shouldCreateCardNumber()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.autoCreateCardNumber();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWin())  &#123;     <span class="comment">// if win</span></span><br><span class="line">	    cc.Director.getInstance().replaceScene(cc.TransitionFade.create(<span class="number">1</span>, <span class="keyword">new</span> HelloWorldScene()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否胜利**********************</span></span><br><span class="line">isWin:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> Win = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) &#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[i][j].getNumber() == <span class="number">2048</span>) &#123;</span><br><span class="line">		    Win = <span class="literal">true</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>9、界面优化</strong></p>
<p>在一个卡片里面，当数字变成两位数、三位数的时候，就需要调整一下数字的大小，在CardSprite的setNumber方法中添加代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数字大小</span></span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">55</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">128</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还需要给不同的数字设置不同的卡片颜色，同样在setNumber方法中添加代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数字的大小来调整颜色</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.number == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">200</span>,<span class="number">190</span>,<span class="number">180</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">230</span>,<span class="number">220</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">220</span>,<span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">180</span>,<span class="number">120</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">140</span>,<span class="number">90</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">120</span>,<span class="number">90</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">64</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">90</span>,<span class="number">60</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">90</span>,<span class="number">60</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">256</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">200</span>,<span class="number">70</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">512</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">200</span>,<span class="number">70</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">1024</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">0</span>,<span class="number">130</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">2048</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">0</span>,<span class="number">130</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>10、最终游戏截图</strong></p>
<p><img src="http://img.blog.csdn.net/20140701140423187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="结语">结语</h2><ul>
<li><p>2048源码：<a href="https://github.com/SongLee24/2048-js" target="_blank" rel="external">https://github.com/SongLee24/2048-js</a></p>
</li>
<li><p>在线试玩：<a href="http://2048m.sinaapp.com" target="_blank" rel="external">http://2048m.sinaapp.com</a> （新浪云）</p>
</li>
</ul>
<p>采用Cocos2D-HTML5引擎进行游戏开发，开发效率更高，加上丰富的工具集支持、实时的各种调试手段和云合作开发手段，更加直接的效果调校方式，完全没有开发环境依赖，各种优势的叠加，可以大幅度降低开发成本，提升游戏的上架速度。</p>
<p>如果觉得这样还不够，我们可以使用Cocos2d-JS-v3.0，同一份JavaScript游戏代码不用修改或者小范围修改，配合Cocos2D-X JavaScript-Binding就能以Hybrid的方式直接作为本地应用发布，也可以编译到Android、iOS等移动平台。</p>
<p>通过Cocos2D-HTML5或Cocos2d-JS，开发者能以一个更快、更惬意的方式实现自己的想法。</p>
<hr>
<p>参考：<a href="http://blog.csdn.net/column/details/love2048.html" target="_blank" rel="external">http://blog.csdn.net/column/details/love2048.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="介绍">介绍</h3><p><strong>Cocos2d-JS</strong>是Cocos2d-x的Javascript版本，它的前身是<strong>Cocos2d-html5</strong>。在3.0版本以前叫做Cocos2d-html5，从3.0版本开始叫做Cocos2d-JS。我们知道Cocos2d-x支持使用C++、Lua、Javascript来进行程序开发，其所内置的是一个Javascript引擎，通过用C++解析Javascript去执行；而Cocos2d-html5是使用Javascript进行开发，最终运行在浏览器里的。那么在v3.0的时候，Cocos2d-html5和Cocos2d-x JSBinding被合到了一起，称作<strong>Cocos2d-JS</strong>。]]>
    
    </summary>
    
      <category term="Cocos2dx" scheme="http://yoursite.com/tags/Cocos2dx/"/>
    
      <category term="应用-Cocos2dx" scheme="http://yoursite.com/categories/%E5%BA%94%E7%94%A8-Cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第K顺序统计量的求解]]></title>
    <link href="http://yoursite.com/2014/06/22/Kth-Order-Statistic/"/>
    <id>http://yoursite.com/2014/06/22/Kth-Order-Statistic/</id>
    <published>2014-06-22T14:33:20.000Z</published>
    <updated>2015-05-09T17:30:39.391Z</updated>
    <content type="html"><![CDATA[<p>一个n个元素组成的集合中，第K个<strong>顺序统计量（Order Statistic）</strong>指的是该集合中第K小的元素，我们要讨论的是如何在线性时间（linear time）里找出一个数组的第K个顺序统计量。</p>
<h3 id="问题描述">问题描述</h3><p><strong>问题</strong>：给定一个含有n个元素的无序数组，找出第k小的元素。</p>
<ul>
<li>k = 1 ：最小值</li>
<li>k = n ：最大值</li>
<li>k = ⌊(n+1)/2⌋ or ⌈(n+1)/2⌉ ：中位数</li>
</ul>
<a id="more"></a>
<p>找最大值或最小值很简单，只需要遍历一次数组并记录下最大值或最小值就可以了。我们在这里要解决的问题是一般性的选择问题。</p>
<p>一种原始的解决方案是，用堆排序或归并排序将输入数据进行排序，然后返回第k个元素。这样在Θ(nlgn)时间内一定可以解决。但是我们希望有更好的方案，最好是线性时间。</p>
<h3 id="期望线性时间的解决方案">期望线性时间的解决方案</h3><p>为了在线性时间内解决这个选择问题，我们使用一个随机的分治算法，即RANDOMIZED-SELECT算法。此算法是使用随机化的快速排序中的随机划分子程序，对输入数组进行随机划分操作，然后判断第k小元素在划分后的哪个区域，对所在区域进行递归划分，最后找到第k小元素。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A,p,q,i)  <span class="comment">// i-th smallest in A[p..q]</span></span><br><span class="line">	<span class="keyword">if</span> p = q</span><br><span class="line">		then <span class="keyword">return</span> A[p]</span><br><span class="line">	r = RANDOMIZED-PARTITION(A, p, q)</span><br><span class="line">	k = r-p+<span class="number">1</span>   <span class="comment">// A[r] is k-th smallest</span></span><br><span class="line">	<span class="keyword">if</span> i=k</span><br><span class="line">		then <span class="keyword">return</span> A[r]</span><br><span class="line">	<span class="keyword">if</span> i&lt;k</span><br><span class="line">		then <span class="keyword">return</span> RANDOMIZED-SELECT(A, p, r-<span class="number">1</span>, i)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		then <span class="keyword">return</span> RANDOMIZED-SELECT(A, r+<span class="number">1</span>, q, i-k)</span><br></pre></td></tr></table></figure></p>
<p>这里的RANDOMIZED-PARTITION()是随机版的划分操作（<a href="http://songlee24.github.io/blog/2014/06/21/kuai-su-pai-xu-de-xing-neng-fen-xi-yu-you-hua/" target="_blank" rel="external">快速排序的分析与优化</a>），可见本算法是一个随机算法，它的<strong>期望时间</strong>是Θ(n)（假设元素的值是不同的）。</p>
<p><strong>1、Lucky-Case</strong>：最好的情况是在正中划分，划分的右边和右边的元素数量相等，但是1/10和9/10的划分也几乎一样好。可以这么说，任何常数比例的划分都和1/2:1/2的划分一样好。这里以1/10和9/10的划分为例，算法运行时间递归式为<code>T(n) &lt;= T(9n/10) + Θ(n)</code>，根据主定理得到<code>T(n) &lt;= Θ(n)</code>。</p>
<p><strong>2、Unlucky-Case</strong>：虽然主元的选取是随机的，但是如果你运气足够差，每次都得到0：n-1的划分，这就是最坏的情况。此时递归式为<code>T(n) = T(n-1) + Θ(n)</code>，则时间复杂度为<code>T(n) = Θ(n^2)</code>。</p>
<p><strong>3、Expected-Time</strong>：期望运行时间为Θ(n)，即线性时间。这里就不证明了，证明需要用到指示器随机变量。</p>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: RandomizedSelect.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月22日 星期日 20时20分08秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=low+<span class="number">1</span>; j&lt;=high; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt;= pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			swap(A[i], A[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i], A[low]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Randomized_Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">int</span> i = rand() % (high+<span class="number">1</span>);</span><br><span class="line">	swap(A[low], A[i]);</span><br><span class="line">	<span class="keyword">return</span> Partition(A, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Randomized_Select</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> i)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p == q)</span><br><span class="line">		<span class="keyword">return</span> A[p];</span><br><span class="line">	<span class="keyword">int</span> r = Randomized_Partition(A, p, q);</span><br><span class="line">	<span class="keyword">int</span> k = r-p+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">		<span class="keyword">return</span> A[r];</span><br><span class="line">	<span class="keyword">if</span>(i &lt; k)</span><br><span class="line">		<span class="keyword">return</span> Randomized_Select(A, p, r-<span class="number">1</span>, i);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> Randomized_Select(A, r+<span class="number">1</span>, q, i-k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[] = &#123;<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">int</span> result = Randomized_Select(A, <span class="number">0</span>, <span class="number">7</span>, i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The "</span> &lt;&lt; i &lt;&lt; <span class="string">"th smallest element is "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最坏情况线性时间的解决方案">最坏情况线性时间的解决方案</h3><p>虽然最坏情况Θ(n^2)出现的概率非常非常小，但是不代表它不会出现。这里就介绍一个非同一般的算法，以保证在最坏情况下也能达到线性时间。</p>
<p>这个SELECT算法的基本思想就是要保证对数组的划分是一个好的划分，它通过自己的方法选取主元（pivot），然后将pivot作为参数传递给快速排序的确定性划分操作PARTITION。</p>
<p>基本步骤：</p>
<ol>
<li><p>将输入数组的n个元素划分为n/5（上取整）组，每组5个元素，且至多只有一个组有剩下的n%5个元素组成。</p>
</li>
<li><p>寻找每个组织中中位数。首先对每组中的元素（至多为5个）进行插入排序，然后从排序后的序列中选择出中位数。</p>
</li>
<li><p>对第2步中找出的n/5（上取整）个中位数，递归调用SELECT以找出其中位数x。（如果是偶数取下中位数）</p>
</li>
<li><p>调用PARTITION过程，按照中位数x对输入数组进行划分。确定中位数x的位置k。</p>
</li>
<li><p>如果i=k，则返回x。否则，如果i &lt; k，则在地区间递归调用SELECT以找出第i小的元素，若干i &gt; k，则在高区找第(i-k)个最小元素。</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20140622221504062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>总结</strong>：RANDOMIZED-SELECT和SELECT算法是基于比较的。我们知道，在比较模型中，排序时间不会优于Ω(nlgn)。之所以这里的选择算法达到了线性时间，是因为它们没有使用排序就解决了选择问题。另外，我们没有使用线性时间排序算法（计数排序/桶排序/基数排序），是因为它们要达到线性时间对输入有很高的要求，而这里不需要关于输入的任何假设。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个n个元素组成的集合中，第K个<strong>顺序统计量（Order Statistic）</strong>指的是该集合中第K小的元素，我们要讨论的是如何在线性时间（linear time）里找出一个数组的第K个顺序统计量。</p>
<h3 id="问题描述">问题描述</h3><p><strong>问题</strong>：给定一个含有n个元素的无序数组，找出第k小的元素。</p>
<ul>
<li>k = 1 ：最小值</li>
<li>k = n ：最大值</li>
<li>k = ⌊(n+1)/2⌋ or ⌈(n+1)/2⌉ ：中位数</li>
</ul>]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间的排序算法]]></title>
    <link href="http://yoursite.com/2014/06/22/linear-sorting-algorithms/"/>
    <id>http://yoursite.com/2014/06/22/linear-sorting-algorithms/</id>
    <published>2014-06-22T03:09:25.000Z</published>
    <updated>2015-05-09T17:20:43.918Z</updated>
    <content type="html"><![CDATA[<p>前面已经介绍了几种排序算法，像插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序（见我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/03/ge-chong-nei-bu-pai-xu-suan-fa-de-shi-xian/" target="_blank" rel="external">各种内部排序算法的实现</a>）等，这些排序算法都有一个共同的特点，就是基于比较。本文将介绍三种非比较的排序算法：计数排序，基数排序，桶排序。它们将突破比较排序的Ω(nlgn)下界，以线性时间运行。<a id="more"></a></p>
<h3 id="比较排序算法的时间下界">比较排序算法的时间下界</h3><p>所谓的<strong>比较排序</strong>是指通过比较来决定元素间的相对次序。</p>
<blockquote>
<p><strong>定理</strong>：对于含n个元素的一个输入序列，任何比较排序算法在最坏情况下，都需要做Ω(nlgn)次比较。</p>
</blockquote>
<p>也就是说，比较排序算法的运行速度不会快于nlgn，这就是基于比较的排序算法的<strong>时间下界</strong>。</p>
<p>通过<strong>决策树（Decision-Tree）</strong>可以证明这个定理，关于决策树的定义以及证明过程在这里就不赘述了。你可以自己去查找资料，推荐观看《<a href="http://v.163.com/movie/2010/12/7/V/M6UTT5U0I_M6V2TBK7V.html" target="_blank" rel="external">MIT公开课：线性时间排序</a>》。</p>
<p>根据上面的定理，我们知道任何比较排序算法的运行时间不会快于nlgn。那么我们是否可以突破这个限制呢？当然可以，接下来我们将介绍三种线性时间的排序算法，它们都不是通过比较来排序的，因此，下界Ω(nlgn)对它们不适用。</p>
<h3 id="计数排序（Counting_Sort）">计数排序（Counting Sort）</h3><p>计数排序的基本思想就是对每一个输入元素x，确定小于x的元素的个数，这样就可以把x直接放在它在最终输出数组的位置上，例如：</p>
<p><img src="http://img.blog.csdn.net/20140622105946593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>算法的步骤大致如下：</p>
<ul>
<li><p>找出待排序的数组中最大和最小的元素</p>
</li>
<li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p>
</li>
<li><p>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p>
</li>
<li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</li>
</ul>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: CountingSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月11日 星期三 00时08分55秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *计数排序：A和B为待排和目标数组，k为数组中最大值,len为数组长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C[k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k+<span class="number">1</span>; ++i)</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">        C[A[i]] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;k+<span class="number">1</span>; ++i)</span><br><span class="line">        C[i] = C[i] + C[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        B[C[A[i]]-<span class="number">1</span>] = A[i];</span><br><span class="line">        C[A[i]] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> origin[<span class="number">8</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">8</span>];</span><br><span class="line">    print(origin, <span class="number">8</span>);</span><br><span class="line">    CountingSort(origin, result, <span class="number">15</span>, <span class="number">8</span>);</span><br><span class="line">    print(result, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>当输入的元素是0到k之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)。</strong>当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。计数排序是一个稳定的排序算法。</p>
<p>可能你会发现，计数排序似乎饶了点弯子，比如当我们刚刚统计出C，C[i]可以表示A中值为i的元素的个数，此时我们直接顺序地扫描C，就可以求出排序后的结果。的确是这样，不过这种方法不再是计数排序，而是桶排序，确切地说，是桶排序的一种特殊情况。</p>
<h3 id="桶排序（Bucket_Sort）">桶排序（Bucket Sort）</h3><p>桶排序（Bucket Sort）的思想是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法）。当要被排序的数组内的数值是均匀分配的时候，桶排序可以以线性时间运行。桶排序过程动画演示：<a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="external">Bucket Sort</a>，桶排序原理图如下：</p>
<p><img src="http://img.blog.csdn.net/20140622110534328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BucketSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月11日 星期三 09时17分32秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 节点 */</span></span><br><span class="line"><span class="keyword">struct</span> node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> max, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    node bucket[len];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bucket[i].value = <span class="number">0</span>;</span><br><span class="line">        bucket[i].next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        node *ist = <span class="keyword">new</span> node();</span><br><span class="line">        ist-&gt;value = A[i];</span><br><span class="line">        ist-&gt;next = NULL;</span><br><span class="line">        <span class="keyword">int</span> idx = A[i]*len/(max+<span class="number">1</span>); <span class="comment">// 计算索引</span></span><br><span class="line">        <span class="keyword">if</span>(bucket[idx].next == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            bucket[idx].next = ist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 按大小顺序插入链表相应位置 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            node *p = &amp;bucket[idx];</span><br><span class="line">            node *q = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(q!=NULL &amp;&amp; q-&gt;value &lt;= A[i])</span><br><span class="line">            &#123;</span><br><span class="line">                p = q;</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ist-&gt;next = q;</span><br><span class="line">            p-&gt;next = ist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        node *p = bucket[i].next;</span><br><span class="line">        <span class="keyword">if</span>(p == NULL)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!= NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            A[count++] = p-&gt;value;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row[<span class="number">11</span>] = &#123;<span class="number">24</span>,<span class="number">37</span>,<span class="number">44</span>,<span class="number">12</span>,<span class="number">89</span>,<span class="number">93</span>,<span class="number">77</span>,<span class="number">61</span>,<span class="number">58</span>,<span class="number">3</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    print(row, <span class="number">11</span>);</span><br><span class="line">    BucketSort(row, <span class="number">235</span>, <span class="number">11</span>);</span><br><span class="line">    print(row, <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基数排序（Radix_Sort）">基数排序（Radix Sort）</h3><p>基数排序（Radix Sort）是一种非比较型排序算法，它将整数按位数切割成不同的数字，然后按每个位分别进行排序。基数排序的方式可以采用MSD（Most significant digital）或LSD（Least significant digital），MSD是从最高有效位开始排序，而LSD是从最低有效位开始排序。</p>
<p>当然我们可以采用MSD方式排序，按最高有效位进行排序，将最高有效位相同的放到一堆，然后再按下一个有效位对每个堆中的数递归地排序，最后再将结果合并起来。但是，这样会产生很多中间堆。所以，通常基数排序采用的是LSD方式。</p>
<p>LSD基数排序实现的基本思路是<strong>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</strong>需要注意的是，对每一个数位进行排序的算法必须是<strong>稳定</strong>的，否则就会取消前一次排序的结果。通常我们使用<code>计数排序</code>或者<code>桶排序</code>作为基数排序的辅助算法。基数排序过程动画演示：<a href="http://www.cs.usfca.edu/~galles/visualization/RadixSort.html" target="_blank" rel="external">Radix Sort</a></p>
<p><strong>C++实现（使用计数排序）</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: RadixSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月22日 星期日 12时04分37秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求num在n位上的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIt</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> power = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        power *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num % power) * <span class="number">10</span> / power;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序（使用计数排序作为辅助）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> C[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 计数数组</span></span><br><span class="line">		<span class="keyword">int</span> B[len];        <span class="comment">// 结果数组</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = findIt(A[j], i);</span><br><span class="line">			C[d] += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;<span class="number">10</span>; ++j)</span><br><span class="line">			C[j] = C[j] + C[j-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>; j&gt;=<span class="number">0</span>; --j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = findIt(A[j], i);</span><br><span class="line">			C[d] -= <span class="number">1</span>;</span><br><span class="line">			B[C[d]] = A[j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将B中排好序的拷贝到A中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; ++j)</span><br><span class="line">			A[j] = B[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">8</span>] = &#123;<span class="number">332</span>, <span class="number">653</span>, <span class="number">632</span>, <span class="number">5</span>, <span class="number">755</span>, <span class="number">433</span>, <span class="number">722</span>, <span class="number">48</span>&#125;;</span><br><span class="line">	print(A, <span class="number">8</span>);</span><br><span class="line">	RadixSort(A, <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">	print(A, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>基数排序的时间复杂度是 O(k·n)，其中n是排序元素个数，k是数字位数。</em></strong>注意这不是说这个时间复杂度一定优于O(nlgn)，因为n可能具有比较大的系数k。</p>
<p>另外，基数排序不仅可以对整数排序，也可以对有多个关键字域的记录进行排序。例如，根据三个关键字年、月、日来对日期进行排序。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面已经介绍了几种排序算法，像插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序（见我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/03/ge-chong-nei-bu-pai-xu-suan-fa-de-shi-xian/">各种内部排序算法的实现</a>）等，这些排序算法都有一个共同的特点，就是基于比较。本文将介绍三种非比较的排序算法：计数排序，基数排序，桶排序。它们将突破比较排序的Ω(nlgn)下界，以线性时间运行。]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速排序的分析与优化]]></title>
    <link href="http://yoursite.com/2014/06/21/quick-sort-analysis/"/>
    <id>http://yoursite.com/2014/06/21/quick-sort-analysis/</id>
    <published>2014-06-21T06:53:39.000Z</published>
    <updated>2015-05-09T17:13:57.590Z</updated>
    <content type="html"><![CDATA[<h3 id="快速排序的介绍">快速排序的介绍</h3><p>快速排序是一种排序算法，对包含n个数的输入数组，最坏的情况运行时间为<strong>Θ(n^2)</strong>[Θ读作theta]。虽然这个最坏情况的运行时间比较差，但快速排序通常是用于排序的最佳的实用选择。这是因为其平均情况下的性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，它还能够进行就地排序，在虚拟内存环境中也能很好的工作。</p>
<p>和归并排序一样，快速排序也是基于<strong>分治法</strong>（Divide and conquer）：<a id="more"></a></p>
<ul>
<li><strong>分解</strong>：数组A[p..r]被划分成两个(可能为空)的子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A[q]，A[q+1..r]中的每个元素都大于等于A[q]。这样元素A[q]就位于其最终位置上了。</li>
<li><strong>解决</strong>：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]排序。</li>
<li><strong>合并</strong>：因为两个子数组是就地排序，不需要合并，整个数组已有序。</li>
</ul>
<p><strong>伪代码</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	x = A[p]</span><br><span class="line">	<span class="tag">i</span> = <span class="tag">p</span></span><br><span class="line">	<span class="keyword">for</span> j=p+<span class="number">1</span> to r</span><br><span class="line">		do <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">			then <span class="tag">i</span> = i+<span class="number">1</span></span><br><span class="line">				 <span class="function"><span class="title">exchange</span><span class="params">(A[i],A[j])</span></span></span><br><span class="line">	<span class="function"><span class="title">exchange</span><span class="params">(A[p], A[i])</span></span></span><br><span class="line">	return i</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">QUICKSORT</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="tag">p</span> &lt; r</span><br><span class="line">		then <span class="tag">q</span> = <span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">			 <span class="function"><span class="title">QUICKSORT</span><span class="params">(A, p, q-<span class="number">1</span>)</span></span></span><br><span class="line">			 <span class="function"><span class="title">QUICKSORT</span><span class="params">(A, q+<span class="number">1</span>, r)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3><p><strong>1、最坏情况</strong></p>
<p>快速排序的最坏情况发生在当<strong>数组已经有序或者逆序排好</strong>的情况下。这样的话划分过程产生的两个区域中有一个没有元素，另一个包含n-1个元素。此时算法的运行时间可以递归地表示为：<code>T(n) = T(n-1)+T(0)+Θ(n)</code>，递归式的解为<code>T(n)=Θ(n^2)</code>。可以看出，快速排序算法最坏情况运行时间并不比插入排序的更好。</p>
<p><strong>2、最好情况</strong></p>
<p>如果我们足够幸运，在每次划分操作中做到最平衡的划分，即将数组划分为n/2:n/2。此时得到的递归式为<code>T(n) = 2T(n/2)+Θ(n)</code>，根据主定理的情况二可得<code>T(n)=Θ(nlgn)</code>。</p>
<p><strong>3、平均情况</strong></p>
<p>假设一：快排中的划分点非常偏斜，比如每次都将数组划分为1/10 : 9/10的两个子区域，这种情况下运行时间是多少呢？运行时间递归式为<code>T(n) = T(n/10)+T(9n/10)+Θ(n)</code>，使用递归树解得<code>T(n)=Θ(nlgn)</code>。可以看出，当划分点非常偏斜的时候，运行时间仍然是Θ(nlgn)。</p>
<p>假设二：Partition所产生的划分既有“好的”，也有“差的”，它们交替出现。这种平均情况下运行时间又是多少呢？这时的递归式为（G表示Good，B表示Bad）：</p>
<blockquote>
<p>G(n) = 2B(n/2) + Θ(n)</p>
<p>B(n) = G(n-1) + Θ(n)</p>
<p>解：G(n) = 2(G(n/2-1) + Θ(n/2)) + Θ(n) = 2G(n/2-1) + Θ(n) = Θ(nlgn)  </p>
</blockquote>
<p>可以看出，当好、差划分交替出现时，快排的运行时间就如全是好的划分一样，仍然是Θ(nlgn) 。</p>
<h3 id="快排的优化">快排的优化</h3><p>经过上面的分析可以知道，在输入有序或逆序时快速排序很慢，在其余情况则表现良好。如果输入本身已被排序，那么就糟了。那么我们如何确保对于所有输入，它均能够获得较好的平均情况性能呢？前面的快速排序我们默认使用数组中第一个元素作为主元。假设随机选择数组中的元素作为主元，则快排的运行时间将不依赖于输入序列的顺序。我们把<strong>随机选择主元</strong>的快速排序叫做Randomized Quicksort。</p>
<p>在随机化的快速排序中，我们不是始终选择第一个元素作为主元，而是从数组A[p…r]中随机选择一个元素，然后将其与第一个元素交换。由于主元元素是随机选择的，我们期望在平均情况下，对输入数组的划分能够比较对称。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">RANDOMIZED-PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="tag">i</span> = <span class="function"><span class="title">RANDOM</span><span class="params">(p, r)</span></span></span><br><span class="line">	<span class="function"><span class="title">exchange</span><span class="params">(A[p], A[i])</span></span></span><br><span class="line">	return <span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="tag">p</span> &lt; r</span><br><span class="line">		then <span class="tag">q</span> = <span class="function"><span class="title">RANDOMIZED-PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">			<span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, p, q-<span class="number">1</span>)</span></span></span><br><span class="line">			<span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, q+<span class="number">1</span>, r)</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们对3万个元素的有序序列分别进行<strong>传统的快速排序</strong> 和 <strong>随机化的快速排序</strong>，并比较它们的运行时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: QuickSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月21日 星期六 10时11分30秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;ctime&gt;  <span class="comment">// clock_t clock</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统划分操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=low+<span class="number">1</span>; j&lt;=high; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt;= pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			swap(A[i], A[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i], A[low]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机化划分操作，随机选择pivot</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_Random</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">int</span> i = rand() % (high+<span class="number">1</span>);</span><br><span class="line">	swap(A[low], A[i]);</span><br><span class="line">	<span class="keyword">return</span> Partition(A, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = Partition(A, low, high);</span><br><span class="line">		QuickSort(A, low, pos-<span class="number">1</span>);</span><br><span class="line">		QuickSort(A, pos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机化快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort_Random</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = Partition_Random(A, low, high);</span><br><span class="line">		QuickSort_Random(A, low, pos-<span class="number">1</span>);</span><br><span class="line">		QuickSort_Random(A, pos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	clock_t t1, t2;</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">30000</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; ++i)</span><br><span class="line">		A[i] = i+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">	t1 = clock();</span><br><span class="line">	QuickSort(A, <span class="number">0</span>, <span class="number">30000</span>-<span class="number">1</span>);</span><br><span class="line">	t1 = clock() - t1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Traditional quicksort took "</span>&lt;&lt; t1 &lt;&lt; <span class="string">" clicks(about "</span> &lt;&lt; ((<span class="keyword">float</span>)t1)/CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds)."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t2 = clock();</span><br><span class="line">	QuickSort_Random(A, <span class="number">0</span>, <span class="number">30000</span>-<span class="number">1</span>);</span><br><span class="line">	t2 = clock() - t2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Randomized quicksort took "</span>&lt;&lt; t2 &lt;&lt; <span class="string">" clicks(about "</span> &lt;&lt; ((<span class="keyword">float</span>)t2)/CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds)."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost ~]$ ./QuickSort </span><br><span class="line">Traditional quicksort took <span class="number">1210309</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">1.21031</span> seconds)</span></span>.</span><br><span class="line">Randomized quicksort took <span class="number">457573</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">0.457573</span> seconds)</span></span>.</span><br><span class="line">[songlee@localhost ~]$ ./QuickSort </span><br><span class="line">Traditional quicksort took <span class="number">1208038</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">1.20804</span> seconds)</span></span>.</span><br><span class="line">Randomized quicksort took <span class="number">644950</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">0.64495</span> seconds)</span></span>.</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看出，对于有序的输入，随机化版本的快速排序的效率会高很多。</p>
<h4 id="问题记录：">问题记录：</h4><p>我们知道交换两个变量的值有以下三种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = a;  <span class="comment">// 方法一</span></span><br><span class="line">a = b;</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a+b;  <span class="comment">// 方法二</span></span><br><span class="line">b = a-b;</span><br><span class="line">a = a-b;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;  <span class="comment">// 方法三</span></span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure>
<p>但是你会发现在本程序中，如果swap函数使用后面两种方法会出错。由于方法二和方法三没有使用中间变量，它们交换值的原理是直接对变量的内存单元进行操作。<strong>如果两个变量对应的同一内存单元，则经过两次加减或异或操作，内存单元的值已经变为了0，因而不能实现变量值交换</strong>。所以当需要交换值的变量可能是同一变量时，必须使用第三变量实现交换，否则会对变量清零。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="快速排序的介绍">快速排序的介绍</h3><p>快速排序是一种排序算法，对包含n个数的输入数组，最坏的情况运行时间为<strong>Θ(n^2)</strong>[Θ读作theta]。虽然这个最坏情况的运行时间比较差，但快速排序通常是用于排序的最佳的实用选择。这是因为其平均情况下的性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，它还能够进行就地排序，在虚拟内存环境中也能很好的工作。</p>
<p>和归并排序一样，快速排序也是基于<strong>分治法</strong>（Divide and conquer）：]]>
    
    </summary>
    
      <category term="快排" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵原地转置]]></title>
    <link href="http://yoursite.com/2014/04/09/matrix-transpose-inplace/"/>
    <id>http://yoursite.com/2014/04/09/matrix-transpose-inplace/</id>
    <published>2014-04-09T02:06:00.000Z</published>
    <updated>2015-05-09T17:09:52.322Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>微软面试题</strong>：将一个MxN的矩阵存储在一个一维数组中，编程实现矩阵的转置。</p>
<p><strong>要求</strong>：空间复杂度为O(1)<a id="more"></a></p>
<h3 id="思路分析">思路分析</h3><p>下面以一个4x2的矩阵A={1,2,3,4,5,6,7,8}进行分析，转置过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20140606173801500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>图中右下角的红色数字表示在一维数组中的下标。矩阵的转置其实就是数组中元素的移动，具体的移动过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20140606173842187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们发现，这些移动的元素的下标是一个个环，下标1的元素移动到4，下标4的元素移动到2，下标2的元素移动到1。在编写程序的时候，我们需要解决两个问题：第一个是如何判定环是否重复（已处理过）；第二个是如何计算当前元素下标的前驱与后继。</p>
<p><strong>第一个问题</strong>：如何判断环是重复已处理过的？因为我们遍历整个数组时下标是从小到大的，所以如果是第一次遍历该环，则第一个下标肯定是这个环中最小的。如果一个环被处理过，那么总能找到一个它的后继是小于它的。从上图可以明显看出来。</p>
<p><strong>第二个问题</strong>：如何计算当前元素下标的前驱与后继？假设转置前某个元素的数组下标为i，则它所在行列为（i/N, i%N），转置后所在行列则为（i%N, i/N），可计算转置后数组下标为<strong>(i%N)*M+i/N</strong>，此为i的<strong>后继</strong>。假设转置后某个元素的数组下标为i，则它所在行列为（i/M, i%M），则转置前所在行列为（i%M, i/M），可计算此时下标为<strong>(i%M)*N+i/M</strong>，此为i的<strong>前驱</strong>。</p>
<h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: matrix_transpose.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月06日 星期五 14时26分15秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后继 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%n)*m + i/n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前驱 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%m)*n + i/m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理以下标i为起点的环 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movedata</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = mtx[i];  <span class="comment">// 暂存</span></span><br><span class="line">    <span class="keyword">int</span> cur = i;       <span class="comment">// 当前下标</span></span><br><span class="line">    <span class="keyword">int</span> pre = getPre(cur, m, n);</span><br><span class="line">    <span class="keyword">while</span>(pre != i)</span><br><span class="line">    &#123;</span><br><span class="line">        mtx[cur] = mtx[pre];</span><br><span class="line">        cur = pre;</span><br><span class="line">        pre = getPre(cur, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    mtx[cur] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转置，即循环处理所有环 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> next = getNext(i, m, n);</span><br><span class="line">        <span class="keyword">while</span>(next &gt; i) <span class="comment">// 若存在后继小于i说明重复</span></span><br><span class="line">            next = getNext(next, m, n);</span><br><span class="line">        <span class="keyword">if</span>(next == i)   <span class="comment">// 处理当前环 </span></span><br><span class="line">            movedata(mtx, i, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出矩阵 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)%n == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mtx[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mtx[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[<span class="number">4</span>*<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before matrix transposition:"</span> &lt;&lt; endl;</span><br><span class="line">    print(matrix, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    transpose(matrix, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After matrix transposition:"</span> &lt;&lt; endl;</span><br><span class="line">    print(matrix, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://img.blog.csdn.net/20140606173940156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>微软面试题</strong>：将一个MxN的矩阵存储在一个一维数组中，编程实现矩阵的转置。</p>
<p><strong>要求</strong>：空间复杂度为O(1)]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[变位词问题]]></title>
    <link href="http://yoursite.com/2014/04/08/brother-word/"/>
    <id>http://yoursite.com/2014/04/08/brother-word/</id>
    <published>2014-04-08T13:10:46.000Z</published>
    <updated>2015-05-09T17:04:38.085Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》第二章提到了一个变位词问题，变位词指的是一个单词可以通过改变其他单词中字母的顺序来得到，也叫做兄弟单词，如army-&gt;mary。由变位词可以引申出几个算法问题，包括字符串包含问题，比较两个字符串是否是变位词，以及找出字典中变位词集合的问题。</p>
<h3 id="字符串包含问题">字符串包含问题</h3><p>(1) 问题描述：存在字符串1和字符串2，假设字符串2相对较短，如何快速地判定字符串2中的字符都存在于字符串1里（假定字符串只包含字母）？<a id="more"></a></p>
<p>(2) 举例：字符串1为ABCDEFGHIJK，字符串2为ABCDE，则字符串1包含字符串2，因为字符串2中包含的字母在字符串1中也都有。</p>
<p>(3) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>最直接的思路就是针对字符串2中的每个字符，轮询字符串1进行比较，看是否在字符串1里面。很明显这种的时间效率为<strong>O(n*m)</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;long_str.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(long_str[j] == short_str[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == long_str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEF"</span>;</span><br><span class="line">    Compare(l, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>这里由于假定了字符串只包含字母，所以我们可以用一个额外的数组flag[26]作为26个字符标识位，先遍历长字符串将对应的标识位置1，再遍历短字符串，如果对应的标示位都是1，则包含；否则不包含。<strong>这种方法的时间复杂度为O(n+m)，为了提高空间效率，这里不使用数组而使用26个bit位来作为标示位（bitset容器）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;26&gt; flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;long_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag.set(n)置第n位为1</span></span><br><span class="line">        flag.<span class="built_in">set</span>(long_str[i]-<span class="string">'A'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag.test(n)判断第n位是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(!flag.test(short_str[i]-<span class="string">'A'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEZ"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(l, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法还可以进行优化，例如如果长字串的前缀就为短字串，那么我们可以不需要n+m次，而只需要2m次。具体实现请自己思考。</p>
<ul>
<li><strong>思路三</strong></li>
</ul>
<p>给每个字母分配一个素数，从2开始到3，5，7…遍历长字串，求得每个字符对应素数的乘积。然后遍历短字串，判断该乘积能否被短字符串中的字符对应的素数整除，如果除的结果存在余数，则说明有不匹配的字母；如果整个过程都没有余数，则说明短字串中的字母在长字串里都有。<strong>这种方法的时间复杂度也是O(n+m)，需要26个额外空间存素数，但是这种方法有一个缺点就是需要跟大整数打交道，因为乘积可能非常大</strong>。（这里我们使用<cstdint>头文件中定义的int64_t和uint64_t）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;cstdint&gt;  // C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> primeNum[<span class="number">26</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,</span><br><span class="line">                        <span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="comment">/* int64_t和uint64_t分别表示64位的有符号和无符号整形数 */</span></span><br><span class="line">    <span class="comment">/* 在不同位数机器的平台下通用，都是64位 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> ch = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;long_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch*primeNum[long_str[i]-<span class="string">'A'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch%primeNum[short_str[i]-<span class="string">'A'</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEK"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(l, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cstdint></p>
<h3 id="比较两个字符串是否为变位词">比较两个字符串是否为变位词</h3><p>(1) 问题描述：如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，问如何在迅速匹配兄弟字符串（如，bad和adb就是兄弟字符串）。</p>
<p>(2) 注意：第一点中讨论了字符串包含问题，但是不要以为两个字符串互相包含就是（变位词）兄弟字符串了，例如aabcde和edcba互相包含，但它们不是变位词。</p>
<p>(3) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>给每个字母分配一个素数，可以通过判断两个字符串的素数乘积是否相等。跟上述素数法一样，时间复杂度也是O(n+m)，需要跟大整数打交道。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;cstdint&gt; // C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> primeNum[<span class="number">26</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,</span><br><span class="line">                        <span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="keyword">uint64_t</span> ch = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch*primeNum[s1[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s2.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch/primeNum[s2[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abandon"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"banadon"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(s1, s2))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They are brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They aren't brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>将两个字符串按照字母表顺序排序，看排序后的字符串是否相等，如果相等则是兄弟字符串（变位词）。这种方法的时间效率根据你使用的排序算法不同而不同。当然，你可以自己写排序算法，这里我们使用C++的STL中的sort()函数对字符串进行排序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义序函数（二元谓词）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 采用泛型算法对s1,s2排序，sort()采用的是快速排序算法</span></span><br><span class="line">    sort(s1.begin(), s1.end(), myfunction);</span><br><span class="line">    sort(s2.begin(), s2.end(), myfunction);</span><br><span class="line">    <span class="keyword">if</span>(!s1.compare(s2))  <span class="comment">// 相等返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abandon"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"banadon"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(s1, s2))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They are brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They aren't brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="字典找出所有变位词集合（重点）">字典找出所有变位词集合（重点）</h3><p>(1) 问题描述：给定一个英语字典，找出其中的所有变位词集合。</p>
<p>(2) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>对于这个问题，最快想到的最直接的方法就是针对每一个单词跟字典中的其他单词进行比较。然而，假设一次比较至少花费1微秒的时间，则拥有二十万单词的字典将花费：<strong>200000单词 x 200000比较/单词 x 1微秒/比较 = 40000x10^6秒 = 40000秒 ≈ 11.1小时</strong>。比较的次数太多了，导致效率低下，我们需要找出效率更高的方法。</p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>标识字典中的每一个单词，使得在相同变位词类中的单词具有相同的的标识，然后集中具有相同标识的单词。将每个单词按照字母表排序，排序后得到的字符串作为该单词的标识。那么对于该问题的解题过程可以分为三步：<strong>第一步，读入字典文件，对单词进行排序得到标识；第二步，将所有的单词按照其标识的顺序排序；第三步，将同一个变位词类中的各个单词放到同一行中</strong>。</p>
<p>这里出现了标识-单词（key-value）对，我们很容易想到C++中的关联容器<strong>map</strong>，使用<strong>map</strong>的好处就是：</p>
<ol>
<li><strong>动态管理内存，容器大小动态改变；</strong></li>
<li><strong>单词与它的标识一一对应，对于相同标识(key)的单词直接加在值(value)后面；</strong></li>
<li><strong>无需根据标识排序，因为map会自动按关键字有序（默认升序）</strong>。 </li>
</ol>
<p>所以，在将每个单词及其标识存入map以后，就可以直接遍历输出了，每一个map元素就是一个变位词集合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fstream&gt;    <span class="comment">// file I/O</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;map&gt;        <span class="comment">// map</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;     <span class="comment">// string</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;  <span class="comment">// sort</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *map是C++中的关联容器</span><br><span class="line"> *     按关键字有序</span><br><span class="line"> *     关键字不可重复</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义比较函数（用于排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span><br><span class="line"> *对每个单词排序</span><br><span class="line"> *排序后字符串作为关键字，原单词作为值</span><br><span class="line"> *存入map中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sign_sort</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dic)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 文件流</span></span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(dic)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't open file: "</span> + <span class="built_in">string</span>(dic) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> aword;</span><br><span class="line">    <span class="built_in">string</span> asign;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; aword)</span><br><span class="line">    &#123;</span><br><span class="line">        asign = aword;</span><br><span class="line">        sort(asign.begin(), asign.end(), myfunction);</span><br><span class="line">        <span class="comment">// 若标识不存在，创建一个新map元素，若存在，加在值后面</span></span><br><span class="line">        word[asign] += aword + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *写入输出文件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!out)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't create file: "</span> + <span class="built_in">string</span>(file) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator begin = word.begin();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator end = word.end();</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; begin-&gt;second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dic;  </span><br><span class="line">    <span class="built_in">string</span> outfile;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input dictionary name: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; dic;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input output filename: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; outfile;</span><br><span class="line"></span><br><span class="line">    sign_sort(dic.c_str());</span><br><span class="line">    write_file(outfile.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>附</strong>：（2012.5.6百度实习笔试题）一个单词交换字母位置，可得另一个单词，如army-&gt;mary，成为兄弟单词。提供一个单词，在字典中找到它的兄弟。描述数据结构和查询过程。</p>
<p><strong>解题思路</strong>：如果不允许进行预处理，那么我们只能顺序遍历整个字典，计算每个单词的标识与给定单词的标识比较。如果允许进行预处理，我们可以如上述思路二将所有单词加入一个map，然后输出关键字（给定单词的标识）对应的值，值中就包含了该单词的所有兄弟单词。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》第二章提到了一个变位词问题，变位词指的是一个单词可以通过改变其他单词中字母的顺序来得到，也叫做兄弟单词，如army-&gt;mary。由变位词可以引申出几个算法问题，包括字符串包含问题，比较两个字符串是否是变位词，以及找出字典中变位词集合的问题。</p>
<h3 id="字符串包含问题">字符串包含问题</h3><p>(1) 问题描述：存在字符串1和字符串2，假设字符串2相对较短，如何快速地判定字符串2中的字符都存在于字符串1里（假定字符串只包含字母）？]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一维向量旋转算法]]></title>
    <link href="http://yoursite.com/2014/04/07/vector-rotation/"/>
    <id>http://yoursite.com/2014/04/07/vector-rotation/</id>
    <published>2014-04-07T12:43:09.000Z</published>
    <updated>2015-05-09T16:52:45.288Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》第二章提到了n元一维向量旋转算法（又称数组循环移位算法）的五种思路，并且比较了它们在时间和空间性能上的区别和优劣。</p>
<h3 id="问题描述">问题描述</h3><p>将一个n元一维向量向左旋转i个位置。例如，假设n=8，i=3，向量abcdefgh旋转为向量defghabc。简单的代码使用一个n元的中间向量在n步内可完成该工作。你能否仅使用几十个额外字节的内存空间，在正比于n的时间内完成向量的旋转？<a id="more"></a></p>
<h3 id="解决方案">解决方案</h3><p><strong>思路一</strong>：将向量x中的前i个元素复制到一个临时数组中，接着将余下的n-i个元素左移i个位置，然后再将前i个元素从临时数组中复制到x中余下的位置。<strong>性能：这种方法使用了i个额外的位置，如果i很大则产生了过大的存储空间的消耗。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 17时07分06秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将前i个元素临时保存</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(s, 0, i)</span></span>;</span><br><span class="line">    <span class="comment">// 将剩余的左移i个位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>    j=i; j&lt;s.size(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        s[j-i] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.substr(<span class="number">0</span>, s.size()-i) + tmp;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路二</strong>：定义一个函数将x向左旋转一个位置（其时间正比于n），然后调用该函数i次。<strong>性能：这种方法虽然空间复杂度为O(1)，但产生了过多的运行时间消耗。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate_1.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 19时49分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateOnce</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;s.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i-<span class="number">1</span>] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[i-<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数i次</span></span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rotateOnce(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路三</strong>：移动x[0]到临时变量t中，然后移动x[i]到x[0]中，x[2i]到x[i]，依次类推，直到我们又回到x[0]的位置提取元素，此时改为从临时变量t中提取元素，然后结束该过程（当下标大于n时对n取模或者减去n）。如果该过程没有移动全部的元素，就从x[1]开始再次进行移动，总共移动i和n的最大公约数次。<strong>性能：这种方法非常精巧，像书中所说的一样堪称巧妙的杂技表演。空间复杂度为O(1)，时间复杂度为线性时间，满足问题的性能要求，但还不是最佳。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate_2.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 20时21分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧几里德（辗转相除）算法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            i = i%j;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            j = j%i;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> times = gcd(s.size(), i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;times; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s[j];</span><br><span class="line">        <span class="keyword">int</span> pre = j; <span class="comment">// 记录上一次的位置</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = pre+i;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= s.size())</span><br><span class="line">                t = t-s.size();</span><br><span class="line">            <span class="keyword">if</span>(t == j) <span class="comment">// 直到tmp原来的位置j为止</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s[pre] = s[t];</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        s[pre] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路四</strong>：旋转向量x实际上就是交换向量ab的两段，得到向量ba，这里a代表x的前i个元素。假设a比b短。将b分割成$b_l$和$b_r$，使$b_r$的长度和a的长度一样。交换a和$b_r$，将$ab_lb_r$转换成$b_rb_la$。因为序列a已在它的最终位置了，所以我们可以集中精力交换b的两个部分了。由于这个新问题和原先的问题是一样的，所以我们以递归的方式进行解决。这种方法可以得到优雅的程序，但是需要巧妙的代码，并且要进行一些思考才能看出它的效率足够高。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></p>
<p><strong>思路五</strong>：（<strong>最佳</strong>）将这个问题看做是把数组ab转换成ba，同时假定我们拥有一个函数可以将数组中特定部分的元素逆序。从ab开始，首先对a求逆，得到$a^r b$，然后对b求逆，得到$a^r b^r$。最后整体求逆，得到$(a^r b^r)^r$，也就是ba。<br>reverse(0, i-1)   /<em>cbadefgh</em>/<br>reverse(i, n-1)  /<em>cbahgfed</em>/<br>reverse(0, n-1) /<em>defghabc</em>/<br><strong>性能：求逆序的方法在时间和空间上都很高效，而且代码非常简短，很难出错。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 23时37分54秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = s[begin];</span><br><span class="line">        s[begin] = s[end];</span><br><span class="line">        s[end] = tmp;</span><br><span class="line">        ++begin;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(s, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">    reverse(s, i, s.size()-<span class="number">1</span>);</span><br><span class="line">    reverse(s, <span class="number">0</span>, s.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展延伸">扩展延伸</h3><p><strong>如何将向量abc旋转变成cba？</strong><br>和前面的问题类似，此向量旋转对应着非相邻内存块的交换模型。解法很相似，即利用恒等式：</p>
<p>$$cba = （a^r b^r c^r）^r$$</p>
<p><strong>注</strong>：在面试或笔试时，如若出现向量旋转（内存块交换）问题，最好使用思路五答题，不仅高效而且简洁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》第二章提到了n元一维向量旋转算法（又称数组循环移位算法）的五种思路，并且比较了它们在时间和空间性能上的区别和优劣。</p>
<h3 id="问题描述">问题描述</h3><p>将一个n元一维向量向左旋转i个位置。例如，假设n=8，i=3，向量abcdefgh旋转为向量defghabc。简单的代码使用一个n元的中间向量在n步内可完成该工作。你能否仅使用几十个额外字节的内存空间，在正比于n的时间内完成向量的旋转？]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>