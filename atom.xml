<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SongLee's Blog]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-10T07:47:57.478Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python3基础（九） 错误和异常]]></title>
    <link href="http://yoursite.com/2014/08/19/python-basic-09/"/>
    <id>http://yoursite.com/2014/08/19/python-basic-09/</id>
    <published>2014-08-19T05:44:15.000Z</published>
    <updated>2015-05-10T07:47:57.478Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍Python中的错误和异常，涉及到简单的异常处理、抛出异常以及清理动作。至于<strong>自定义异常类</strong>，将在介绍类与继承的时候讲到。</p>
<h3 id="一、定义">一、定义</h3><p>常见的两种错误：语法错误 和 异常。</p>
<p><strong>1、语法错误（Syntax Errors）</strong></p>
<p>语法错误，也就是解析时错误。当我们写出不符合python语法的代码时，在解析时会报SyntaxError，并且会显示出错的那一行，并用小箭头指明最早探测到错误的位置。比如：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = input(<span class="string">'please input an integer:'</span>)</span><br><span class="line"><span class="keyword">if</span> int(x) &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p>
<p>在python 3中会报语法错误：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">File</span> <span class="string">"/home/songlee/test"</span>, <span class="keyword">line</span> 3</span><br><span class="line">    <span class="keyword">print</span> 'hello world'</span><br><span class="line">                      ^</span><br><span class="line">SyntaxError: invalid <span class="keyword">syntax</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、异常（Exceptions）</strong></p>
<p>即使语句或表达式在语法上是正确的，但在尝试运行时也可能发生错误，运行时错误就叫做 异常（Exceptions） 。异常并不是致命的问题，因为我们可以在程序中对异常进行处理。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">ZeroDivisionError</span><span class="symbol">:</span> division by zero</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="number">2</span> + x*<span class="number">3</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> name <span class="string">'x'</span> is <span class="keyword">not</span> <span class="keyword">defined</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'2'</span> + <span class="number">2</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="constant">TypeError</span><span class="symbol">:</span> <span class="constant">Can</span><span class="string">'t convert '</span>int<span class="string">' object to str implicitly</span></span><br></pre></td></tr></table></figure></p>
<p>上面展示了三种exception的类型：ZeroDivisionError、NameError、TypeError ，它们都是内置异常的名称。标准异常的名字是内建的标识符 (但并不是关键字)。</p>
<p><br></p>
<h3 id="二、处理异常（try…except…）">二、处理异常（try…except…）</h3><p>我们可以使用 try…except… 语句来处理异常。try 语句块中是要执行的语句，except 语句块中是异常处理语句。一个 try 语句可以有多条的 except 语句，用以指定不同的异常，但至多只有一个会被执行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    x = <span class="function"><span class="title">int</span><span class="params">(input(<span class="string">'please input an integer:'</span>)</span></span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">30</span>/x &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'Hello World!'</span>)</span></span></span><br><span class="line">except ValueError:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'That was no valid number. Try again...'</span>)</span></span></span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'The divisor can not be zero, Try again...'</span>)</span></span></span><br><span class="line">except:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">'Handling other exceptions...'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，当输入a（非数字）时，将抛出<strong><em>ValueError</em></strong>异常；当输入0时，将抛出<strong><em>ZeroDivisionError</em></strong>异常；当抛出<strong><em>其他类型</em></strong>的异常时，将执行except:后的处理语句。</p>
<p>如果在 try 语句执行时，出现了一个异常，该语句的剩下部分将被跳过。并且如果该异常的类型匹配到了 except 后面的异常名，那么该 except 后的语句将被执行。注意，如果 except 后面没有跟异常名，表示它匹配任何类型的异常，<code>except:</code>必须放在最后。</p>
<p>一个 except 语句可以同时包括多个异常名，但需要用括号括起来，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">``` </span><br><span class="line"><span class="keyword">try</span> / <span class="keyword">except</span> 语句可以有一个可选的 <span class="keyword">else</span> 语句。<span class="keyword">else</span> 语句必须要放在所有 <span class="keyword">except</span> 语句后面，当**没有异常发生**的时候，<span class="keyword">else</span> 从句将被执行：</span><br></pre></td></tr></table></figure></p>
<p>try:<br>    name = input(‘please input an integer:’)<br>    f = open(name, ‘r’)<br>except IOError:<br>    print(‘Cannot open’, name)<br>except:<br>    print(‘Unexpected errors.’)<br>else:<br>    print(‘close the file’, name)<br>    f.close()<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;br&gt;</span></span><br><span class="line"><span class="comment">###三、抛出异常（raise）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>raise 语句<span class="keyword">*</span><span class="keyword">*</span>允许程序员强制地抛出一个特定的异常，例如：</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>raise NameError(‘HiThere’)     # 抛出异常<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>NameError: HiThere<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> 抛出的异常必须是一个异常实例或类（派生自 Exception 的类）。</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">###四、清理动作（<span class="keyword">finally</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> 语句有另一种可选的`<span class="keyword">finally</span>`从句，用于自定义一些扫尾清理的工作。</span><br></pre></td></tr></table></figure></module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<p>try:<br>    x = int(input(‘please input an integer:’))<br>    if x &gt; 5:<br>        print(‘Hello World!’)<br>except ValueError:<br>    print(‘It was not a number. Try again.’)<br>finally:<br>    print(‘Some clean-up actions!’)<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**与 <span class="keyword">else</span> 从句的区别在于：** <span class="keyword">else</span> 语句只在没有异常发生的情况下执行，而 <span class="keyword">finally</span> 语句则不管异常发生与否都会执行。准确的说，<span class="keyword">finally</span> 语句总是在退出 <span class="keyword">try</span> 语句前被执行，无论是正常退出、异常退出，还是通过<span class="keyword">break</span>、<span class="keyword">continue</span>、<span class="keyword">return</span>退出。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>def divide(x, y):<br>…     try:<br>…             result = x / y<br>…     except ZeroDivisionError:<br>…             print(‘error: division by zero!’)<br>…     else:<br>…             print(‘executing else-clause,’, ‘result is’, result)<br>…     finally:<br>…             print(‘executing finally-clause’)<br>… </p>
<p>divide(2, 1)      # 正常退出<br>executing else-clause, result is 2.0<br>executing finally-clause</p>
<p>divide(2, 0)      # 异常退出<br>error: division by zero!<br>executing finally-clause</p>
<p>divide(‘2’, ‘1’)  # 异常退出，异常未被处理。<br>executing finally-clause<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>  File “<stdin>“, line 3, in divide<br>TypeError: unsupported operand type(s) for /: ‘str’ and ‘str’<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从上面看出，finally 语句在任何情况下都被执行了。对于没有被 except 处理的异常，将在执行完 finally 后被重新抛出。</span><br><span class="line"></span><br><span class="line">另外，有些对象预定义了标准的<span class="strong">**清理动作（clean-up actions）**</span>。当对象不再需要时，该动作将被执行，无论对其使用的操作是否成功。例如下面的[<span class="link_label">文件I/O</span>](<span class="link_url">http://songlee24.github.io/2014/08/14/python-basic-07/</span>)例子：</span><br></pre></td></tr></table></figure></stdin></module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<p>for line in open(“myfile.txt”):<br>    print(line, end=””)<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码的问题在于，在此代码成功执行后，文件依然被打开着。但<span class="escape">`w</span>ith<span class="escape">`语</span>句可以让文件对象在使用后被正常的清理掉：</span><br></pre></td></tr></table></figure></p>
<p>with open(“myfile.txt”) as f:<br>    for line in f:<br>        print(line, end=””)<br>```<br>在执行该语句后，文件 f 就会被关闭，就算是在读取时碰到了问题，文件 f 也会被关闭。像文件这样的对象，总会提供预定义的清理工作。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍Python中的错误和异常，涉及到简单的异常处理、抛出异常以及清理动作。至于<strong>自定义异常类</strong>，将在介绍类与继承的时候讲到。</p>
<h3 id="一、定义">一、定义</h3><p>常见的两种错误：语法错误 和 异常。</p>
<p><strong>1、语法错误（Syntax Errors）</strong></p>
<p>语法错误，也就是解析时错误。当我们写出不符合python语法的代码时，在解析时会报SyntaxError，并且会显示出错的那一行，并用小箭头指明最早探测到错误的位置。比如：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（八） 模块]]></title>
    <link href="http://yoursite.com/2014/08/18/python-basic-08/"/>
    <id>http://yoursite.com/2014/08/18/python-basic-08/</id>
    <published>2014-08-18T13:45:54.000Z</published>
    <updated>2015-05-10T07:50:12.691Z</updated>
    <content type="html"><![CDATA[<p>在程序中定义<a href="http://songlee24.github.io/2014/08/09/python-basic-05/" target="_blank" rel="external">函数</a>可以实现代码重用。但当你的代码逐渐变得庞大时，你可能想要把它分割成几个文件，以便能够更简单地维护。同时，你希望在一个文件中写的代码能够被其他文件所重用，这时我们应该使用<strong>模块（module）</strong>。</p>
<h3 id="一、导入模块">一、导入模块</h3><p>在Python中，一个<code>.py</code>文件就构成一个模块。一个模块中的定义可以<strong>导入（import）</strong>到另一个模块或主模块。</p>
<p>比如你可以通过内置模块platform来查看你当前的操作平台信息：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line">s = platform.platform()</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># 我的输出：Linux-3.15.8-200.fc20.x86_64-x86_64-with-fedora-20-Heisenbug</span></span><br></pre></td></tr></table></figure></p>
<p>又比如你可以通过内置模块time获取当前的时间：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> time</span></span><br><span class="line">s = time.ctime()</span><br><span class="line"><span class="built_in">print</span>(s)<span class="preprocessor"></span><br><span class="line"># 输出：Mon Aug 18 16:04:57 2014</span></span><br></pre></td></tr></table></figure></p>
<p>每个模块有其私有的符号表，在该模块内部当成全局符号表来使用。 当我们将一个模块导入到当前模块时，只有被导入模块的名称被放入当前模块的全局符号表里，所以我们不用担心变量名发生冲突。</p>
<p><strong>其他几种导入方式：</strong></p>
<p>1、<code>import a as b</code>：导入模块a，并将模块a重命名为b。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import <span class="tag">time</span> as x   </span><br><span class="line">s = x.<span class="function"><span class="title">ctime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure></p>
<p>2、<code>from a import func</code>：直接把模块内的函数或变量的名称导入当前模块符号表里。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line">s = ctime()   <span class="comment"># 这时可以直接调用函数，而不用再使用time.ctime()</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>3、<code>from a import *</code>：导入模块中所有的名字（以下划线开头的名字除外）到当前模块符号表里。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">s = ctime()   </span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>注意：导入 * 是不好的，因为它常常产生难以阅读的代码，并且会容易产生名字冲突。</p>
<p><br></p>
<h3 id="二、模块搜索路径">二、模块搜索路径</h3><p>当导入名为 a 的模块时, 解释器会先从内建模块尝试匹配，如果没找到，则将在 <code>sys.path</code> 记录的所有目录中搜索 a.py 文件，而<code>sys.path</code>则包括：</p>
<ul>
<li>当前程序所在目录</li>
<li>标准库的安装目录</li>
<li>操作系统环境变量PYTHONPATH所包含的目录</li>
</ul>
<p>变量 sys.path 是一个字符串列表，它为解释器指定了模块的搜索路径。它通过环境变量 PATHONPATH 初始化为一个默认路径，当没有设置 PYTHONPATH 时, 就使用内建默认值来初始化。你可以通过标准 list 操作来修改它：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import sys</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sys.path.append(<span class="string">'/ufs/guido/lib/python'</span>)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、模块的_name_">三、模块的_<em>name_</em></h3><p>对于任何一个模块，模块的名字都可以通过全局变量 <code>__name__</code>得到：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">time</span></span><br><span class="line">s = <span class="built_in">time</span>.__name__</span><br><span class="line"><span class="built_in">print</span>(s)    # 输出<span class="built_in">time</span></span><br></pre></td></tr></table></figure></p>
<p>一个模块既可以在其它模块中导入使用，也可以当作脚本直接运行。不同的是，当导入到其他模块时，__name__的值是被导入模块的名字；而当作为脚本运行时，__name__的值被设为<strong>“__main__“</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">'This program is being run by itself'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">'I am being imported into another module'</span>)</span><br></pre></td></tr></table></figure></p>
<p>当作脚本执行：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">test</span>.py </span><br><span class="line">This <span class="keyword">program</span> is being <span class="keyword">run</span> <span class="keyword">by</span> itself</span><br></pre></td></tr></table></figure></p>
<p>当作导入模块使用：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import test</span><br><span class="line"><span class="constant">I</span> am being imported into another <span class="class"><span class="keyword">module</span></span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、dir()_函数">四、dir() 函数</h3><p>在<a href="http://songlee24.github.io/blog/2014/08/13/python3ji-chu-liu/" target="_blank" rel="external">Python3基础六</a>中我们提到，可以通过内置dir()函数查询一个类或者对象的所有属性。除此之外，我们还可以用它列出一个模块里定义的所有名字，它返回一个有序字串列表：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import builtins</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dir(builtins)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="五、包">五、包</h3><p>可以把多个模块，即多个.py文件，放在同一个文件夹中，构成一个<strong>包（Package）</strong>。例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          顶级包</span><br><span class="line">      __init__<span class="class">.py</span>               初始化这个声音包</span><br><span class="line">      formats/                  格式转换子包</span><br><span class="line">              __init__<span class="class">.py</span></span><br><span class="line">              wavread<span class="class">.py</span></span><br><span class="line">              wavwrite<span class="class">.py</span></span><br><span class="line">              aiffread<span class="class">.py</span></span><br><span class="line">              aiffwrite<span class="class">.py</span></span><br><span class="line">              auread<span class="class">.py</span></span><br><span class="line">              auwrite<span class="class">.py</span></span><br><span class="line">              ...</span><br><span class="line">      effects/                  音效子包</span><br><span class="line">              __init__<span class="class">.py</span></span><br><span class="line">              echo<span class="class">.py</span></span><br><span class="line">              surround<span class="class">.py</span></span><br><span class="line">              reverse<span class="class">.py</span></span><br><span class="line">              ...</span><br><span class="line">      filters/                  过滤器子包</span><br><span class="line">              __init__<span class="class">.py</span></span><br><span class="line">              equalizer<span class="class">.py</span></span><br><span class="line">              vocoder<span class="class">.py</span></span><br><span class="line">              karaoke<span class="class">.py</span></span><br><span class="line">              ...</span><br></pre></td></tr></table></figure></p>
<p>注意：在每个包文件夹里都必须包含一个 __init__.py 的文件，告诉Python，该文件夹是一个包。__init__.py 可以是一个空文件。</p>
<p>我们可以通过<code>import 包名.模块名</code>导入包中的子模块，例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sound<span class="class">.effects</span><span class="class">.echo</span></span><br></pre></td></tr></table></figure></p>
<p>当然，也可以使用<code>from... import...</code>句式导入包中的模块：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo               <span class="comment"># 导入echo子模块</span></span><br><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter    <span class="comment"># 导入echo子模块中的函数或变量</span></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *                  <span class="comment"># 导入__all__变量中所有的子模块</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在程序中定义<a href="http://songlee24.github.io/2014/08/09/python-basic-05/">函数</a>可以实现代码重用。但当你的代码逐渐变得庞大时，你可能想要把它分割成几个文件，以便能够更简单地维护。同时，你希望在一个文件中写的代码能够被其他文件所重用，这时我们应该使用<strong>模块（module）</strong>。</p>
<h3 id="一、导入模块">一、导入模块</h3><p>在Python中，一个<code>.py</code>文件就构成一个模块。一个模块中的定义可以<strong>导入（import）</strong>到另一个模块或主模块。</p>
<p>比如你可以通过内置模块platform来查看你当前的操作平台信息：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python FAQ2：赋值、浅拷贝、深拷贝的区别？]]></title>
    <link href="http://yoursite.com/2014/08/15/python-FAQ-02/"/>
    <id>http://yoursite.com/2014/08/15/python-FAQ-02/</id>
    <published>2014-08-14T16:58:57.000Z</published>
    <updated>2015-05-10T07:39:06.313Z</updated>
    <content type="html"><![CDATA[<p>在写Python过程中，经常会遇到对象的拷贝，如果不理解<strong>浅拷贝</strong>和<strong>深拷贝</strong>的概念，你的代码就可能出现一些问题。所以，在这里按个人的理解谈谈它们之间的区别。<br><br></p>
<h3 id="一、赋值（assignment）">一、赋值（assignment）</h3><p>在《<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/" target="_blank" rel="external">Python FAQ1</a>》一文中，对赋值已经讲的很清楚了，关键要理解<strong>变量与对象的关系</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="number">139701469405552</span></span><br><span class="line"><span class="number">139701469405552</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在Python中，用一个变量给另一个变量<strong>赋值</strong>，其实就是给当前内存中的对象增加一个“标签”而已。</p>
<p>如上例，通过使用内置函数 id() ，可以看出 a 和 b 指向内存中同一个对象。<code>a is b</code>会返回 True 。<br><br></p>
<h3 id="二、浅拷贝（shallow_copy）">二、浅拷贝（shallow copy）</h3><p><strong>注意：浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。</strong></p>
<p>所谓“浅拷贝”，是指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象）</p>
<p>常见的浅拷贝有：切片操作、工厂函数、对象的copy()方法、copy模块中的copy函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = list(a)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b))          <span class="comment"># a和b身份不同</span></span><br><span class="line"><span class="number">140601785066200</span> <span class="number">140601784764968</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):       <span class="comment"># 但它们包含的子对象身份相同</span></span><br><span class="line"><span class="prompt">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="number">140601911441984</span> <span class="number">140601911441984</span></span><br><span class="line"><span class="number">140601911442016</span> <span class="number">140601911442016</span></span><br><span class="line"><span class="number">140601911442048</span> <span class="number">140601911442048</span></span><br></pre></td></tr></table></figure></p>
<p>从上面可以明显的看出来，a 浅拷贝得到 b，a 和 b 指向内存中不同的 <strong>list</strong> 对象，但它们的元素却指向相同的 <strong>int</strong> 对象。这就是浅拷贝！<br><br></p>
<h3 id="三、深拷贝（deep_copy）">三、深拷贝（deep copy）</h3><p>所谓“深拷贝”，是指创建一个新的对象，然后递归的拷贝原对象所包含的子对象。深拷贝出来的对象与原对象没有任何关联。</p>
<p>深拷贝只有一种方式：copy模块中的deepcopy函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="tag">b</span> = copy.<span class="function"><span class="title">deepcopy</span><span class="params">(a)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(id(a)</span></span>, <span class="function"><span class="title">id</span><span class="params">(b)</span></span>)</span><br><span class="line"><span class="number">140601785065840</span> <span class="number">140601785066200</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="function"><span class="title">zip</span><span class="params">(a, b)</span></span>:</span><br><span class="line">...     <span class="function"><span class="title">print</span><span class="params">(id(x)</span></span>, <span class="function"><span class="title">id</span><span class="params">(y)</span></span>)</span><br><span class="line">... </span><br><span class="line"><span class="number">140601911441984</span> <span class="number">140601911441984</span></span><br><span class="line"><span class="number">140601911442016</span> <span class="number">140601911442016</span></span><br><span class="line"><span class="number">140601911442048</span> <span class="number">140601911442048</span></span><br></pre></td></tr></table></figure>
<p>看了上面的例子，有人可能会疑惑：</p>
<p><strong>为什么使用了深拷贝，a和b中元素的id还是一样呢？</strong> </p>
<p>答：这是因为对于<strong>不可变对象</strong>，当需要一个新的对象时，python可能会返回已经存在的某个类型和值都一致的对象的引用。而且这种机制并不会影响 a 和 b 的相互独立性，因为当两个元素指向同一个不可变对象时，对其中一个赋值不会影响另外一个。</p>
<p>我们可以用一个包含可变对象的列表来确切地展示“浅拷贝”与“深拷贝”的区别：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = copy.copy(a)              <span class="comment"># 浅拷贝得到b</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>c = copy.deepcopy(a)          <span class="comment"># 深拷贝得到c</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b))           <span class="comment"># a 和 b 不同</span></span><br><span class="line"><span class="number">139832578518984</span> <span class="number">139832578335520</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):        <span class="comment"># a 和 b 的子对象相同</span></span><br><span class="line"><span class="prompt">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="number">139832578622816</span> <span class="number">139832578622816</span></span><br><span class="line"><span class="number">139832578622672</span> <span class="number">139832578622672</span></span><br><span class="line"><span class="number">139832578623104</span> <span class="number">139832578623104</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(c))           <span class="comment"># a 和 c 不同</span></span><br><span class="line"><span class="number">139832578518984</span> <span class="number">139832578622456</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, c):        <span class="comment"># a 和 c 的子对象也不同</span></span><br><span class="line"><span class="prompt">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="number">139832578622816</span> <span class="number">139832578621520</span></span><br><span class="line"><span class="number">139832578622672</span> <span class="number">139832578518912</span></span><br><span class="line"><span class="number">139832578623104</span> <span class="number">139832578623392</span></span><br></pre></td></tr></table></figure></p>
<p>从这个例子中可以清晰地看出浅拷贝与深拷贝地区别。</p>
<p><br><br><br></p>
<h3 id="总结：">总结：</h3><p>1、赋值：简单地拷贝对象的引用，两个对象的id相同。<br>2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。<br>3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。</p>
<p>浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写Python过程中，经常会遇到对象的拷贝，如果不理解<strong>浅拷贝</strong>和<strong>深拷贝</strong>的概念，你的代码就可能出现一些问题。所以，在这里按个人的理解谈谈它们之间的区别。<br><br></p>
<h3 id="一、赋值（assignment）">一、赋值（assignment）</h3><p>在《<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/">Python FAQ1</a>》一文中，对赋值已经讲的很清楚了，关键要理解<strong>变量与对象的关系</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(id(a), id(b), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="number">139701469405552</span></span><br><span class="line"><span class="number">139701469405552</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（七） 输入和输出]]></title>
    <link href="http://yoursite.com/2014/08/14/python-basic-07/"/>
    <id>http://yoursite.com/2014/08/14/python-basic-07/</id>
    <published>2014-08-14T13:16:46.000Z</published>
    <updated>2015-05-10T07:36:42.774Z</updated>
    <content type="html"><![CDATA[<p>一个程序可以从键盘读取输入，也可以从文件读取输入；而程序的结果可以输出到屏幕上，也可以保存到文件中便于以后使用。本文介绍Python中最基本的I/O函数。</p>
<p><br></p>
<h3 id="一、控制台I/O">一、控制台I/O</h3><p><strong>读取键盘输入</strong></p>
<p>内置函数<code>input([prompt])</code>，用于从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = input(<span class="string">"Enter your input:"</span>)</span><br></pre></td></tr></table></figure></p>
<p>注：在Python 3.x版本中取消了 raw_input() 函数。</p>
<p><strong>打印到屏幕</strong></p>
<p>最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print([<span class="link_label">object, ...</span>][<span class="link_reference">, sep=' '</span>][<span class="link_label">, end='endline_character_here'</span>][<span class="link_reference">, file=redirect_to_here</span>])</span><br></pre></td></tr></table></figure></p>
<p>方括号内是可选的，sep表示分割符，end表示结束符，file表示重定向文件。如果要给sep、end、file指定值必须使用关键字参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'hello'</span>, <span class="string">'world'</span>, sep=<span class="string">'%'</span>)    <span class="comment"># 输出hello%world</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello'</span>, <span class="string">'world'</span>, end=<span class="string">'*'</span>)    <span class="comment"># 输出hello world*，并且不换行</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、文件I/O">二、文件I/O</h3><p>读写文件之前，先用open()函数打开一个文件，它会返回一个文件对象（file object）：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="function"><span class="title">open</span><span class="params">(filename，mode)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果不指定mode参数，文件将默认以<strong>‘r’</strong>模式打开。模式中的字符有：</p>
<ul>
<li><strong>r</strong>：只读</li>
<li><strong>w</strong>：只写，如果文件已存在则将其覆盖。如果该文件不存在，创建新文件</li>
<li><strong>+</strong>：读写（<strong>不能单独使用</strong>）</li>
<li><strong>a</strong>：打开文件用于追加，只写，不存在则创建新文件</li>
<li><strong>b</strong>：以二进制模式打开（<strong>不能单独使用</strong>）</li>
</ul>
<p>所以可能的模式大概有<strong>r、w、r+、w+、rb、wb、rb+、wb+、a、a+、ab、ab+</strong>，注意只有w和a可以创建文件。</p>
<p>通常情况下，文件都是以文本模式（text mode）打开的，也就是说，从文件中读写的是以一种特定的编码格式进行编码（默认的是 UTF-8）的<strong>字符串</strong>。如果文件以二进制模式（binary mode）打开，数据将以<strong>字节对象</strong>的形式进行读写：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">'a.txt'</span>,<span class="string">'wb+'</span>)</span><br><span class="line">f.<span class="built_in">write</span>(<span class="string">'I like apple!'</span>)   <span class="comment"># 报错</span></span><br><span class="line">f.<span class="built_in">write</span>(b<span class="string">'I like apple!'</span>)  <span class="comment"># 以bytes对象的形式进行读写</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://docs.python.org/3.4/library/stdtypes.html#bytes" target="_blank" rel="external"><strong>Bytes对象</strong></a>是0到127的不可修改的整数序列，或纯粹的 ASCII 字符，它的用途是存储二进制数据。  </p>
<ol>
<li>可以通过<strong>在一个字符串前面加上’b’</strong>来创建一个bytes literal；</li>
<li>也可以通过<strong>bytes() 函数</strong>创建一个 bytes 对象。</li>
</ol>
<p>注意：如果bytes() 函数的初始化器是一个字符串，那么必须提供一种编码。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1 = b<span class="attribute">'This</span> <span class="keyword">is</span> <span class="typename">string</span>'</span><br><span class="line">b2 = bytes(<span class="attribute">'This</span> <span class="keyword">is</span> <span class="typename">string</span>', <span class="attribute">'UTF</span>-<span class="number">8</span>')   # 必须指定编码格式</span><br></pre></td></tr></table></figure></p>
<p>字符串对象与字节对象是不兼容的，要将 bytes 转变为 str， bytes 对象必须要进行解码，使用<strong>decode()</strong> 方法：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = bytes(<span class="string">'This is string'</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line">print(b, b.decode(), sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="preprocessor"># 输出：</span></span><br><span class="line"><span class="preprocessor"># b'This is string'</span></span><br><span class="line"><span class="preprocessor"># This is string</span></span><br></pre></td></tr></table></figure></p>
<p><strong>文件对象的方法</strong>（假设f是一个文件对象）：</p>
<ul>
<li><strong>f.read(size) ：</strong>读取size个字节的数据，然后作为字符串或 bytes 对象返回。size是一个可选参数，如果不指定size，则读取文件的所有内容。</li>
<li><strong>f.readline() ：</strong>读取一行。在字符串末尾会留下换行符 (\n)，如果到文件尾，返回空字符串。</li>
<li><strong>f.readlines() ：</strong>读取所有行，储存在列表中，每个元素是一行，相当于<code>list(f)</code>。</li>
<li><strong>f.write(string) ：</strong>将 string 写入到文件中，返回写入的字符数。如果以二进制模式写文件，需要将string转换为 bytes 对象。</li>
<li><strong>f.tell() ：</strong>返回文件对象当前所处的位置，它是从文件开头开始算起的字节数。 </li>
<li><strong>f.seek(offset, from_what) ：</strong>改变文件对象所处的位置。offset是相对参考位置的偏移量，from_what 取值 0（文件头, 默认）、1（当前位置）、2（文件尾）表示参考位置。</li>
<li><strong>f.close() ：</strong>关闭文件对象。</li>
</ul>
<p>这些都是很常用的方法，当然文件对象不止这些方法。根据打开的模式不同，open() 返回的文件对象类型也不同：</p>
<ul>
<li><strong>TextIOWrapper</strong>：文本模式，返回TextIOWrapper对象。</li>
<li><strong>BufferedReader</strong>：读二进制，即rb，返回BufferedReader对象。</li>
<li><strong>BufferedWriter</strong>：写和追加二进制，即wb、ab，返回BufferedWriter对象。</li>
<li><strong>BufferedRandom</strong>：读/写模式，即含有+的模式，返回BufferedRandom对象。</li>
</ul>
<p>可以在这些文件对象上运行 dir() 或 help()，查看它们所有的方法。</p>
<p><strong>补充</strong>：</p>
<p>1、在文本模式下，seek()方法只会相对于文件起始位置进行定位。（除了定位文件尾可以用 <code>seek(0, 2)</code>之外）<br>2、可以循环迭代一个文件对象一行一行读取：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="operator">in</span> f:</span><br><span class="line">print(<span class="built_in">line</span>, <span class="function"><span class="keyword">end</span>='')</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、格式化输出">三、格式化输出</h3><p>一般来说，我们希望更多的控制输出格式，而不是简单的以空格分割。这里有两种方式：</p>
<ul>
<li>第一种是由你自己控制。使用字符串切片、连接操作以及 <a href="https://docs.python.org/3.4/library/stdtypes.html#str.center" target="_blank" rel="external">string</a> 包含的一些有用的操作。</li>
<li>第二种是使用<a href="https://docs.python.org/3.4/library/stdtypes.html#str.format" target="_blank" rel="external">str.format()</a>方法。</li>
</ul>
<p>下面给一个示例：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 第一种方式：自己控制</span></span><br><span class="line"><span class="keyword">for</span> x in range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	print(str(x).rjust(<span class="number">2</span>), str(x*x).rjust(<span class="number">3</span>), end=<span class="string">' '</span>)</span><br><span class="line">	print(str(x*x*x).rjust(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 第二种方式：str.format()</span></span><br><span class="line"><span class="keyword">for</span> x in range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	print(<span class="string">'&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;'</span>.format(x, x*x, x*x*x))</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 输出都是：</span></span><br><span class="line"><span class="preprocessor">#  1   1    1</span></span><br><span class="line"><span class="preprocessor">#  2   4    8</span></span><br><span class="line"><span class="preprocessor">#  3   9   27</span></span><br><span class="line"><span class="preprocessor">#  4  16   64</span></span><br><span class="line"><span class="preprocessor">#  5  25  125</span></span><br><span class="line"><span class="preprocessor">#  6  36  216</span></span><br><span class="line"><span class="preprocessor">#  7  49  343</span></span><br><span class="line"><span class="preprocessor">#  8  64  512</span></span><br><span class="line"><span class="preprocessor">#  9  81  729</span></span><br><span class="line"><span class="preprocessor"># 10 100 1000</span></span><br></pre></td></tr></table></figure></p>
<p>第一种方式中，字符串对象的 <strong>str.rjust()</strong> 方法的作用是将字符串靠右，并默认在左边填充空格，类似的方法还有 <strong>str.ljust()</strong> 和 <strong>str.center()</strong> 。这些方法并不会写任何东西，它们仅仅返回新的字符串，如果输入很长，它们并不会截断字符串。<strong>我们注意到，</strong>同样是输出一个平方与立方表，使用str.format()会方便很多。</p>
<p>str.format()的基本用法如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print<span class="list">(<span class="quoted">'We</span> are the &#123;&#125; who say <span class="string">"&#123;&#125;!"</span>'.format<span class="list">(<span class="quoted">'knights</span>', <span class="quoted">'Ni</span>')</span>)</span></span><br><span class="line">We are the knights who say <span class="string">"Ni!"</span></span><br></pre></td></tr></table></figure></p>
<p>括号及括号里的字符将会被 format() 中的参数替换.。括号中的数字用于指定传入对象的位置：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(<span class="string">'&#123;0&#125; and &#123;1&#125;'</span>.format(<span class="string">'Kobe'</span>, <span class="string">'James'</span>))</span><br><span class="line"><span class="constant">Kobe</span> <span class="keyword">and</span> <span class="constant">James</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(<span class="string">'&#123;1&#125; and &#123;0&#125;'</span>.format(<span class="string">'Kobe'</span>, <span class="string">'James'</span>))</span><br><span class="line"><span class="constant">James</span> <span class="keyword">and</span> <span class="constant">Kobe</span></span><br></pre></td></tr></table></figure></p>
<p>如果在 format() 中使用了<strong>关键字参数</strong>，那么它们的值会指向使用该名字的参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'The &#123;thing&#125; is &#123;adj&#125;.'</span>.format(thing=<span class="string">'flower'</span>, adj=<span class="string">'beautiful'</span>))</span><br><span class="line">The flower <span class="keyword">is</span> beautiful.</span><br></pre></td></tr></table></figure></p>
<p>可选项<code>&#39;:&#39;</code>和格式标识符可以跟着 field name，这样可以进行更好的格式化：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(<span class="string">'The value of PI is &#123;0:.3f&#125;.'</span>.<span class="built_in">format</span>(math.<span class="constant">pi</span>))</span><br><span class="line">The <span class="built_in">value</span> <span class="operator">of</span> <span class="constant">PI</span> is <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure></p>
<p>在<code>&#39;:&#39;</code>后传入一个整数，可以保证该域至少有这么多的宽度，用于美化表格时很有用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>table = &#123;<span class="string">'Jack'</span>:<span class="number">4127</span>, <span class="string">'Rose'</span>:<span class="number">4098</span>, <span class="string">'Peter'</span>:<span class="number">7678</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> name, phone <span class="keyword">in</span> table.items():</span><br><span class="line"><span class="prompt">... </span>    print(<span class="string">'&#123;0:10&#125; ==&gt; &#123;1:10d&#125;'</span>.format(name, phone))</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">Peter      ==&gt;       <span class="number">7678</span></span><br><span class="line">Rose       ==&gt;       <span class="number">4098</span></span><br><span class="line">Jack       ==&gt;       <span class="number">4127</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以将<a href="http://songlee24.github.io/blog/2014/08/09/python3ji-chu-wu-han-shu/" target="_blank" rel="external">参数解包</a>进行格式化输出。例如，将table解包为关键字参数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table = &#123;<span class="string">'Jack'</span>:<span class="number">4127</span>, <span class="string">'Rose'</span>:<span class="number">4098</span>, <span class="string">'Peter'</span>:<span class="number">7678</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Jack is &#123;Jack&#125;, Rose is &#123;Rose&#125;, Peter is &#123;Peter&#125;.'</span>.format(**table))</span><br><span class="line"># 输出：Jack <span class="keyword">is</span> <span class="number">4127</span>, Rose <span class="keyword">is</span> <span class="number">4098</span>, Peter <span class="keyword">is</span> <span class="number">7678.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>补充：</strong>  </p>
<p>% 操作符也可以实现字符串格式化。它将左边的参数作为类似 sprintf() 式的格式化字符串，而将右边的代入：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">print(<span class="attribute">'The</span> value <span class="keyword">of</span> PI <span class="keyword">is</span> %<span class="number">10.3</span>f.' %math.pi)</span><br><span class="line"># 输出：The value <span class="keyword">of</span> PI <span class="keyword">is</span>      <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure></p>
<p>因为这种旧式的格式化最终会从Python语言中移除，应该更多的使用 str.format() 。</p>
<p><br><br><br><br></p>
<h3 id="附：文本模式与二进制模式">附：文本模式与二进制模式</h3><p>1、在Windows系统中，文本模式下，默认是将Windows平台的行末标识符 \r\n 在读时转为 \n ，而在写时将 \n 转为 \r\n 。 这种隐藏的行为对于文本文件是没有问题的，但是对于二进制数据像 JPEG 或 EXE 是会出问题的。在使用这些文件时请小心使用二进制模式。</p>
<p>2、在类Unix/Linux系统中，行末标识符为 \n，即文件以 \n 代表换行。所以Unix/Linux系统中在文本模式和二进制模式下并无区别。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个程序可以从键盘读取输入，也可以从文件读取输入；而程序的结果可以输出到屏幕上，也可以保存到文件中便于以后使用。本文介绍Python中最基本的I/O函数。</p>
<p><br></p>
<h3 id="一、控制台I/O">一、控制台I/O</h3><p><strong>读取键盘输入</strong></p>
<p>内置函数<code>input([prompt])</code>，用于从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（六） 深入list列表]]></title>
    <link href="http://yoursite.com/2014/08/13/python-basic-06/"/>
    <id>http://yoursite.com/2014/08/13/python-basic-06/</id>
    <published>2014-08-12T16:14:05.000Z</published>
    <updated>2015-05-10T07:35:18.179Z</updated>
    <content type="html"><![CDATA[<p>正如<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/" target="_blank" rel="external">Python FAQ1附录</a>中说的， Python中任何值都是一个对象，所以任何类型（int、str、list…）都是一个类。而类就必然有它的方法或属性，我们要记下这么多类的所有方法显然是不可能的，这里介绍两个小技巧：</p>
<ul>
<li><strong>dir()</strong> ：内置函数，用来查询一个类或者对象所有属性，比如<code>&gt;&gt;&gt; dir(list)</code>。</li>
<li><strong>help()</strong> ：内置函数，用来查询具体的说明文档，比如<code>&gt;&gt;&gt; help(int)</code>。</li>
</ul>
<p>在<a href="http://songlee24.github.io/2014/08/08/python-basic-02/" target="_blank" rel="external">Python的基本数据类型</a>中，我们初步了解了list列表，也介绍了列表是Python 中使用最频繁的数据类型。本文将进一步深入学习列表的使用。<br><a id="more"></a><br></p>
<h3 id="一、列表的方法">一、列表的方法</h3><p>list.<strong>append</strong>(x)<br>在列表的尾部添加一个项，等价于 <code>a[len(a):] = [x]</code>。</p>
<p>list.<strong>extend</strong>(L)<br>将给定的列表L接到当前列表后面，等价于 <code>a[len(a):] = L</code>。</p>
<p>list.<strong>insert</strong>(i, x)<br>在给定的位置 i 前插入项，例如：a.insert(0, x) 会在列表的头部插入，而 a.insert(len(a), x) 则等价于 a.append(x)。</p>
<p>list.<strong>remove</strong>(x)<br>移除列表中第一个值为 x 的项，没有的话会产生一个错误。</p>
<p>list.<strong>pop</strong>([i])<br>删除列表给定位置的项，并返回它。如果没有指定索引，<code>a.pop()</code> 移除并返回列表的最后一项。（方括号表示可选）</p>
<p>list.<strong>clear</strong>()<br> 删除列表中的所有项，相当于 <code>del a[:]</code>。</p>
<p>list.<strong>index</strong>(x)<br>返回列表中第一个值为 x 的项的索引。如果没有匹配的项, 则产生一个错误。</p>
<p>list.<strong>count</strong>(x)<br>返回列表中 x 出现的次数。</p>
<p>list.<strong>sort</strong>()<br>就地完成列表排序。</p>
<p>list.<strong>reverse</strong>()<br>就地完成列表项的翻转。</p>
<p>list.<strong>copy</strong>()<br>返回列表的一个浅拷贝，相当于<code>a[:]</code>。<br><br></p>
<h3 id="二、列表当栈">二、列表当栈</h3><p>List的方法使得其可以很方便地作为一个<strong>栈</strong>来使用。我们知道，栈的特点是最后进入的元素最先出来（即后入先出），用<code>append()</code>方法进行压栈，用不指定索引的<code>pop()</code>方法进行出栈。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">	stack.append(x)   <span class="comment"># 入栈</span></span><br><span class="line">	print(<span class="string">'push'</span>, x, end=<span class="string">' '</span>)</span><br><span class="line">	print(stack)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Now stack is'</span>, stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(stack)&gt;<span class="number">0</span>:</span><br><span class="line">	print(<span class="string">'pop'</span>, stack.pop(), end=<span class="string">' '</span>) <span class="comment"># 出栈</span></span><br><span class="line">	print(stack)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、列表当队列">三、列表当队列</h3><p>列表还可以当作<strong>队列</strong>来使用，队列的特性是第一个加入的元素第一个取出来（即先入先出）。然而，把列表当队列使用效率并不高，因为从列表的尾部添加和弹出元素是很快的，而在列表的开头插入或弹出是比较慢的（因为所有元素都得移动一个位置）。</p>
<p>要实现一个队列, 使用标准库的<a href="https://docs.python.org/3.4/library/collections.html#collections.deque" target="_blank" rel="external">collections.deque</a>， 它被设计成在两端添加和弹出都很快。示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from collections import <span class="built_in">deque</span></span><br><span class="line"><span class="built_in">queue</span> = <span class="built_in">deque</span>()       <span class="preprocessor"># 创建空队列</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> x in <span class="title">range</span><span class="params">(1,6)</span>:</span><br><span class="line">	<span class="built_in">queue</span>.<span class="title">append</span><span class="params">(x)</span>   # 入队</span><br><span class="line">	<span class="title">print</span><span class="params">('push', x, end=' ')</span></span><br><span class="line">	<span class="title">print</span><span class="params">(<span class="built_in">list</span>(<span class="built_in">queue</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">print</span><span class="params">('Now <span class="built_in">queue</span> is', <span class="built_in">list</span>(<span class="built_in">queue</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="title">len</span><span class="params">(<span class="built_in">queue</span>)</span>&gt;0:</span><br><span class="line">	<span class="title">print</span><span class="params">('pop', <span class="built_in">queue</span>.popleft()</span>, end</span>=<span class="string">' '</span>)  <span class="preprocessor"># 出队</span></span><br><span class="line">	print(<span class="built_in">list</span>(<span class="built_in">queue</span>))</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、列表推导式">四、列表推导式</h3><p>列表推导式提供了从序列创建列表的简单途径。通常程序会对序列的每一个元素做些操作，并以其结果作为新列表的元素，或者根据指定的条件来创建子序列。</p>
<p>列表推导式的结构是：在一个<strong>方括号</strong>里，首先是一个表达式，随后是一个 for 子句，然后是零个或更多的 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。 示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 推导式</span></span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"><span class="comment"># 输出是[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x!=y]  <span class="comment"># 推导式</span></span><br><span class="line"><span class="built_in">print</span>(pairs)</span><br><span class="line"><span class="comment"># 输出是[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="五、列表嵌套">五、列表嵌套</h3><p>Python中并没有二维数组的概念，但我们可以通过<strong>列表嵌套</strong>达到同样的目的。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">mat</span> = [</span><br><span class="line">		[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">		[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">		[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">	  ]</span><br></pre></td></tr></table></figure></p>
<p>同样，我们可以使用推导式生成嵌套的列表：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mat = <span class="string">[[1,2,3], [4,5,6], [7,8,9]]</span></span><br><span class="line">new_mat = [ [row[i] <span class="keyword">for</span> row <span class="keyword">in</span> mat] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] ] # 嵌套</span><br><span class="line"><span class="built_in">print</span>(new_mat)</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><strong>附：del语句</strong></p>
<p><code>del</code>语句可以通过给定索引（而不是值）来删除列表中的项，它与返回一个值的<strong>pop()</strong>方法不同。del语句也可以移除列表中的切片，或者清除整个列表 ：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">2</span>]    <span class="comment"># 删除指定索引项</span></span><br><span class="line">print(lst)    </span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># 删除切片</span></span><br><span class="line">print(lst)</span><br><span class="line"><span class="keyword">del</span> lst[:]    <span class="comment"># 删除整个列表</span></span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p>
<p>del也可以用于删除变量实体：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">del</span> lst</span><br></pre></td></tr></table></figure></p>
<p>在删除变量实体之后引用 <strong>lst</strong> 的话会产生错误。</p>
<p>（全文完）</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>正如<a href="http://songlee24.github.io/2014/08/12/python-FAQ-01/">Python FAQ1附录</a>中说的， Python中任何值都是一个对象，所以任何类型（int、str、list…）都是一个类。而类就必然有它的方法或属性，我们要记下这么多类的所有方法显然是不可能的，这里介绍两个小技巧：</p>
<ul>
<li><strong>dir()</strong> ：内置函数，用来查询一个类或者对象所有属性，比如<code>&gt;&gt;&gt; dir(list)</code>。</li>
<li><strong>help()</strong> ：内置函数，用来查询具体的说明文档，比如<code>&gt;&gt;&gt; help(int)</code>。</li>
</ul>
<p>在<a href="http://songlee24.github.io/2014/08/08/python-basic-02/">Python的基本数据类型</a>中，我们初步了解了list列表，也介绍了列表是Python 中使用最频繁的数据类型。本文将进一步深入学习列表的使用。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python FAQ1：传值，还是传引用？]]></title>
    <link href="http://yoursite.com/2014/08/12/python-FAQ-01/"/>
    <id>http://yoursite.com/2014/08/12/python-FAQ-01/</id>
    <published>2014-08-11T16:19:24.000Z</published>
    <updated>2015-05-10T07:30:07.259Z</updated>
    <content type="html"><![CDATA[<p>在C/C++中，传值和传引用是函数参数传递的两种方式。由于思维定式，从C/C++转过来的Python初学者也经常会感到疑惑：<strong>在Python中，<a href="http://songlee24.github.io/2014/08/09/python-basic-05/" target="_blank" rel="external">函数</a>参数传递是传值，还是传引用呢？</strong></p>
<p>看下面两段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">foo(x)    <span class="comment"># 输出5</span></span><br><span class="line">print(x)  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2]</span></span><br><span class="line">foo(x)</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>看完第一段代码，会有人说这是<strong>值传递</strong>，因为函数并没有改变x的值；看完第二段代码，又会有人说这是<strong>传引用</strong>，因为函数改变了x的内容。</p>
<p>那么，Python中的函数到底是传值还是传引用呢？看下面的解释。</p>
<p><br></p>
<h3 id="一、变量和对象">一、变量和对象</h3><p>我们需要先知道Python中的“变量”与C/C++中“变量”是不同的。</p>
<p><strong>在C/C++中</strong>，当你初始化一个变量时，就是声明一块存储空间并写入值。相当于<strong>把一个值放入一个盒子里</strong>：<br><code>int a = 1;</code><br><img src="http://img.blog.csdn.net/20140811213617169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>现在”a”盒子里放了一个整数1，当给变量a赋另外一个值时会替换盒子a里面的内容：<br><code>a = 2;</code><br><img src="http://img.blog.csdn.net/20140811214003681?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>当你把变量a赋给另外一个变量时，会拷贝a盒子中的值并放入一个新的“盒子”里：<br><code>int b = a;</code><br><img src="http://img.blog.csdn.net/20140811214347058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><img src="http://img.blog.csdn.net/20140811214003681?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>在Python中</strong>，一个变量可以说是<strong>内存中的一个对象的“标签”或“引用”</strong>：<br><code>a = 1</code><br><img src="http://img.blog.csdn.net/20140811215128273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>现在变量a指向了内存中的一个int型的对象（a相当于对象的标签）。如果给a重新赋值，那么标签a将会移动并指向另一个对象：<br><code>a = 2</code><br><img src="http://img.blog.csdn.net/20140811215650741?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>原来的值为1的int型对象仍然存在，但我们不能再通过a这个标识符去访问它了（<strong>当一个对象没有任何标签或引用指向它时，它就会被自动释放</strong>）。如果我们把变量a赋给另一个变量，我们只是给当前内存中对象增加一个“标签”而已：<br><code>b = a</code><br><img src="http://img.blog.csdn.net/20140811220515281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>综上所述，在Python中变量只是一个标签一个标识符，它指向内存中的对象。故<strong>变量并没有类型，类型是属于对象的</strong>，这也是Python中的变量可以被任何类型赋值的原因。</p>
<p><br></p>
<h3 id="二、可变对象与不可变对象">二、可变对象与不可变对象</h3><p>在<a href="http://songlee24.github.io/blog/2014/08/08/python3ji-chu-er/" target="_blank" rel="external"><strong>Python的基本数据类型</strong></a>中，我们知道numbers、strings和tuples是不可更改的对象，而list、dict是可以修改的对象。那么可变与不可变有什么区别呢？看下面示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">a</span> = <span class="number">1</span>     <span class="comment"># a指向内存中一个int型对象</span></span><br><span class="line"><span class="operator">a</span> = <span class="number">2</span>     <span class="comment"># 重新赋值</span></span><br></pre></td></tr></table></figure></p>
<p>当将a重新赋值时，因为原来值为1的对象是不能改变的，所以a会指向一个新的int对象，其值为2。（如上面的图示）<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lst</span> = [<span class="number">1</span>, <span class="number">2</span>]   <span class="comment"># lst指向内存中一个list类型的对象</span></span><br><span class="line">lst[<span class="number">0</span>] = <span class="number">2</span>     <span class="comment"># 重新赋值lst中第一个元素</span></span><br></pre></td></tr></table></figure></p>
<p>因为list类型是可以改变的，所以第一个元素变更为2。更确切的说，lst的第一个元素是int型，重新赋值时一个新的int对象被指定给第一个元素，但是对于lst来说，它所指的列表型对象没有变，只是列表的内容（其中一个元素）改变了。</p>
<p>好了，到这里我们就很容易解释本文开头的两段代码了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">foo(x)    <span class="comment"># 输出5</span></span><br><span class="line">print(x)  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码把x作为参数传递给函数，这时x和arg都指向内存中值为1的对象。然后在函数中arg = 5时，因为int对象不可改变，于是创建一个新的int对象（值为5）并且令arg指向它。而x仍然指向原来的值为1的int对象，所以函数没有改变x变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2]</span></span><br><span class="line">foo(x)</span><br><span class="line">print(x)   <span class="comment"># 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码同样把x传递给函数foo，那么x和arg都会指向同一个list类型的对象。因为list对象是可以改变的，函数中使用append在其末尾添加了一个元素，list对象的内容发生了改变，但是x和arg仍然是指向这一个list对象，所以变量x的内容发生了改变。</p>
<p>那么Python中参数传递是传值，还是传引用呢？准确的回答：<strong>都不是</strong>。之所以不是传值，因为没有产生复制，而且函数拥有与调用者同样的对象。而似乎更像是C++的传引用？但是有时却不能改变实参的值。只能这样说：<strong>对于不可变的对象，它看起来像C++中的传值方式；对于可变对象，它看起来像C++中的按引用传递。</strong></p>
<p><br><br></p>
<h3 id="附：_Everything_is_Object_in_Python">附：  <strong>Everything is Object in Python</strong></h3><p>Python使用对象模型来储存数据，任何类型的值都是一个对象。所有的python对象都有3个特征：身份、类型和值。</p>
<ul>
<li><strong>身份</strong>：每一个对象都有自己的唯一的标识，可以使用内建函数<strong>id()</strong>来得到它。这个值可以被认为是该对象的内存地址。</li>
<li><strong>类型</strong>：对象的类型决定了该对象可以保存的什么类型的值，可以进行什么操作，以及遵循什么样的规则。<strong>type()</strong>函数来查看python 对象的类型。</li>
<li><strong>值</strong>：对象表示的数据项。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">id</span><span class="params">(a)</span></span></span><br><span class="line"><span class="number">140068196051520</span></span><br><span class="line">&gt;&gt;&gt; <span class="tag">b</span> = <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">id</span><span class="params">(b)</span></span></span><br><span class="line"><span class="number">140068196051552</span></span><br><span class="line">&gt;&gt;&gt; c = <span class="tag">a</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">id</span><span class="params">(c)</span></span></span><br><span class="line"><span class="number">140068196051520</span></span><br><span class="line">&gt;&gt;&gt; c is <span class="tag">a</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c is not <span class="tag">b</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>运算符<code>is</code>、<code>is not</code>就是通过id()的返回值（即身份）来判定的，也就是看它们是不是同一个对象的“标签”。</p>
<p>（全文完）<br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++中，传值和传引用是函数参数传递的两种方式。由于思维定式，从C/C++转过来的Python初学者也经常会感到疑惑：<strong>在Python中，<a href="http://songlee24.github.io/2014/08/09/python-basic-05/">函数</a>参数传递是传值，还是传引用呢？</strong></p>
<p>看下面两段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">foo(x)    <span class="comment"># 输出5</span></span><br><span class="line">print(x)  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（五） 函数]]></title>
    <link href="http://yoursite.com/2014/08/09/python-basic-05/"/>
    <id>http://yoursite.com/2014/08/09/python-basic-05/</id>
    <published>2014-08-09T15:58:33.000Z</published>
    <updated>2015-05-10T00:10:59.702Z</updated>
    <content type="html"><![CDATA[<p><strong>函数（function）</strong>是组织好的、可重复使用的、具有一定功能的代码段。函数能提高应用的模块性和代码的重复利用率，Python中已经提供了很多内建函数，比如print()，同时Python还允许用户自定义函数。</p>
<h3 id="定义">定义</h3><p>定义函数使用关键字<code>def</code>，后接函数名和放在圆括号( )中的可选参数列表，函数内容以<strong>冒号</strong>起始并且<strong>缩进</strong>。一般格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">	<span class="string">"""文档字符串"""</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>注意：参数列表可选，文档字符串可选，return语句可选。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="string">"""Print a Fibonacci series"""</span></span><br><span class="line">	a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> b &lt; n:</span><br><span class="line">		print(b, end=<span class="string">' '</span>)</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fib(<span class="number">2000</span>)  <span class="comment"># call</span></span><br><span class="line">f = fib    <span class="comment"># assignment</span></span><br><span class="line">f(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></p>
<p>函数名的值是一种用户自定义的函数类型。函数名的值可以被赋予另一个名字，使其也能作为函数使用。</p>
<p><br></p>
<h3 id="函数变量作用域">函数变量作用域</h3><p>在函数内部定义的变量拥有一个局部作用域，在函数外定义的拥有全局作用域。注意：在函数内部可以引用全局变量，但无法对其赋值（除非用<code>global</code>进行声明）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>         <span class="comment"># 全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'func1() print a ='</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">21</span>    <span class="comment"># 局部变量a</span></span><br><span class="line">	print(<span class="string">'func2() print a ='</span>, a) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> a</span><br><span class="line">	a = <span class="number">10</span>    <span class="comment"># 修改全局变量a</span></span><br><span class="line">	print(<span class="string">'func3() print a ='</span>, a)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br><span class="line">func3()</span><br><span class="line">print(<span class="string">'the global a ='</span>, a)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="函数调用">函数调用</h3><p><strong>1、普通调用</strong></p>
<p>与其他语言中函数调用一样，Python中在调用函数时，需要给定和形参相同个数的实参并按顺序一一对应。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">	print(<span class="string">'Name:'</span>,name,<span class="string">'Age:'</span>,age,<span class="string">'Gender:'</span>,gender,end=<span class="string">' '</span>)</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fun(<span class="string">'Jack'</span>, <span class="number">20</span>, <span class="string">'man'</span>) <span class="comment"># call</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、使用关键字参数调用函数</strong></p>
<p>函数也可以通过<code>keyword=value</code> 形式的关键字参数来调用，因为我们明确指出了对应关系，所以参数的顺序也就无关紧要了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">	print(<span class="string">'Name:'</span>,name,<span class="string">'Age:'</span>,age,<span class="string">'Gender:'</span>,gender,end=<span class="string">' '</span>)</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fun(gender=<span class="string">'man'</span>, name=<span class="string">'Jack'</span>, age=<span class="number">20</span>) <span class="comment"># using keyword arguments</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3、调用具有默认实参的函数</strong></p>
<p>Python中的函数也可以给一个或多个参数指定默认值，这样在调用时可以选择性地省略该参数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">fun</span><span class="params">(a, b, c=5)</span>:</span></span><br><span class="line">	print(a+b+c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2)</span></span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2,3)</span></span></span><br></pre></td></tr></table></figure></p>
<p><em>注意</em>：通常情况下默认值只被计算一次，但如果默认值是一个<strong>可变对象</strong>时会有所不同, 如列表, 字典, 或大多类的对象时。例如，下面的函数在随后的调用中会累积参数值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">fun</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">	L.append(a)</span><br><span class="line">	print(L)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1)</span>  # 输出[1]</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(2)</span>  # 输出[1, 2]</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(3)</span>  # 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4、调用可变参数函数</strong></p>
<p>通过在形参前加一个星号（*）或两个星号（**）来指定函数可以接收任意数量的实参。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(*args)</span>:</span></span><br><span class="line">	print(type(args))</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt;</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(**args)</span>:</span></span><br><span class="line">	print(type(args))</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">fun(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>,e=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br><span class="line"><span class="comment"># &#123;'d': 4, 'e': 5, 'b': 2, 'c': 3, 'a': 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>从两个示例的输出可以看出：当参数形如<code>*args</code>时，传递给函数的任意个实参会按位置被包装进一个元组（tuple）；当参数形如<code>**args</code>时，传递给函数的任意个<code>key=value</code>实参会被包装进一个字典（dict）。</p>
<p><strong>5、通过解包参数调用函数</strong></p>
<p>上一点说到传递任意数量的实参时会将它们打包进一个元组或字典，当然有打包也就有<strong>解包（unpacking）</strong>。通过 单星号和双星号对List、Tuple和Dictionary进行解包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span>:</span></span><br><span class="line">	print(a+b+c)</span><br><span class="line"></span><br><span class="line">fun()   <span class="comment"># 正常调用</span></span><br><span class="line">list1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">dict1 = &#123;<span class="string">'a'</span>:<span class="number">40</span>, <span class="string">'b'</span>:<span class="number">50</span>, <span class="string">'c'</span>:<span class="number">60</span>&#125;</span><br><span class="line">fun(*list1)   <span class="comment"># 解包列表</span></span><br><span class="line">fun(**dict1)  <span class="comment"># 解包字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 66</span></span><br><span class="line"><span class="comment"># 150</span></span><br></pre></td></tr></table></figure></p>
<p>注：*用于解包Sequence，**用于解包字典。解包字典会得到一系列的<code>key=value</code>，故本质上就是使用<strong>关键字参数</strong>调用函数。</p>
<p><br></p>
<h3 id="lambda表达式">lambda表达式</h3><p>lambda关键词能创建小型匿名函数。lambda函数能接收任何数量的参数但只能返回一个表达式的值，它的一般形式如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">lambda</span> [<span class="atom">arg1</span> [,<span class="atom">arg2</span>,.....<span class="atom">argn</span>]] : <span class="atom">expression</span></span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以在任何需要函数对象的地方使用，它们在语法上被限制为单一的表达式：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda x, y: x+<span class="literal">y</span></span><br><span class="line"><span class="keyword">print</span>(<span class="literal">f</span>(10, 20))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_fun</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> x: x+n</span><br><span class="line"></span><br><span class="line">f = make_fun(<span class="number">15</span>)</span><br><span class="line">print(f(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="文档字符串">文档字符串</h3><p>函式体的第一个语句可以是三引号括起来的字符串， 这个字符串就是函数的<strong>文档字符串</strong>，或称为docstring 。我们可以使用<code>print(function.__doc__)</code>输出文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""Some information of this function.</span><br><span class="line">	This is documentation string."""</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">print(fun.__doc__)</span><br></pre></td></tr></table></figure></p>
<p>文档字符串主要用于描述一些关于函数的信息，让用户交互地浏览和输出。建议养成在代码中添加文档字符串的好习惯。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>函数（function）</strong>是组织好的、可重复使用的、具有一定功能的代码段。函数能提高应用的模块性和代码的重复利用率，Python中已经提供了很多内建函数，比如print()，同时Python还允许用户自定义函数。</p>
<h3 id="定义">定义</h3><p>定义函数使用关键字<code>def</code>，后接函数名和放在圆括号( )中的可选参数列表，函数内容以<strong>冒号</strong>起始并且<strong>缩进</strong>。一般格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">	<span class="string">"""文档字符串"""</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（四） 条件与循环控制]]></title>
    <link href="http://yoursite.com/2014/08/09/python-basic-04/"/>
    <id>http://yoursite.com/2014/08/09/python-basic-04/</id>
    <published>2014-08-09T00:28:43.000Z</published>
    <updated>2015-05-09T23:59:59.883Z</updated>
    <content type="html"><![CDATA[<p>Python的流程控制语句包括：if条件语句、while循环语句、for循环语句、range函数以及break、continue、pass控制语句。这些语句在Python中的语义和在其他语言中是一样的，所以这里就只说它们的写法。</p>
<h3 id="if语句">if语句</h3><p>if语句是最常用的条件控制语句，Python中的一般形式为：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件一:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">elif</span> 条件二:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure></p>
<p>Python中用<code>elif</code>代替了<code>else if</code>，所以if语句的关键字为：if - elif - else。</p>
<p><strong>注意</strong>：<br>1、每个条件后面要使用<strong>冒号（:）</strong>，表示接下来是满足条件后要执行的语句块。<br>2、使用<strong>缩进</strong>来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>3、在Python中没有switch - case语句。</p>
<p>示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="function"><span class="title">int</span><span class="params">(input(<span class="string">"Please enter an integer: "</span>)</span></span>)</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Negative.'</span>)</span></span></span><br><span class="line">elif x == <span class="number">0</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Zero.'</span>)</span></span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Positive.'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="while语句">while语句</h3><p>Python中while语句的一般形式：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure></p>
<p>同样需要注意冒号和缩进。另外，在Python中<strong>没有do..while循环</strong>。</p>
<p>示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">10</span>:  <span class="comment"># 循环输出斐波纳契数列</span></span><br><span class="line">	print(b)</span><br><span class="line">	<span class="operator">a</span>, b = b, <span class="operator">a</span>+b</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="for语句">for语句</h3><p>Python中的for语句与C语言中的for语句有点不同：<strong>C语言中的for语句允许用户自定义迭代步骤和终止条件；而Python的for语句可以遍历任何序列（sequence），按照元素在序列中的出现顺序依次迭代。</strong>一般形式为：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">variable</span> <span class="keyword">in</span> <span class="keyword">sequence</span>:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'cat'</span>,<span class="string">'love'</span>,<span class="string">'apple'</span>,<span class="string">'python'</span>,<span class="string">'friends'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">words</span>:</span><br><span class="line">	print(<span class="keyword">item</span>, <span class="built_in">len</span>(<span class="keyword">item</span>))</span><br></pre></td></tr></table></figure></p>
<p>如果你需要在循环体内修改你正迭代的序列，你最好是制作一个副本，这时<a href="http://blog.csdn.net/lisonglisonglisong/article/details/38440761" target="_blank" rel="external">切片标记</a>就非常有用了：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'cat'</span>,<span class="string">'love'</span>,<span class="string">'apple'</span>,<span class="string">'python'</span>,<span class="string">'friends'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">words</span>[:]:    <span class="comment"># 制作整个列表的切片副本</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(<span class="keyword">item</span>) &gt;= <span class="number">6</span>:</span><br><span class="line">		<span class="keyword">words</span>.insert(<span class="number">0</span>, <span class="keyword">item</span>)</span><br><span class="line">print(<span class="keyword">words</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们注意到循环语句中还可以使用<code>else子句</code>，下面第五点有讲到。</p>
<p><br></p>
<h3 id="range函数">range函数</h3><p>如果你要遍历一个数字序列，那么内置的<strong>range()</strong>函数就可以派上用场了。函数range()常用于for循环中，用于产生一个算术数列：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">10</span>))   <span class="comment"># 默认从0开始</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">1</span>, <span class="number">11</span>))  <span class="comment"># 从1到11，前闭后开</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>))  <span class="comment"># 5表示步长，每隔5取一个数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">2</span>, <span class="number">11</span>)</span></span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(i)</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="break、continue、pass及else子句">break、continue、pass及else子句</h3><p><strong>break</strong></p>
<p>break语句与C语言中的一样，跳出最近的for或while循环。</p>
<p><strong>continue</strong></p>
<p>continue语句同样是从 C 语言借用的, 它终止当前迭代而进行循环的<br>下一次迭代。</p>
<p><strong>pass</strong></p>
<p>pass语句什么都不做，它只在语法上需要一条语句但程序不需要任何操作时使用。pass语句是为了保持程序结构的完整性。</p>
<p><strong>else子句</strong></p>
<p>在循环语句中还可以使用<code>else子句</code>，else子句在<strong>序列遍历结束</strong>（for语句）或<strong>循环条件为假</strong>（while语句）时执行，但循环被break终止时不执行：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 循环结束执行<span class="keyword">else</span>子句</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(2, 11):</span><br><span class="line">	<span class="keyword">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span>('<span class="keyword">for</span> statement is over.')</span><br><span class="line"></span><br><span class="line"># 被<span class="keyword">break</span>终止时不会执行<span class="keyword">else</span>子句</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(5):</span><br><span class="line">	<span class="keyword">if</span>(i == 4):</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span>('<span class="keyword">for</span> statement is over')  # 不会输出</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python的流程控制语句包括：if条件语句、while循环语句、for循环语句、range函数以及break、continue、pass控制语句。这些语句在Python中的语义和在其他语言中是一样的，所以这里就只说它们的写法。</p>
<h3 id="if语句">if语句</h3><p>if语句是最常用的条件控制语句，Python中的一般形式为：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（三） 运算符]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-03/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-03/</id>
    <published>2014-08-08T12:13:46.000Z</published>
    <updated>2015-05-10T07:24:58.749Z</updated>
    <content type="html"><![CDATA[<p>Python中的运算符大部分与C语言的类似，但也有很多不同的地方。这里就大概地罗列一下Python 3中的运算符。</p>
<h3 id="算术运算符">算术运算符</h3><a id="more"></a>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>x + y</td>
<td>加</td>
<td>10+20=30</td>
</tr>
<tr>
<td>x - y</td>
<td>减</td>
<td>10-5=5</td>
</tr>
<tr>
<td>x * y</td>
<td>乘</td>
<td>3*6=18</td>
</tr>
<tr>
<td>x / y</td>
<td>除-返回浮点数</td>
<td>2/4 = 0.5</td>
</tr>
<tr>
<td>x // y</td>
<td>取整除 - 返回商的整数部分</td>
<td>2//4 = 0</td>
</tr>
<tr>
<td>x % y</td>
<td>取余</td>
<td>15 % 4 = 3</td>
</tr>
<tr>
<td>-x</td>
<td>异号</td>
<td>-(-5) = 5</td>
</tr>
<tr>
<td>+x</td>
<td>不变号</td>
<td>+5 = 5</td>
</tr>
<tr>
<td>abs(x)</td>
<td>取绝对值</td>
<td>abs(-0.4) = 0.4</td>
</tr>
<tr>
<td>int(x)</td>
<td>x转换为整数</td>
<td>int(5.9) = 5</td>
</tr>
<tr>
<td>float(x)</td>
<td>x转换为浮点数</td>
<td>float(5) = 5.0</td>
</tr>
<tr>
<td>complex(re, im)</td>
<td>返回复数 - re为实数部分 im为虚数部分</td>
<td>complex(4,3) = 4+3j</td>
</tr>
<tr>
<td>c.conjugate()</td>
<td>返回c的共轭复数</td>
<td>c=4+3j; c.conjugate() = 4-3j</td>
</tr>
<tr>
<td>divmod(x, y)</td>
<td>返回一个数值对(x//y, x%y)</td>
<td>divmod(8, 3) = (2, 2)</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>x的y次幂</td>
<td>pow(2, 5) = 32</td>
</tr>
<tr>
<td>x**y</td>
<td>x的y次幂</td>
<td>2 ** 5 = 32</td>
</tr>
</tbody>
</table>
<p>Note：</p>
<ol>
<li>双斜杠 // 除法总是向下取整。 </li>
<li>从符点数到整数的转换可能会舍入也可能截断，建议使用math.floor()和math.ceil()明确定义的转换。</li>
<li>Python定义<code>pow(0, 0)</code>和<code>0 ** 0</code>等于1。</li>
</ol>
<p><br></p>
<h3 id="比较运算符">比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>is</td>
<td>判断两个标识符是不是引用自一个对象</td>
</tr>
<tr>
<td>is not</td>
<td>判断两个标识符是不是引用自不同对象</td>
</tr>
</tbody>
</table>
<p>Note： </p>
<ol>
<li>八个比较运算符优先级相同。</li>
<li>Python允许<code>x &lt; y &lt;= z</code>这样的链式比较，它相当于<code>x &lt; y and y &lt;= z</code>。 </li>
<li>复数不能进行大小比较，只能比较是否相等。</li>
</ol>
<p><br></p>
<h3 id="逻辑运算符">逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x or y</td>
<td>if x is false, then y, else x</td>
</tr>
<tr>
<td>x and y</td>
<td>if x is false, then x, else y</td>
</tr>
<tr>
<td>not x</td>
<td>if x is false, then True, else False</td>
</tr>
</tbody>
</table>
<p>Note： </p>
<ol>
<li><code>or</code>是个短路运算符，它只有在第一个运算数为False时才会计算第二个运算数的值。</li>
<li><code>and</code>也是个短路运算符，它只有在第一个运算数为True时才会计算第二个运算数的值。</li>
<li><code>not</code>的优先级比其他类型的运算符低，所以not a == b相当于not (a == b)，而 a == not b是错误的。</li>
</ol>
<p><br></p>
<h3 id="位运算符">位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x &#124; y</td>
<td>按位或运算符</td>
</tr>
<tr>
<td>x &amp; y</td>
<td>按位与运算符</td>
</tr>
<tr>
<td>x ^ y</td>
<td>按位异或运算符</td>
</tr>
<tr>
<td>x &lt;&lt; n</td>
<td>左移动运算符</td>
</tr>
<tr>
<td>x &gt;&gt; n</td>
<td>右移动运算符</td>
</tr>
<tr>
<td>~x</td>
<td>按位取反运算符</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="赋值运算符">赋值运算符</h3><p>复合赋值运算符与算术运算符是一一对应的：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
</tr>
<tr>
<td>//=</td>
<td>取整除法运算符</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="成员运算符">成员运算符</h3><p>Python提供了成员运算符，测试一个元素是否在一个序列（Sequence）中。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在指定的序列中找到值返回True，否则返回False。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回True，否则返回False。</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中的运算符大部分与C语言的类似，但也有很多不同的地方。这里就大概地罗列一下Python 3中的运算符。</p>
<h3 id="算术运算符">算术运算符</h3>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（二） 基本数据类型]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-02/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-02/</id>
    <published>2014-08-08T08:00:56.000Z</published>
    <updated>2015-05-09T23:57:04.233Z</updated>
    <content type="html"><![CDATA[<p>Python中的变量<strong>不需要声明</strong>。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在Python中，变量就是变量，它没有类型，<strong>我们所说的“类型”是变量所指的内存中对象的类型</strong>。Python 3中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<p>本文主要先介绍这几种数据类型的定义和它们之间的联系与区别。<br><a id="more"></a></p>
<h3 id="Numbers">Numbers</h3><p>Python 3支持<strong>int、float、bool、complex</strong>（复数）。数值类型的赋值和计算都是很直观的，就像大多数语言一样。内置的<code>type()</code>函数可以用来查询变量所指的对象类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="keyword">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; &lt;<span class="title">class</span> '<span class="title">float</span>'&gt; &lt;<span class="title">class</span> '<span class="title">bool</span>'&gt; &lt;<span class="title">class</span> '<span class="title">complex</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>数值运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余 </span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p><strong>要点</strong>：<br>1、Python可以同时为多个变量赋值，如<code>a, b = 1, 2</code>。<br>2、一个变量可以通过赋值指向不同类型的对象。<br>3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。<br>4、在混合计算时，Pyhton会把整型转换成为浮点数。</p>
<h3 id="Strings">Strings</h3><p>Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来，同时使用反斜杠(\)转义特殊字符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = <span class="string">'Yes,he doesn\'t'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(s, type(s), len(s))</span><br><span class="line">Yes,he doesn<span class="string">'t &lt;class '</span>st<span class="string">r'&gt; 14</span></span><br></pre></td></tr></table></figure></p>
<p>如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)</span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)</span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure></p>
<p>另外，反斜杠可以作为续行符，表示下一行是上一行的延续。还可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>跨越多行。</p>
<p>字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'str'</span>+<span class="string">'ing'</span>, <span class="string">'my'</span>*<span class="number">3</span>)</span><br><span class="line">string mymymy</span><br></pre></td></tr></table></figure></p>
<p>Python中的字符串有<strong>两种索引方式</strong>，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。注意，没有单独的字符类型，一个字符就是长度为1的字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></p>
<p>还可以对字符串进行<strong>切片</strong>，获取一段子串。用冒号分隔两个索引，形式为<code>变量[头下标:尾下标]</code>。截取的范围是前闭后开的，并且两个索引都可以省略：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word = <span class="string">'ilovepython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">1</span><span class="symbol">:</span><span class="number">5</span>]</span><br><span class="line"><span class="string">'love'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="symbol">:</span>]</span><br><span class="line"><span class="string">'ilovepython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">5</span><span class="symbol">:</span>]</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[-<span class="number">10</span><span class="symbol">:-</span><span class="number">6</span>]</span><br><span class="line"><span class="string">'love'</span></span><br></pre></td></tr></table></figure></p>
<p>与C字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如<code>word[0] = &#39;m&#39;</code>会导致错误。</p>
<p><strong>要点</strong>：<br>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。<br>2、字符串可以用+运算符连接在一起，用*运算符重复。<br>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。<br>4、Python中的字符串不能改变。</p>
<h3 id="List">List</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。列表是写在<strong>方括号</strong>之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = [<span class="string">'him'</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="string">'her'</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line">[<span class="string">'him'</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="string">'her'</span>]</span><br></pre></td></tr></table></figure></p>
<p>和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。详细的在这里就不赘述了。</p>
<p>列表还支持串联操作，使用+操作符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a + [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p>与Python字符串不一样的是，列表中的元素是可以改变的：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>] = []   <span class="comment"># 删除</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。</p>
<p><strong>要点</strong>：<br>1、List写在方括号之间，元素用逗号隔开。<br>2、和字符串一样，list可以被索引和切片。<br>3、List可以使用+操作符进行拼接。<br>4、List中的元素是可以改变的。</p>
<h3 id="Tuple">Tuple</h3><p>元组（tuple）与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。元组写在<strong>小括号</strong>里，元素之间用逗号隔开。元组中的元素类型也可以不相同：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = <span class="list">(<span class="number">1991</span>, <span class="number">2014</span>, <span class="quoted">'physics</span>', <span class="quoted">'math</span>')</span></span><br><span class="line">&gt;&gt;&gt; print<span class="list">(<span class="keyword">a</span>, type<span class="list">(<span class="keyword">a</span>)</span>, len<span class="list">(<span class="keyword">a</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1991</span>, <span class="number">2014</span>, <span class="quoted">'physics</span>', <span class="quoted">'math</span>')</span> &lt;class <span class="quoted">'tuple</span><span class="quoted">'&gt;</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。其实，可以把字符串看作一种特殊的元组。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(tup[<span class="number">0</span>], tup[<span class="number">1</span><span class="symbol">:</span><span class="number">5</span>])</span><br><span class="line"><span class="number">1</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup[<span class="number">0</span>] = <span class="number">11</span>  <span class="comment"># 修改元组元素的操作是非法的</span></span><br></pre></td></tr></table></figure></p>
<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">tup1 =</span> () <span class="comment"># 空元组</span></span><br><span class="line"><span class="variable">tup2 =</span> (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></p>
<p>另外，元组也支持用+操作符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup1, tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(tup1+tup2)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<p>string、list和tuple都属于<strong>sequence（序列）</strong>。</p>
<p>要点：<br>1、与字符串一样，元组的元素不能修改。<br>2、元组也可以被索引和切片，方法一样。<br>3、注意构造包含0或1个元素的元组的特殊语法规则。<br>4、元组也可以使用+操作符进行拼接。</p>
<h3 id="Sets">Sets</h3><p>集合（set）是一个<strong>无序不重复</strong>元素的集。基本功能是进行成员关系测试和消除重复元素。可以使用<strong>大括号</strong> 或者 <strong>set()函数</strong>创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; student = &#123;<span class="string">'Tom'</span>, <span class="string">'Jim'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(student)   <span class="comment"># 重复的元素被自动去掉</span></span><br><span class="line">&#123;<span class="string">'Jim'</span>, <span class="string">'Jack'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Rose'</span> in student  <span class="comment"># membership testing（成员测试）</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="comment"># set可以进行集合运算</span></span><br><span class="line">... </span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a - b     <span class="comment"># a和b的差集</span></span><br><span class="line">&#123;<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a | b     <span class="comment"># a和b的并集</span></span><br><span class="line">&#123;<span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a &amp; b     <span class="comment"># a和b的交集</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a ^ b     <span class="comment"># a和b中不同时存在的元素</span></span><br><span class="line">&#123;<span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>要点：<br>1、set集合中的元素不重复，重复了它会自动去掉。<br>2、set集合可以用大括号或者set()函数创建，但空集合必须使用set()函数创建。<br>3、set集合可以用来进行成员测试、消除重复元素。 </p>
<h3 id="Dictionary">Dictionary</h3><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。字典是一种映射类型（mapping type），它是一个无序的<strong>键 : 值</strong>对集合。关键字必须使用不可变类型，也就是说list和包含可变类型的tuple不能做关键字。在同一个字典中，关键字还必须互不相同。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dic = &#123;&#125;  <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel = &#123;<span class="string">'Jack'</span><span class="symbol">:</span><span class="number">1557</span>, <span class="string">'Tom'</span><span class="symbol">:</span><span class="number">1320</span>, <span class="string">'Rose'</span><span class="symbol">:</span><span class="number">1886</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel</span><br><span class="line">&#123;<span class="string">'Tom'</span><span class="symbol">:</span> <span class="number">1320</span>, <span class="string">'Jack'</span><span class="symbol">:</span> <span class="number">1557</span>, <span class="string">'Rose'</span><span class="symbol">:</span> <span class="number">1886</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel[<span class="string">'Jack'</span>]   <span class="comment"># 主要的操作：通过key查询</span></span><br><span class="line"><span class="number">1557</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; del tel[<span class="string">'Rose'</span>]  <span class="comment"># 删除一个键值对</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel[<span class="string">'Mary'</span>] = <span class="number">4127</span>  <span class="comment"># 添加一个键值对</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel</span><br><span class="line">&#123;<span class="string">'Tom'</span><span class="symbol">:</span> <span class="number">1320</span>, <span class="string">'Jack'</span><span class="symbol">:</span> <span class="number">1557</span>, <span class="string">'Mary'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(tel.keys())  <span class="comment"># 返回所有key组成的list</span></span><br><span class="line">[<span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Mary'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sorted(tel.keys()) <span class="comment"># 按key排序</span></span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Tom'</span> in tel       <span class="comment"># 成员测试</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Mary'</span> not in tel  <span class="comment"># 成员测试</span></span><br><span class="line"><span class="constant">False</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数 <strong>dict()</strong> 直接从键值对sequence中构建字典，当然也可以进行推导，如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dict([(<span class="string">'sape'</span>, <span class="number">4139</span>), (<span class="string">'guido'</span>, <span class="number">4127</span>), (<span class="string">'jack'</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">'jack'</span><span class="symbol">:</span> <span class="number">4098</span>, <span class="string">'sape'</span><span class="symbol">:</span> <span class="number">4139</span>, <span class="string">'guido'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; &#123;<span class="symbol">x:</span> x**<span class="number">2</span> for x in (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span><span class="symbol">:</span> <span class="number">4</span>, <span class="number">4</span><span class="symbol">:</span> <span class="number">16</span>, <span class="number">6</span><span class="symbol">:</span> <span class="number">36</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dict(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">'jack'</span><span class="symbol">:</span> <span class="number">4098</span>, <span class="string">'sape'</span><span class="symbol">:</span> <span class="number">4139</span>, <span class="string">'guido'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p>要点：<br>1、字典是一种映射类型，它的元素是键值对。<br>2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用{ }。 </p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中的变量<strong>不需要声明</strong>。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在Python中，变量就是变量，它没有类型，<strong>我们所说的“类型”是变量所指的内存中对象的类型</strong>。Python 3中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<p>本文主要先介绍这几种数据类型的定义和它们之间的联系与区别。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（一） Hello World]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-01/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-01/</id>
    <published>2014-08-08T02:35:14.000Z</published>
    <updated>2015-05-09T23:55:19.007Z</updated>
    <content type="html"><![CDATA[<p>对于新手一般会遇到一个问题：<strong>学习Python 2还是Python 3呢？</strong>  对于我个人而言，我是个完全的新手，没有历史包袱，所以我直接学习Python 3。我相信在未来几年，Python 3会逐步取代Python 2成为主流。</p>
<p>Python是一门解释型、面向对象、动态数据类型的高级程序设计语言，更多的介绍看<a href="https://docs.python.org/3.4/tutorial/appetite.html" target="_blank" rel="external">官方文档</a>。Python让程序更加的紧凑、可读性更强，用 Python 写的程序通常比同样的C、C++或Java程序要短得多，这是因为以下几个原因：<br><a id="more"></a></p>
<ul>
<li>高级数据结构使你能够在单条的语句中表达复杂的操作。</li>
<li>代码块的组织依赖于缩进而不是开始/结束符，例如{ }。</li>
<li>参数或变量不需要声明。</li>
</ul>
<p>OK！下面开始让我们进入Python的世界吧！</p>
<h3 id="第一个HelloWorld程序">第一个HelloWorld程序</h3><p><strong>1、交互模式</strong></p>
<p>交互模式即命令行模式，在Linux终端输入<code>$python</code>即可进入Python交互模式，主提示符&gt;&gt;&gt;提示你输入命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="constant">Python</span> <span class="number">3.3</span>.<span class="number">2</span> (default, <span class="constant">Jun</span> <span class="number">30</span> <span class="number">2014</span>, <span class="number">17</span><span class="symbol">:</span><span class="number">20</span><span class="symbol">:</span><span class="number">03</span>) </span><br><span class="line">[<span class="constant">GCC</span> <span class="number">4.8</span>.<span class="number">3</span> <span class="number">20140624</span> (<span class="constant">Red</span> <span class="constant">Hat</span> <span class="number">4.8</span>.<span class="number">3</span>-<span class="number">1</span>)] on linux</span><br><span class="line"><span class="constant">Type</span> <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>输入多行结构时就需要从属提示符了，例如下面这个if语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>flag=<span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">if</span> flag:</span><br><span class="line"><span class="prompt">... </span>    print(<span class="string">"Hello World!"</span>)</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">Hello World!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>注：在Python 3.x中，print是一个函数，所以必须使用括号输出。</p>
<p><strong>2、脚本文件</strong></p>
<p>我们也可以将代码写到一个.py文件中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后用python命令执行该脚本文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python hello<span class="class">.py</span> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p><strong>3、可执行脚本</strong></p>
<p>在类Unix系统中，Python脚本可以像Shell脚本那样直接执行，通过在脚本文件开头添加一行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br></pre></td></tr></table></figure></p>
<p>然后通过chmod命令修改权限为可执行：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>chmod +x hello.py</span><br></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello<span class="class">.py</span> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="基础语法">基础语法</h3><p><strong>1、编码</strong></p>
<p>默认情况下，Python 3源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。当然你也可以为源码文件指定不同的编码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、标识符</strong></p>
<p>在Python 3中，非-ASCII 标识符也是允许的了。但最好还是只使用英文、数字、下划线作为标识符，并且不能以数字开头。（区分大小写）</p>
<p><strong>3、python保留字</strong></p>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个<a href="https://docs.python.org/2/library/keyword.html" target="_blank" rel="external">keyword</a> module，可以输出当前版本的所有关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>4、注释</strong></p>
<p>Python中单行注释以#开头，多行注释用三个单引号（’’’）或者三个双引号（”””）将注释括起来。</p>
<p><strong>5、行与缩进</strong></p>
<p>python最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<p><br><br><br><br><br></p>
<h3 id="附：">附：</h3><p>在现在的Unix/Linux系统中都会内置Python解释器，在我的Fedora20系统中就同时装了python2和python3。在终端输入<code>$python</code>会使用python 2.x的解释器，输入<code>$python3</code>会使用python 3.x的解释器。现在我想修改一下<strong>软链接</strong>，让<code>$python</code>命令默认使用python 3.x解释器，<code>$python2</code>命令使用python 2.x解释器。怎么做？</p>
<p><strong>软链接：</strong> 一种特殊的文件，该文件的内容是指向另一个文件的位置或路径。它不占用磁盘空间，类似于Windows操作系统中的快捷方式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">硬链接：<span class="tag">ln</span> <span class="attr_selector">[参数]</span> 源文件 目标文件</span><br><span class="line">软链接：<span class="tag">ln</span> <span class="tag">-s</span> <span class="attr_selector">[源文件或目录]</span> <span class="attr_selector">[目标文件或目录]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>ln命令</strong>的功能是为某一个文件在另外一个位置建立一个同步的链接（软链接或者硬链接），现在我要修改python的软链接：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/python2.7 /</span>usr<span class="regexp">/bin/</span>python2  <span class="comment">// 创建python2软链接</span></span><br><span class="line">$ sudo rm <span class="regexp">/usr/</span>bin<span class="regexp">/python  /</span>/ 删除原来的python软链接</span><br><span class="line">$ sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/python3.3 /</span>usr<span class="regexp">/bin/</span>python  <span class="comment">// 创建新的python软链接</span></span><br></pre></td></tr></table></figure></p>
<p>修改了软链接以后的一个伴随的问题是：有些用python写的命令不能执行了，因为python2和python3的语法不兼容。比如<strong>yum命令</strong>，它是python写的，从yum文件开头的<code>#!/usr/bin/python</code>可以看出来。因为python软链接被修改为指向python 3.x解释器，所以执行yum命令时会报语法错误。</p>
<p>我们可以通过修改yum文件来修复这个问题，既然之前我们已经创建了python2软链接指向python 2.x解释器，所以我们修改yum文件开头为<code>#!/usr/bin/python2</code>就可以了，这样在执行yum命令时就会使用python 2.x解释器而不是python 3.x的解释器了。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于新手一般会遇到一个问题：<strong>学习Python 2还是Python 3呢？</strong>  对于我个人而言，我是个完全的新手，没有历史包袱，所以我直接学习Python 3。我相信在未来几年，Python 3会逐步取代Python 2成为主流。</p>
<p>Python是一门解释型、面向对象、动态数据类型的高级程序设计语言，更多的介绍看<a href="https://docs.python.org/3.4/tutorial/appetite.html">官方文档</a>。Python让程序更加的紧凑、可读性更强，用 Python 写的程序通常比同样的C、C++或Java程序要短得多，这是因为以下几个原因：<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1987年国际C语言混乱代码大赛获奖的一行代码]]></title>
    <link href="http://yoursite.com/2014/08/06/Obfuscated-C-Code-Contest/"/>
    <id>http://yoursite.com/2014/08/06/Obfuscated-C-Code-Contest/</id>
    <published>2014-08-06T09:15:43.000Z</published>
    <updated>2015-05-09T18:31:06.371Z</updated>
    <content type="html"><![CDATA[<p>最近<a href="http://coolshell.cn" target="_blank" rel="external">CoolShell博主</a>做了一个很有意思的在线puzzle，这些谜题很有趣同时也有一定的难度。由于水平有限，我并没有通关，我觉得这些题还是很值得一做的，从中可以学到很多东西。</p>
<p>例如其中的第二题：<br><img src="http://img.blog.csdn.net/20140806160507493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><a id="more"></a></p>
<p>题目中给出了一个键盘和一行看不懂的字符串。这个键盘的<strong>键盘布局</strong>和现在通用的键盘（<strong>QWERTY键盘</strong>）不一样，它叫做<strong><a href="http://baike.baidu.com/view/1410112.htm" target="_blank" rel="external">Dvorak键盘</a></strong>。这里就不多作解释了，详细的可以去Google。根据提示：<strong>我们需要通过两种键盘的布局映射，将给出的字符串转换成QWERTY键盘下的输出。</strong>当然，你可以自己一对一写出来，不过<a href="http://wbic16.xedoloh.com/dvorak.html" target="_blank" rel="external">在线转换工具</a>更方便。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">macb</span><span class="params">()</span> ? <span class="title">lpcbyu</span><span class="params">(&amp;gbcq/<span class="variable">_</span>\<span class="number">021</span><span class="comment">%ocq\012\0_=w(gbcq)/_dak._=&#125;_ugb_[0q60)s+</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>转换之后得到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() &#123; <span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是1987年<strong>国际C语言混乱代码大赛（The International Obfuscated C Code Contest, IOCCC）</strong>一等奖的获奖代码，由贝尔实验室的David Korn提交。当然平时我们不会写出这么复杂难懂的代码，但是分析这样的代码却可以扩展我们的知识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* unix被编译器内定为一个宏 </span><br><span class="line">	 * 相当于#define unix 1     */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"unix=%d\n"</span>, unix); <span class="comment">/* =1 */</span>	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印字符串"un"，因为"fun"是个字符数组</span><br><span class="line">	 * "fun"+1相当于字符指针右移，指向"un" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="string">"fun"</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* "have"是个字符数组，"have"[1]即字符a</span><br><span class="line">	 * 输出97，即第二个字符'a'的ASCII值。*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="string">"have"</span>[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在C语言中，x[1] = 1[x] */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span>)[<span class="string">"have"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 97 - 96 = 0x61 - 0x60 = 1 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span>)[<span class="string">"have"</span>] - <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所以 "fun"+((1)["have"]-0x60) 相当于"fun"+1，输出"un" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"fun"</span> + ((<span class="number">1</span>)[<span class="string">"have"</span>] - <span class="number">0x60</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将其中的1用unix代替 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 以上为后半部分 = "un" */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面两个都输出"bcde", 因为指针都是从'b'开始 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"abcde"</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;<span class="string">"abcde"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &amp;"abcde"[1] == &amp;(1)["abcde"]  输出一样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;(<span class="number">1</span>)[<span class="string">"abcde"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1用unix代替 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;unix[<span class="string">"abcde"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面输出"%six" 并换行 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;<span class="string">"?%six\n"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注意：</span><br><span class="line">	   \012 = 0x0a = \n, </span><br><span class="line">	   第一个字符 \021 被跳过</span><br><span class="line">	   \0 是空字符  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 同样输出"%six" 并换行 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;<span class="string">"\021%six\012\0"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相当于这样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;unix[<span class="string">"\021%six\012\0"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 把字符串"%six\n"当作格式，输出"ABix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>], <span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相当于这样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%six\n"</span>, <span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所以下面的可以输出"unix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%six\n"</span>, (unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 至此，问题解决！！！输出"unix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要用到了x[a]和指针运算的一些知识，相信上面的步骤和注释已经很清楚了，最终结果就是输出<code>unix</code>。<br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近<a href="http://coolshell.cn">CoolShell博主</a>做了一个很有意思的在线puzzle，这些谜题很有趣同时也有一定的难度。由于水平有限，我并没有通关，我觉得这些题还是很值得一做的，从中可以学到很多东西。</p>
<p>例如其中的第二题：<br><img src="http://img.blog.csdn.net/20140806160507493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">]]>
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之普通函数指针与成员函数指针]]></title>
    <link href="http://yoursite.com/2014/08/01/cpp-function-pointer/"/>
    <id>http://yoursite.com/2014/08/01/cpp-function-pointer/</id>
    <published>2014-08-01T11:43:55.000Z</published>
    <updated>2015-05-09T18:27:27.205Z</updated>
    <content type="html"><![CDATA[<p><strong>函数指针（function pointer）</strong>是通过指向函数的指针间接调用函数。相信很多人对指向一般函数的函数指针使用的比较多，而对指向类成员函数的函数指针则比较陌生。我最近也被问到了这方面的问题，心中却也没有清晰的答案。故决定去查阅资料，并按照自己的思路写下这篇学习总结。<br><br></p>
<h3 id="普通函数指针">普通函数指针</h3><p>通常我们所说的<strong>函数指针</strong>指的是指向一般普通函数的指针。和其他指针一样，函数指针指向某种特定类型，<strong>所有被同一指针运用的函数必须具有相同的形参类型和返回类型。</strong><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">// 声明函数指针</span></span><br></pre></td></tr></table></figure></p>
<p>这里，pf指向的函数类型是<code>int (int, int)</code>，即函数的参数是两个int型，返回值也是int型。注：<strong>*pf两端的括号必不可少，如果不写这对括号，则pf是一个返回值为int指针的函数。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// typedef一个类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1+s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pFun pf1 = add;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf1)(<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 调用add函数</span></span><br><span class="line">	pf1 = mns;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf1)(<span class="number">8</span>,<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// 调用mns函数</span></span><br><span class="line">	<span class="built_in">string</span> (*pf2)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;) = merge;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf2)(<span class="string">"hello "</span>, <span class="string">"world"</span>) &lt;&lt; endl;  <span class="comment">// 调用merge函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如示例代码，直接声明函数指针变量显得冗长而烦琐，所以我们可以使用<code>typedef</code>定义自己的函数指针类型。另外，函数指针还可以作为函数的形参类型，实参则可以直接使用函数名。<br><br></p>
<h3 id="成员函数指针">成员函数指针</h3><p><strong>成员函数指针（member function pointer）</strong>是指可以指向类的非静态成员函数的指针。类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。<strong>与普通函数指针不同的是，</strong><br>成员函数指针不仅要指定目标函数的形参列表和返回类型，还必须指出成员函数所属的类。因此，我们必须在*之前添加<code>classname::</code>以表示当前定义的指针指向classname的成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (A::*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">// 声明一个成员函数指针</span></span><br></pre></td></tr></table></figure></p>
<p>同理，这里<code>A::*pf</code>两端的括号也是必不可少的，如果没有这对括号，则pf是一个返回A类数据成员（int型）指针的函数。注意：和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = &amp;A::add;   <span class="comment">// 正确：必须显式地使用取址运算符（&amp;）</span></span><br><span class="line">pf = A::add;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<p><strong>当我们初始化一个成员函数指针时，其指向了类的某个成员函数，但并没有指定该成员所属的对象——直到使用成员函数指针时，才提供成员所属的对象。</strong>下面是一个成员函数指针的使用示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(A::*pClassFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 成员函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" + "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m+n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m+n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" - "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m-n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" * "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m*n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m*n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dev</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" / "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m/n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(pClassFun fun, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">// 类内部接口</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*fun)(m, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(A obj, pClassFun fun, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">// 类外部接口</span></span><br><span class="line">	<span class="keyword">return</span> (obj.*fun)(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"member function 'call':"</span> &lt;&lt; endl;</span><br><span class="line">	a.call(&amp;A::add, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::mns, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::mul, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::dev, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"external function 'call':"</span> &lt;&lt; endl;</span><br><span class="line">	call(a, &amp;A::add, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::mns, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::mul, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::dev, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如示例所示，我们一样可以使用<code>typedef</code>定义成员函数指针的类型别名。另外，<strong>我们需要留意函数指针的使用方法</strong>：对于普通函数指针，是这样使用<code>(*pf)(arguments)</code>，因为要调用函数，必须先解引用函数指针，而函数调用运算符()的优先级较高，所以<code>(*pf)</code>的括号必不可少；对于成员函数指针，唯一的不同是需要在某一对象上调用函数，所以只需要加上成员访问符即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(obj.*pf)(arguments)         <span class="comment">// obj 是对象</span></span><br><span class="line">(objptr-&gt;*pf)(arguments)     <span class="comment">// objptr是对象指针</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="函数表驱动">函数表驱动</h3><p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法就是将其存入一个<strong>函数表（function table）</strong>当中。当程序需要执行某个特定的函数时，就从表中查找对应的函数指针，用该指针来调用相应的程序代码，这个就是函数指针在<strong>表驱动法</strong>中的应用。</p>
<p><strong>表驱动法（Table-Driven Approach）</strong>就是用查表的方法获取信息。通常，在数据不多时可用逻辑判断语句（if…else或switch…case）来获取信息；但随着数据的增多，逻辑语句会越来越长，此时表驱动法的优势就体现出来了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(A::*pClassFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;    <span class="comment">// 构造函数，初始化表</span></span><br><span class="line">		table[<span class="string">"+"</span>] = &amp;A::add;</span><br><span class="line">		table[<span class="string">"-"</span>] = &amp;A::mns;</span><br><span class="line">		table[<span class="string">"*"</span>] = &amp;A::mul;</span><br><span class="line">		table[<span class="string">"/"</span>] = &amp;A::dev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" + "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m+n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m+n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" - "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m-n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" * "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m*n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m*n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dev</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" / "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m/n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找表，调用相应函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*table[s])(m, n);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, pClassFun&gt; table;  <span class="comment">// 函数表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.call(<span class="string">"+"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"-"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"*"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"/"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个示例，示例中的“表”通过map来实现（当然也可以使用数组）。表驱动法使用时需要注意：一是如何查表，从表中读取正确的数据；二是表里存放什么，如数值或函数指针。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>函数指针（function pointer）</strong>是通过指向函数的指针间接调用函数。相信很多人对指向一般函数的函数指针使用的比较多，而对指向类成员函数的函数指针则比较陌生。我最近也被问到了这方面的问题，心中却也没有清晰的答案。故决定去查阅资料，并按照自己的思路写下这篇学习总结。<br><br></p>
<h3 id="普通函数指针">普通函数指针</h3><p>通常我们所说的<strong>函数指针</strong>指的是指向一般普通函数的指针。和其他指针一样，函数指针指向某种特定类型，<strong>所有被同一指针运用的函数必须具有相同的形参类型和返回类型。</strong>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之动态数组类的封装]]></title>
    <link href="http://yoursite.com/2014/07/28/cpp-dynamic-array/"/>
    <id>http://yoursite.com/2014/07/28/cpp-dynamic-array/</id>
    <published>2014-07-27T17:52:34.000Z</published>
    <updated>2015-05-09T18:24:03.618Z</updated>
    <content type="html"><![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/" target="_blank" rel="external">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3><a id="more"></a>
<p>当用new为一个动态数组申请一块内存时，数组中的元素是<strong>连续存储</strong>的，例如 vector和string。当向一个动态数组添加元素时，如果没有空间容纳新元素，不可能简单地将新元素添加到内存中的其他位置——因为元素必须连续存储。所以<strong>必须重新分配一块更大的内存空间，将原来的元素从旧位置移动到新空间中，然后添加新元素，释放旧的内存空间</strong>。如果我们每添加一个新元素，就执行一次这样的内存分配和释放操作，效率将会慢到不行。</p>
<p>为了避免上述的代价，必须减少内存重新分配的次数。所以我们采取的策略是：<strong>在不得不分配新的内存空间时，分配比新的空间需求更大的内存空间（通常为2倍）</strong>。这样，在相当一段时间内，添加元素时就不用重新申请内存空间。注意，只有当迫不得已时才可以分配新的内存空间。</p>
<h3 id="类的四大函数">类的四大函数</h3><p>一个C++类一般至少有四大函数，即构造函数、拷贝构造函数、拷贝赋值运算符、析构函数。如果类未自己定义上述函数，C++编译器将为其合成4个默认的版本。但是往往编译器合成的并不是我们所期望的，为此我们有必要自己定义它们。</p>
<p><strong>构造函数</strong></p>
<p>类的<strong>构造函数（constructor）</strong>用来初始化类对象的非static数据成员，无论何时只要类的对象被创建，就会执行构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();  <span class="comment">// 构造函数</span></span><br><span class="line">	Foo(<span class="built_in">string</span> &amp;s);  <span class="comment">// 接受一个参数的构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数的名字和类名相同，没有返回类型。类可以包含多个构造函数（重载），它们之间在参数数量或类型上需要有所区别。<strong>构造函数有一个初始化部分和一个函数体</strong>，成员的初始化是在函数体执行之前完成的。</p>
<p><strong>拷贝构造函数</strong></p>
<p>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数（copy constructor）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝构造函数定义了如何用一个对象<strong>初始化</strong>另一个同类型的对象。拷贝初始化通常使用拷贝构造函数来完成。<strong>拷贝初始化</strong>发生在下列情况中：</p>
<ul>
<li>使用等号（=）初始化一个变量</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素</li>
</ul>
<p><strong>拷贝赋值运算符</strong></p>
<p>类的<strong>拷贝赋值运算符（copy-assignment operator）</strong>是一个名为<code>operator=</code>的函数。类似于其他任何函数，它也有一个返回类型和一个参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝赋值运算符定义了如何将一个对象<strong>赋值</strong>给另一个同类型的对象。赋值运算符是一个成员函数也是一个二元运算符，其左侧运算对象就绑定到隐式的this指针，右侧运算对象作为显式参数传递。<strong>注意</strong>：为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>
<p><strong>析构函数</strong></p>
<p>类的<strong>析构函数（destructor）</strong>用来释放类对象使用的资源并销毁类对象的非static数据成员，无论何时只要一个对象被销毁，就会自动执行析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~Foo();  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>析构函数的名字由波浪号（~）加类名构成，也没有返回类型。由于析构函数不接受参数，因此它不能被重载。<strong>析构函数有一个函数体和一个析构部分</strong>，销毁一个对象时，首先执行析构函数体，然后按初始化顺序的逆序销毁成员。</p>
<h3 id="运算符的重载">运算符的重载</h3><p>重载的运算符是具有特殊名字的函数：<strong>它们的名字由关键字<code>operator</code>和其后要定义的运算符号共同组成</strong>。和其他函数一样，重载的运算符也包含返回类型、参数列表、函数体，比如拷贝赋值运算符。</p>
<p>当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。有些运算符必须作为成员，而另一些运算符作为普通函数比作为成员更好：</p>
<ul>
<li>赋值（=）、下标（[ ]）、调用（( )）和成员访问箭头（-&gt;）运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常应该是成员。</li>
<li>具有<strong>对称性</strong>的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
<p>当然，除了赋值运算符之外，我们还需要为动态数组定义<strong>下标运算符operator []</strong>。下标运算符必须是成员函数。为了让下标可以出现在赋值运算符的任意一端，下标运算符函数通常返回所访问元素的引用。</p>
<h3 id="动态数组类的封装">动态数组类的封装</h3><p>下面给出了动态数组DArray类的接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DArray</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> *m_Data;  <span class="comment">// 存放数组的动态内存指针</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;      <span class="comment">// 数组的元素个数</span></span><br><span class="line">	<span class="keyword">int</span> m_Max;       <span class="comment">// 预留给动态数组的内存大小</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;     <span class="comment">// 初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">()</span></span>;     <span class="comment">// 释放动态内存</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">InvalidateIndex</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 判断下标的合法性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DArray();        <span class="comment">// 默认构造函数</span></span><br><span class="line">	DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue = <span class="number">0</span>);  <span class="comment">// 构造函数，设置数组大小，默认值为dValue</span></span><br><span class="line">	DArray(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	DArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	~DArray();       <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;    <span class="comment">// 输出显式所有数组元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;   <span class="comment">// 获取数组的大小（元素个数）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetSize</span><span class="params">(<span class="keyword">int</span> nSize)</span></span>;  <span class="comment">// 重新设置数组的大小</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 获取指定位置元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetAt</span><span class="params">(<span class="keyword">int</span> nIndex,<span class="keyword">double</span> dValue)</span></span>; <span class="comment">// 重置指定元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;     <span class="comment">// 删除指定位置地元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertAt</span><span class="params">(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 插入一个新的元素到数组中</span></span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span>;      <span class="comment">// 重载下标运算符[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是我的实现：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DArray::Init()</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = <span class="number">0</span>;   <span class="comment">// 默认情况下数组不包含元素</span></span><br><span class="line">	m_Max = <span class="number">1</span>;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DArray::Free()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DArray::InvalidateIndex(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&gt;=<span class="number">0</span> &amp;&amp; nIndex&lt;m_Size)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">DArray::DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize == <span class="number">0</span>)</span><br><span class="line">		Init();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Size = nSize;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i]=dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = arr.m_Size;  <span class="comment">/*复制常规成员*/</span></span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];   <span class="comment">/*复制指针指向的内容*/</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_Data, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">DArray&amp; DArray::<span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;arr)  <span class="comment">/*自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	m_Size = arr.m_Size;</span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	<span class="comment">/* 先将右侧对象拷贝到临时对象中，然后再销毁左侧对象*/</span> </span><br><span class="line">	<span class="keyword">double</span> *m_Temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">	<span class="built_in">memcpy</span>(m_Temp, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">	m_Data = m_Temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">DArray::~DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Free();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> DArray::Print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: The empty array can't be Printed."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m_Size; ++i)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m_Data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组大小</span></span><br><span class="line"><span class="keyword">int</span> DArray::GetSize()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组大小</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetSize(<span class="keyword">int</span> nSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize &lt; m_Size)   <span class="comment">/*截断*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nSize; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m_Size&lt;=nSize &amp;&amp; nSize&lt;=m_Max)  <span class="comment">/*新增元素置0*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nSize &gt; m_Max)   <span class="comment">/*需要重新分配空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span> *temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			temp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	m_Size = nSize; <span class="comment">/*设置数组大小*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素</span></span><br><span class="line"><span class="keyword">double</span> DArray::GetAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of GetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置指定位置元素的值</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of SetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line"><span class="keyword">void</span> DArray::PushBack(<span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/*数组大小加1*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除一个元素</span></span><br><span class="line"><span class="keyword">void</span> DArray::DeleteAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of DeleteAt is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nIndex; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = m_Data[i+<span class="number">1</span>];</span><br><span class="line">		m_Data[m_Size-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		--m_Size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个新元素到指定位置</span></span><br><span class="line"><span class="keyword">void</span> DArray::InsertAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of InsertAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)  <span class="comment">/* 未满，插入 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>               <span class="comment">/* 重新分配空间 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/* 数组大小加1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载下标运算符[]</span></span><br><span class="line"><span class="keyword">double</span> DArray::<span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;=m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index in [] is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过简单的测试，暂时还没有发现Bug。可能测试并不全面，如果你发现了问题，希望你能在评论里告诉我，万分感谢！！！<br><br><br><br></p>
<h3 id="附：String类的实现">附：String类的实现</h3><p>C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能要求具备 std::string 的功能，但至少要求能正确管理资源。</p>
<p>如果你弄懂了上面DArray类的写法，那么实现String类应该就不难了。因为面试官一般只是想考查你能不能正确地写出构造函数、析构函数、拷贝构造函数、拷贝赋值运算符以及+、[ ]、&lt;&lt;、&gt;&gt;运算符重载等等。下面给出一个String类的接口，你可以自己试试手实现一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;  </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp;,String&amp;); <span class="comment">//重载&lt;&lt;运算符  </span></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp;,String&amp;); <span class="comment">//重载&gt;&gt;运算符  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    String();   <span class="comment">// 默认构造函数</span></span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* str);       <span class="comment">// 带参构造函数  </span></span><br><span class="line">    String(<span class="keyword">const</span> String&amp; rhs);        <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs);   <span class="comment">// 拷贝赋值运算符  </span></span><br><span class="line">    String <span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span>;  <span class="comment">//operator+  </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator!=   </span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span>);              <span class="comment">//operator[]  </span></span><br><span class="line">    <span class="function">size_t <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_str() <span class="keyword">const</span>;</span><br><span class="line">    ~String();    <span class="comment">// 析构函数 </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是String类的实现，注意一些得分点：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::String()</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	m_data[<span class="number">0</span>] = <span class="string">'\0'</span>;  <span class="comment">/*得分点：空字符串存放结束标志'\0'*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参的构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)  <span class="comment">/*得分点：自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">	<span class="keyword">delete</span> [] m_data; <span class="comment">/*得分点：释放左侧对象资源*/</span></span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator+</span></span><br><span class="line">String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	String newStr;</span><br><span class="line">	newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data)+<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(newStr.m_data, m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator==</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(m_data, rhs.m_data) == <span class="number">0</span>) <span class="comment">/*相等返回0*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator!=</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;<span class="built_in">strlen</span>(m_data))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_data[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of [] is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String大小</span></span><br><span class="line">size_t String::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取C风格字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* String::c_str() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str.m_data;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&gt;&gt;运算符</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">255</span>];</span><br><span class="line">	is &gt;&gt; temp;</span><br><span class="line">	str = temp;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之new与delete、malloc与free]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-new-malloc/"/>
    <id>http://yoursite.com/2014/07/25/cpp-new-malloc/</id>
    <published>2014-07-25T14:06:45.000Z</published>
    <updated>2015-05-09T18:20:44.204Z</updated>
    <content type="html"><![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br><a id="more"></a><br>标准库定义了operator new函数的几个重载版本，没有使用<code>noexcept</code>说明的版本在内存分配失败时可能会抛出bad_alloc异常，而使用了的不会抛出异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t )</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t );	</span><br><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用new表达式时，实际执行了三步操作：</p>
<ul>
<li>new表达式调用上面的<strong>operator new</strong>（或者<strong>operator new[]</strong>）的标准库函数，函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</li>
<li>编译器运行相应的<strong>构造函数</strong>以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ul>
<p>对于operator new函数或者operator new[]函数来说，它的返回类型必须是void*，第一个形参的类型必须是size_t且该形参不能含有默认实参。当编译器调用operator new或者operator new[]函数时，会把存储指定对象或者指定对象的数组所需的字节数传给size_t形参。</p>
<p><strong>delete表达式</strong></p>
<p>标准库也定义了operator delete函数的几个重载版本，<code>noexcept</code>说明符表示在内存分配失败时返回空指针而不是抛出bad_alloc异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用delete表达式时，实际执行了两步操作：</p>
<ul>
<li>对指针所指的对象或者所指的数组中的元素执行对应的<strong>析构函数</strong>。</li>
<li>编译器调用<strong>operator delete</strong>（或者<strong>operator delete[]</strong>）的标准库函数释放内存空间。</li>
</ul>
<p>对于operator delete函数或者operator delete[]函数来说，它们的返回类型必须是void，第一个形参的类型必须是void*。执行一条delete表达式将调用相应的operator函数，并用指向待释放内存的指针来初始化void*形参。<br><br></p>
<h3 id="malloc和free">malloc和free</h3><p>malloc和free是C/C++中的<strong>标准库函数</strong>，也是用于申请动态内存和释放内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="built_in">malloc</span>( size_t size );</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">free</span><span class="params">( <span class="keyword">void</span>* ptr )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>malloc函数</strong>接受一个表示待分配字节数的size_t，返回指向分配空间的指针；如果分配失败，则返回空指针。<strong>free函数</strong>接受一个void<em>，它是malloc返回的指针的副本，free将相关内存返还给系统。<em>*注意</em></em>：malloc函数并不会调用构造函数来初始化内存，free函数也不会自动调用析构函数。<br><br></p>
<h3 id="new和malloc、delete和free的区别">new和malloc、delete和free的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;     <span class="comment">// 没有初始化列表， 所以没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();   <span class="comment">// 空初始化列表， 执行zero初始化,  所以初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);  <span class="comment">// 非空初始化列表， 执行值初始化， 所以初始化为3</span></span><br><span class="line"><span class="comment">// 注：对于没有构造函数的内置类型，new会不会初始化在于有没有初始列表（空列表“()”也算）</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];     <span class="comment">// 分配大小为sizeof(int)*100;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p5 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"><span class="keyword">double</span> *p6 = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p><strong>new和malloc的区别：</strong></p>
<ol>
<li><p>new是一个运算符，malloc()是一个库函数。</p>
</li>
<li><p>new会调用构造函数，而malloc()不会。</p>
</li>
<li><p>new返回指定类型的指针，而malloc()返回void*。</p>
</li>
<li><p>new会自动计算需要分配的空间，而malloc()需要手工计算字节数。</p>
</li>
<li><p>new可以被重载，而malloc()不能。<br><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> [] p2;</span><br><span class="line"><span class="built_in">free</span>(p3);</span><br><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>delete和free的区别：</strong></p>
<ol>
<li><p>delete是一个运算符，free()是一个库函数。</p>
</li>
<li><p>delete会调用析构函数，而free()不会。</p>
</li>
<li><p>delete可以被重载，而free()不能。</p>
</li>
</ol>
<p><br><br><br><br></p>
<h3 id="总结：">总结：</h3><p>malloc和free是C/C++中的标准库函数，new和delete是C++的运算符。对于非内置数据类型的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之命名空间]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-namespace/"/>
    <id>http://yoursite.com/2014/07/25/cpp-namespace/</id>
    <published>2014-07-25T10:34:52.000Z</published>
    <updated>2015-05-09T18:17:13.366Z</updated>
    <content type="html"><![CDATA[<p>在C++中，<strong>命名空间（namespace）</strong>的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个<strong>全局命名空间（global namespace）</strong>，全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用<code>::member</code>的形式表示）。</p>
<h3 id="定义命名空间">定义命名空间</h3><p><strong>1、每个命名空间都是一个作用域</strong><br><a id="more"></a><br>和其他作用域类似，在命名空间中的每个名字必须表示唯一实体，而在不同命名空间中，可以有相同名字的成员。</p>
<p><strong>2、命名空间可以是不连续的</strong></p>
<p>命名空间可以定义在几个不同的部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;</span><br><span class="line">    <span class="comment">/* …… */</span></span><br><span class="line">&#125;   <span class="comment">// 命名空间作用域后面无须分号</span></span><br></pre></td></tr></table></figure></p>
<p>如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间添加一些新的成员。</p>
<p><strong>3、命名空间是可以嵌套的</strong></p>
<p>嵌套的命名空间是指定义在其他命名空间中的命名空间。嵌套的命名空间是一个嵌套的作用域，内层命名空间声明的名字将隐藏外层命名空间声明的同名成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">namespace</span> outer &#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> inner &#123;</span><br><span class="line">		<span class="keyword">int</span> z = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; outer::inner::z;  <span class="comment">// 输出10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，通常我们不把#include头文件放在命名空间内部。</p>
<p><strong>4、未命名的命名空间</strong></p>
<p><strong>未命名的命名空间（unnamed namespace）</strong>是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。在标准C++引入命名空间的概念之前，程序需要将名字声明成<code>static</code>以使其对于整个文件有效，但是，现在在文件中进行静态声明的做法已经被C++标准取消了，取而代之的是使用<strong>未命名的命名空间</strong>。</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。也就是说，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。<em>另外，由于未命名的命名空间它没有名字，所以其中定义的名字的作用域与该命名空间所在的作用域相同</em>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;   <span class="comment">// i的全局声明</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">10</span>;  <span class="comment">// 错误，二义性</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> local &#123;</span><br><span class="line">    <span class="keyword">namespace</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">local::i = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="使用命名空间">使用命名空间</h3><p>对命名空间中成员的引用，需要使用命名空间的作用域运算符<strong>(::)</strong>。但是，像<code>namespace_name::member_name</code>这样使用命名空间的成员非常烦琐，我们需要使用一些其他的更简便的方法。</p>
<p><strong>1、命名空间的别名</strong></p>
<p>有些命名空间的名字很长或者命名空间嵌套了很多层，我们可以为其设定一个较短的同义词，也就是别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cln = cpluslus_learning_namespace;</span><br><span class="line"><span class="keyword">namespace</span> Qlib = outer::inner::QueryLib;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、using声明</strong></p>
<p>一条<strong>using声明（using declaration）</strong>语句一次只引入命名空间的一个成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::[命名空间名::……]成员名;   <span class="comment">// 例如 using OLib::List;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3、using指示</strong></p>
<p><strong>using指示（using directive）</strong>和using声明不同的地方是，我们无法控制哪些名字是可见的，因为using指示会使得某个特定的命名空间中所有的名字都可见：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   <span class="comment">// 引入命名空间std</span></span><br></pre></td></tr></table></figure></p>
<p>使用命名空间主要是为了防止名字冲突，如果随意使用using指示注入命名空间的所有名字，将重新引入名字冲突的问题。另外，<strong>using声明和using指示在作用域上有区别</strong>：using声明是将一个成员引入当前命名空间作用域内；using指示是将所有成员引入当前和上一层命名空间作用域内：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;    <span class="comment">// 命名空间</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">16</span>, j=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;   <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> nsp;   <span class="comment">// 如果使用j，将在::j和nsp::j之间产生冲突</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; j;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将using指示<code>using namespace nsp;</code>改成using声明<code>using nsp::j;</code>则会正确输出15。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C++中，<strong>命名空间（namespace）</strong>的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个<strong>全局命名空间（global namespace）</strong>，全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用<code>::member</code>的形式表示）。</p>
<h3 id="定义命名空间">定义命名空间</h3><p><strong>1、每个命名空间都是一个作用域</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之模板特例化]]></title>
    <link href="http://yoursite.com/2014/07/23/cpp-template-specialization/"/>
    <id>http://yoursite.com/2014/07/23/cpp-template-specialization/</id>
    <published>2014-07-22T16:19:13.000Z</published>
    <updated>2015-05-09T18:14:35.042Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/blog/2014/07/18/c-plus-plus-xue-xi-zhi-han-shu-mo-ban-yu-lei-mo-ban/" target="_blank" rel="external">模板</a>是C++中一个很重要的特性，写一份代码能用于多种数据类型（包括用户自定义类型）。例如，STL的sort()函数可以用于多种数据类型的排序，类stack可以用作多种数据类型的栈。但是，<strong>如果我们想对特定的数据类型执行不同的代码（而不是通用模板）呢？</strong>这种情况下就可以使用<strong>模板特例化（template specialization）</strong>。</p>
<h3 id="函数模板特例化">函数模板特例化</h3><a id="more"></a>
<p>当特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。使用关键字template后跟一个空尖括号&lt;&gt;，即<code>template &lt;&gt;</code>，以指出我们正在特例化一个模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The main template fun(): "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;   <span class="comment">// 对int型特例化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Specialized template for int type: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	fun&lt;<span class="keyword">char</span>&gt;(<span class="string">'a'</span>);</span><br><span class="line">	fun&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">	fun&lt;<span class="keyword">float</span>&gt;(<span class="number">9.15</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">The</span> main <span class="keyword">template</span> fun(): a</span><br><span class="line"><span class="type">Specialized</span> <span class="keyword">template</span> <span class="keyword">for</span> <span class="type">int</span> <span class="keyword">type</span>: <span class="number">10</span></span><br><span class="line"><span class="type">The</span> main <span class="keyword">template</span> fun(): <span class="number">9</span>.<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<p>对于除int型外的其他数据类型，都会调用通用版本的函数模板<code>fun(T a)</code>；对于int型，则会调用特例化版本的<code>fun(int a)</code>。注意，<strong>一个特例化版本的本质是一个实例</strong>，而非函数的重载。因此，特例化不影响函数匹配。</p>
<h3 id="类模板特例化">类模板特例化</h3><p>除了特例化函数模板，我们还可以<strong>特例化类模板</strong>。下面是一个简单的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"General template object"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">// 对int型特例化</span></span><br><span class="line"><span class="keyword">class</span> Test&lt;<span class="keyword">int</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Specialized template object"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Test&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	Test&lt;<span class="keyword">char</span>&gt; b;</span><br><span class="line">	Test&lt;<span class="keyword">float</span>&gt; c;</span><br><span class="line">	a.print();</span><br><span class="line">	b.print();</span><br><span class="line">	c.print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Specialized</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br><span class="line"><span class="type">General</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br><span class="line"><span class="type">General</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br></pre></td></tr></table></figure></p>
<p>另外，与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，这种叫做类模板的<strong>偏特化</strong> 或 <strong>部分特例化（partial specialization）</strong>。例如，C++标准库中的类vector的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Allocator&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在vector这个例子中，一个参数被绑定到bool类型，而另一个参数仍未绑定需要由用户指定。注意，一个类模板的部分特例化版本仍然是一个模板，因为使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/blog/2014/07/18/c-plus-plus-xue-xi-zhi-han-shu-mo-ban-yu-lei-mo-ban/">模板</a>是C++中一个很重要的特性，写一份代码能用于多种数据类型（包括用户自定义类型）。例如，STL的sort()函数可以用于多种数据类型的排序，类stack可以用作多种数据类型的栈。但是，<strong>如果我们想对特定的数据类型执行不同的代码（而不是通用模板）呢？</strong>这种情况下就可以使用<strong>模板特例化（template specialization）</strong>。</p>
<h3 id="函数模板特例化">函数模板特例化</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之可变参数的函数与模板]]></title>
    <link href="http://yoursite.com/2014/07/22/cpp-changeable-parameter/"/>
    <id>http://yoursite.com/2014/07/22/cpp-changeable-parameter/</id>
    <published>2014-07-22T08:12:24.000Z</published>
    <updated>2015-05-09T18:10:49.174Z</updated>
    <content type="html"><![CDATA[<p>所谓<strong>可变参数</strong>指的是函数的参数个数可变，参数类型不定的函数。为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，我们可以编写<strong>可变参数模板</strong>。另外，C++还有一种特殊的<strong>省略符形参</strong>，可以用它传递可变数量的实参，不过这种一般只用于与C函数交互的接口程序。</p>
<h3 id="可变参数函数">可变参数函数</h3><a id="more"></a>
<p> <strong>1、initializer_list形参</strong></p>
<p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参（C++11新标准）。和vector一样，initializer_list也是一种模板类型。下面看看initializer_list提供的一些操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;initializer_list&gt;  <span class="comment">// 头文件</span></span></span><br><span class="line">initializer_list&lt;T&gt; lst;    <span class="comment">// 默认初始化，T类型元素的空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;; <span class="comment">// 初始化为初始值列表的副本</span></span><br><span class="line">lst2(lst)     <span class="comment">// 拷贝或赋值不会拷贝列表中的元素；拷贝后，</span></span><br><span class="line">lst2 = lst    <span class="comment">// 原始列表和副本共享元素</span></span><br><span class="line">lst.size()    <span class="comment">// 列表中的元素数量</span></span><br><span class="line">lst.begin()   <span class="comment">// 返回指向lst中首元素的指针</span></span><br><span class="line">lst.end()     <span class="comment">// 返回指向lst中尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure></p>
<p>下面给出一个例子，需要注意的是，含有initializer_list形参的函数也可以同时拥有其他形参。另外，如果想给initializer_list形参传递一个实参的序列，必须把序列<strong>放在一对花括号内</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="built_in">string</span>&gt; li)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">("")</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> beg=li.begin(); beg!=li.end(); ++beg)</span><br><span class="line">		str += *beg;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; func(&#123;<span class="string">"This"</span>,<span class="string">" "</span>,<span class="string">"is"</span>,<span class="string">" "</span>,<span class="string">"C++"</span>&#125;) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>2、省略符形参</strong></p>
<p>函数可以用省略符形参”…”表示不定参数部分，省略符形参只能出现在形参列表的最后一个位置，它的形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="comment">// 典型例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>省略符形参应该仅仅用于C和C++通用的类型</strong>，因为大多数类类型的对象在传递给省略符形参时都无法正确拷贝。下面是<strong>&lt; cstdarg &gt;</strong>头文件中的几个宏定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdarg&gt;  <span class="comment">// C中是&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// va_list是一种数据类型，args用于持有可变参数。</span></span><br><span class="line"><span class="comment">// 定义typedef char* va_list;</span></span><br><span class="line">va_list args;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用va_start并传入两个参数：第一个参数为va_list类型的变量</span></span><br><span class="line"><span class="comment">// 第二个参数为"..."前最后一个参数名</span></span><br><span class="line"><span class="comment">// 将args初始化为指向第一个参数（可变参数列表）</span></span><br><span class="line">va_start(args, paramN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索参数，va_arg的第一个参数是va_list变量，第二个参数指定返回值的类型</span></span><br><span class="line"><span class="comment">// 每一次调用va_arg会获取当前的参数，并自动更新指向下一个可变参数。</span></span><br><span class="line">va_arg(args,type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放va_list变量</span></span><br><span class="line">va_end(args);</span><br></pre></td></tr></table></figure></p>
<p>下面给出一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_nums</span><span class="params">(<span class="keyword">int</span> count,...)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	va_list args;</span><br><span class="line">	va_start(args, count);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; ++i)</span><br><span class="line">		result += va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; add_nums(<span class="number">4</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器是将参数压入栈中进行传递的。传递实参的时候，编译器会从实参列表中，按从右到左的顺序将参数入栈，对于add_nums(4, 25, 25, 50, 50)的调用，则入栈的顺序是 50, 50, 25, 25, 4 (注意没有可变参数与不可变参数之分)。由于栈的地址是从高到低的，所以在知道了第一个参数地址和参数的类型之后，就可以获取各个参数的地址。<br><br></p>
<h3 id="可变参数模板">可变参数模板</h3><p>一个<strong>可变参数模板（variadic template）</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包（parameter packet）</strong>。存在两种参数包：<strong>模板参数包</strong>（表示零个或多个模板参数）和<strong>函数参数包</strong>（表示零个或多个函数参数）。</p>
<p>上述说到我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数，但是所有实参必须具有相同的类型。当我们既不知道要处理的实参数目也不知道它们的类型时，我们就需要使用可变参数的函数模板了。我们用一个<strong>省略号</strong>来指出一个模板参数或函数参数表示一个包：<em>在一个模板参数列表中，<code>class...</code>或<code>typename...</code>指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;...rest)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可变参数函数模板通常是递归的。第一步调用处理包中的第一个实参，然后用剩余的实参调用自身。<strong>为了终止递归，我们还需要定义一个非可变参数的函数模板</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并处理包中最后一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;...rest)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;     <span class="comment">// 打印第一个实参</span></span><br><span class="line">	print(rest...);       <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	print(<span class="string">"string1"</span>, <span class="number">2</span>, <span class="number">3.14f</span>, <span class="string">"string2"</span>, <span class="number">42</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非可变参数版本的<code>print</code>负责终止递归并打印初始调用中的最后一个实参。对于最后一次递归调用<code>print(42)</code>，两个<code>print</code>版本都是可行的。但是，非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。<br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓<strong>可变参数</strong>指的是函数的参数个数可变，参数类型不定的函数。为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，我们可以编写<strong>可变参数模板</strong>。另外，C++还有一种特殊的<strong>省略符形参</strong>，可以用它传递可变数量的实参，不过这种一般只用于与C函数交互的接口程序。</p>
<h3 id="可变参数函数">可变参数函数</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之函数模板与类模板]]></title>
    <link href="http://yoursite.com/2014/07/18/cpp-template/"/>
    <id>http://yoursite.com/2014/07/18/cpp-template/</id>
    <published>2014-07-18T10:58:57.000Z</published>
    <updated>2015-05-09T18:06:44.265Z</updated>
    <content type="html"><![CDATA[<p><strong>泛型编程（Generic Programming）</strong>是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。</p>
<p><strong>模板（template）</strong>是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。<br><a id="more"></a></p>
<h3 id="函数模板">函数模板</h3><p>一个通用的<strong>函数模板（function template）</strong>就是一个公式，可用来生成针对特定类型或特定值的函数版本。模板定义以<strong>关键字template</strong>开始，后面跟一个<strong>模板参数列表</strong>，列表中的多个<strong>模板参数（template parameter）</strong>以逗号分隔。模板参数表示在类或函数定义中用到的类型或值。</p>
<p><strong>1、类型参数</strong></p>
<p>一个模板<strong>类型参数（type parameter）</strong>表示的是一种类型。我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数前必须使用关键字<strong>class</strong> 或 <strong>typename</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// typename和class一样的</span></span><br><span class="line"><span class="function">T <span class="title">function</span><span class="params">(T* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T tmp = *p;   <span class="comment">// 临时变量类型为T</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;   <span class="comment">// 返回值类型为T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键字typename和class是一样的作用，但显然typename比class更为直观，它更清楚地指出随后的名字是一个类型名。</p>
<p>编译器用模板类型实参为我们<strong>实例化（instantiate）</strong>特定版本的函数，一个版本称做模板的一个<strong>实例（instantiation）</strong>。当我们调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参。当然如果函数没有模板类型的参数，则我们需要特别指出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; function(&amp;a) &lt;&lt; endl;     <span class="comment">// 编译器根据函数实参推断模板实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; function&lt;<span class="keyword">int</span>&gt;(&amp;a) &lt;&lt; endl;   <span class="comment">// &lt;int&gt;指出模板参数为int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、非类型参数</strong></p>
<p>在模板中还可以定义<strong>非类型参数（nontype parameter）</strong>，一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> M, <span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; M+N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>* C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; C &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">char</span> (&amp;R)[<span class="number">9</span>]&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">void</span> (*f)(<span class="keyword">const</span> <span class="keyword">char</span>*)&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	f(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">9</span>] = <span class="string">"template"</span>;   <span class="comment">// 全局变量，具有静态生存期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	add&lt;<span class="number">10</span>, <span class="number">20</span>&gt;();</span><br><span class="line">	func1&lt;arr&gt;(<span class="string">"pointer"</span>);</span><br><span class="line">	func2&lt;arr&gt;(<span class="string">"reference"</span>);</span><br><span class="line">	func3&lt;print&gt;(<span class="string">"template function pointer"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代。一个非类型参数可以是一个整型，或者是一个指向对象或函数的指针或引用：绑定到整形（非类型参数）的实参必须是一个<strong>常量表达式</strong>，绑定到指针或引用（非类型参数）的实参必须具有<strong>静态的生存期</strong>（比如全局变量），不能把<strong>普通局部变量</strong> 或 <strong>动态对象</strong>绑定到指针或引用的非类型形参。<br><br></p>
<h3 id="类模板">类模板</h3><p>相应的，<strong>类模板（class template）</strong>是用来生成类的蓝图。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，所以我们必须<strong>显式</strong>的提供模板实参。与函数模板一样，类模板参数可以是<strong>类型参数</strong>，也可以是<strong>非类型参数</strong>，这里就不再赘述了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Array(T arr[], <span class="keyword">int</span> s);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *ptr;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板外部定义成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::Array(T arr[], <span class="keyword">int</span> s)</span><br><span class="line">&#123;</span><br><span class="line">	ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">	size = s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">		ptr[i]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; *(ptr+i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">5</span>] = &#123;<span class="string">'J'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>&#125;;</span><br><span class="line">	Array&lt;<span class="keyword">char</span>&gt; charArr(a, <span class="number">5</span>);</span><br><span class="line">	charArr.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArr(b, <span class="number">5</span>);</span><br><span class="line">	intArr.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板的成员函数</strong></p>
<p>与其他类一样，我们既可以在类模板内部，也可以在类模板外部定义其成员函数。定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">return_type class_name&lt;T&gt;::member_name(parm-<span class="built_in">list</span>) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，对于一个实例化了的类模板，其成员函数只有在使用时才被实例化。如果一个成员函数没有被使用，则它不会被实例化。</p>
<p><strong>类模板和友元</strong></p>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板的友元，则友元被授权可以访问所有模板的实例。如果友元自身是模板，类可以授权给所有友元模板的实例，也可以只授权给特定实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Pal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;C&gt;;  <span class="comment">// 用类C实例化的Pal是C的一个友元</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; <span class="comment">//Pal2所有实例都是C的友元;无须前置声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> C2 &#123;</span><br><span class="line">	<span class="comment">// C2的每个实例将用相同类型实例化的Pal声明为友元,一对一关系</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;T&gt;;</span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; </span><br><span class="line">	<span class="comment">// Pal3是普通非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板的static成员</strong></p>
<p>类模板可以声明static成员。<strong>类模板的每一个实例都有其自己独有的static成员对象</strong>，对于给定的类型X，所有class_name&lt; X &gt;类型的对象共享相同的一份static成员实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//...其他操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i;  <span class="comment">// 静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Foo&lt;T&gt;::i = <span class="number">10</span>;  <span class="comment">// 初始化为10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Foo&lt;<span class="keyword">int</span>&gt; f1;</span><br><span class="line">	Foo&lt;<span class="keyword">int</span>&gt; f2;</span><br><span class="line">	Foo&lt;<span class="keyword">float</span>&gt; f3;</span><br><span class="line">	f1.print();   <span class="comment">// 输出11</span></span><br><span class="line">	f2.print();   <span class="comment">// 输出12</span></span><br><span class="line">	f3.print();   <span class="comment">// 输出11</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过类类型对象来访问一个类模板的static对象，也可以使用作用域运算符（::）直接访问静态成员。类似模板类的其他成员函数，一个static成员函数也只有在使用时才会实例化。</p>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>泛型编程（Generic Programming）</strong>是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。</p>
<p><strong>模板（template）</strong>是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之多重继承与虚继承]]></title>
    <link href="http://yoursite.com/2014/07/17/cpp-inheritance/"/>
    <id>http://yoursite.com/2014/07/17/cpp-inheritance/</id>
    <published>2014-07-17T12:22:31.000Z</published>
    <updated>2015-05-09T18:03:42.863Z</updated>
    <content type="html"><![CDATA[<h3 id="多重继承">多重继承</h3><p>我们知道，在单继承中，派生类的对象中包含了<strong>基类部分</strong> 和 <strong>派生类自定义部分</strong>。同样的，在<strong>多重继承（multiple inheritance）</strong>关系中，派生类的对象包含了每个基类的子对象和自定义成员的子对象。下面是一个多重继承关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> B&#123; <span class="comment">/*  */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C继承了A，派生类D又继承了B和C，如图所示，一个D对象中含有一个B部分、一个C部分（其中又含有一个A部分）以及在D中声明的非静态数据成员：<a id="more"></a><br><img src="http://img.blog.csdn.net/20140717181313546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>构造与析构：</strong></p>
<p>构造一个派生类对象将首先构造它的所有基类子对象，其中基类的构造顺序与派生列表中基类的出现顺序保持一致，即B -&gt; A -&gt; C -&gt; D。<br>销毁一个派生类对象的顺序正好与其创建的顺序相反，即析构函数的调用顺序正好与构造函数相反，即D -&gt; C -&gt; A -&gt; B。注意派生类的析构函数只负责清除派生类本身分配的资源（析构函数体），派生类的成员及基类都是<strong>自动销毁</strong>的（隐式析构阶段）。</p>
<p><strong>类型转换：</strong></p>
<p>在多重继承的情况下，可以令某个可访问基类的指针或引用直接指向一个派生类对象。编译器不会在派生类向基类的几种转换中进行比较和选择，在它看来转换到任意一种基类都一样好。<br><br></p>
<h3 id="虚继承">虚继承</h3><p>尽管在派生列表中不允许同一个基类出现两次，但实际上派生类可以多次继承同一个类。<br><img src="http://img.blog.csdn.net/20140717200257421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>派生类通常会含有继承链上每个类对应的子部分。<strong>在上面的两种情况中，class D都间接地继承了class A两次，那么意味着class D中包含了class A的两份拷贝。所以在一个class D的对象中将含有2组class A的成员，此时若不加前缀限定符直接使用某个成员将引发“二义性”错误</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():str(<span class="string">"name"</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	d.str = <span class="string">"songlee"</span>;  <span class="comment">// 错误：对成员‘str’的请求有歧义</span></span><br><span class="line">	d.print();  <span class="comment">// 错误：对成员‘print’的请求有歧义</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然你可以使用作用域<code>d.B::str = &quot;songlee&quot;;</code>和<code>d.B::print();</code>来规避“二义性”错误，但这并没有从根本上解决问题。</p>
<p>为了解决上述问题，C++提供了<strong>虚继承（virtual inheritance）</strong>的机制。虚继承的目的是令某个类作出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>。在这种机制下，不论虚基类在继承体系中出现多少次，在派生类中都只包含唯一一个共享的虚基类子对象。<strong>我们指定虚基类的方式是在派生列表中添加关键字virtual：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():str(<span class="string">"name"</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;   <span class="comment">// 虚继承，A为虚基类</span></span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;   <span class="comment">// 关键字public和virtual的顺序随意</span></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	d.str = <span class="string">"songlee"</span>;   <span class="comment">// 正确</span></span><br><span class="line">	d.print();           <span class="comment">// 正确</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在派生列表中添加virtual（关键字public和virtual的顺序随意）指定A为虚基类，B和C将共享A的同一份实例，这样在D的对象中也将只有A的唯一一份实例，所以A的成员可以被直接访问，并且不会产生二义性。</p>
<p>虚继承最典型的应用是iostream继承于istream和ostream，而istream和ostream虚继承于ios：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> istream : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> ostream : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> iostream : <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><strong>注意：</strong></p>
<ol>
<li>支持向基类的常规类型转换。也就是说即使基类是虚基类，也能通过基类的指针或引用操作派生类的对象。</li>
<li>虚继承只是解决了一个派生类对象中存在同一个基类的多份拷贝的问题，并没有解决多个基类存在同名成员的二义性问题。</li>
<li>在虚继承中，虚基类是由最低层的派生类负责初始化的。如上例中，当创建一个D对象时，D位于派生的最低层并由它负责初始化共享的A基类部分。</li>
<li>含有虚基类的对象的构造顺序与一般的多重继承的构造顺序稍有区别：先初始化虚基类子对象（最低层派生类负责），然后按派生列表中的顺序依次对直接基类（非虚）进行初始化。</li>
<li>析构的顺序与构造的顺序正好相反。</li>
</ol>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多重继承">多重继承</h3><p>我们知道，在单继承中，派生类的对象中包含了<strong>基类部分</strong> 和 <strong>派生类自定义部分</strong>。同样的，在<strong>多重继承（multiple inheritance）</strong>关系中，派生类的对象包含了每个基类的子对象和自定义成员的子对象。下面是一个多重继承关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> B&#123; <span class="comment">/*  */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C继承了A，派生类D又继承了B和C，如图所示，一个D对象中含有一个B部分、一个C部分（其中又含有一个A部分）以及在D中声明的非静态数据成员：]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
</feed>