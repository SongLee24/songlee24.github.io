<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[神奕的博客]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-07-29T13:37:31.542Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[第一个MapReduce程序——WordCount]]></title>
    <link href="http://yoursite.com/2015/07/29/mapreduce-word-count/"/>
    <id>http://yoursite.com/2015/07/29/mapreduce-word-count/</id>
    <published>2015-07-29T13:34:39.000Z</published>
    <updated>2015-07-29T13:37:31.542Z</updated>
    <content type="html"><![CDATA[<p>通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个程序就是词频统计<code>WordCount</code>程序。</p>
<h1 id="一、MapReduce简介">一、MapReduce简介</h1><h2 id="1-1_MapReduce编程模型">1.1 MapReduce编程模型</h2><p>MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。</p>
<p>在Hadoop中，用于执行MapReduce任务的机器角色有两个：<a id="more"></a></p>
<ul>
<li>JobTracker用于调度工作的，一个Hadoop集群中只有一个JobTracker，位于master。</li>
<li>TaskTracker用于执行工作，位于各slave上。</li>
</ul>
<p>在分布式计算中，MapReduce框架负责处理了并行编程中分布式存储、工作调度、负载均衡、容错均衡、容错处理以及网络通信等复杂问题，把处理过程高度抽象为两个函数：map和reduce，map负责把任务分解成多个任务，reduce负责把分解后多任务处理的结果汇总起来。</p>
<p>需要注意的是，用MapReduce来处理的数据集（或任务）必须具备这样的特点：待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理。</p>
<h2 id="1-2_MapReduce处理过程">1.2 MapReduce处理过程</h2><p>在Hadoop中，每个MapReduce任务都被初始化为一个Job，每个Job又可以分为两种阶段：map阶段和reduce阶段。</p>
<ul>
<li>map：<code>(K1, V1)</code> ——&gt; <code>list(K2, V2)</code></li>
<li>reduce：<code>(K2, list(V2))</code> ——&gt; <code>list(K3, V3)</code></li>
</ul>
<p>如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150728184403091" alt=""></p>
<p><br></p>
<h1 id="二、运行WordCount程序">二、运行WordCount程序</h1><p>在运行程序之前，需要先搭建好Hadoop集群环境，参考《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/46974723" target="_blank" rel="external">Hadoop+HBase+ZooKeeper分布式集群环境搭建</a>》。</p>
<h1 id="2-1_源代码">2.1 源代码</h1><p>WordCount可以说是最简单的MapReduce程序了，只包含三个文件：一个 Map 的 Java 文件，一个 Reduce 的 Java 文件，一个负责调用的主程序 Java 文件。</p>
<p>我们在当前用户的主文件夹下创建<code>wordcount_01/</code>目录，在该目录下再创建<code>src/</code>和<code>classes/</code>。 src 目录存放 Java 的源代码，classes 目录存放编译结果。</p>
<p><strong>TokenizerMapper.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">	Text word = <span class="keyword">new</span> Text();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">		<span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">			word.set(itr.nextToken());</span><br><span class="line">			context.write(word, one);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IntSumReducer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(IntWritable val:values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WordCount.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"wordcount"</span>);</span><br><span class="line">		job.setJarByClass(WordCount.class);</span><br><span class="line">		job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">		job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">		job.setReducerClass(IntSumReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个.java源文件均置于 src 目录下。</p>
<h2 id="2-2_编译">2.2 编译</h2><p>Hadoop 2.x 版本中jar不再集中在一个 hadoop-core-*.jar 中，而是分成多个 jar。编译WordCount程序需要如下三个 jar：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar</span><br></pre></td></tr></table></figure></p>
<p>使用<code>javac</code>命令进行编译：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd wordcount_01</span><br><span class="line"></span><br><span class="line">$ javac -<span class="keyword">classpath</span> <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop/</span>share<span class="regexp">/hadoop/</span>common<span class="regexp">/hadoop-common-2.6.0.jar:/</span>home<span class="regexp">/hadoop/</span>hadoop<span class="regexp">/share/</span>hadoop<span class="regexp">/mapreduce/</span>hadoop-mapreduce-client-core-<span class="number">2.6</span>.<span class="number">0</span>.jar:<span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop/</span>share<span class="regexp">/hadoop/</span>common<span class="regexp">/lib/</span>commons-cli-<span class="number">1.2</span>.jar -d classes<span class="regexp">/ src/</span>*.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-classpath，设置源代码里使用的各种类库所在的路径，多个路径用<code>&quot;:&quot;</code>隔开。</li>
<li>-d，设置编译后的 class 文件保存的路径。</li>
<li>src/*.java，待编译的源文件。</li>
</ul>
<h2 id="2-3_打包">2.3 打包</h2><p>将编译好的 class 文件打包成 Jar 包，jar 命令是 JDK 的打包命令行工具。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar -cvf wordcount<span class="class">.jar</span> classes</span><br></pre></td></tr></table></figure>
<p>打包结果是 wordcount.jar 文件，放在当前目录下。</p>
<h2 id="2-4_执行">2.4 执行</h2><p>执行hadoop程序的时候，输入文件必须先放入hdfs文件系统中，不能是本地文件。</p>
<p><strong>1 . 先查看hdfs文件系统的根目录：</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop<span class="regexp">/bin/hadoop fs -ls /</span></span><br><span class="line">Found <span class="number">1</span> items</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          <span class="number">0</span> <span class="number">2015</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">14</span>:<span class="number">38</span> /hbase</span><br></pre></td></tr></table></figure></p>
<p>可以看出，hdfs的根目录是一个叫<code>/hbase</code>的目录。</p>
<p><strong>2 . 然后利用<code>put</code>将输入文件（多个输入文件位于<code>input</code>文件夹下）复制到hdfs文件系统中：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop fs -put <span class="tag">input</span> /hbase</span><br></pre></td></tr></table></figure></p>
<p><strong>3 . 运行wordcount程序</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount_01/wordcount<span class="class">.jar</span> WordCount /hbase/<span class="tag">input</span> /hbase/output</span><br></pre></td></tr></table></figure>
<p>提示找不到 WordCount 类：<code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: WordCount</code>…</p>
<p>因为程序中声明了 package ，所以在命令中也要 com.lisong.hadoop.WordCount 写完整：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount_01/wordcount<span class="class">.jar</span> com<span class="class">.lisong</span><span class="class">.hadoop</span><span class="class">.WordCount</span> /hbase/<span class="tag">input</span> /hbase/output</span><br></pre></td></tr></table></figure></p>
<p>其中 “jar” 参数是指定 jar 包的位置，com.lisong.hadoop.WordCount 是主类。运行程序处理 input 目录下的多个文件，将结果写入 /hbase/output 目录。</p>
<p><strong>4 . 查看运行结果</strong></p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">hadoop/bin/hadoop</span> <span class="comment">fs</span> <span class="literal">-</span><span class="comment">ls</span> <span class="comment">/hbase/output</span></span><br><span class="line"><span class="comment">Found</span> <span class="comment">2</span> <span class="comment">items</span></span><br><span class="line"><span class="literal">-</span><span class="comment">rw</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span>   <span class="comment">3</span> <span class="comment">hadoop</span> <span class="comment">supergroup</span>          <span class="comment">0</span> <span class="comment">2015</span><span class="literal">-</span><span class="comment">07</span><span class="literal">-</span><span class="comment">28</span> <span class="comment">18:05</span> <span class="comment">/hbase/output/_SUCCESS</span></span><br><span class="line"><span class="literal">-</span><span class="comment">rw</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span>   <span class="comment">3</span> <span class="comment">hadoop</span> <span class="comment">supergroup</span>         <span class="comment">33</span> <span class="comment">2015</span><span class="literal">-</span><span class="comment">07</span><span class="literal">-</span><span class="comment">28</span> <span class="comment">18:05</span> <span class="comment">/hbase/output/part</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="comment">00000</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>/hbase/output/</code>目录下有两个文件，结果就存在<code>part-r-00000</code>中：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop<span class="regexp">/bin/</span>hadoop fs -cat <span class="regexp">/hbase/</span>output/part-r-<span class="number">00000</span></span><br><span class="line">Google	<span class="number">6</span></span><br><span class="line">Java	<span class="number">2</span></span><br><span class="line">baidu	<span class="number">3</span></span><br><span class="line">hadoop	<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="三、WordCount程序分析">三、WordCount程序分析</h1><h2 id="3-1_Hadoop数据类型">3.1 Hadoop数据类型</h2><p>Hadoop MapReduce操作的是键值对，但这些键值对并不是Integer、String等标准的Java类型。为了让键值对可以在集群上移动，Hadoop提供了一些实现了<code>WritableComparable</code>接口的基本数据类型，以便用这些类型定义的数据可以被<strong>序列化</strong>进行网络传输、文件存储与大小比较。</p>
<ul>
<li>值：仅会被简单的传递，必须实现<code>Writable</code>或<code>WritableComparable</code>接口。</li>
<li>键：在Reduce阶段排序时需要进行比较，故只能实现<code>WritableComparable</code>接口。</li>
</ul>
<p>下面是8个预定义的Hadoop基本数据类型，它们均实现了<code>WritableComparable</code>接口：</p>
<table>
<thead>
<tr>
<th>类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BooleanWritable</td>
<td style="text-align:left">标准布尔型数值</td>
</tr>
<tr>
<td>ByteWritable</td>
<td style="text-align:left">单字节数值</td>
</tr>
<tr>
<td>DoubleWritable</td>
<td style="text-align:left">双字节数</td>
</tr>
<tr>
<td>FloatWritable</td>
<td style="text-align:left">浮点数</td>
</tr>
<tr>
<td>IntWritable</td>
<td style="text-align:left">整型数</td>
</tr>
<tr>
<td>LongWritable</td>
<td style="text-align:left">长整型数</td>
</tr>
<tr>
<td>Text</td>
<td style="text-align:left">使用UTF8格式存储的文本</td>
</tr>
<tr>
<td>NullWritable</td>
<td style="text-align:left">当<code>&lt;key,value&gt;</code>中的key或value为空时使用</td>
</tr>
</tbody>
</table>
<h2 id="3-2_源代码分析">3.2 源代码分析</h2><p><strong>3.2.1 Map过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">	Text word = <span class="keyword">new</span> Text();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">		<span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">			word.set(itr.nextToken());</span><br><span class="line">			context.write(word, one);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map过程需要继承<code>org.apache.hadoop.mapreduce</code>包中 Mapper 类，并<strong>重写</strong>其map方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的模板参数：第一个Object表示输入key的类型；第二个Text表示输入value的类型；第三个Text表示表示输出键的类型；第四个IntWritable表示输出值的类型。</p>
<p>作为map方法输入的键值对，其value值存储的是文本文件中的一行（以回车符为行结束标记），而key值为该行的首字母相对于文本文件的首地址的偏移量。然后StringTokenizer类将每一行拆分成为一个个的单词，并将<code>&lt;word,1&gt;</code>作为map方法的结果输出，其余的工作都交有 MapReduce框架 处理。</p>
<p><strong>注：</strong><code>StringTokenizer</code>是Java工具包中的一个类，用于将字符串进行拆分——默认情况下使用空格作为分隔符进行分割。</p>
<p><strong>3.2.2 Reduce过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(IntWritable val:values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reduce过程需要继承<code>org.apache.hadoop.mapreduce</code>包中 Reducer 类，并 <strong>重写</strong> reduce方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中模板参数同Map一样，依次表示是输入键类型，输入值类型，输出键类型，输出值类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span></span></span><br></pre></td></tr></table></figure>
<p>reduce 方法的输入参数 key 为单个单词，而 values 是由各Mapper上对应单词的计数值所组成的列表（一个实现了 Iterable 接口的变量，可以理解成 values 里包含若干个 IntWritable 整数，可以通过迭代的方式遍历所有的值），所以只要遍历 values 并求和，即可得到某个单词出现的总次数。</p>
<p><strong>3.2.3 执行作业</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"wordcount"</span>);</span><br><span class="line">		job.setJarByClass(WordCount.class);</span><br><span class="line">		job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">		job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">		job.setReducerClass(IntSumReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MapReduce中，由Job对象负责管理和运行一个计算任务，并通过Job的一些方法对任务的参数进行相关的设置，此处：</p>
<ul>
<li>设置了使用<code>TokenizerMapper.class</code>完成Map过程中的处理，使用<code>IntSumReducer.class</code>完成Combine和Reduce过程中的处理。</li>
<li>还设置了Map过程和Reduce过程的输出类型：key的类型为Text，value的类型为IntWritable。</li>
<li><p>任务的输出和输入路径则由命令行参数指定，并由FileInputFormat和FileOutputFormat分别设定。</p>
<ol>
<li>FileInputFormat类的很重要的作用就是将文件进行切分 split，并将 split 进一步拆分成key/value对</li>
<li>FileOutputFormat类的作用是将处理结果写入输出文件。</li>
</ol>
</li>
<li><p>完成相应任务的参数设定后，即可调用 <code>job.waitForCompletion()</code> 方法执行任务。</p>
</li>
</ul>
<p><strong>3.2.4 WordCount流程</strong></p>
<p>1）将文件拆分成splits，由于测试用的文件较小，所以每个文件为一个split，并将文件按行分割形成<code>&lt;key,value&gt;</code>对，key为偏移量（包括了回车符），value为文本行。这一步由MapReduce框架自动完成，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729173938301" alt=""></p>
<p>2）将分割好的<code>&lt;key,value&gt;</code>对交给用户定义的map方法进行处理，生成新的<code>&lt;key,value&gt;</code>对，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150729174039812" alt=""></p>
<p>3）得到map方法输出的<code>&lt;key,value&gt;</code>对后，Mapper会将它们按照key值进行排序，并执行Combine过程，将key值相同的value值累加，得到Mapper的最终输出结果。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729174057622" alt=""></p>
<p>4）Reducer先对从Mapper接收的数据进行排序，再交由用户自定义的reduce方法进行处理，得到新的<code>&lt;key,value&gt;</code>对，并作为WordCount的输出结果，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729174400615" alt=""></p>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<hr>
<p>参考： 实战Hadoop：开启通向云计算的捷径</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个程序就是词频统计<code>WordCount</code>程序。</p>
<h1 id="一、MapReduce简介">一、MapReduce简介</h1><h2 id="1-1_MapReduce编程模型">1.1 MapReduce编程模型</h2><p>MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。</p>
<p>在Hadoop中，用于执行MapReduce任务的机器角色有两个：]]>
    
    </summary>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
      <category term="大数据-Hadoop" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase技术简介]]></title>
    <link href="http://yoursite.com/2015/07/24/hbase-introduction/"/>
    <id>http://yoursite.com/2015/07/24/hbase-introduction/</id>
    <published>2015-07-23T16:49:08.000Z</published>
    <updated>2015-07-23T17:03:00.981Z</updated>
    <content type="html"><![CDATA[<h1 id="一、HBase简介">一、HBase简介</h1><p>HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，类似Google BigTable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。<a id="more"></a></p>
<p><img src="http://img.blog.csdn.net/20150723155042611" alt=""></p>
<p>上图描述了Hadoop EcoSystem中的各层系统，其中HBase位于结构化存储层，Hadoop HDFS为HBase提供了高可靠性的底层存储支持，Hadoop MapReduce为HBase提供了高性能的计算能力，Zookeeper为HBase提供了稳定服务和failover机制。</p>
<p>此外，Pig和Hive还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单。 Sqoop则为HBase提供了方便的RDBMS数据导入功能，使得传统数据库数据向HBase中迁移变的非常方便。</p>
<p><br></p>
<h1 id="二、HBase访问接口">二、HBase访问接口</h1><ol>
<li><p>Native Java API，最常规和高效的访问方式，适合Hadoop MapReduce Job并行批处理HBase表数据</p>
</li>
<li><p>HBase Shell，HBase的命令行工具，最简单的接口，适合HBase管理使用</p>
</li>
<li><p>Thrift Gateway，利用Thrift序列化技术，支持C++，PHP，Python等多种语言，适合其他异构系统在线访问HBase表数据</p>
</li>
<li><p>REST Gateway，支持REST 风格的Http API访问HBase, 解除了语言限制</p>
</li>
<li><p>Pig，可以使用Pig Latin流式编程语言来操作HBase中的数据，和Hive类似，本质最终也是编译成MapReduce Job来处理HBase表数据，适合做数据统计</p>
</li>
<li><p>Hive，当前Hive的Release版本尚没有加入对HBase的支持，但在下一个版本Hive 0.7.0中将会支持HBase，可以使用类似SQL语言来访问HBase。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、HBase数据模型">三、HBase数据模型</h1><h2 id="3-1_Table_&amp;_Column_Family">3.1 Table &amp; Column Family</h2><p><img src="http://img.blog.csdn.net/20150724005727007" alt=""></p>
<p><strong>Row Key：</strong> </p>
<p>行键，Table的主键，用来检索记录。访问HBase table中的行，只有三种方式：</p>
<ul>
<li>通过单个row key访问</li>
<li>通过row key的range</li>
<li>全表扫描</li>
</ul>
<p>row key可以是任意字符串（最大长度是 64KB，实际应用中长度一般为 10-100bytes左右），在HBase内部，row key保存为字节数组。数据按照row key的字典序（byte order）排序存储，因此设计key时要充分排序存储这个特性，将经常一起读取的行存储放到一起。</p>
<p>HBase支持单行事务，行的一次读写是原子操作 （不论一次读写多少列），这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。</p>
<p><strong>Column Family</strong>：</p>
<p>列簇，Table在水平方向有一个或者多个Column Family组成，一个Column Family中可以由任意多个Column组成，即Column Family支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。</p>
<p>列名都以列族作为前缀。例如’courses:history’，’courses:math’，都属于courses 这个列族。<br>访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族上的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</p>
<p><strong>Timestamp</strong>: </p>
<p>时间戳，每次数据操作对应的时间戳，可以看作是数据的version number。时间戳的类型是 64位整型。时间戳可以由HBase在数据写入时自动赋值，此时时间戳是精确到毫秒的当前系统时间；时间戳也可以由客户显式赋值，如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。</p>
<p>为了避免数据存在过多版本造成的的管理 （包括存储和索引）负担，HBase提供了两种数据版本回收方式：一是保存数据的最后n个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<p><strong>Cell：</strong></p>
<p>由 {<code>row key</code>, <code>column family</code>, <code>column qualifier</code>, <code>version</code>} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存贮。</p>
<h2 id="3-2_Table_&amp;_Region">3.2 Table &amp; Region</h2><p>当Table随着记录数不断增加而变大后，会逐渐分裂成多份splits，成为regions，一个region由[startkey,endkey)表示，不同的region会被Master分配给相应的RegionServer进行管理：</p>
<p><img src="http://img.blog.csdn.net/20150723171646985" alt=""></p>
<h2 id="3-3_-ROOT-_&amp;&amp;_-META-_Table">3.3 -ROOT- &amp;&amp; .META. Table</h2><p>HBase中有两张特殊的Table，-ROOT-和.META.</p>
<ul>
<li><p>.META.：记录了用户表的Region信息，.META.可以有多个regoin</p>
</li>
<li><p>-ROOT-：记录了.META.表的Region信息，-ROOT-只有一个region</p>
</li>
<li><p>Zookeeper中记录了-ROOT-表的location</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150723172102610" alt=""></p>
<p>Client访问用户数据之前需要首先访问zookeeper，然后访问-ROOT-表，接着访问.META.表，最后才能找到User Table的位置去访问，中间需要多次网络操作，不过Client端会做cache缓存。</p>
<p><br></p>
<h1 id="四、HBase系统架构">四、HBase系统架构</h1><p><img src="http://img.blog.csdn.net/20150723173041385" alt=""></p>
<p><strong>Client</strong></p>
<p>HBase Client使用HBase的RPC机制与HMaster和HRegionServer进行通信，对于管理类操作，Client与HMaster进行RPC；对于数据读写类操作，Client与HRegionServer进行RPC</p>
<p><strong>Zookeeper</strong></p>
<p>Zookeeper Quorum中除了存储了-ROOT-表的地址和HMaster的地址，HRegionServer也会把自己以Ephemeral方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的健康状态。此外，Zookeeper也避免了HMaster的单点问题，见下文描述。</p>
<p><strong>HMaster</strong></p>
<p>HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行，HMaster在功能上主要负责Table和Region的管理工作：</p>
<ol>
<li><p>管理用户对Table的增、删、改、查操作</p>
</li>
<li><p>管理HRegionServer的负载均衡，调整Region分布</p>
</li>
<li><p>在Region Split后，负责新Region的分配</p>
</li>
<li><p>在HRegionServer停机后，负责失效HRegionServer 上的Regions迁移</p>
</li>
<li><p>HDFS的垃圾文件回收 </p>
</li>
</ol>
<p>注意：Client访问HBase上数据的过程并不需要HMaster参与（寻址访问Zookeeper和HRegionServer，数据读写访问HRegioneServer），HMaster仅仅维护者table和region的元数据信息，负载很低。</p>
<p><strong>HRegionServer</strong></p>
<p>HRegionServer主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。</p>
<p><img src="http://img.blog.csdn.net/20150723174212472" alt=""></p>
<p><strong>注意，每个HRegsionServer维护一个HLog文件</strong></p>
<p>HRegionServer内部管理了一系列HRegion对象，每个HRegion对应了Table中的一个Region，HRegion中由多个HStore组成。每个HStore对应了Table中的一个Column Family的存储，可以看出每个Column Family其实就是一个集中的存储单元，因此最好将具备共同IO特性的column放在一个Column Family中，这样最高效。</p>
<p><strong>HStore</strong></p>
<p>HStore 是HBase存储的核心，其中由两部分组成：</p>
<ul>
<li>MemStore</li>
<li>StoreFiles。</li>
</ul>
<p>MemStore是Sorted Memory Buffer，用户写入的数据首先会放入MemStore，当MemStore满了以后会Flush成一个StoreFile（底层实现是HFile）。</p>
<p>Compaction：当StoreFile文件数量增长到一定阈值，会触发Compact合并操作，将多个StoreFiles合并成一个StoreFile，合并过程中会进行版本合并和数据删除，因此可以看出HBase其实只有增加数据，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的写操作只要进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
<p>Split：当StoreFiles Compact后，会逐步形成越来越大的StoreFile，当单个StoreFile大小超过一定阈值后，会触发Split操作，同时把当前Region Split成2个Region，父Region会下线，新Split出的2个孩子Region会被HMaster分配到相应的HRegionServer上，使得原先1个Region的压力得以分流到2个Region上。下图描述了Compaction和Split的过程：</p>
<p><img src="http://img.blog.csdn.net/20150723175721133" alt=""></p>
<p><strong>HLog</strong></p>
<p>在理解了上述HStore的基本原理后，还必须了解一下HLog的功能，因为上述的HStore在系统正常工作的前提下是没有问题的，但是在分布式系统环境中，无法避免系统出错或者宕机，因此一旦HRegionServer意外退出，MemStore中的内存数据将会丢失，这就需要引入HLog了。</p>
<p>每个HRegionServer中都有一个HLog对象，HLog是一个实现Write Ahead Log的类，在每次用户操作写入MemStore的同时，也会写一份数据到HLog文件中（HLog文件格式见后续），HLog文件定期会滚动出新的，并删除旧的文件（已持久化到StoreFile中的数据）。当HRegionServer意外终止后，HMaster会通过Zookeeper感知到，HMaster首先会处理遗留的 HLog文件，将其中不同Region的Log数据进行拆分，分别放到相应region的目录下，然后再将失效的region重新分配，领取 到这些region的HRegionServer在Load Region的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后flush到StoreFiles，完成数据恢复。</p>
<p><br></p>
<h1 id="五、HBase存储格式">五、HBase存储格式</h1><p>HBase中的所有数据文件都存储在Hadoop HDFS文件系统上，主要包括上述提出的两种文件类型：</p>
<ol>
<li><p>HFile， HBase中KeyValue数据的存储格式，HFile是Hadoop的二进制格式文件，实际上StoreFile就是对HFile做了轻量级包装，即StoreFile底层就是HFile</p>
</li>
<li><p>HLog File，HBase中WAL（Write Ahead Log） 的存储格式，物理上是Hadoop的Sequence File</p>
</li>
</ol>
<p><strong>HFile</strong></p>
<p>下图是HFile V2的存储格式：</p>
<p><img src="http://img.blog.csdn.net/20150724000300134" alt=""></p>
<p>HFile的组成分成四部分，分别是Scanned Block（数据block）、Non-Scanned block（元数据block）、Load-on-open（在hbase运行时，HFile需要加载到内存中的索引、bloom filter和文件信息）以及trailer（文件尾）。</p>
<p>在HFile中根据一个key搜索一个data的过程： </p>
<ol>
<li><p>先内存中对HFile的root index进行二分查找。如果支持多级索引的话，则定位到的是leaf/intermediate index，如果是单级索引，则定位到的是data block</p>
</li>
<li><p>如果支持多级索引，则会从缓存/hdfs（分布式文件系统）中读取leaf/intermediate index chunk，在leaf/intermediate chunk根据key值进行二分查找（leaf/intermediate index chunk支持二分查找），找到对应的data block。</p>
</li>
<li><p>从缓存/hdfs中读取data block。</p>
</li>
<li><p>在data block中遍历查找key。</p>
</li>
</ol>
<p>Data Block是HBase I/O的基本单元，为了提高效率，HRegionServer中有基于LRU的 Block Cache 机制。每个Data块的大小可以在创建一个Table的时候通过参数指定（默认64K），大号的Block有利于顺序Scan，小号Block利于随机查询。在DataBlock中存储的是一系列KeyValue，在KeyValue后面跟一个timestamp，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150724000710687" alt=""></p>
<p>HFile里面的每个KeyValue对就是一个简单的byte数组。但是这个byte数组里面包含了很多项，并且有固定的结构。KV结构图如下：</p>
<p><img src="http://img.blog.csdn.net/20150724000728042" alt=""></p>
<p>可以看出KeyValue格式分为四个部分：KeyLength、ValueLength、Key、Value。</p>
<p>其中KeyLength和ValueLength都是整型，表示长度。Key有固定的格式，KeyType有四种类型，分别是Put、Delete、 DeleteColumn和DeleteFamily。Value部分没有这么复杂的结构，就是纯粹的二进制数据了。</p>
<p><strong>HLogFile</strong></p>
<p><img src="http://img.blog.csdn.net/20150724000757602" alt=""></p>
<p>上图中示意了HLog文件的结构，其实HLog文件就是一个普通的Hadoop Sequence File，Sequence File 的Key是HLogKey对象，HLogKey中记录了写入数据的归属信息，除了table和region名字外，同时还包括 sequence number和timestamp，timestamp是“写入时间”，sequence number的起始值为0，或者是最近一次存入文件系统中sequence number。</p>
<p>HLog Sequece File的Value是HBase的KeyValue对象，即对应HFile中的KeyValue，可参见上文描述。</p>
<p><br></p>
<h1 id="六、关键流程">六、关键流程</h1><h2 id="6-1_region定位">6.1 region定位</h2><p>HBase如何找到某个row key （或者某个row key的range）所在的region？使用三层类似B+树的结构来保存region位置：</p>
<ul>
<li>第一层：Zookeeper保存了-ROOT-表的位置。</li>
<li>第二层：-ROOT- 表保存了.META.表所有region的位置，通过-ROOT-表，可以访问.META.表的数据。</li>
<li>第三层：.META.是一个特殊的表，保存了HBase中所有数据表的region位置信息。</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li>-ROOT-表永远不会被split，保证了只需要三次跳转，就能定位到任意region</li>
<li>META.表每行保存一个region的位置信息，row key采用表名+表的最后一行编码而成</li>
<li>为了加快访问，.META.表的全部region都保存在内存中</li>
<li>Client会将查询过的位置信息保存缓存起来，缓存不会主动失效</li>
</ol>
<h2 id="6-2_region分配">6.2 region分配</h2><p>任何时刻，一个region只能分配给一个HRegionServer。HMaster记录了当前有哪些可用的HRegionServer。以及当前哪些region分配给了哪些HRegionServer，哪些region还没有分配。当存在未分配的region，并且有一个HRegionServer上有可用空间时，HMaster就给这个HRegionServer发送一个装载请求，把region分配给这个HRegionServer。HRegionServer得到请求后，就开始对此region提供服务。</p>
<h2 id="6-3_写请求处理">6.3 写请求处理</h2><p>数据在更新时首先写入Log（WAL log）和内存（MemStore）中，MemStore中的数据是排序的，当MemStore累计到一定阈值时，就会创建一个新的MemStore，并且将老的MemStore添加到flush队列，由单独的线程flush到磁盘上，成为一个StoreFile。与此同时，系统会在Zookeeper中记录一个redo point，表示这个时刻之前的变更已经持久化了。</p>
<p>当系统出现意外时，可能导致内存（MemStore）中的数据丢失，此时使用Log（WAL log）来恢复checkpoint之后的数据。</p>
<p>前面提到过StoreFile是只读的，一旦创建后就不可以再修改。因此HBase的更新其实是不断追加的操作，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的写操作只要 进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
<h2 id="6-4_读请求处理">6.4 读请求处理</h2><p>如果想快速读取数据，通用的原则是数据保持有序 并 尽可能保存在内存里。HBase实现了这两个目标。</p>
<ol>
<li>HBase提供三维有序存储，首先以rowkey字典序，然后以column family + column qualifier字典序，最后单元格是以timestamp时间戳降序排序。</li>
<li>HBase读操作使用了LRU缓存技术，这种缓存叫做BlockCache，用来保存从HFile里读入内存的频繁访问的数据。</li>
</ol>
<p>从HBase读数据，会依次访问三个地方：首先检查MemStore，然后检查BlockCache，最后才会访问硬盘上的对应HFile。</p>
<h2 id="6-5_Compact/Split">6.5 Compact/Split</h2><p>上文已经讲到，当StoreFile文件数量达到一定阈值，会触发compaction；当单个StoreFile大小超过一定阈值后，会触发split。</p>
<p>Compaction分为两种：major compaction（大合并）和 minor compaction（小合并）</p>
<ol>
<li><p>minor compaction把多个小HFile合并成一个大HFile，主要是为了提高读效率（因为一个row可能散布在多个HFile文件中）。minor compaction不做任何删除数据、过期数据的清理工作。</p>
</li>
<li><p>major compaction是把给定region的一个列族的所有HFile合并成一个文件，major compaction会丢弃有删除标记的或过期的内容，释放占用的空间。</p>
</li>
<li><p>minor合并是轻量级的，可以频繁发生；major合并相当耗资源，不要经常使用，且通常需要手工触发。</p>
</li>
</ol>
<p>Split操作过程完成的非常快，因为原始的数据文件并不会被改变，系统只是简单的创建两个Reference文件指向原始的数据文件，每个Reference文件管理原始文件一半的数据。Reference文件名字是一个ID，它使用被参考的region的名字的hash作为前缀，例如：1278437856009925445.3323223323。Reference文件只含有非常少量的信息，这些信息包括被分割的原始region的key以及这个文件管理前半段还是后半段。只有当系统做compaction的时候原始数据文件才会被分割成两个独立的文件并放到相应的region目录下面，同时原始数据文件和那些Reference文件也会被清除。</p>
<h2 id="6-6_HRegionServer上线和下线">6.6 HRegionServer上线和下线</h2><p>HMaster使用Zookeeper来跟踪HRegionServer状态。当某个HRegionServer启动时，会首先在Zookeeper上的server目录下建立代表自己的文件，并获得该文件的独占锁。由于HMaster订阅了server目录上的变更消息，当server目录下的文件出现新增或删除操作时，HMaster可以得到来自Zookeeper的实时通知。因此一旦HRegionServer上线，HMaster能马上得到消息。</p>
<p>当HRegionServer下线时，它和Zookeeper的会话断开，Zookeeper自动释放代表这台server的文件上的独占锁。而HMaster不断轮询server目录下文件的锁状态，如果发现某个HRegionServer丢失了它自己的独占锁（或者HMaster连续几次和HRegionServer通信都无法成功），HMaster就会去尝试获取代表这个HRegionServer的读写锁，一旦获取成功，就可以确定：</p>
<ul>
<li>可能性一：HRegionServer和Zookeeper之间的网络断开了;</li>
<li>可能性二：HRegionServer挂了;</li>
</ul>
<p>的其中一种情况发生了，无论哪种情况，HRegionServer都无法继续为它的region提供服务了，此时HMaster会删除server目录下代表这台HRegionServer的文件，并将这台HRegionServer的region分配给其它还活着的HRegionServer。</p>
<p>如果网络短暂出现问题导致HRegionServer丢失了它的锁，那么HRegionServer重新连接到Zookeeper之后，只要代表它的文件还在，它就会不断尝试获取这个文件上的锁，一旦获取到了，就可以继续提供服务。</p>
<h2 id="6-7_HMaster上线和下线">6.7 HMaster上线和下线</h2><p>HMaster启动会依次进行以下步骤:</p>
<ol>
<li>从Zookeeper上获取唯一一个master的锁，用来阻止其它HMaster成为工作HMaster。</li>
<li>扫描Zookeeper上的server目录，获得当前可用的HRegionServer列表。</li>
<li>和2中的每个HRegionServer通信，获得当前已分配的region和HRegionServer的对应关系。</li>
<li>扫描.META.中region的集合，计算得到当前还未分配的region，将他们放入待分配region列表。</li>
</ol>
<p>由于HMaster只维护表和region的元数据，而不参与表数据IO的过程，因此HMaster下线仅导致所有元数据的修改被冻结（无法创建删除表，无法修改表的schema，无法进行region的负载均衡，无法处理region上下线，无法进行region的合并，唯一例外的是region的split可以正常进行，因为只有HRegionServer参与），表的数据读写还可以正常进行。因此HMaster下线短时间内对整个HBase集群没有影响。</p>
<p>从上线过程可以看到，HMaster保存的信息全是可以冗余信息（都可以从系统其它地方收集到或者计算出来），因此，一般HBase集群中总是有一个HMaster在提供服务，还有一个以上的HMaster在等待时机抢占它的位置。</p>
<p><br></p>
<h1 id="七、结束">七、结束</h1><p>本文对HBase技术在功能和设计上进行了大致的介绍，由于篇幅有限，本文没有过多深入地描述HBase的一些细节技术。</p>
<p><br><br><br><br><br></p>
<hr>
<p>转自：</p>
<p>[1] www.searchtb.com/2011/01/understanding-hbase.html<br>[2] blog.csdn.net/john_f_lau/article/category/1832241<br>[3] my.oschina.net/zhengyang841117/blog/188723</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、HBase简介">一、HBase简介</h1><p>HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，类似Google BigTable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop+HBase+ZooKeeper分布式集群环境搭建]]></title>
    <link href="http://yoursite.com/2015/07/20/hadoop-hbase-zookeeper-distributed-mode/"/>
    <id>http://yoursite.com/2015/07/20/hadoop-hbase-zookeeper-distributed-mode/</id>
    <published>2015-07-20T14:52:53.000Z</published>
    <updated>2015-07-21T14:28:56.535Z</updated>
    <content type="html"><![CDATA[<h2 id="一、环境说明">一、环境说明</h2><p>集群环境至少需要3个节点（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通，下面举例说明，配置节点IP分配如下：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">User</th>
<th style="text-align:left">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td style="text-align:left">192.168.59.133</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave1</td>
<td style="text-align:left">192.168.59.134</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave2</td>
<td style="text-align:left">192.168.59.135</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
</tbody>
</table>
<a id="more"></a>三个节点均使用<code>CentOS 6.5</code>系统，为了便于维护，集群环境配置项最好使用相同用户名、用户密码、相同hadoop、hbase、zookeeper目录结构。<br><br><strong>注：</strong> 可以通过编辑<code>/etc/sysconfig/network</code>文件来修改 hostname 。<br><br>##二、准备工作<br><br>###2.1 安装JDK<br><br>在三台机器上配置JDK环境，下载 <code>jdk-8u51-linux-x64.rpm</code> 文件直接安装：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh jdk-<span class="number">8u</span>51-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p>修改配置文件 <code>vim /etc/profile</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.<span class="number">8.0</span>_51</span><br><span class="line">export PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">export CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/<span class="tag">dt</span><span class="class">.jar</span>:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>然后重新加载配置文件使之生效：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2_添加Hosts映射关系">2.2 添加Hosts映射关系</h3><p>分别在三个节点上添加hosts映射关系：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vim /etc/hosts</span><br></pre></td></tr></table></figure></p>
<p>添加的内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.59.133 master</span><br><span class="line">192.168.59.134 slave1</span><br><span class="line">192.168.59.135 slave2</span><br></pre></td></tr></table></figure>
<h3 id="2-3_集群之间SSH无密码登陆">2.3 集群之间SSH无密码登陆</h3><p>CentOS默认安装了ssh，如果没有你需要先安装ssh 。</p>
<p>集群环境的使用必须通过ssh无密码登陆来执行，本机登陆本机必须无密码登陆，主机与从机之间必须可以双向无密码登陆，从机与从机之间无限制。</p>
<p><strong>2.3.1 设置master无密码自登陆</strong></p>
<p>主要有三步：①生成公钥和私钥、②导入公钥到认证文件、③更改权限<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="prompt">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">700</span> ~<span class="regexp">/.ssh &amp;&amp; chmod 600 ~/</span>.ssh/*</span><br></pre></td></tr></table></figure></p>
<p>测试，第一次登录可能需要yes确认，之后就可以直接登录了：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br><span class="line">Last login: Sat Jul <span class="number">18</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">44</span> <span class="number">2015</span> <span class="keyword">from</span> localhost</span><br></pre></td></tr></table></figure></p>
<p>对于 slave1 和 slave2，进行无密码自登陆设置，操作同上。</p>
<p><strong>2.3.2 设置主机-&gt;从机的无密码登录</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@slave1</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@slave2</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>ssh hadoop<span class="variable">@slave1</span></span><br><span class="line"><span class="constant">Last </span><span class="symbol">login:</span> <span class="constant">Sat Jul </span><span class="number">18</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">41</span> <span class="number">2015</span> from master</span><br><span class="line"></span><br><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>ssh hadoop<span class="variable">@slave2</span></span><br><span class="line"><span class="constant">Last </span><span class="symbol">login:</span> <span class="constant">Sat Jul </span><span class="number">18</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">14</span> <span class="number">2015</span> from master</span><br></pre></td></tr></table></figure></p>
<p><strong>2.3.3 设置从机-&gt;主机的无密码登录</strong></p>
<p>分别在slave1、slave2上执行：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@master</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="三、Hadoop集群安装配置">三、Hadoop集群安装配置</h2><p>这里会将hadoop、hbase、zookeeper的安装包都解压到<code>/home/hadoop/</code>个人主文件夹下，并重命名为hadoop、hbase、zookeeper。</p>
<h3 id="3-1_修改hadoop配置">3.1 修改hadoop配置</h3><p>配置文件都在<code>~/hadoop/etc/</code>目录下</p>
<p><strong>3.1.1 core-site.xml</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;configuration&gt;</span></span><br><span class="line">	<span class="variable">&lt;property&gt;</span></span><br><span class="line">		<span class="variable">&lt;name&gt;</span>fs.<span class="keyword">default</span>.name<span class="variable">&lt;/name&gt;</span></span><br><span class="line">		<span class="variable">&lt;value&gt;</span>hdfs://master:<span class="number">9000</span><span class="variable">&lt;/value&gt;</span></span><br><span class="line">	<span class="variable">&lt;/property&gt;</span></span><br><span class="line"><span class="variable">&lt;/configuration&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.2 hadoop-env.sh</strong></p>
<p>添加JDK路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>
<p><strong>3.1.3 hdfs-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hadoop/name<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hadoop/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>3<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.4 mapred-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.5 修改masters文件</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master</span><br></pre></td></tr></table></figure>
<p><strong>3.1.6 修改slaves文件</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave1</span></span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
<p>注意：三台机器上都进行相同的配置，都放在相同的路径下。</p>
<p>使用<code>scp</code>命令进行从本地到远程（或远程到本地）的文件拷贝操作：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop     slave1:/</span>home/hadoop</span><br><span class="line">scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop     slave2:/</span>home/hadoop</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2_启动hadoop集群">3.2 启动hadoop集群</h3><p>进入master的<code>~/hadoop</code>目录，执行以下操作：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hadoop namenode -<span class="built_in">format</span></span><br></pre></td></tr></table></figure></p>
<p>格式化namenode，第一次启动服务前执行的操作，以后不需要执行。</p>
<p>然后启动hadoop：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sbin/<span class="operator"><span class="keyword">start</span>-<span class="keyword">all</span>.sh</span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>jps</code>命令能看到除jps外有5个进程：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>jps</span><br><span class="line"><span class="number">4866</span> <span class="constant">NodeManager</span></span><br><span class="line"><span class="number">4370</span> <span class="constant">NameNode</span></span><br><span class="line"><span class="number">4899</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">4648</span> <span class="constant">SecondaryNameNode</span></span><br><span class="line"><span class="number">4779</span> <span class="constant">ResourceManager</span></span><br><span class="line"><span class="number">4460</span> <span class="constant">DataNode</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="四、ZooKeeper集群安装配置">四、ZooKeeper集群安装配置</h2><p>解压zookeeper-3.3.2.tar.gz并重命名为zookeeper。</p>
<h3 id="4-1_修改配置文件zoo-cfg">4.1 修改配置文件zoo.cfg</h3><p>进入<code>~/zookeeper/conf</code>目录：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp zoo_sample<span class="class">.cfg</span> zoo.cfg</span><br></pre></td></tr></table></figure></p>
<p>拷贝<code>zoo_sample.cfg</code>文件为<code>zoo.cfg</code>，并编辑如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/hadoop/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span>.1=<span class="number">192.168</span>.59.133:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="keyword">server</span>.2=<span class="number">192.168</span>.59.134:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="keyword">server</span>.3=<span class="number">192.168</span>.59.135:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-2_新建并编辑myid文件">4.2 新建并编辑myid文件</h3><p>在dataDir目录下新建myid文件，输入一个数字（master为<code>1</code>，slave1为<code>2</code>，slave2为<code>3</code>）：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir /home/hadoop/zookeeper/data</span><br><span class="line"><span class="variable">$ </span>echo <span class="string">"1"</span> &gt; <span class="regexp">/home/hadoop</span><span class="regexp">/zookeeper/data</span><span class="regexp">/myid</span></span><br></pre></td></tr></table></figure></p>
<p>同样使用<code>scp</code>命令进行远程复制，只不过要修改每个节点上<code>myid</code>文件中的数字。</p>
<h3 id="4-3_启动ZooKeeper集群">4.3 启动ZooKeeper集群</h3><p>在ZooKeeper集群的每个结点上，执行启动ZooKeeper服务的脚本：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>~<span class="regexp">/zookeeper/bin</span><span class="regexp">/zkServer.sh start</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果启动报类似异常:QuorumCnxManager@384] - Cannot open channel to 2 at election address slave-02/192.168.0.178:3888 是可以忽略的,因为该服务启动时会尝试连接所有节点,而其他节点尚未启动。通过后面部分可以看到，集群在选出一个Leader后，最后稳定 了。其他结点可能也出现类似问题，属于正常。</p>
</li>
<li><p>关闭防火墙。在hadoop集群环境(linux系统)中最好关闭防火墙，不然会出现很多问题，例如namenode找不到datanode等。如果不关闭防火墙，客户端使用API操作HDFS以及ZooKeeper，可能就会出现下面常见的两种异常：</p>
<ul>
<li>使用API操作HDFS时会出现异常：java.net.NoRouteToHostException: No route to host</li>
<li>使用API操作ZK时会出现异常：org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss for xxxx</li>
</ul>
</li>
<li><p>使用root权限登陆后，输入关闭防火墙命令：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/iptables <span class="literal">stop</span></span><br><span class="line">$ <span class="keyword">service</span> iptables <span class="literal">stop</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改禁用selinux：     /etc/selinux/config文件，设置<code>&quot;SELINUX=disabled&quot;</code></p>
</li>
</ol>
<p><br></p>
<h2 id="五、HBase集群安装配置">五、HBase集群安装配置</h2><p>解压hbase-1.0.1.1-bin.tar.gz并重命名为hbase。</p>
<h3 id="5-1_hbase-env-sh">5.1 hbase-env.sh</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1.8.0_51</span><br><span class="line"><span class="keyword">export</span> HBASE_CLASSPATH=<span class="regexp">/home/</span>hadoop/hadoop/etc/hadoop/</span><br><span class="line"><span class="keyword">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2_hbase-site-xml">5.2 hbase-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.master<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master,slave1,slave2<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>zookeeper.session.timeout<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.support.append<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3_更改_regionservers">5.3 更改 regionservers</h3><p>在 regionservers 文件中添加slave列表：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave1</span></span><br><span class="line">slave2</span><br></pre></td></tr></table></figure></p>
<p><strong>5.4 分发并同步安装包</strong></p>
<p>将整个hbase安装目录都拷贝到所有slave服务器：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hbase  slave1:/</span>home/hadoop</span><br><span class="line">$ scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hbase  slave2:/</span>home/hadoop</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="六、启动集群">六、启动集群</h3><p> <strong>1. 启动ZooKeeper</strong></p>
<p>~/zookeeper/bin/zkServer.sh start</p>
<p><strong>2. 启动hadoop</strong></p>
<p>~/hadoop/sbin/start-all.sh</p>
<p><strong>3. 启动hbase</strong></p>
<p>~/hbase/bin/start-base.sh</p>
<p><strong>4. 启动后，master上进程和slave进程列表</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>jps</span><br><span class="line"><span class="number">6225</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">2897</span> <span class="constant">SecondaryNameNode </span>  <span class="comment"># hadoop进程</span></span><br><span class="line"><span class="number">2710</span> <span class="constant">NameNode </span>           <span class="comment"># hadoop master进程</span></span><br><span class="line"><span class="number">3035</span> <span class="constant">ResourceManager </span>    <span class="comment"># hadoop进程</span></span><br><span class="line"><span class="number">5471</span> <span class="constant">HMaster </span>            <span class="comment"># hbase master进程</span></span><br><span class="line"><span class="number">2543</span> <span class="constant">QuorumPeerMain </span>     <span class="comment"># zookeeper进程</span></span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@slave1</span> ~]<span class="variable">$ </span>jps</span><br><span class="line"><span class="number">4689</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">2533</span> <span class="constant">QuorumPeerMain </span>      <span class="comment"># zookeeper进程</span></span><br><span class="line"><span class="number">2589</span> <span class="constant">DataNode </span>            <span class="comment"># hadoop slave进程</span></span><br><span class="line"><span class="number">4143</span> <span class="constant">HRegionServer </span>       <span class="comment"># hbase slave进程</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 进入hbase shell进行验证</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>hbase/bin/hbase shell</span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">42</span><span class="symbol">:</span><span class="number">11</span>,<span class="number">725</span> <span class="constant">WARN</span>  [main] util.<span class="constant">NativeCodeLoader</span><span class="symbol">:</span> <span class="constant">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="constant">HBase</span> <span class="constant">Shell</span>; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.</span><br><span class="line"><span class="constant">Type</span> <span class="string">"exit&lt;RETURN&gt;"</span> to leave the <span class="constant">HBase</span> <span class="constant">Shell</span></span><br><span class="line"><span class="constant">Version</span> <span class="number">1.0</span>.<span class="number">1.1</span>, re1dbf4df30d214fca14908df71d038081577ea46, <span class="constant">Sun</span> <span class="constant">May</span> <span class="number">17</span> <span class="number">12</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">26</span> <span class="constant">PDT</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">hbase(main):001:0&gt;</span> list</span><br><span class="line"><span class="constant">TABLE</span>                                                                                </span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.6950</span> seconds</span><br><span class="line"><span class="status"></span><br><span class="line">=&gt;</span> []</span><br><span class="line"><span class="prompt">hbase(main):002:0&gt;</span> status</span><br><span class="line"><span class="number">2</span> servers, <span class="number">0</span> dead, <span class="number">1.0000</span> average load</span><br><span class="line"></span><br><span class="line"><span class="prompt">hbase(main):003:0&gt;</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br></p>
<hr>
<p>参考：<br>[1] www.smalldeng.blog.51cto.com/1038075/1329290<br>[2] www.marysee.blog.51cto.com/1000292/629405<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、环境说明">一、环境说明</h2><p>集群环境至少需要3个节点（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通，下面举例说明，配置节点IP分配如下：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">User</th>
<th style="text-align:left">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td style="text-align:left">192.168.59.133</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave1</td>
<td style="text-align:left">192.168.59.134</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave2</td>
<td style="text-align:left">192.168.59.135</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-Hadoop" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase单机环境搭建]]></title>
    <link href="http://yoursite.com/2015/07/20/hbase-standalone-mode/"/>
    <id>http://yoursite.com/2015/07/20/hbase-standalone-mode/</id>
    <published>2015-07-20T14:37:48.000Z</published>
    <updated>2015-07-20T14:44:41.307Z</updated>
    <content type="html"><![CDATA[<p>在搭建HBase单机环境之前，首先你要保证你已经搭建好Java环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version&#10;java version &#34;1.8.0_51&#34;&#10;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)&#10;Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p><code>JAVA_HOME</code>路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME&#10;/usr/java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>在单机模式中，HBase并不使用 HDFS，仅使用本地文件系统 —— ZooKeeper程序与HBase程序运行在同一个JVM进程中。<br><br>#一、下载HBase<br><br>虚拟机：VMware-workstation-11.1.0<br>操作系统：CentOS 6.5<br>JDK：jdk1.8.0_51<br>HBase：hbase-1.0.1.1<br><br>1、 下载的是HBase最新稳定版<code>hbase-1.0.1.1-bin.tar.gz</code>，地址 <a href="http://apache.fayea.com/hbase/" target="_blank" rel="external">http://apache.fayea.com/hbase/</a><br><br>2、 解压到个人主目录下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxf hbase-1.0.1.1-bin.tar.gz&#10;$ cd hbase-1.0.1.1</span><br></pre></td></tr></table></figure>
<h1 id="二、配置HBase">二、配置HBase</h1><p>需要配置两个文件。</p>
<p>1、hbase-env.sh</p>
<p>编辑文件<code>vim conf/hbase-env.sh</code>，去掉#注释，<code>JAVA_HOME</code>改成jdk对应的路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_51&#10;export HBASE_MANAGES_ZK=true</span><br></pre></td></tr></table></figure></p>
<p>Hbase依赖于zookeeper，所有的节点和客户端都必须能够访问zookeeper。</p>
<p>HBase的安装包里面有自带的ZooKeeper，<code>HBASE_MANAGES_ZK</code>环境变量用来设置是使用HBase默认自带的 Zookeeper还是使用独立的ZooKeeper。</p>
<ul>
<li><code>HBASE_MANAGES_ZK</code>为 false 时使用独立的.</li>
<li><code>HBASE_MANAGES_ZK</code>为 true 时表示使用默认自带的，让Hbase启动的时候同时也启动自带的ZooKeeper。</li>
</ul>
<p>2、hbase-site.xml</p>
<p>编辑文件<code>vim conf/hbase-site.xml</code>，设置数据保存的目录：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:///home/songlee/hbase-1.0.1.1/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下Hbase是写到/tmp的，在重启的时候/tmp会被清空，数据就会丢失。</p>
<h1 id="三、启动HBase">三、启动HBase</h1><p>使用HBase提供的脚本启动HBase：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/start-hbase.sh &#10;starting master, logging to /home/songlee/hbase-1.0.1.1/bin/../logs/hbase-songlee-master-songlee.out</span><br></pre></td></tr></table></figure></p>
<p>查看Java进程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps&#10;5464 HMaster&#10;5561 Jps</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>HMaster</code>进程已经启动了。</p>
<h1 id="四、HBase_Shell交互">四、HBase Shell交互</h1><p>HBase Shell是一个封装了Java API的JRuby应用软件，通过它可以与HBase集群进行交互。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hbase <span class="built_in">shell</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">07</span>,<span class="number">171</span> WARN  [main] util.NativeCodeLoader: Unable <span class="built_in">to</span> <span class="built_in">load</span> native-hadoop library <span class="keyword">for</span> your <span class="built_in">platform</span>... <span class="keyword">using</span> builtin-java classes where applicable</span><br><span class="line">HBase Shell; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list <span class="operator">of</span> supported commands.</span><br><span class="line">Type <span class="string">"exit&lt;RETURN&gt;"</span> <span class="built_in">to</span> leave <span class="operator">the</span> HBase Shell</span><br><span class="line">Version <span class="number">1.0</span>.1.1, re1dbf4df30d214fca14908df71d038081577ea46, Sun May <span class="number">17</span> <span class="number">12</span>:<span class="number">34</span>:<span class="number">26</span> PDT <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>建表：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):006:0&#62; create &#39;mytable&#39;,&#39;cf&#39;&#10;0 row(s) in 0.3090 seconds</span><br></pre></td></tr></table></figure></p>
<p>添加数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):008:0&#62; put &#39;mytable&#39;,&#39;first&#39;,&#39;cf:message&#39;,&#39;hello HBase!&#39;&#10;0 row(s) in 0.1420 seconds&#10;&#10;hbase(main):009:0&#62; put &#39;mytable&#39;,&#39;second&#39;,&#39;cf:foo&#39;,0x0&#10;0 row(s) in 0.0220 seconds&#10;&#10;hbase(main):010:0&#62; put &#39;mytable&#39;,&#39;third&#39;,&#39;cf:bar&#39;,3.14159&#10;0 row(s) in 0.0180 seconds</span><br></pre></td></tr></table></figure></p>
<p>获取数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):011:0&#62; get &#39;mytable&#39;,&#39;first&#39;&#10;COLUMN                          CELL                                                                                      &#10; cf:message                     timestamp=1437015412793, value=hello HBase!                                               &#10;1 row(s) in 0.0540 seconds</span><br></pre></td></tr></table></figure></p>
<p>扫描表：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):012:0&#62; scan &#39;mytable&#39;&#10;ROW                             COLUMN+CELL                                                                               &#10; first                          column=cf:message, timestamp=1437015412793, value=hello HBase!                            &#10; second                         column=cf:foo, timestamp=1437015468629, value=0                                           &#10; third                          column=cf:bar, timestamp=1437015511565, value=3.14159                                     &#10;3 row(s) in 0.0650 seconds</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在搭建HBase单机环境之前，首先你要保证你已经搭建好Java环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version&#10;java version &#34;1.8.0_51&#34;&#10;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)&#10;Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p><code>JAVA_HOME</code>路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME&#10;/usr/java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015实习生求职季总结]]></title>
    <link href="http://yoursite.com/2015/05/23/intern-seeking-experience/"/>
    <id>http://yoursite.com/2015/05/23/intern-seeking-experience/</id>
    <published>2015-05-23T01:40:05.000Z</published>
    <updated>2015-05-23T07:14:57.577Z</updated>
    <content type="html"><![CDATA[<p style="font-size:15pt;font-weight:bold">一、实习季Timeline</p>

<p>从2015年4月开始找实习，前后历时两个月，参加了很多的笔试/面试。这是一个焦虑又美好的学期，我在这段时间里学到了很多东西。</p>
<iframe src="http://timelinejs.sinaapp.com/" width="100%" height="500" frameborder="0"></iframe>

<a id="more"></a>
<p>这一个学期就这么磕磕绊绊的过了一半了，决定去360实习以后，也终于能安下心来。因为等待（笔试/面试通知）真的是很痛苦的一件事。</p>
<p>参加的笔试/面试越多，越发现自己有很多的不足。求职难免碰壁，这两个月我被虐了好几次，导致我的自信心直线下降。但现在来看，我觉得被虐反而更好，它让我不断总结和反思：哪一块的知识不知道就补哪一块，然后不断地提高自己。</p>
<p><br></p>
<p style="font-size:15pt;font-weight:bold">二、经验之谈</p>

<p>我在本科时就决定要进互联网行业，在做过的项目中是C++开发居多，所以也自然而然的走向了服务端开发方向。从这两个月的笔试/面试经历来看，其实做后台服务端开发主要就是要掌握5个方面的基础知识，而且需要较深入。</p>
<ol>
<li><p><strong>语言：</strong>编程语言必然要掌握一门的，而且需要熟练的掌握。从笔试/面试的情况来看，基本就是 C/C++/Java 熟练掌握一门，最好还会一门脚本语言（Perl/Python/Shell）。因为我是C++党，所以这里推荐一下学习C++要看的书：</p>
<ul>
<li>《C++ Primer》不用多说，入门必看。</li>
<li>《Effective C++》《More Effective C++》《深度探索C++对象模型》进阶。</li>
<li>《Effective STL》《STL源码剖析》了解C++ STL。</li>
</ul>
</li>
<li><p><strong>算法与数据结构：</strong>这个就不用多说，不管什么岗位都要有算法基础的。</p>
<ul>
<li>《算法导论》最经典，但有人说上面讲的太繁琐，其实我也觉得，可能是水平还不够。</li>
<li>《程序员面试金典》《编程之美》《剑指offer》</li>
<li>刷题：LeetCode</li>
</ul>
</li>
<li><p><strong>操作系统：</strong>做服务端开发，对操作系统一定要很了解。通常考的最多的是进程线程、内存管理、I/O管理。</p>
<ul>
<li>《现代操作系统》《深入理解计算机系统》这是原理方面的。</li>
<li>《UNIX环境高级编程》服务端是比较偏Unix/Linux的。</li>
<li>如果你还要了解Linux内核的话…</li>
</ul>
</li>
<li><p><strong>网络：</strong>主要是指TCP/IP，做服务端必须熟练掌握TCP/IP，这点不需要解释什么。</p>
<ul>
<li>《TCP/IP协议详解》卷1，必看网络协议经典书籍。</li>
<li>《计算机网络：自顶向下方法》也是讲原理的。</li>
<li>《Unix网络编程》了解了原理，需要实战一下。</li>
</ul>
</li>
<li><p><strong>数据库：</strong>不论什么样的应用，都需要数据库的支持，数据库无处不在。而现在主流的还是关系型数据库，建议学MySQL。</p>
<ul>
<li>《数据库系统概念》了解数据库。</li>
<li>《SQL Cookbook》《SQL入门经典》了解SQL结构化查询语言。</li>
<li>《高性能MySQL》《MySQL技术内幕》学习MySQL本身。</li>
</ul>
</li>
</ol>
<p>当然，上面推荐的书籍是各领域评分较高的书籍，我目前也就看了一部分（要是都看完了，我就不是这个水平了）。除了打好基础，你还可以了解某一些领域的知识，比如《Linux高性能服务器编程》帮你从整体上了解服务端开发，《分布式系统原理与范型》了解分布式，或者看一些经典的论文，比如Google三大论文，或者学习Hadoop/Spark分布式计算框架等等。</p>
<p>下面是百度公司分享的一个技术能力模型：</p>
<center><br><img src="http://img.blog.csdn.net/20150523134332379" alt=""><br></center>

<p>对于基础知识，必然是要全部掌握的；而对于技术领域，可以择其一而攻之。</p>
<p><br></p>
<p style="font-size:15pt;font-weight:bold">三、计划和展望</p>

<p>这个实习生招聘季，经过多个<code>笔试-&gt;总结-&gt;面试-&gt;总结</code>的循环，我学到了很多，提高了很多。同时，也更加明确了自己将来要做什么，要往哪个方向走。</p>
<p>我会记住并保持这段时间的这种心态，在接下来一年的实习时间里，看完还没看完的书，了解并学习一些新的领域，完成给自己制定的<code>To-Do-List</code>。相信在一年后的毕业招聘季中，我能更加地得心应手。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p style="font-size:15pt;font-weight:bold">一、实习季Timeline</p>

<p>从2015年4月开始找实习，前后历时两个月，参加了很多的笔试/面试。这是一个焦虑又美好的学期，我在这段时间里学到了很多东西。</p>
<iframe src='http://timelinejs.sinaapp.com/' width='100%' height='500' frameborder='0'></iframe>]]>
    
    </summary>
    
      <category term="非技术-杂谈" scheme="http://yoursite.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF-%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求最长回文子串]]></title>
    <link href="http://yoursite.com/2015/05/12/longest-palindromic-substring/"/>
    <id>http://yoursite.com/2015/05/12/longest-palindromic-substring/</id>
    <published>2015-05-12T12:53:19.000Z</published>
    <updated>2015-05-12T13:11:43.312Z</updated>
    <content type="html"><![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。<a id="more"></a></p>
<h3 id="解法二：动态规划法$O(n^2)$">解法二：动态规划法$O(n^2)$</h3><p>动态规划法是在暴力解法上进行的优化。通过记录一些我们需要的东西，来避免暴力解法中很多重复的判断。</p>
<p>假设 $dp[i][j]$ 表示子串 $s[i…j]$ 是否是回文，那么对于动态规划表 $dp$ 的打表方式如下：</p>
<ul>
<li><p>初始化：<br>$$\begin{cases}<br>dp[i][i] = true  &amp; \text{(0 &lt;= i &lt;= n-1)}\\<br>dp[i][i-1] = true &amp; \text{(1 &lt;= i &lt;= n-1) }\\<br>others = fasle<br>\end{cases}$$</p>
</li>
<li><p>动态规划的状态转移方程：<br>$$<br>dp[i][j] =<br>\begin{cases}<br>dp[i+1][j-1], &amp; \text{if s[i] == s[j]} \\<br>false, &amp; \text{if s[i] ≠ s[j]}<br>\end{cases}<br>$$</p>
</li>
</ul>
<p>C++代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="comment">// 动态规划表，全部初始化为true</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=len; ++k) &#123;    <span class="comment">// 枚举子串的长度</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-k; ++i) &#123;  <span class="comment">// 枚举子串起始位置</span></span><br><span class="line">			<span class="keyword">int</span> j = i+k-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">				start = i;      <span class="comment">// 记录回文子串的起点和长度</span></span><br><span class="line">				maxlen = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解法三：中心扩展法$O(n^2)$">解法三：中心扩展法$O(n^2)$</h3><p>这个算法思想其实很简单，就是对给定的字符串S，分别以该字符串S中的每一个字符 c 为中心，向两边扩展，记录下以字符 c 为中心的回文子串的长度。时间复杂度为$O(n^2)$，空间复杂度仅为$O(1)$。</p>
<p>但有一点需要注意的是，回文的情况可能是 a b a，也可能是 a b b a。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别向左右扩展，返回扩展后的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right]) </span><br><span class="line">	&#123;</span><br><span class="line">		left--;</span><br><span class="line">		right++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substr(left+<span class="number">1</span>, right-left-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最长回文子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> longest;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> p1 = expand(s, i, i);  <span class="comment">// 奇数</span></span><br><span class="line">		<span class="keyword">if</span> (p1.size() &gt; longest.size())</span><br><span class="line">			longest = p1;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">string</span> p2 = expand(s, i, i+<span class="number">1</span>);  <span class="comment">// 偶数</span></span><br><span class="line">		<span class="keyword">if</span> (p2.size() &gt; longest.size())</span><br><span class="line">			longest = p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br>另外，据说还有一个很巧妙的算法，叫Manacher算法，可以在 $O(n)$ 的时间复杂度里求出最长回文子串。由于这个算法我没有研究过，在这里就不介绍了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计并实现一个LRU Cache]]></title>
    <link href="http://yoursite.com/2015/05/10/design-LRU-Cache/"/>
    <id>http://yoursite.com/2015/05/10/design-LRU-Cache/</id>
    <published>2015-05-10T12:33:13.000Z</published>
    <updated>2015-05-10T13:23:03.702Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。<a id="more"></a></p>
<h4 id="2_原理">2 原理</h4><p>Cache 技术所依赖的原理是”程序执行与数据访问的<strong>局部性原理</strong>“，这种局部性表现在两个方面：</p>
<ol>
<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令或数据通常是顺序存放的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到Cache中实现。空间局部性通常是使用较大的高速缓存，并将 预取机制 集成到高速缓存控制逻辑中来实现。</p>
<h4 id="3_替换策略">3 替换策略</h4><p>Cache的容量是有限的，当Cache的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。常用的替换策略有以下几种：</p>
<ol>
<li><p><strong>随机算法（Rand）</strong>：随机法是随机地确定替换的存储块。设置一个随机数产生器，依据所产生的随机数，确定替换块。这种方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p><strong>先进先出算法（FIFO, First In First Out）</strong>：先进先出法是选择那个最先调入的那个块进行替换。当最先调入并被多次命中的块，很可能被优先替换，因而不符合局部性规律。这种方法的命中率比随机法好些，但还不满足要求。</p>
</li>
<li><p><strong>最久未使用算法（LRU, Least Recently Used）</strong>：LRU法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。</p>
</li>
<li><p><strong>最不经常使用算法（LFU, Least Frequently Used）</strong>：将最近一段时期内，访问次数最少的块替换出Cache。</p>
</li>
</ol>
<h4 id="4_概念的扩充">4 概念的扩充</h4><p>如今高速缓存的概念已被扩充，不仅在CPU和主内存之间有Cache，而且在内存和硬盘之间也有Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的Cache──称为Internet临时文件夹或网络内容缓存等。<strong>凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。</strong></p>
<p><br></p>
<h3 id="二、LRU_Cache的实现">二、LRU Cache的实现</h3><p><strong>Google的一道面试题：</strong></p>
<p>Design an LRU cache with all the operations to be done in $O(1)$ .</p>
<h4 id="1_思路分析">1 思路分析</h4><p>对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。</p>
<p>为了能够快速删除最久没有访问的数据项和插入最新的数据项，我们使用 <strong>双向链表</strong> 连接Cache中的数据项，并且保证链表维持数据项从最近访问到最旧访问的顺序。</p>
<ul>
<li><p><strong>插入</strong>：当Cache未满时，新的数据项只需插到双链表头部即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>替换</strong>：当Cache已满时，将新的数据项插到双链表头部，并删除双链表的尾结点即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>查找</strong>：每次数据项被查询到时，都将此数据项移动到链表头部。</p>
</li>
</ul>
<p>经过分析，我们知道使用双向链表可以保证插入和替换的时间复杂度是$O(1)$，但查询的时间复杂度是$O(n)$，因为需要对双链表进行遍历。为了让查找效率也达到$O(1)$，很自然的会想到使用 <strong>hash table</strong> 。</p>
<h4 id="2_代码实现">2 代码实现</h4><p>从上述分析可知，我们需要使用两种数据结构：</p>
<ol>
<li><strong>双向链表（Doubly Linked List）</strong></li>
<li><strong>哈希表（Hash Table）</strong></li>
</ol>
<p>下面是LRU Cache的 C++ 实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的节点结构</span></span><br><span class="line"><span class="keyword">struct</span> LRUCacheNode &#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	LRUCacheNode* prev;</span><br><span class="line">	LRUCacheNode* next;</span><br><span class="line">	LRUCacheNode():key(<span class="number">0</span>),value(<span class="number">0</span>),prev(NULL),next(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LRUCache</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, LRUCacheNode*&gt; m;  <span class="comment">// 代替hash_map</span></span><br><span class="line">	LRUCacheNode* head;     <span class="comment">// 指向双链表的头结点</span></span><br><span class="line">	LRUCacheNode* tail;     <span class="comment">// 指向双链表的尾结点</span></span><br><span class="line">	<span class="keyword">int</span> capacity;           <span class="comment">// Cache的容量</span></span><br><span class="line">	<span class="keyword">int</span> count;              <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> capacity);       <span class="comment">// 构造函数</span></span><br><span class="line">	~LRUCache();                  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;             <span class="comment">// 查询数据项</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>; <span class="comment">// 未满时插入,已满时替换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeLRUNode</span><span class="params">()</span></span>;                 <span class="comment">// 删除尾结点（最久未使用）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">detachNode</span><span class="params">(LRUCacheNode* node)</span></span>;    <span class="comment">// 分离当前结点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertToFront</span><span class="params">(LRUCacheNode* node)</span></span>; <span class="comment">// 节点插入到头部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LRUCache::LRUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	<span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">	head = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	tail = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	head-&gt;prev = NULL;</span><br><span class="line">	head-&gt;next = tail;</span><br><span class="line">	tail-&gt;prev = head;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~LRUCache()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">	<span class="keyword">delete</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LRUCache::get(<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);      <span class="comment">// 命中，移至头部 </span></span><br><span class="line">		insertToFront(node);</span><br><span class="line">		<span class="keyword">return</span> node-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::<span class="built_in">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">		<span class="keyword">if</span>(count == capacity)   <span class="comment">// Cache已满</span></span><br><span class="line">			removeLRUNode();</span><br><span class="line"></span><br><span class="line">		node-&gt;key = key;</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		m[key] = node;          <span class="comment">// 插入哈希表</span></span><br><span class="line">		insertToFront(node);    <span class="comment">// 插入链表头部</span></span><br><span class="line">		++count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		insertToFront(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::removeLRUNode()</span><br><span class="line">&#123;</span><br><span class="line">	LRUCacheNode* node = tail-&gt;prev;</span><br><span class="line">	detachNode(node);</span><br><span class="line">	m.erase(node-&gt;key);</span><br><span class="line">	--count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::detachNode(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">	node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::insertToFront(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = head-&gt;next;</span><br><span class="line">	node-&gt;prev = head;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">	node-&gt;next-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trie树|前缀树的介绍与实现]]></title>
    <link href="http://yoursite.com/2015/05/09/prefix-tree/"/>
    <id>http://yoursite.com/2015/05/09/prefix-tree/</id>
    <published>2015-05-09T12:17:12.000Z</published>
    <updated>2015-05-10T12:30:30.917Z</updated>
    <content type="html"><![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center><a id="more"></a></p>
<p>上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li>
<li>从根节点到<strong>某一个节点</strong>，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符互不相同。</li>
</ol>
<p>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p>
<p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做<strong>前缀树（Prefix Tree）</strong>。</p>
<p><br></p>
<h1 id="二、Trie树的优缺点">二、Trie树的优缺点</h1><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p>
<h2 id="优点">优点</h2><ol>
<li><p>插入和查询的效率很高，都为$O(m)$，其中 $m$ 是待插入/查询的字符串的长度。</p>
<ul>
<li>关于查询，会有人说 hash 表时间复杂度是$O(1)$不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。</li>
</ul>
</li>
<li><p>Trie树中不同的关键字不会产生冲突。</p>
</li>
<li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p>
</li>
<li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p>
</li>
<li><p>Trie树可以对关键字按<strong>字典序</strong>排序。</p>
</li>
</ol>
<h2 id="缺点">缺点</h2><ol>
<li><p>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</p>
</li>
<li><p>空间消耗比较大。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、Trie树的应用">三、Trie树的应用</h1><h2 id="1、字符串检索">1、字符串检索</h2><p>检索/查询功能是Trie树最原始的功能。<strong>思路</strong>就是从根节点开始一个一个字符进行比较：</p>
<ul>
<li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li>
<li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、词频统计">2、词频统计</h2><p>Trie树常被搜索引擎系统用于文本词频统计    。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量<code>count</code>来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后<code>count</code>置1。</p>
<p><strong>注意：第一、第二种应用也都可以用 hash table 来做。</strong></p>
<h2 id="3、字符串排序">3、字符串排序</h2><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p>
<h2 id="4、前缀匹配">4、前缀匹配</h2><p>例如：找出一个字符串集合中所有以<code>ab</code>开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以<code>a-&gt;b-&gt;</code>开头的路径上的关键字即可。</p>
<p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h2 id="5、作为其他数据结构和算法的辅助结构">5、作为其他数据结构和算法的辅助结构</h2><p>如后缀树，AC自动机等。</p>
<p><br></p>
<h1 id="四、Trie树的实现">四、Trie树的实现</h1><p>这里为了方便，我们假设所有的关键字都由 a-z 的字母组成。下面是 trie 树的一种典型实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ALPHABET_SIZE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">	trie_node *children[ALPHABET_SIZE]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;*trie;</span><br><span class="line"></span><br><span class="line">trie_node* create_trie_node()</span><br><span class="line">&#123;</span><br><span class="line">	trie_node* pNode = <span class="keyword">new</span> trie_node();</span><br><span class="line">	pNode-&gt;count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ALPHABET_SIZE; ++i)</span><br><span class="line">		pNode-&gt;children[i] = NULL;</span><br><span class="line">	<span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trie_insert</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;children[*p-<span class="string">'a'</span>] == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;children[*p-<span class="string">'a'</span>] = create_trie_node();</span><br><span class="line">		&#125;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 查询：不存在返回0，存在返回出现的次数</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trie_search</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p &amp;&amp; node!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(node == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 关键字集合</span></span><br><span class="line">	<span class="keyword">char</span> keys[][<span class="number">8</span>] = &#123;<span class="string">"the"</span>, <span class="string">"a"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>, <span class="string">"any"</span>, <span class="string">"by"</span>, <span class="string">"bye"</span>, <span class="string">"their"</span>&#125;;</span><br><span class="line">	trie root = create_trie_node();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建trie树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		trie_insert(root, keys[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检索字符串</span></span><br><span class="line">	<span class="keyword">char</span> s[][<span class="number">32</span>] = &#123;<span class="string">"Present in trie"</span>, <span class="string">"Not present in trie"</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"the"</span>, trie_search(root, <span class="string">"the"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"these"</span>, trie_search(root, <span class="string">"these"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"their"</span>, trie_search(root, <span class="string">"their"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"thaw"</span>, trie_search(root, <span class="string">"thaw"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于Trie树，我们一般只需要插入和搜索操作。上面这段代码实现了一棵Trie树，该Trie树可以用来检索单词和统计词频。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center>]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑排序（Topological Sorting）]]></title>
    <link href="http://yoursite.com/2015/05/07/topological-sorting/"/>
    <id>http://yoursite.com/2015/05/07/topological-sorting/</id>
    <published>2015-05-07T15:23:52.000Z</published>
    <updated>2015-05-10T12:13:59.727Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。<a id="more"></a></p>
<p>例如，下面这个图：</p>
<center><br><img src="http://img.blog.csdn.net/20150507001028284" alt=""><br></center>

<p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环。</li>
</ol>
<center><br><img src="http://img.blog.csdn.net/20150507001759702" alt=""><br></center>

<p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p>
<p>通常，一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</p>
<p><br></p>
<h3 id="二、拓扑排序的应用">二、拓扑排序的应用</h3><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p>
<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 <a, b=""> 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</a,></p>
<p><br></p>
<h3 id="三、拓扑排序的实现">三、拓扑排序的实现</h3><p>根据上面讲的方法，我们关键是要<strong>维护一个入度为0的顶点的集合</strong>。</p>
<p>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用<strong>邻接表</strong>来存储图，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类声明************************/</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;             <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;    <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;      <span class="comment">// 维护一个入度为0的顶点的集合</span></span><br><span class="line">	<span class="keyword">int</span>* indegree;     <span class="comment">// 记录每个顶点的入度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                   <span class="comment">// 构造函数</span></span><br><span class="line">	~Graph();                       <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;     <span class="comment">// 添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">topological_sort</span><span class="params">()</span></span>;        <span class="comment">// 拓扑排序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类定义************************/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line"></span><br><span class="line">	indegree = <span class="keyword">new</span> <span class="keyword">int</span>[V];  <span class="comment">// 入度全部初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		indegree[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph::~Graph()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] adj;</span><br><span class="line">	<span class="keyword">delete</span> [] indegree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w); </span><br><span class="line">	++indegree[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Graph::topological_sort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">			q.push(i);         <span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;             <span class="comment">// 计数，记录当前已经输出的顶点数 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = q.front();      <span class="comment">// 从队列中取出一个顶点</span></span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;      <span class="comment">// 输出该顶点</span></span><br><span class="line">		++count;</span><br><span class="line">		<span class="comment">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class="line">		<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator beg = adj[v].begin();</span><br><span class="line">		<span class="keyword">for</span>( ; beg!=adj[v].end(); ++beg)</span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[*beg]))</span><br><span class="line">				q.push(*beg);   <span class="comment">// 若入度为0，则入栈</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(count &lt; V)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;           <span class="comment">// 没有输出全部顶点，有向图中有回路</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;            <span class="comment">// 拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下DAG图：</p>
<p><img src="http://img.blog.csdn.net/20150507013500102" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(6)</span></span>;   <span class="comment">// 创建图</span></span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	g.topological_sort();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>
<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的<code>queue</code>。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为$O(V+E)$。</p>
<p><br><br><br><br><br><br><br><br><br>另外，拓扑排序还可以采用 <a href="http://songlee24.github.io/2014/07/04/depth-first-search/" target="_blank" rel="external">深度优先搜索（DFS）</a>的思想来实现，详见《<a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank" rel="external">topological sorting via DFS</a>》。</p>
<p><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解公钥与私钥]]></title>
    <link href="http://yoursite.com/2015/05/03/public-key-and-private-key/"/>
    <id>http://yoursite.com/2015/05/03/public-key-and-private-key/</id>
    <published>2015-05-03T05:05:36.000Z</published>
    <updated>2015-05-10T12:08:33.440Z</updated>
    <content type="html"><![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/" target="_blank" rel="external">AES加密算法</a>》。<a id="more"></a></p>
<p><strong>2、公钥算法</strong></p>
<p><strong>公钥加密算法</strong>，也就是 <strong>非对称加密算法</strong>，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥：</p>
<ul>
<li>公钥和私钥成对出现</li>
<li>公开的密钥叫公钥，只有自己知道的叫私钥</li>
<li>用公钥加密的数据只有对应的私钥可以解密</li>
<li>用私钥加密的数据只有对应的公钥可以解密</li>
<li>如果可以用公钥解密，则必然是对应的私钥加的密</li>
<li>如果可以用私钥解密，则必然是对应的公钥加的密</li>
</ul>
<p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p>
<p><br></p>
<h3 id="二、实现数据的安全传输">二、实现数据的安全传输</h3><p>要实现数据的安全传输，当然就要对数据进行加密了。</p>
<p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用<strong>非对称算法</strong>，过程如下：</p>
<ol>
<li>首先 接收方 生成一对密钥，即私钥和公钥；</li>
<li>然后，接收方 将公钥发送给 发送方；</li>
<li>发送方用收到的公钥对数据加密，再发送给接收方；</li>
<li>接收方收到数据后，使用自己的私钥解密。</li>
</ol>
<p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p>
<p><img src="http://img.blog.csdn.net/20150502122610368" alt=""></p>
<p><br></p>
<h3 id="三、对信息进行数字签名">三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常<strong>“数字签名”</strong>是用来验证发送方的身份并帮助保护数据的完整性。</p>
<p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p>
<ol>
<li>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</li>
<li>保证信息自签发后到收到为止未曾作过任何修改。</li>
</ol>
<p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p>
<p><br></p>
<h3 id="四、公钥算法的缺点">四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是<strong>效率非常低</strong>，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p>
<ol>
<li>首先，发送方使用对称算法对原始信息进行加密。</li>
<li>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</li>
<li>接收方 将公钥发送给 发送方。</li>
<li>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</li>
<li>接收方用私钥进行解密得到对称算法的密钥。</li>
<li>发送方再把已加密的原始信息发送给接收方。</li>
<li>接收方使用对称算法的密钥进行解密。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150502122733376" alt=""></p>
<p><br><br><br><br><br><strong>总结：</strong></p>
<ol>
<li><p>每个用户都有一对私钥和公钥。  </p>
<ul>
<li>私钥用来进行解密和签名，是给自己用的。</li>
<li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li>
</ul>
</li>
<li><p>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。  </p>
</li>
<li><p>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。</p>
</li>
</ol>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<p>图片来源：www.cnblogs.com/chnking/archive/2007/08/30/875947.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/">AES加密算法</a>》。]]>
    
    </summary>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字节序：Big Endian 和 Little Endian]]></title>
    <link href="http://yoursite.com/2015/05/02/endianess/"/>
    <id>http://yoursite.com/2015/05/02/endianess/</id>
    <published>2015-05-02T04:56:43.000Z</published>
    <updated>2015-05-10T12:03:45.446Z</updated>
    <content type="html"><![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：<a id="more"></a></p>
<ul>
<li><p>Motorola 6800，PowerPC 970，SPARC（除V9外）等处理器采用 Big Endian方式存储数据；</p>
</li>
<li><p>x86系列，VAX，PDP-11等处理器采用Little Endian方式存储数据。</p>
</li>
</ul>
<p>另外，还有一些处理器像ARM, DEC Alpha的字节序是可配置的。</p>
<p><br></p>
<h3 id="二、大端与小端">二、大端与小端</h3><p>那么，到底什么是大端，什么是小端？ 如下图：</p>
<center><br><img src="http://img.blog.csdn.net/20150501200116979" alt=""><br></center>

<p>我相信上面的图已经够直观了。也就是说：</p>
<ul>
<li>Big Endian 是指低地址端 存放 高位字节。</li>
<li>Little Endian 是指低地址端 存放 低位字节。</li>
</ul>
<p><strong>各自的优势：</strong></p>
<ol>
<li>Big Endian：符号位的判定固定为第一个字节，容易判断正负。</li>
<li>Little Endian：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。</li>
</ol>
<p><br></p>
<h3 id="三、为什么要注意字节序">三、为什么要注意字节序</h3><p>如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。</p>
<p>但是，如果你的程序要跟别人的程序产生交互呢？ 比如，当一个 C/C++ 的程序要与一个 Java 程序交互时：</p>
<ul>
<li><p>C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的 x86 处理器是 Little Endian</p>
</li>
<li><p>JAVA编写的程序则唯一采用 Big Endian 方式来存储数据</p>
</li>
</ul>
<p>试想，如果你的C/C++程序将变量 <code>a = 0x12345678</code> 的首地址传递给了Java程序，由于Java采取 Big Endian 方式存储数据，很自然的它会将你的数据翻译为 <code>0x78563412</code>。显然，问题就出现了！！！</p>
<p>另外，网络传输一般采用 Big Endian，也被称之为<strong>网络字节序</strong>，或<strong>网络序</strong>。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p>
<p><br></p>
<h3 id="四、判断机器的字节序">四、判断机器的字节序</h3><p>由于 C/C++ 存储数据时的字节序依赖所在平台的CPU，所以我们可以通过C/C++程序判定机器的端序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Endianness</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span>( *((<span class="keyword">char</span>*)&amp;a) == <span class="number">0x12</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Big Endian"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Little Endian"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="五、网络序和主机序">五、网络序和主机序</h3><p><strong>网络字节序</strong>：TCP/IP各层协议将字节序定义为 Big Endian，因此TCP/IP协议中使用的字节序是大端序。</p>
<p><strong>主机字节序</strong>：整数在内存中存储的顺序，现在 Little Endian 比较普遍。（不同的 CPU 有不同的字节序）</p>
<p>在进行网络通信时 通常需要调用相应的函数进行主机序和网络序的转换。Berkeley socket API 定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】三个经典同步问题]]></title>
    <link href="http://yoursite.com/2015/04/30/linux-three-syn-problems/"/>
    <id>http://yoursite.com/2015/04/30/linux-three-syn-problems/</id>
    <published>2015-04-30T13:37:46.000Z</published>
    <updated>2015-05-10T11:58:29.924Z</updated>
    <content type="html"><![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/" target="_blank" rel="external">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。<a id="more"></a></p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。</p>
</li>
<li><p>整理思路：这里比较简单，只有生产者和消费者两个进程，且这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步的PV操作的位置。</p>
</li>
<li><p>信号量设置：信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量<code>full</code>用于记录当前缓冲池中“满”缓冲区数，初值为 0；信号量<code>empty</code>用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
</li>
</ol>
<p><strong>代码示例：</strong>（semaphore类的封装见下文）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;           <span class="comment">// 临界区互斥信号量</span></span><br><span class="line"><span class="function">semaphore <span class="title">empty</span><span class="params">("/home", N)</span></span>;       <span class="comment">// 记录空缓冲区数，初值为N</span></span><br><span class="line"><span class="function">semaphore <span class="title">full</span><span class="params">("/home/songlee",0)</span></span>; <span class="comment">// 记录满缓冲区数，初值为0</span></span><br><span class="line"><span class="keyword">int</span> buffer[N];                     <span class="comment">// 缓冲区，大小为N</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* producer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	empty.P();                 <span class="comment">// empty减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	buffer[i] = <span class="number">10</span> + rand() % <span class="number">90</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Producer %d write Buffer[%d]: %d\n"</span>,arg,i+<span class="number">1</span>,buffer[i]);</span><br><span class="line">	i = (i+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	full.V();                  <span class="comment">// full加1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* consumer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	full.P();                  <span class="comment">// full减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"                               \033[1;31m"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Consumer %d read Buffer[%d]: %d\n"</span>,arg,j+<span class="number">1</span>,buffer[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\033[0m"</span>);</span><br><span class="line">	j = (j+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	empty.V();                 <span class="comment">// empty加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开10个生产者线程，10个消费者线程</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, producer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, consumer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行输出结果：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Producer <span class="number">1</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">2</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">Producer <span class="number">3</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">Producer <span class="number">5</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">4</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">1</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">6</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">2</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">                               Consumer <span class="number">3</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">                               Consumer <span class="number">4</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">5</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">6</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">7</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">Producer <span class="number">8</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">10</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">9</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">                               Consumer <span class="number">10</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">9</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br><span class="line">                               Consumer <span class="number">7</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">8</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、读者-写者问题">二、读者-写者问题</h3><p><strong>问题描述：</strong></p>
<p>有读者和写者两组并发线程，共享一个文件，当两个或以上的读线程同时访问共享数据时不会产生副作用，但若某个写线程和其他线程（读线程或写线程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：由题目分析可知，读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
</li>
<li><p>整理思路：写者是比较简单的，它与任何线程互斥，用互斥信号量的 PV 操作即可解决。读者的问题比较复杂，它必须实现与写者的互斥，多个读者还可以同时读。所以，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时，不同的读者对计数器的访问也应该是互斥的。</p>
</li>
<li><p>信号量设置：首先设置一个计数器<code>count</code>，用来记录当前的读者数量，初值为0；设置互斥信号量<code>mutex</code>，用于保护更新 count 变量时的互斥；设置互斥信号量<code>rw</code>用于保证读者和写者的互斥访问。</p>
</li>
</ol>
<p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;           <span class="comment">// 记录当前的读者数量</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/",1)</span></span>;  <span class="comment">// 用于保护更新count变量时的互斥</span></span><br><span class="line"><span class="function">semaphore <span class="title">rw</span><span class="params">("/home",1)</span></span>; <span class="comment">// 用于保证读者和写者的互斥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* writer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	rw.P();              <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d start writing...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d finish writing...\n"</span>, arg);</span><br><span class="line">	</span><br><span class="line">	rw.V();              <span class="comment">// 释放共享文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* reader(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当第一个读线程读文件时</span></span><br><span class="line">		rw.P();          <span class="comment">// 阻止写线程写</span></span><br><span class="line">	++count;             <span class="comment">// 读者计数器加1</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d start reading...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d finish reading...\n"</span>, arg);</span><br><span class="line"></span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	--count;             <span class="comment">// 读者计数器减1</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当最后一个读线程读完文件</span></span><br><span class="line">		rw.V();          <span class="comment">// 允许写线程写</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">8</span>];     <span class="comment">// 开6个读线程，2个写线程</span></span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">2</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">3</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">4</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">3</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">5</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">4</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">6</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">5</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">7</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Reader</span> <span class="number">2</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">2</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> finish reading...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> finish writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> finish writing...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> finish reading...</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、哲学家进餐问题">三、哲学家进餐问题</h3><p><strong>问题描述：</strong></p>
<p>一张圆桌上坐着 5 名哲学家，桌子上每两个哲学家之间摆了<strong>一根</strong>筷子，桌子的中间是一碗米饭，如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150430145440864" alt=""></p>
<p>哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li><p>整理思路：显然这里有 5 个线程，那么要如何让一个哲学家拿到左右两个筷子而不造成死锁或饥饿现象？解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或死锁现象的发生。</p>
</li>
<li><p>信号量设置：定义互斥信号量数组<code>chopstick[5] = {1,1,1,1,1}</code>用于对 5 根筷子的互斥访问。</p>
</li>
</ol>
<p><strong>示例代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;  <span class="comment">// 信号量数组</span></span><br><span class="line">Pi()                                  <span class="comment">// i号哲学家的线程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		P(chopstick[i]);              <span class="comment">// 取左边筷子</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 取右边筷子</span></span><br><span class="line">		eat;                          <span class="comment">// 进餐</span></span><br><span class="line">		V(chopstick[i]);              <span class="comment">// 放回左边筷子</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 放回右边筷子</span></span><br><span class="line">		think;                        <span class="comment">// 思考</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的伪代码存在一个问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完<code>P(chopstick[i])</code>），筷子已经被拿光了，等到他们再想拿右边的筷子的时候，就全被阻塞了，这就出现了死锁。</p>
<p>为了防止死锁的发生，可以对哲学家线程施加一些限制条件，比如：</p>
<ul>
<li>至多允许四个哲学家同时进餐；</li>
<li>仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子；</li>
<li>对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再抓他右边的筷子，而偶数号哲学家刚好相反。</li>
</ul>
<p>这里，我们采用第二种方法来改进上面的算法，即当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;semaphore*&gt; chopstick;   <span class="comment">// 信号量数组</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;  <span class="comment">// 设置取左右筷子的信号量 &lt;-- 关键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P1(<span class="keyword">void</span>* arg)  <span class="comment">// 第1个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 1 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P2(<span class="keyword">void</span>* arg)  <span class="comment">// 第2个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 2 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P3(<span class="keyword">void</span>* arg)  <span class="comment">// 第3个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 3 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P4(<span class="keyword">void</span>* arg)  <span class="comment">// 第4个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 4 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P5(<span class="keyword">void</span>* arg)  <span class="comment">// 第5个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 5 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	semaphore *sem1 = <span class="keyword">new</span> semaphore(<span class="string">"/home"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem2 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem3 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/java"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem4 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/ADT"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem5 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/Test"</span>, <span class="number">1</span>);</span><br><span class="line">	chopstick.push_back(sem1);</span><br><span class="line">	chopstick.push_back(sem2);</span><br><span class="line">	chopstick.push_back(sem3);</span><br><span class="line">	chopstick.push_back(sem4);</span><br><span class="line">	chopstick.push_back(sem5);</span><br><span class="line"></span><br><span class="line">	pthread_t id;</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id, NULL, P1, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P2, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P3, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P4, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P5, NULL);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">delete</span> sem1;</span><br><span class="line">	<span class="keyword">delete</span> sem2;</span><br><span class="line">	<span class="keyword">delete</span> sem3;</span><br><span class="line">	<span class="keyword">delete</span> sem4;</span><br><span class="line">	<span class="keyword">delete</span> sem5;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Philosopher</span> <span class="number">2</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">1</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">3</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">4</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">5</span> eat.</span><br></pre></td></tr></table></figure></p>
<p>注意：创建信号量时的 路径参数 请改成你的系统中存在的路径！！！</p>
<p><br><br><br><br></p>
<h3 id="附：semaphore类的封装">附：semaphore类的封装</h3><p>上面的代码中都使用了这个<code>semaphore</code>类，实现如下：</p>
<ul>
<li><strong>semaphore.h</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> semaphore &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	semaphore(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>); <span class="comment">/*构造函数*/</span></span><br><span class="line">	~semaphore();                <span class="comment">/*析构函数*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>;                    <span class="comment">/*P操作*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>;                    <span class="comment">/*V操作*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>semaphore.cpp</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"></span><br><span class="line">semaphore::semaphore(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">semaphore::~semaphore()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::P()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::V()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">int</span> semaphore::init_sem(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，要创建不同的信号量，必须传递不同的路径参数（这样获取的 key 值才会不一样）。</p>
<p>注意，本文的关注点并不在于 linux 下如何创建信号量以及如何封装起来才更方便，而是通过几个经典的同步实例，了解在多线程环境下如何解决这类线程同步问题。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】同步与互斥的区别]]></title>
    <link href="http://yoursite.com/2015/04/29/linux-syn-mut-difference/"/>
    <id>http://yoursite.com/2015/04/29/linux-syn-mut-difference/</id>
    <published>2015-04-29T15:45:11.000Z</published>
    <updated>2015-05-10T11:56:23.819Z</updated>
    <content type="html"><![CDATA[<p>同步与互斥这两个概念经常被混淆，所以在这里说一下它们的区别。</p>
<h3 id="一、同步与互斥的区别">一、同步与互斥的区别</h3><h4 id="1-_同步">1. 同步</h4><p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。</p>
<p>例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;   <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">T1() &#123;</span><br><span class="line">	...</span><br><span class="line">	x;           <span class="comment">// 语句x</span></span><br><span class="line">	V(S);        <span class="comment">// 告诉线程T2，语句x已经完成</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);        <span class="comment">// 检查语句x是否运行完成</span></span><br><span class="line">	y;           <span class="comment">// 检查无误，运行y语句</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-_互斥">2. 互斥</h4><p><strong>互斥</strong>，又称<strong>间接制约关系</strong>，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。</p>
<p>例如，打印机就是一种临界资源，而访问打印机的代码片段称为临界区，故每次只允许一个线程进入临界区。—— 我们同样可以使用信号量解决互斥问题，只需把临界区置于 P(S) 和 V(S) 之间，即可实现两线程对临界资源的互斥访问。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">1</span>;   <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">T1() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	线程T1的临界区;  <span class="comment">// 访问临界资源</span></span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	线程T2的临界区;  <span class="comment">// 访问临界资源</span></span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、一个同步的例子">二、一个同步的例子</h3><p>如下图，为了求出 1 到 n 的平均值，需要三个线程协调它们的工作次序来完成，这就是同步：</p>
<p><img src="http://img.blog.csdn.net/20150429225128423" alt=""></p>
<p>为了使多个线程按顺序正确执行，应设置若干个初始值为 0 的信号量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.hpp"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sem1, sem2;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;  <span class="comment">/*1...n的平均值*/</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> average = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* t1(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		sum += i;</span><br><span class="line">	sem_v(sem1);  <span class="comment">/*V操作，通知t2求和已完成*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* t2(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	sem_p(sem1);  <span class="comment">/*P操作，等待t1完成*/</span>	</span><br><span class="line">	average = (<span class="keyword">double</span>)sum/n;</span><br><span class="line">	sem_v(sem2);  <span class="comment">/*V操作，通知main求平均已完成*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	sem1 = creat_sem(<span class="string">"/"</span> , <span class="number">0</span>); <span class="comment">/*创建信号量*/</span></span><br><span class="line">	sem2 = creat_sem(<span class="string">"/home"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	pthread_t id[<span class="number">2</span>];</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, t1, NULL);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, t2, NULL);</span><br><span class="line"></span><br><span class="line">	sem_p(sem2);  <span class="comment">/*P操作，等待t2完成*/</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is: "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The average is: "</span> &lt;&lt; average &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	del_sem(sem1); <span class="comment">/*删除信号量*/</span></span><br><span class="line">	del_sem(sem2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是信号量的相关函数，详见《<a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">信号量</a>》。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semaphore.hpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建信号量，返回其ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">/*信号量集ID*/</span></span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(sem_id, value);</span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程 t2 需要等待线程 t1 （求和）完成以后才能够执行；主线程 main 需要等待线程 t2 （求平均）完成以后才能够执行输出。编译运行结果如下：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -lpthread -o <span class="keyword">synchronized</span> <span class="keyword">synchronized</span>.cpp </span><br><span class="line">$ ./<span class="keyword">synchronized</span> </span><br><span class="line">The sum <span class="keyword">is</span>: <span class="number">55</span></span><br><span class="line">The average <span class="keyword">is</span>: <span class="number">5.5</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<p><strong>总结：</strong></p>
<ol>
<li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li>
<li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li>
<li>互斥是一种特殊的同步。</li>
</ol>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>同步与互斥这两个概念经常被混淆，所以在这里说一下它们的区别。</p>
<h3 id="一、同步与互斥的区别">一、同步与互斥的区别</h3><h4 id="1-_同步">1. 同步</h4><p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。</p>
<p>例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux编程】进程间通信（IPC）]]></title>
    <link href="http://yoursite.com/2015/04/21/linux-IPC/"/>
    <id>http://yoursite.com/2015/04/21/linux-IPC/</id>
    <published>2015-04-21T12:51:21.000Z</published>
    <updated>2015-05-10T11:50:29.559Z</updated>
    <content type="html"><![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。<a id="more"></a></p>
<h3 id="1、特点：">1、特点：</h3><ol>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ol>
<h3 id="2、原型：">2、原型：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[2])</span></span>;    <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150419222058628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>要关闭管道只需将这两个文件描述符关闭即可。</p>
<h3 id="3、例子">3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150419223853807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">		read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="二、FIFO">二、FIFO</h2><p><strong>FIFO</strong>，也称为命名管道，它是一种文件类型。</p>
<h3 id="1、特点">1、特点</h3><ol>
<li><p>FIFO可以在无关的进程之间交换数据，与无名管道不同。</p>
</li>
<li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
</li>
</ol>
<h3 id="2、原型">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p>
<p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p>
<ul>
<li><p>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p>
</li>
<li><p>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p>
</li>
</ul>
<h3 id="3、例子-1">3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</p>
<ul>
<li><p><strong>write_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;   <span class="comment">// exit</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;    <span class="comment">// O_WRONLY</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;time.h&gt;     <span class="comment">// time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	time_t tp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO </span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">		n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">		<span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">		perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./write_fifo </span><br><span class="line">I am <span class="number">5954</span> <span class="keyword">process</span>.</span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./read_fifo </span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p><br><br><br>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p>
<p><img src="http://img.blog.csdn.net/20150420131002360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><br></p>
<h2 id="三、消息队列">三、消息队列</h2><p><strong>消息队列</strong>，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<h3 id="1、特点-1">1、特点</h3><ol>
<li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ol>
<h3 id="2、原型-1">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(key_t key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p>
<ul>
<li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li>
<li>key参数为<code>IPC_PRIVATE</code>。</li>
</ul>
<p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p>
<ul>
<li><code>type == 0</code>，返回队列中的第一个消息；</li>
<li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li>
<li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li>
</ul>
<p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p>
<h3 id="3、例子-2">3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p>
<ul>
<li><p><strong>msg_server.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环读取消息</span></span><br><span class="line">	<span class="keyword">for</span>(;;) </span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">		msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">		<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">		msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msg_client.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加消息，类型为888</span></span><br><span class="line">	msg.mtype = <span class="number">888</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">	msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取类型为777的消息</span></span><br><span class="line">	msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="四、信号量">四、信号量</h2><p><strong>信号量（semaphore）</strong>与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<h3 id="1、特点-2">1、特点</h3><ol>
<li><p>信号量用于进程间同步，若要在进程间传递数据需要结合<em>共享内存</em>。</p>
</li>
<li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p>
</li>
<li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
</li>
<li><p>支持信号量组。</p>
</li>
</ol>
<h3 id="2、原型-2">2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做<strong>二值信号量（Binary Semaphore）</strong>。而可以取多个正整数的信号量被称为通用信号量。</p>
<p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(key_t key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], size_t numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 。</p>
<p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sembuf </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 sem_op 是一次操作中的信号量的改变量：</p>
<ul>
<li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们。</p>
</li>
<li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p>
<ul>
<li>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</li>
<li>当相应的资源数不能满足请求时，这个操作与<code>sem_flg</code>有关。<ul>
<li>sem_flg 指定<code>IPC_NOWAIT</code>，则semop函数出错返回<code>EAGAIN</code>。</li>
<li>sem_flg 没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p>
<ul>
<li>当信号量已经为0，函数立即返回。</li>
<li>如果信号量的值不为0，则依据<code>sem_flg</code>决定函数动作：<ul>
<li>sem_flg指定<code>IPC_NOWAIT</code>，则出错返回<code>EAGAIN</code>。</li>
<li>sem_flg没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR  </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p>
<ul>
<li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li>
<li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li>
</ul>
<h3 id="3、例子-3">3、例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">	<span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	tmp.val = value;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//	若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//	若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//	释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//	如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">	key_t key;  </span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">	init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">		del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p>
<p><br></p>
<h2 id="五、共享内存">五、共享内存</h2><p><strong>共享内存（Shared Memory）</strong>，指两个或多个进程共享一个给定的存储区。</p>
<h3 id="1、特点-3">1、特点</h3><ol>
<li><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>
</li>
<li><p>因为多个进程可以同时操作，所以需要进行同步。</p>
</li>
<li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p>
</li>
</ol>
<h3 id="2、原型-3">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(key_t key, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="keyword">void</span> *shmat(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag);</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p>
<p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p>
<p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p>
<p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p>
<h3 id="3、例子-4">3、例子</h3><p>下面这个例子，使用了<strong>【共享内存+信号量+消息队列】</strong>的组合来实现服务器进程与客户进程间的通信。</p>
<ul>
<li>共享内存用来传递数据；</li>
<li>信号量用来同步；</li>
<li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li>
</ul>
<p><strong>Server.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(key_t key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">	<span class="keyword">struct</span> shmid_ds buf1;  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">	<span class="keyword">struct</span> msqid_ds buf2;  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量</span></span><br><span class="line">	semid = creat_sem(key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span> </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			sem_p(semid);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">			sem_v(semid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">	shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">	msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">	del_sem(semid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Client.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取信号量</span></span><br><span class="line">	<span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 写数据</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">		<span class="keyword">switch</span>(c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">				sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">				sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">				msg.mtype = <span class="number">888</span>;  </span><br><span class="line">				msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">				msg.mtype = <span class="number">888</span>;</span><br><span class="line">				msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br></pre></td></tr></table></figure></p>
<p>注释已经很详细了，所以代码的其他部分我就不解释了，下面是运行结果截图：</p>
<p><img src="http://img.blog.csdn.net/20150421203538923" alt=""></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可利用空间表（Free List）]]></title>
    <link href="http://yoursite.com/2015/04/08/free-list/"/>
    <id>http://yoursite.com/2015/04/08/free-list/</id>
    <published>2015-04-08T03:11:00.000Z</published>
    <updated>2015-05-10T11:47:00.859Z</updated>
    <content type="html"><![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br><a id="more"></a><br>为了避免频繁的new/delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从free list中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p>
<p>要求：</p>
<ol>
<li>实现一个对固定大小内存块进行管理的通用FreeList类，给出定义和实现。要求不能使用STL中的容器类。定义类的接口和实现时注意通用性、健壮性和可测试性。</li>
<li>如果该类的对象可能会被多个thread同时访问，请描述如何怎样保证线程安全。有没有办法在保证线程安全的同时尽可能增大并发度？如果有也请描述你的思路。</li>
</ol>
</blockquote>
<p><br></p>
<h3 id="一、介绍">一、介绍</h3><p>“可利用空间表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即<strong>可利用空间表（free list）</strong>。</p>
<p>当用户请求分配时，系统从可利用空间表中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到可利用空间表中，因此，可利用空间表亦称为“存储池”。</p>
<p>可利用空间表有三种结点结构：</p>
<ol>
<li><p><strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。</p>
</li>
<li><p><strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。</p>
</li>
<li><p><strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即可利用空间表中只有一个大小为整个存储区的结点。随着分配和回收的进行，可利用空间表的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是可利用空间表中的任一结点都能满足，而需要按照申请的长度在可利用空间表中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略：</p>
<ul>
<li><p><strong>首次适配法</strong>：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）</p>
</li>
<li><p><strong>最佳适配法</strong>：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）</p>
</li>
<li><p><strong>最差适配法</strong>：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）</p>
</li>
</ul>
</li>
</ol>
<p>三种分配策略适合于不同的情况，<code>首次适配法</code>的优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足 —— 这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。<code>最佳适配法</code>的优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统。<code>最差适配法</code>的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</p>
<p><br></p>
<h3 id="二、C++实现">二、C++实现</h3><p>根据题目要求，实现一个对固定大小内存块进行管理的通用FreeList类，即结点大小相同。其实这是最简单的一种实现，注意几个实现要点：</p>
<ul>
<li><p>一个静态成员指针static FreeList* freelist，用来指向可利用空间表。</p>
</li>
<li><p>重载 new 和 delete。</p>
</li>
</ul>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">class</span> FreeList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> FreeList&lt;Elem&gt; *freelist;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Elem element;</span><br><span class="line">	FreeList *next;</span><br><span class="line">	FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next=NULL);</span><br><span class="line">	FreeList(FreeList* next=NULL);</span><br><span class="line">	<span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>;    <span class="comment">// 重载new</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;   <span class="comment">// 重载delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;* FreeList&lt;Elem&gt;::freelist = NULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;element = elem;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span>* FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*freelist没有可用空间，就从系统分配*/</span></span><br><span class="line">	<span class="keyword">if</span>(freelist == NULL)  </span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">new</span> FreeList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*否则，从freelist表头摘取结点*/</span></span><br><span class="line">	FreeList&lt;Elem&gt;* temp = freelist;</span><br><span class="line">	freelist = freelist-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span> FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*把要释放的结点空间加入到freelist中*/</span></span><br><span class="line">	((FreeList&lt;Elem&gt;*)ptr)-&gt;next = freelist;</span><br><span class="line">	freelist = (FreeList&lt;Elem&gt;*)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>至于线程安全的问题，在多线程的环境下，线程同步的方式有多种：临界区、事件、互斥量、信号量。比如，我们可以把访问该类对象的代码段设置为 Critical Section，这样同一时间就只有一个线程可以执行这段代码。为了尽可能增大并发度，更好的方式是将代码改造成对临界数据的保护而不是对临界代码的保护，这样就可以令不会同时访问相同临界数据的线程完全并行地执行。</p>
<p>这是我个人的观点，如果你有更好的想法，欢迎交流和指正！</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br>]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2051-最小的K个数（Top K问题）]]></title>
    <link href="http://yoursite.com/2015/03/21/hua-wei-OJ2051/"/>
    <id>http://yoursite.com/2015/03/21/hua-wei-OJ2051/</id>
    <published>2015-03-21T11:36:34.000Z</published>
    <updated>2015-05-10T11:39:10.276Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组<a id="more"></a></li>
</ol>
<p><strong>输出：</strong></p>
<p>输出一个整数数组</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 5 7 2</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、Top_K问题">二、Top K问题</h1><p>对于 Top K 问题有很多种解法。</p>
<h2 id="解法一：排序">解法一：排序</h2><p>相信很多人会首先想到这种方法，先把数组按升序/降序进行排序，然后输出 K 个最小/最大的数。</p>
<ul>
<li>常规的排序方法时间复杂度至少是$Θ(nlog_2n)$。（<a href="http://songlee24.github.io/2014/04/03/implementation-of-internal-sortings/" target="_blank" rel="external">快排或堆排序</a>）</li>
<li>可能你会说，我们可以使用<a href="http://songlee24.github.io/2014/06/22/linear-sorting-algorithms/" target="_blank" rel="external">线性时间的排序算法</a>。当然可以，但通常它们对输入的数组有一定的要求。比如计数排序要求 n 个数都是正整数，且它们的取值范围不太大。</li>
</ul>
<h2 id="解法二：部分排序_$O(n*k)$">解法二：部分排序 $O(n*k)$</h2><p>由于我们只需要找出最小/最大的 k 个数，所以我们可以进行部分排序，比如<strong>简单选择排序</strong> 和 <strong>冒泡排序</strong>，它们每一趟都能把一个最小/最大元素放在最终位置上，所以进行 k 趟就能把 n 个数中的前 k 个排序出来。</p>
<p>部分简单选择排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123; <span class="comment">// k趟</span></span><br><span class="line">		<span class="keyword">int</span> Min = i;         <span class="comment">// 记录最小元素的位置</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[Min])</span><br><span class="line">				Min = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Min != i)  <span class="comment">// 与A[i]交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[Min];</span><br><span class="line">			A[Min] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>部分冒泡排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)  <span class="comment">// k趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j)  <span class="comment">// 一趟冒泡过程</span></span><br><span class="line">			<span class="keyword">if</span>(A[j-<span class="number">1</span>] &gt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = A[j-<span class="number">1</span>];</span><br><span class="line">				A[j-<span class="number">1</span>] = A[j];</span><br><span class="line">				A[j] = tmp;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="keyword">false</span>)  <span class="comment">// 已经有序</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，$O(nlog_2n)$ 与 $O(n*k)$ 哪一个更好呢？这取决于 k 的大小。在 k 较小的情况下，即 $k &lt;= log_2n$，可以选择部分排序。</p>
<h2 id="解法三：快排划分_$O(n*log_2k)$">解法三：快排划分 $O(n*log_2k)$</h2><p>根据基于快排<code>partition</code>操作的《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/33419201" target="_blank" rel="external">第k顺序统计量的求解</a>》，我们知道，当我们求出第 k 顺序统计量时，位于它前面的元素都比它小，位于它后面的元素都比它大。这时，数组的前 k 个数就是最小的 k 个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[high]&gt;=pivot)</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[low]&lt;=pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(low == high)</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = partition(A, low, high);</span><br><span class="line">	<span class="keyword">int</span> i = pos - low + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">		<span class="keyword">return</span> pos;  <span class="comment">// 返回前k个数的</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; k)</span><br><span class="line">		<span class="keyword">return</span> topK(A, low, pos, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> topK(A, pos+<span class="number">1</span>, high, k-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们说这个算法的平均时间复杂度是线性的，更准确地说，是 $O(n∗log_2k)$。另外，为了避免特殊数据下的算法退化，最好使用随机化版本的划分操作。</p>
<h2 id="解法四：大根堆_$O(n∗log_2k)$">解法四：大根堆 $O(n∗log_2k)$</h2><p>参见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/24846247" target="_blank" rel="external">堆排序</a>》，可以用大小为 k 的大根堆来存储最小的 k 个数。大根堆的堆顶元素就是最小 k 个数中最大的一个。每次新考虑一个数 X：</p>
<ul>
<li><p>如果 X 比堆顶的元素 Y 大，则不需要改变原来的堆，因为这个元素比最小的 k 个数都大。</p>
</li>
<li><p>如果 X 比堆顶元素 Y 小，那么用 X 替换堆顶的元素 Y。在 X 替换堆顶元素 Y 之后，大根堆的结构可能被破坏，需要进行向下调整。调整过程的时间复杂度是 $O(log_2k)$ 。</p>
</li>
</ul>
<p>遍历完成以后，数组的前 k 个数就是最小的 k 个数，但是它们并非有序，而是以堆的形式存在。C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> temp = A[i];  <span class="comment">// 暂存A[i]  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])  </span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大  </span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])  </span><br><span class="line">		&#123;  </span><br><span class="line">			A[i] = A[largest];  </span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置  </span></span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 维护 A[0...k-1] 这个大根堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, k);  <span class="comment">// 先用前面的k个数建大根堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i] &lt; A[<span class="number">0</span>])  <span class="comment">// 如果小于堆顶元素，替换之</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[<span class="number">0</span>];</span><br><span class="line">			A[<span class="number">0</span>] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">			AdjustDown(A, <span class="number">0</span>, k);  <span class="comment">// 向下调整</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：找最小的 $k$ 个数，就维护一个大根堆；找最大的 $k$ 个数，就维护一个小根堆。</p>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>第二部分已经讲解地很清楚了，几种解法都可以，只要注意输入输出的格式就行了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ1964-求解立方根（牛顿迭代法）]]></title>
    <link href="http://yoursite.com/2015/03/20/hua-wei-OJ1964/"/>
    <id>http://yoursite.com/2015/03/20/hua-wei-OJ1964/</id>
    <published>2015-03-20T11:32:16.000Z</published>
    <updated>2015-05-10T11:35:27.608Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<ul>
<li>计算一个数字的立方根，不使用库函数。</li>
<li>函数原型<code>double getCubeRoot(double input)</code></li>
</ul>
<p><strong>输入：</strong><a id="more"></a></p>
<p>待求解参数 double类型</p>
<p><strong>输出：</strong></p>
<p>输出参数的立方根，保留一位小数</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">216</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.0</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、解题报告">二、解题报告</h1><p>本题要求一个数的立方根的近似值，精确到小数点后的一位。这里使用 <a href="http://baike.baidu.com/view/643093.htm" target="_blank" rel="external"><strong>牛顿迭代法</strong></a> 求近似值。</p>
<p>牛顿迭代法，又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），<strong>它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法</strong>。多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x) = 0$的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程$f(x) = 0$的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。另外该方法广泛用于计算机编程中。</p>
<p>设 $r$ 是的根，选取 $x_0$ 作为 $r$ 的初始近似值：</p>
<ul>
<li><p>过点$(x_0,f(x_0))$做曲线$y=f(x)$的切线L，L的方程为 $y=f(x_0)+f’(x_0)(x-x_0)$，求出L与x轴交点的横坐标 $x_1 = x_0-\frac{f(x_0)}{f’(x_0)}$，称 $x_1$为 $r$ 的一次近似值。</p>
</li>
<li><p>过点 $(x_1,f(x_1))$ 做曲线 $y=f(x)$ 的切线，并求该切线与x轴交点的横坐标 $x_2 = x_1-\frac{f(x_1)}{f’(x_1)}$，称 $x_2$ 为 $r$ 的二次近似值。</p>
</li>
<li><p>重复以上过程，得 $r$ 的近似值序列。其中， $x_{n+1} = x_n-\frac{f(x_n)}{f’(x_n)}$ 称为 $r$ 的 $n+1$ 次近似值，上式称为<strong>牛顿迭代公式</strong>。</p>
</li>
</ul>
<hr>
<p>首先确定我们的函数 $f(x)$：</p>
<p>$$f(x) = x^3 - m$$</p>
<p>其中 $m$ 是一个常数，程序的输入。求导函数：</p>
<p>$$f’(x) = 3x^2$$</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> E 0.01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> num)</span> <span class="comment">// 函数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x*x-num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> _f(<span class="keyword">double</span> x)  <span class="comment">// 导函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>*x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getCubeRoot</span><span class="params">(<span class="keyword">double</span> input)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x0;  </span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		x0 = r;</span><br><span class="line">		r = x0 - f(x0,input)/_f(x0);</span><br><span class="line">	&#125; <span class="keyword">while</span>(f(r,input) &gt; E || f(r,input) &lt; -E);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">double</span> result = getCubeRoot(x); </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<ul>
<li>计算一个数字的立方根，不使用库函数。</li>
<li>函数原型<code>double getCubeRoot(double input)</code></li>
</ul>
<p><strong>输入：</strong>]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2288-合唱队（最长递增子序列）]]></title>
    <link href="http://yoursite.com/2015/03/19/hua-wei-OJ2288/"/>
    <id>http://yoursite.com/2015/03/19/hua-wei-OJ2288/</id>
    <published>2015-03-19T11:26:41.000Z</published>
    <updated>2015-05-10T11:31:34.675Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K) 。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。<a id="more"></a></p>
<p><strong>输入：</strong></p>
<p>第一行整数 N，表示同学的总数<br>第二行整数数组，空格隔开，表示 N 位同学身高</p>
<p><strong>输出：</strong></p>
<p>最少需要几位同学出列</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">186 186 150 200 160 130 197 200</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、最长递增子序列">二、最长递增子序列</h1><p><strong>最长递增子序列（Longest Increasing Subsequence）</strong>是指找到一个给定序列的最长子序列的长度，使得子序列中的所有元素单调递增。</p>
<p>例如：{ 3，5，7，1，2，8 }  的 LIS 是 { 3，5，7，8 }，长度为 4。</p>
<h2 id="解法一：转化为求最长公共子序列">解法一：转化为求最长公共子序列</h2><p>其实可以把 求最长递增子序列问题 转化为 求最长公共子序列的问题。</p>
<ul>
<li>设数组 { 3， 5， 7， 1， 2， 8 } 为 A</li>
<li>对数组 A 排序，排序后的数组为 B = { 1， 2， 3， 5， 7， 8 }。</li>
<li>于是，求数组 A 的最长递增子序列，就是求数组 A 与数组 B 的最长公共子序列。</li>
</ul>
<p>最长公共子序列的求法见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/41548557" target="_blank" rel="external">动态规划DP</a>》。本方法的时间复杂度是 </p>
<p>$$Θ(nlgn)+ Θ(n^2) = Θ(n^2)$$</p>
<h2 id="解法二：动态规划法">解法二：动态规划法</h2><p>虽然解法一也是使用动态规划，但是与解法一不同的是，解法二不进行转化，而是直接在原问题上采用动态规划法。</p>
<p><strong>最优子结构：</strong></p>
<p>对于长度为 N 的数组 $A[N] = { a<em>0, a_1, a_2, …, a</em>{n-1}}$，假设我们想求以 $a_i$ 结尾的最大递增子序列长度，设为$L[i]$，那么</p>
<p>$$<br>L[i] =<br>\begin{cases}<br>max(L[j]) + 1,  &amp; \text{where $j &lt; i$ and $A[j] &lt; A[i]$} \[2ex]<br>1, &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
<p>也就是 $j$ 的范围是 0 到 $i–1$。这样，想求 $a_i$ 结尾的最大递增子序列的长度，我们就需要遍历 $i$ 之前的所有位置 $j$（0到 i-1），找出$A[j] &lt; A[i]$，计算这些 $j$ 中，能产生最大 $L[j]$ 的 $j$，之后就可以求出 $L[i]$。之后对每一个$A[N]$中的元素都计算以他们各自结尾的最大递增子序列的长度，这些长度的最大值，就是我们要求的问题——数组$A$的最大递增子序列的长度。</p>
<p><strong>重叠子问题：</strong></p>
<p>根据上述推导式采用递归实现的话，有些子问题会被计算很多次。</p>
<p><strong>动态规划法：</strong></p>
<p>综上所述，LIS 问题具有动态规划需要的两个性质，可以使用动态规划求解该问题。设数组 A = { 3，5，7，1，2，8 }，则：</p>
<center><br><img src="http://img.blog.csdn.net/20150424101652021" alt=""><br></center>

<p>具体的打表方式如下：</p>
<ul>
<li>初始化对角线为 1；</li>
<li>对每一个 i，遍历 j（0 到 i-1）：<ul>
<li>若<code>A[i] &lt;= A[j]</code>，置 1。</li>
<li>若<code>A[i] &gt; A[j]</code>，取第 j 行的<strong>最大值</strong>加 1。</li>
</ul>
</li>
</ul>
<p>打完表以后，最后一行的最大值就是最长递增子序列的长度。由于每次都进行遍历，故时间复杂度还是 $Θ(n^2)$ 。</p>
<p>通常在实现的时候我们不会创建一整个表，因为这样太浪费空间。由打表的过程可知，我们只需要一个一维数组来保存每一行的最大值即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LIS 的动态规划方式实现</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLISLength</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* 一维数组 */</span></span><br><span class="line">   <span class="keyword">int</span>* lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化为1 */</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">      lis[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 计算每个i对应的lis最大值，即打表的过程 */</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)     <span class="comment">// 0到i-1</span></span><br><span class="line">         <span class="keyword">if</span> ( A[i] &gt; A[j] &amp;&amp; lis[i] &lt; lis[j]+<span class="number">1</span>)</span><br><span class="line">            lis[i] = lis[j] + <span class="number">1</span>;  <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 数组中最大的那个，就是最长递增子序列的长度 */</span></span><br><span class="line">   <span class="keyword">int</span> maxlis = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> ( maxlis &lt; lis[i] )</span><br><span class="line">         maxlis = lis[i];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> [] lis;</span><br><span class="line">   <span class="keyword">return</span> maxlis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; getLISLength(arr, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三：Θ(nlgn)的方案">解法三：Θ(nlgn)的方案</h2><p>本解法的具体操作如下：</p>
<ul>
<li>开一个栈，依次读取数组元素 x 与栈顶元素 top：<ul>
<li>如果 x &gt; top，将 x 入栈；</li>
<li>如果 x &lt; top，则二分查找栈中第一个 大于等于x 的数，并用 x 替换它。</li>
</ul>
</li>
</ul>
<p>遍历结束之后，最长递增序列长度即为栈的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLISLength</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 模拟栈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.size()==<span class="number">0</span> || v.back()&lt;A[i])</span><br><span class="line">			v.push_back(A[i]);</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">// 二分查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> mid, low=<span class="number">0</span>, high=v.size()-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">			&#123;</span><br><span class="line">				mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(v[mid] &lt; A[i])</span><br><span class="line">					low = mid + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					high = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v[low] = A[i];  <span class="comment">// 替换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了二分搜索，故时间复杂度变成了 $Θ(nlgn)$。</p>
<p>特别注意的是：本方法<strong>只能</strong>用于求最长递增子序列的长度，千万不要以为栈中的序列就是最长递增子序列：</p>
<ul>
<li><p>例一：原序列为1，5，8，3，6，7<br>栈为1，5，8，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6；再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。</p>
</li>
<li><p>例二：原序列为1，5，8，3<br>则最终栈为1，3，8。明显这不是最长递增子序列！</p>
</li>
</ul>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>根据题意可知，我们需要求出一个“中间点”，使得其左边的【最长递增子序列】和其右边的【最长递减子序列】之和最大。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">	<span class="keyword">int</span> *A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lis[i]表示以A[i]为结尾的最长递增子序列的长度</span></span><br><span class="line">	<span class="keyword">int</span> *lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line">	<span class="comment">// lds[i]表示以A[i]为起点的最长递减子序列的长度</span></span><br><span class="line">	<span class="keyword">int</span> *lds = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		lis[i] = <span class="number">1</span>;</span><br><span class="line">		lds[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt; A[j] &amp;&amp; lis[i] &lt; lis[j]+<span class="number">1</span>)</span><br><span class="line">				lis[i] = lis[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>; j&gt;i; --j)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt; A[j] &amp;&amp; lds[i] &lt; lds[j]+<span class="number">1</span>)</span><br><span class="line">				lds[i] = lds[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxl = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="keyword">if</span>(maxl &lt; lis[i]+lds[i])</span><br><span class="line">			maxl = lis[i] + lds[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; len - maxl + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] lis;</span><br><span class="line">	<span class="keyword">delete</span> [] lds;</span><br><span class="line">	<span class="keyword">delete</span> [] A;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K) 。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2011-最长公共子串]]></title>
    <link href="http://yoursite.com/2015/03/18/hua-wei-OJ2011/"/>
    <id>http://yoursite.com/2015/03/18/hua-wei-OJ2011/</id>
    <published>2015-03-18T11:19:52.000Z</published>
    <updated>2015-05-10T11:24:31.089Z</updated>
    <content type="html"><![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串<a id="more"></a></p>
<p><strong>输出：</strong></p>
<p>输出一个整数</p>
<p><strong>样例输入：</strong><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">asdfas</span> werasdfaswer</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、解题报告">二、解题报告</h3><p>与最长公共子序列（参见《<a href="http://songlee24.github.io/2014/11/27/dynamic-programming/" target="_blank" rel="external">动态规划DP</a>》）一样，最长公共子串也可以使用动态规划解决，只不过思路不太一样。准确地说，是打表的方式不一样。</p>
<p>举个例子：s1 = <code>bab</code>，s2 = <code>caba</code>。表如下</p>
<center><br><img src="http://img.blog.csdn.net/20150423105150153" alt=""><br></center>

<p>具体打表的方法是：</p>
<ul>
<li>第一行、第一列初始化为 0；</li>
<li>对于其他的格子：<ul>
<li>若对应的两个字符相等，格子的值设为左上角的值加 1。</li>
<li>若对应的两个字符不相等，直接置 0 。</li>
</ul>
</li>
</ul>
<p><br><br>这样的话，表中的最大元素就是 最长公共子串 的<strong>长度</strong>。并且也可以很容易看出最长公共子串有 2 个，分别是<code>ba</code>和<code>ab</code>。</p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLCStringLength</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> input, s1, s2;</span><br><span class="line">	getline(<span class="built_in">cin</span>, input);</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">	ss &gt;&gt; s1;</span><br><span class="line">	ss &gt;&gt; s2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getLCStringLength(s1, s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、扩展">三、扩展</h3><p>如何输出所有的最长公共子串？</p>
<p>很简单，我们记录下 s1 和 s2 的公共子串分别在 s1 、s2 中起始位置（即表中值为 1 的坐标）。打表完成以后，我们已经知道了最长公共子串的长度<code>length</code>，通过<code>substr()</code>判断即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.substr(i-<span class="number">1</span>, length) == s2.substr(j-<span class="number">1</span>, length)</span><br></pre></td></tr></table></figure></p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCString</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; firstPos;  <span class="comment">// 记录子串开始的坐标 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">				<span class="keyword">if</span>(table[i][j] == <span class="number">1</span>) </span><br><span class="line">					firstPos.push_back(make_pair(i, j));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出所有的最长公共子串</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator beg = firstPos.begin();</span><br><span class="line">	<span class="keyword">for</span>( ; beg!=firstPos.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start1 = beg-&gt;first-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> start2 = beg-&gt;second-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s1.substr(start1, biggest) == s2.substr(start2, biggest))</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s1.substr(start1, biggest) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"hello,world,james"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"james is saying hello"</span>;</span><br><span class="line">	printLCString(s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（二）]]></title>
    <link href="http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/"/>
    <id>http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/</id>
    <published>2015-03-16T18:40:53.000Z</published>
    <updated>2015-05-10T11:17:34.068Z</updated>
    <content type="html"><![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）<a id="more"></a></p>
<ul>
<li>进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行 pop 操作。</li>
</ul>
<p><strong>3.4</strong> 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</p>
<ul>
<li>每次只能移动一个盘子</li>
<li>盘子只能从柱子顶端滑出移到下一根柱子</li>
<li>盘子只能叠在比它大的盘子上</li>
</ul>
<p>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><strong>3.5</strong> 实现一个<code>MyQueue</code>类，该类用两个栈来实现一个队列。</p>
<p><strong>3.6</strong> 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code>和<code>isEmpty</code>。</p>
<p><strong>3.7</strong> 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>等。</p>
<p><br><br></p>
<h3 id="4、树与图">4、树与图</h3><p><strong>4.1</strong> 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</p>
<p><strong>4.2</strong> 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</p>
<p><strong>4.3</strong> 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</p>
<p><strong>4.4</strong> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</p>
<p><strong>4.5</strong> 实现一个函数，检查一棵二叉树是否为二叉查找树。</p>
<p><strong>4.6</strong> 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</p>
<p><strong>4.7</strong> 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</p>
<p><strong>4.8</strong> 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</p>
<p><strong>4.9</strong> 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</p>
<p><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>3.1 描述如何只用一个数组来实现三个栈。</strong></p>
<p>这个问题的难易程度取决于每个栈是<em>固定分割</em> 还是 <em>动态分割</em>。</p>
<ul>
<li><strong>固定分割</strong>：也就是每个栈分配固定大小的空间。这是最简单的实现方法，但是效率不高，因为即使某个栈是空的，它的空间也不能被别的栈使用。下面是每个栈占数组1/3的实现代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100</span>;  <span class="comment">// 每个栈的大小</span></span><br><span class="line">	<span class="keyword">int</span> tops[<span class="number">3</span>];                  <span class="comment">// 3个栈的栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>*size];              <span class="comment">// 共享的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">absTopOfStack</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// 返回栈顶指针在数组中的绝对量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		tops[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::absTopOfStack(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> flag * size + tops[flag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tops[flag] == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(tops[flag]+<span class="number">1</span> &gt;= size) <span class="comment">/*检查有无空闲空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Out of space.\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		++tops[flag];</span><br><span class="line">		arr[absTopOfStack(flag)] = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = arr[absTopOfStack(flag)];</span><br><span class="line">	arr[absTopOfStack(flag)] = <span class="number">0</span>;   <span class="comment">/*清零*/</span></span><br><span class="line">	--tops[flag];  <span class="comment">/*指针自减*/</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> arr[absTopOfStack(flag)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>动态分割</strong>：允许栈的大小灵活可变，要实现起来难度有点大。</p>
<ul>
<li><p><strong>思路一</strong>：我们可以先考虑<em>用一个数组实现两个栈</em>，思路很简单：分别用数组的两端作为两个栈的起点，向中间扩展，若两个栈中的元素总和不超过n，两个栈不会重叠。基于同样的想法，我们可以把第三个栈实现在数组的中部，当前两个栈中有一个满了（即将重叠第三个栈时），平移第三个栈以扩展栈空间。这种方法由于需要搬移元素所以效率不高。</p>
</li>
<li><p><strong>思路二</strong>：链式栈。通过链表的方式来实现栈，如下图：</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150407021806320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>链式栈</strong>是在一个数组上实现多个栈（3个、4个、5个…）的通用解决方案。下面是示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;       <span class="comment">// 存储关键字</span></span><br><span class="line">	<span class="keyword">int</span> preIndex;  <span class="comment">// 记录上一个元素的位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> top1, top2, top3;</span><br><span class="line">	<span class="keyword">int</span> array_size;  <span class="comment">// 数组的大小，即栈的最大容量</span></span><br><span class="line">	<span class="keyword">int</span> current_ptr; <span class="comment">// 下一个元素入栈的位置</span></span><br><span class="line">	Node* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks(<span class="keyword">int</span> size);</span><br><span class="line">	~Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks(<span class="keyword">int</span> size):array_size(size),</span><br><span class="line">	top1(-<span class="number">1</span>),top2(-<span class="number">1</span>),top3(-<span class="number">1</span>),current_ptr(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arr = <span class="keyword">new</span> Node[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stacks::~Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> top1 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> top2 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> top3 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error flag of stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(current_ptr == array_size) <span class="comment">// 栈已满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is full.\n"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		arr[current_ptr].key = value;</span><br><span class="line">		<span class="keyword">switch</span> (flag)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top1;</span><br><span class="line">			top1 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top2;</span><br><span class="line">			top2 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top3;</span><br><span class="line">			top3 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++current_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		value = arr[top1].key;</span><br><span class="line">		top1 = arr[top1].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		value = arr[top2].key;</span><br><span class="line">		top2 = arr[top2].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		value = arr[top3].key;</span><br><span class="line">		top3 = arr[top3].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top1].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top2].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top3].key;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.2 请设计一个栈，除pop与push方法，还支持min方法，可返回栈元素中的最小值。pop、push和min三个方法的时间复杂度必须为O(1)。</strong></p>
<p>通常来说<code>pop</code>和<code>push</code>方法的时间复杂度就是O(1)，关键是<code>min</code>方法。</p>
<p>可能有人会想 在Stack类里添加一个int型的变量用来记录最小值。当新元素入栈时，比较新元素与最小值，若新元素更小则更新最小值，此时<code>push</code>的时间效率是O(1)；但是当 minValue 出栈时，我们需要遍历整个栈，找出新的最小值，此时<code>pop</code>操作的时间效率就不符合O(1)的要求了。</p>
<ul>
<li><strong>思路一</strong>：记录每种状态下的最小值。通过给栈元素增加一个 min 字段，每个元素在入栈时记录当前状态下的最小值。这么一来，要找到最小值，直接查看栈顶元素的 min 就行了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	node n;</span><br><span class="line">	n.value = v;</span><br><span class="line">	n.min = v &lt; min() ? v : min();</span><br><span class="line">	s.push(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> top = s.top().value;</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> s.top().min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：利用辅助栈保存最小值。这种方法比思路一更节省空间一些 ———— 因为思路一中每个栈元素都要记录 min，而使用辅助栈，当入栈元素大于当前最小值时，不需要记录。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_s;  <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(v &lt;= min())</span><br><span class="line">		min_s.push(v);</span><br><span class="line">	s.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> top = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">if</span>(top == min())</span><br><span class="line">		min_s.pop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(min_s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> min_s.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong> 3.3 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）</strong></p>
<p>根据题意，<code>SetOfStacks</code>中应该有一个栈数组，而<code>push</code>和<code>pop</code>都是操作栈数组中的最后一个栈。入栈时若最后一个栈被填满，就需新建一个栈；出栈后若最后一个栈为空，就必须从栈数组中移除这个栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SetOfStacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; stacks;</span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 一个栈的最大存储量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SetOfStacks(<span class="keyword">int</span> cap);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现**********/</span></span><br><span class="line">SetOfStacks::SetOfStacks(<span class="keyword">int</span> cap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SetOfStacks::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!stacks.empty() &amp;&amp; stacks.back().size() &lt; capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		stacks.back().push(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 必须新建一个栈</span></span><br><span class="line">		s.push(v);</span><br><span class="line">		stacks.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SetOfStacks::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(stacks.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = stacks.back().top();</span><br><span class="line">	stacks.back().pop();</span><br><span class="line">	<span class="keyword">if</span>(stacks.back().empty())</span><br><span class="line">		stacks.pop_back();  <span class="comment">// 移除</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶：实现一个popAt(int index)方法，根据指定的子栈，执行 pop 操作。</strong></p>
<p>设想当弹出 栈1 的栈顶元素时，我们需要移出 栈2 的栈底元素，并将其推到栈1中。随后，将栈3的栈底元素推入栈2，将栈4的栈底元素推入栈3，以此类推。</p>
<p>有人可能会说，没必要执行“推入”操作，有些栈不填满也可以啊！而且还降低了时间复杂度。但是若之后有人假定所有的栈（最后一个栈除外）都是填满的，就可能出现意想不到的 error！这个问题并没有“标准答案”，你应该跟面试官讨论各种做法的优劣。</p>
<p><br><br><strong>3.4 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</strong></p>
<ul>
<li><strong>每次只能移动一个盘子</strong></li>
<li><strong>盘子只能从柱子顶端滑出移到下一根柱子</strong></li>
<li><strong>盘子只能叠在比它大的盘子上</strong></li>
</ul>
<p><strong>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</strong></p>
<p><img src="http://img.blog.csdn.net/20150407021526401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>首先我们从最简单的开始整理自己的思路：</p>
<ul>
<li>当<code>n=1</code>时，因为只有一个盘子，所以可以直接将盘子1从柱1移至柱3.</li>
<li>当<code>n=2</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1从柱1移至柱2。</li>
<li>将盘子2从柱1移至柱3。</li>
<li>将盘子1从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=3</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将上面两个盘子从柱1移至柱2，同上。</li>
<li>将盘子3移至柱3。</li>
<li>将盘子1、2从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=4</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1、2、3移至柱2，具体做法参见前面。</li>
<li>将盘子4移至柱3。</li>
<li>将盘子1、2、3移至柱3。</li>
</ol>
</li>
</ul>
<p>把柱1上的盘子移至柱3，需要柱2作为缓冲。可以看出，上面的过程是递归的，很自然地就可以导出递归算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Tower</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; disks;  <span class="comment">// 用整数的大小表示盘子的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> d)</span></span>;             <span class="comment">// 向柱子上添加盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveButtomTo</span><span class="params">(Tower &amp;t)</span></span>; <span class="comment">// 移动最下面那块盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveDisks</span><span class="params">(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span></span>;  <span class="comment">// 利用buf将n块盘子移至dest</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************实现*********************/</span></span><br><span class="line"><span class="keyword">void</span> Tower::add(<span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!disks.empty() &amp;&amp; disks.top() &lt;= d) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error placing disk "</span> &lt;&lt; d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		disks.push(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Tower::moveButtomTo(Tower &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> top = disks.top();</span><br><span class="line">	disks.pop();</span><br><span class="line">	t.add(top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现 —— 注意使用引用</span></span><br><span class="line"><span class="keyword">void</span> Tower::moveDisks(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/*将上面的n-1块盘子移至缓冲区*/</span></span><br><span class="line">		moveDisks(n-<span class="number">1</span>, buf, dest);</span><br><span class="line">		<span class="comment">/*将最下面那块盘子移至目的地*/</span></span><br><span class="line">		moveButtomTo(dest);</span><br><span class="line">		<span class="comment">/*将缓冲区的n-1块盘子移至目的地*/</span></span><br><span class="line">		buf.moveDisks(n-<span class="number">1</span>, dest, *<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************测试*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tower tower[<span class="number">3</span>];  <span class="comment">// 3根柱子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		tower[<span class="number">0</span>].add(i);</span><br><span class="line">	<span class="comment">// 移动</span></span><br><span class="line">	tower[<span class="number">0</span>].moveDisks(<span class="number">5</span>, tower[<span class="number">2</span>], tower[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.5 实现一个MyQueue类，该类用两个栈来实现一个队列。</strong></p>
<p>队列和栈的主要区别就是元素进出顺序。假设两个栈分别是 Newest 和 Oldest，为了用这两个栈达到先进先出（FIFO）的效果，在入队时我们将元素压入 Newest 栈，然后将 Newest 的元素弹出，压入 Oldest 栈中（这样就达到了反转的效果），在出队时，我们从 Oldest 栈中弹出元素。</p>
<p>注意，为了避免频繁的执行从 Newest 到 Oldest 的反转操作，我们规定：只有在发现 Oldest 为空时，才执行反转操作 —— 将 Newest 中的所有元素弹出并压入 Oldest 中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Newest;  <span class="comment">// 新入队的元素</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Oldest;  <span class="comment">// 准备出队的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverseStacks</span><span class="params">()</span></span>;  <span class="comment">// 将Newest元素弹出，压入Oldest </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;           <span class="comment">// 队列大小</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span></span>;  <span class="comment">// 入队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span>;        <span class="comment">// 出队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>;            <span class="comment">// 队首元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Oldest为空才进行反转，避免频繁操作</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::reverseStacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Oldest.empty())  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!Newest.empty()) &#123;</span><br><span class="line">			Oldest.push(Newest.top());</span><br><span class="line">			Newest.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Oldest.size()+Newest.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入Newest，最新元素始终位于它的顶端</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::enqueue(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	Newest.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Oldest出队</span></span><br><span class="line"><span class="keyword">int</span> MyQueue::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">int</span> value = Oldest.top();</span><br><span class="line">	Oldest.pop();</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::top()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">return</span> Oldest.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.6 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek和isEmpty。</strong></p>
<p>可以想到的一种做法是，搜索整个栈，找出最小元素，将其压入另一个栈；然后，在剩余元素中找出最小的，并将其入栈。但这种做法实际上需要两个额外的栈，一个用来存放最终的有序序列，一个在搜索时用作缓冲区。</p>
<p>那么，只使用一个额外的栈怎么做呢？可以从S1逐一弹出元素，然后按顺序插入S2中，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150407021739968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>S1是未排序的，S2是排好序的：</p>
<ul>
<li><p>从S1中弹出5，我们需要在S2中找到合适的位置插入这个数，所以将 12 和 8 移至 S1 中，然后将 5 压入 S2。</p>
</li>
<li><p>那么 8 和 12 需不需要移回 S2 呢？其实不需要，对于这两个数，我们可以像处理 5 那样重复相关步骤就可以了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Sort(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = s.top();</span><br><span class="line">		s.pop();          <span class="comment">// 弹出元素存到临时变量</span></span><br><span class="line">		<span class="keyword">while</span>(!r.empty() &amp;&amp; r.top() &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(r.top());</span><br><span class="line">			r.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		r.push(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>3.7 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 enqueue、dequeueAny、dequeueDog 和 dequeueCat 等。</strong></p>
<p><strong>思路一</strong>：只维护一个队列。那么 dequeueAny 就容易实现，而 dequeueDog 和 dequeueCat 就需迭代访问整个队列，找到第一只被收养的狗或猫。这种解法明显效率不高。</p>
<p><strong>思路二</strong>：为猫和狗各维护一个队列。那么 dequeueDog 和 dequeueCat 很容易实现，而 dequeueAny 需要比较猫队列与狗队列的队首，看哪个“更老”。为了方便 dequeueAny 的实现，我们给每个动物加一个额外的变量，以标记进入队列的先后顺序。这种解法显然更简单更高效！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> order;    <span class="comment">// 标记先后顺序</span></span><br><span class="line">	Animal(<span class="built_in">string</span> s):name(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******* 狗 *******/</span></span><br><span class="line"><span class="keyword">class</span> Dog : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dog(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* 猫 *******/</span></span><br><span class="line"><span class="keyword">class</span> Cat : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cat(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******队列*******/</span></span><br><span class="line"><span class="keyword">class</span> Queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;Dog&gt; dogs;</span><br><span class="line">	<span class="built_in">list</span>&lt;Cat&gt; cats;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue():order(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Dog d)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		d.order = order++;</span><br><span class="line">		dogs.push_back(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Cat c)</span>  <span class="comment">// 重载</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		c.order = order++;</span><br><span class="line">		cats.push_back(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Dog <span class="title">dequeueDog</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Dog d = dogs.front();</span><br><span class="line">		dogs.pop_front();</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Cat <span class="title">dequeueCat</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Cat c = cats.front();</span><br><span class="line">		cats.pop_front();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Animal <span class="title">dequeueAny</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dogs.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">		<span class="keyword">if</span>(cats.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dogs.front().order &lt; cats.front().order)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
<hr>
<p><strong>下面的题是关于树或图，做下面的题之前，首先我们要能够创建一棵二叉树或一个图：</strong></p>
<ul>
<li><strong>创建二叉树</strong>：二叉树是什么相信就不用我多说了，可以递归地根据输入创建一棵二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">&#125; *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归地创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		T = NULL;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = x;</span><br><span class="line">	createBinaryTree(T-&gt;left);</span><br><span class="line">	createBinaryTree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	createBinaryTree(T); </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>创建二叉查找树</strong>： 可以由一个数组生成一棵二叉查找树，见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757" target="_blank" rel="external">二叉查找树（BST）</a>》。</p>
</li>
<li><p><strong>创建图</strong>：图有两种存储方式，邻接矩阵和邻接表，这里采用邻接表来创建图。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Graph  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">int</span> V;                         <span class="comment">// 顶点数  </span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                <span class="comment">// 邻接表  </span></span><br><span class="line"> </span><br><span class="line">	Graph(<span class="keyword">int</span> V);                  <span class="comment">// 构造函数  </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;    <span class="comment">// 向图中添加边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span>  </span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;  </span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span>  </span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)  </span><br><span class="line">&#123;  </span><br><span class="line">	adj[v].push_back(w);          <span class="comment">// 将w添加到v的链表  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><strong>4.1 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</strong></p>
<p>本题明确地给出了平衡树的定义，我们的解法就是根据定义直接递归检查每棵子树的高度。代码中的 checkHeight 方法以递归方式获取左右子树的高度。若子树是平衡的，返回该子树的实际高度；若子树不平衡，返回-1，这时所有递归都会立即返回：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line"> * 平衡返回高度，不平衡返回-1</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查左子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> leftHeight = checkHeight(T-&gt;left);</span><br><span class="line">	<span class="keyword">if</span>(leftHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查右子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> rightHeight = checkHeight(T-&gt;right);</span><br><span class="line">	<span class="keyword">if</span>(rightHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查当前结点是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> diff = leftHeight&gt;rightHeight ? </span><br><span class="line">		leftHeight-rightHeight : rightHeight-leftHeight;</span><br><span class="line">	<span class="keyword">if</span>(diff &gt; <span class="number">1</span>)  <span class="comment">// 不平衡，返回-1</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>          <span class="comment">// 平衡，返回高度</span></span><br><span class="line">		<span class="keyword">return</span> leftHeight&gt;rightHeight ? leftHeight+<span class="number">1</span> : rightHeight+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkHeight(T) == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.2 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</strong></p>
<p>只需通过图的遍历，比如深度优先搜索或广度优先搜索，就能解决这个问题。</p>
<p>我们从其中一个结点出发，在遍历过程中检查是否找到另一个结点。在这个算法中，访问过的结点都应标记为“已访问”，以免循环和重复访问结点。下面的示例代码使用了广度优先搜索：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPathExist</span><span class="params">(Graph g, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;  <span class="comment">// 当做队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> V = g.getVertexNum();  <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)  </span><br><span class="line">		visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">	visited[start] = <span class="keyword">true</span>; <span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	<span class="built_in">queue</span>.push_back(start);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node = <span class="built_in">queue</span>.front(); <span class="comment">// 出队</span></span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=g.adj[node].begin(); i!=g.adj[node].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(*i == end)  <span class="comment">// 是否等于另一个结点</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">					<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.3 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</strong></p>
<p>要让二叉查找树的高度最小，就必须让左右子树的结点数越接近越好。根据二叉查找树的性质（中序遍历的序列是一个递增的有序序列），可以让该数组中间的值成为根节点，前半区间成为左子树，后半区间成为右子树。然后，每一个区间中间的值又成为子树的根节点，以此类推。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* createMinBST(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &gt; high)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span> NULL; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">	TreeNode* T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = A[mid];</span><br><span class="line">	T-&gt;left = createMinBST(A, low, mid-<span class="number">1</span>);</span><br><span class="line">	T-&gt;right = createMinBST(A, mid+<span class="number">1</span>, high);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.4 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</strong></p>
<p>根据题意，你可能认为这个问题需要一层一层遍历，每一层构成一个链表。但其实可以用任意方式遍历树，只要记住结点位于哪一层即可。</p>
<p>下面是使用先序遍历实现的一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLevelLists</span><span class="params">(BiTree T, <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode*&gt;&gt; &amp;lists, <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lists.size() &lt;= level)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>&lt;TreeNode*&gt; lst;</span><br><span class="line">		lst.push_back(T);</span><br><span class="line">		lists.push_back(lst);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		lists.at(level).push_back(T);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	createLevelLists(T-&gt;left, lists, level+<span class="number">1</span>);  <span class="comment">// 左子树</span></span><br><span class="line">	createLevelLists(T-&gt;right, lists, level+<span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以使用其他遍历方式，比如层序遍历、广度优先搜索。</p>
<p><br><br><strong>4.5 实现一个函数，检查一棵二叉树是否为二叉查找树。</strong></p>
<ul>
<li><strong>思路一</strong>：检查中序序列是否是升序。这是二叉查找树的性质，但<strong>需要注意的是</strong>，这种方法无法正确处理树中的重复值。若假定这棵树不包含重复值，则这种方法是有效的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inOrder</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*检查左子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;left, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查当前结点*/</span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= last)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	last = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查右子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;right, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = INT_MIN;</span><br><span class="line">	<span class="keyword">return</span> inOrder(T, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：自上而下传递最小和最大值，判断每个结点是否在范围内。假定根结点的值是20，最开始的范围是（<code>INT_MIN</code>,<code>INT_MAX</code>），根结点明显在这个范围内。然后判断左孩子是否在（<code>INT_MIN</code>, 20）这个范围内，右孩子是否在（20 ,<code>INT_MAX</code>）这个范围内。以此类推，递归下去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= min || T-&gt;data &gt; max)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!checkBST(T-&gt;left,min,T-&gt;data) || !checkBST(T-&gt;right,T-&gt;data,max))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> checkBST(T, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.6 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</strong></p>
<p>见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757#t2" target="_blank" rel="external">BST的前驱与后继</a>》，本题要求的是中序遍历中的后继结点。求一个结点 x 的后继，有两种情况：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继是右子树中值最小的结点，即右子树最左边的结点。</p>
</li>
<li><p>若结点 x 的右子树为空，表示已遍访 x 的子树。我们必须回到 x 的父结点，记父结点为 p ：</p>
<ul>
<li><p>如果 x 是 p 的左儿子，那么下一个要访问的结点就是 p ；</p>
</li>
<li><p>如果 x 是 p 的右儿子，表示已遍访 p 的子树，这时需从 p 往上继续访问，直到遇到一个祖先结点 pp，它的左儿子也是结点 x 的祖先。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* successor_BST(TreeNode* n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* tmp = n-&gt;right;</span><br><span class="line">		<span class="keyword">while</span>(tmp-&gt;left!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* p = n-&gt;parent;</span><br><span class="line">		<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right==n)</span><br><span class="line">		&#123;</span><br><span class="line">			n = p;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.7 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</strong></p>
<p>我们在解题之前应该先要问问面试官，这棵树的结点是否包含指向父结点的指针。</p>
<ul>
<li><p><strong>情况一</strong>：如果每个结点中包含指向父结点的指针，那么就可以直接向上追踪 p 和 q 的路径，直到两者相交。当然，在向上追踪的过程中我们需要标记结点是否已经被访问过，比如可以给结点添加<code>isVisited</code>域、或者将已访问结点映射到散列表。</p>
</li>
<li><p><strong>情况二</strong>：如果结点不包含指向父结点的指针，又不得将额外的结点储存在另外的数据结构中。那么我们的做法就是：从上向下判断，若 p 和 q 都在某结点的左边，就到左子树中查找共同祖先；若都在该结点的右边，则在右子树中查找共同祖先。要是 p 和 q 不在同一边，那么就表示已经找到第一个共同祖先了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若p为root的子孙，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(root == p)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> cover(root-&gt;left, p) || cover(root-&gt;right, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* getCommonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	<span class="keyword">if</span>(T == p || T == q)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> pAtLeft = cover(T-&gt;left, p);</span><br><span class="line">	<span class="keyword">bool</span> qAtLeft = cover(T-&gt;left, q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*若p和q不在同一边，则表示已经找到第一个共同祖先*/</span></span><br><span class="line">	<span class="keyword">if</span>(pAtLeft != qAtLeft)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="comment">/*若在同一边，遍访那一边*/</span></span><br><span class="line">	TreeNode* child = pAtLeft ? T-&gt;left : T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(child, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* commonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cover(T, p) || !cover(T, q))  <span class="comment">// --错误检查--</span></span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(T, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.8 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</strong></p>
<p>首先考虑小数据量的情况，可以求出两棵树的前序和中序遍历序列，若 T2 前序遍历是 T1 前序遍历的子串，并且 T2 中序遍历是 T1 中序遍历的子串，则 T2 为 T1 的子树。假设T1的节点数为 N，T2的节点数为 M。遍历两棵树的时间复杂度是 O(N + M)， 判断字符串是否为另一个字符串的子串的复杂性也是 O(N + M)（比如使用KMP算法）。所以总的时间复杂度是<code>O(N+M)</code>，所需的空间也是<code>O(N+M)</code>。———— 这里需要注意一点：对于左结点或者右结点为 null 的情况，需要在字符串中插入特殊字符表示。</p>
<p>对于简单的情形，上面的解法还算不错。但是当数据量非常大时，暂存前序和中序序列可能要占用太多的内存，所以我们考虑另一种解法：遍历 T1，每当 T1 的某个节点与 T2 的根节点值相同时，就判断两棵子树是否相同。假设 T2 的根节点在 T1 中出现了 k 次，那么算法的时间复杂度就是<code>O(N + k*M)</code>，最坏情况下是<code>O(N*M)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配两棵子树，完全一样返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL &amp;&amp; t2 == NULL) <span class="comment">/*若两者都为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL || t2 == NULL) <span class="comment">/*若只有一个为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data != t2-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> matchTree(t1-&gt;left,t2-&gt;left) &amp;&amp; matchTree(t1-&gt;right,t2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历大树t1，当某个结点与t2根结点相同，matchTree判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">/*大的树已经空了，还未找到子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data == t2-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(matchTree(t1, t2))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subTree(t1-&gt;left, t2) || subTree(t1-&gt;right, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t2 == NULL)  <span class="comment">/*空树一定是子树*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">	<span class="keyword">return</span> subTree(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的两种解法，哪种解法比较好呢？</p>
<ul>
<li><p>方法一会占用 O(N + M) 的内存，而另外一种解法只会占用 O(logN + logM) 的内存（递归的栈内存）。当考虑扩展性时，内存使用的多寡是个很重要的因素。</p>
</li>
<li><p>方法一的时间复杂度为O(N + M)，方法二最差的时间复杂度是O(N*M)。但是最差情况的时间复杂度并没有代表性，我们需要进一步观察，因为更可能的情况是很早就发现两棵树的不同，早早的退出了 matchTree。</p>
</li>
</ul>
<p>总的来说，在空间效率上，第二种解法更好。在时间上，需要通过实际数据来验证。</p>
<p><br><br><strong>4.9 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</strong></p>
<p>下面我们采用简化推广法来解题。</p>
<p><strong>Step 1 </strong>： 简化——假设路径必须从根节点开始，但可以在任意结点结束，该怎么解决？</p>
<p>在这种情况下，问题就会变得容易很多。我们可以从根节点开始，向下访问子节点，计算每条路径上到当前节点为止的数值总和，若与给定值相同则打印当前路径。注意，就算找到总和，仍要继续访问这条路径（因为可能存在正负相抵消的情况）。</p>
<p><strong>Step 2 </strong>： 推广——路径可从任意结点开始</p>
<p>如果路径可以从任意结点开始，在任意结点结束。在这种情况下我们稍作调整，对于每个结点，都向“上”检查是否有总和为 sum 的路径。具体来讲就是：递归访问每个结点 p 时，我们将 root 到 p 的完整 path 传入函数；然后，函数会从 p 到 root 逆序将结点上的值加起来，当每条子路径的总和等于 sum 时，打印该条子路径。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印从start到end的路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> path[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求一棵子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> leftDepth = depth(n-&gt;left);</span><br><span class="line">		<span class="keyword">int</span> rightDepth = depth(n-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> leftDepth&gt;rightDepth ? leftDepth+<span class="number">1</span> : rightDepth+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum, <span class="keyword">int</span> path[], <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*将当前结点插入路径*/</span></span><br><span class="line">	path[level] = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从当前结点到root结点，看是否存在和为sum的路径*/</span></span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		t += path[i];</span><br><span class="line">		<span class="keyword">if</span>(t == sum)</span><br><span class="line">			print(path, i, level);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*递归*/</span></span><br><span class="line">	findSum(T-&gt;left, sum, path, level+<span class="number">1</span>);</span><br><span class="line">	findSum(T-&gt;right, sum, path, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = depth(T);</span><br><span class="line">	<span class="keyword">int</span> *path = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(dep*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	findSum(T, sum, path, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(path);<span class="comment">/*释放内存*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
</feed>