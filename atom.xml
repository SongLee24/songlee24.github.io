<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[神奕的博客]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-04-02T04:09:21.618Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java基础笔记（四） IO/NIO与序列化]]></title>
    <link href="http://yoursite.com/2016/03/31/java-basic-note-4/"/>
    <id>http://yoursite.com/2016/03/31/java-basic-note-4/</id>
    <published>2016-03-31T11:42:57.000Z</published>
    <updated>2016-04-02T04:09:21.618Z</updated>
    <content type="html"><![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第十一章_I/O与序列化">第十一章 I/O与序列化</h1><h2 id="1、File类">1、File类</h2><p>Java中访问本地系统是通过<code>java.io.File</code>类。 File类可以使用 <strong>绝对路径</strong> 或 <strong>相对路径</strong> 来创建 File 对象，然后调用 File 对象的方法来操作文件和目录。<br><a id="more"></a><br><strong>&gt;&gt; File类常用方法</strong></p>
<ol>
<li><p>访问文件名相关的方法</p>
<ul>
<li><code>String getName()</code>：获取文件名</li>
<li><code>String getPath()</code>：获取路径名</li>
<li><code>String getAbsolutePath()</code>：获取绝对路径名</li>
<li><code>File getAbsoluteFile()</code>：返回绝对路径的File对象</li>
<li><code>String getParent()</code>：返回上一级目录名</li>
<li><code>boolean renameTo(File newName)</code>：重命名</li>
</ul>
</li>
<li><p>文件检测相关的方法</p>
<ul>
<li><code>boolean exists()</code>：判断是否存在</li>
<li><code>boolean canWrite()</code>：判断是否可写</li>
<li><code>boolean canRead()</code>：判断是否可读</li>
<li><code>boolean isFile()</code>：判断是否是文件（而不是目录）</li>
<li><code>boolean isDirectory()</code>：判断是否是目录</li>
<li><code>boolean isAbsolute()</code>：判断是否是绝对路径</li>
</ul>
</li>
<li><p>获取常规文件信息</p>
<ul>
<li><code>long lastModified()</code>：返回文件的最后修改时间</li>
<li><code>long length()</code>：返回文件内容的长度</li>
</ul>
</li>
<li><p>文件操作相关的方法</p>
<ul>
<li><code>boolean createNewFile()</code>：当此File对象所对应的文件不存在时，创建它。</li>
<li><code>boolean delete()</code>：删除文件或路径</li>
<li><code>static File createTempFile(String prefix, String suffix)</code>：创建临时空文件</li>
<li><code>void deleteOnExit()</code>：指定当Java虚拟机退出时，删除该文件或目录</li>
</ul>
</li>
<li><p>目录操作相关的方法</p>
<ul>
<li><code>boolean mkdir()</code>：创建目录</li>
<li><code>String[] list()</code>：列出当前目录的所有子文件名和子目录名，返回String数组</li>
<li><code>File[] listFiles()</code>：列出当前目录的所有子文件名和子目录名，返回File数组</li>
<li><code>static File[] listRoots()</code>：列出系统所有的根路径，静态方法。</li>
</ul>
</li>
</ol>
<p><strong>&gt;&gt; 文件过滤器</strong></p>
<p>上述File类的<code>list()</code>方法有一个重载版本：</p>
<ul>
<li><code>String[] list(FilenameFilter filter)</code></li>
</ul>
<p>通过过滤器参数可以只列出符合条件的文件或目录。<code>FilenameFilter</code>接口内只有一个方法<code>accept(File dir, String name)</code>，该方法将依次对所有的子文件名或子目录名进行迭代，返回<code>true</code>则表示符合要求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">".gz"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"/home/master/software"</span>);</span><br><span class="line">		String[] nameList = file.list(<span class="keyword">new</span> MyFilter());</span><br><span class="line">		<span class="keyword">for</span>(String n : nameList) &#123;</span><br><span class="line">			System.out.println(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<h2 id="2、理解Java的IO流">2、理解Java的IO流</h2><p><strong>&gt;&gt; 流的分类</strong></p>
<p>Java中把不同的输入/输出源（键盘、文件、网络连接等）抽象表述为“流”（Stream）。按照不同的分类方式，可以将流分为不同的类型。</p>
<ol>
<li><p>按照流的流向来分：</p>
<ul>
<li><strong>输入流</strong>：从程序的角度，只能从中读取数据，不能向其写入数据 —— 输入流主要由<code>InputStream</code>和<code>Reader</code>作为基类。</li>
<li><strong>输出流</strong>：从程序的角度，只能向其写入数据，不能从中读取数据 —— 输出流主要由<code>OutputStream</code>和<code>Writer</code>作为基类。</li>
</ul>
</li>
<li><p>按照操作的数据单元来分：</p>
<ul>
<li><strong>字节流</strong>：字节流操作的数据单元是一个字节（8个bit）—— 字节流主要由<code>InputStream</code>和<code>OutputStream</code>作为基类。</li>
<li><strong>字符流</strong>：字符流操作的数据单元是一个字符（两个字节，16个bit）—— 字符流主要由<code>Reader</code>和<code>Writer</code>作为基类。</li>
</ul>
</li>
<li><p>按照流的角色来分：</p>
<ul>
<li><strong>节点流</strong>：直接与IO设备（如磁盘、网络）交互的流，称为节点流，节点流也被称为低级流。</li>
<li><strong>处理流</strong>：对一个已存在的流进行封装，封装后的流称为处理流，处理流也被称为高级流。</li>
</ul>
</li>
</ol>
<p><strong>&gt;&gt; 流的概念模型</strong></p>
<p>Java把所有IO设备里的有序数据抽象成流模型。</p>
<p>对于输入流的 InputStream 和 Reader 而言，它们把输入设备抽象成一个“水管”，水管里的每个“水滴”依次排序，如下图：</p>
<p><img src="http://img.blog.csdn.net/20160329155324549" alt=""></p>
<p>输入流使用 <strong>隐式的指针</strong> 来记录读取位置，每当程序从输入流里读取一个或多个“水滴”后，记录指针自动向后移动。</p>
<p>对于输出流的 OutputStream 和 Writer 而言，它们同样把输出设备抽象成一个“水管”，只是这个水管里一开始没有“水滴”，如下图：</p>
<p><img src="http://img.blog.csdn.net/20160329155410023" alt=""></p>
<p>当程序执行输出时，相当于依次把“水滴”放入水管中，输出流同样采用 隐式的指针 来标识当前水滴即将放入的位置。</p>
<p><strong>&gt;&gt; 基类的接口</strong></p>
<p>InputStream 和 Reader 是所有输入流的抽象基类，它们都包含如下三个方法：</p>
<ul>
<li><p><code>int read()</code>：从输入流读取单个字节/字符，返回所读取到的字节/字符数据。</p>
</li>
<li><p><code>int read(byte[]/char[] buf)</code>：从输入流中最多读取 buf.length 个字节/字符数据，并将其存在 buf 数组中，返回实际读取的字节/字符数量。</p>
</li>
<li><p><code>int read(byte[]/char[] buf, int off, int len)</code>：从输入流中最多读取 len 个字节/字符数据，并将其存在 buf 数组中。放入数组 buf 时，并不是从数组起点开始，而是从 off 位置开始，返回实际读取的字节/字符数量。</p>
</li>
</ul>
<p>可以看出，两个基类提供的方法基本一样，只是读取的数据单元不相同。当 read 方法返回 -1 时，表明到了输入流的结尾。</p>
<p>OutputStream 和 Writer 是所有输出流的抽象基类，它们都包含了如下三个方法：</p>
<ul>
<li><p><code>void write(int c)</code>：将指定的字节/字符输出到输出流中。</p>
</li>
<li><p><code>void write(byte[]/char[] buf)</code>：将字节数组/字符数组中的数据输出到指定的输出流中。</p>
</li>
<li><p><code>void write(byte[]/char[] buf, int off, int len)</code>：将字节数组/字符数组从 off 位置开始，长度为 len 的字节/字符输出到输出流中。</p>
</li>
</ul>
<p>其中 Writer 还包含额外的两个方法：</p>
<ul>
<li><code>void write(String str)</code></li>
<li><code>void write(String str, int off, int len)</code></li>
</ul>
<hr>
<p><br></p>
<h2 id="3、处理流模型">3、处理流模型</h2><p>像 FileInputStream、FileReader 等实现类都是节点流，它们都是直接与文件交互的。<strong>处理流</strong>则是对节点流进行了一层包装，处理流的好处主要在于：</p>
<ol>
<li><p><strong>性能的提高</strong>：主要以增加缓冲的方式来提高I/O的效率；</p>
</li>
<li><p><strong>操作的便捷</strong>：处理流可能提供一系列更便捷的方法来一次输入/输出大批量的内容；</p>
</li>
<li><p><strong>接口的统一</strong>：通过处理流来读写，程序可以采用完全相同的代码来访问不同的数据源，随着处理流所包装的节点流的变化，程序访问的数据源也相应变化。（这是典型的<strong>装饰器</strong>设计模式）</p>
</li>
</ol>
<p>Java程序无须理会访问的设备是磁盘、网络还是文件，只需要将这些节点流包装成处理流，通过处理流来执行输入/输出功能。在关闭I/O流资源时，只要关闭最上层的处理流即可。</p>
<p><img src="http://img.blog.csdn.net/20160329172503354" alt=""></p>
<p>那么，怎么识别处理流呢？只要流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流。</p>
<hr>
<p><br></p>
<h2 id="4、输入/输出流体系">4、输入/输出流体系</h2><p>Java的输入/输出体系提供了近40个类，如下表 —— <strong>粗体</strong>标出的类属于节点流，必须直接与指定的物理节点关联；<em>斜体</em>标出的代表抽象基类，无法直接创建实例。</p>
<p><img src="http://img.blog.csdn.net/20160329173315803" alt=""></p>
<p>从表中可以看出，我们不仅可以把 数组 或 字符串 当作物理节点来访问，也可以把 管道 作为物理节点进行进程间通信。另外，Java提供了 4 个缓冲流（处理流），用以增加缓冲功能，提高输入输出效率。</p>
<h3 id="&gt;&gt;_转换流"><strong>&gt;&gt; 转换流</strong></h3><p>Java提供了两个转换流，用来将字节流转换成字符流：</p>
<ul>
<li><code>InputStreamReader</code>：将字节输入流转换成字符输入流；</li>
<li><code>OutputStreamWriter</code>：将字节输出流转换成字符输出流。</li>
</ul>
<p>由于字符流比字节流操作更方便，如果输入输出的是二进制内容，通常使用字节流；而如果是文本内容，则应该考虑字符流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(line.equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">				System.exit(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"输入内容为："</span>+line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上例所示，标准输入<code>System.in</code>是 InputStream 类的实例，使用不太方便。由于键盘输入都是文本内容，所以可以使用<code>InputStreamReader</code>转换成字符流，普通的 Reader 读取输入依然不方便，可以再将普通 Reader 包装成<code>BufferedReader</code>，然后逐行进行读取。</p>
<h3 id="&gt;&gt;_推回输入流"><strong>&gt;&gt; 推回输入流</strong></h3><p>Java提供了两个与众不同的流<code>PushbackInputStream</code>、<code>PushbackReader</code>，叫推回输入流。</p>
<ul>
<li><p><code>void unread(int b)</code>：将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容；</p>
</li>
<li><p><code>void unread(byte[]/char[] buf)</code>：将一个字节数组/字符数组推回到推回缓冲区里，从而允许重复读取刚刚读取的内容；</p>
</li>
<li><p><code>void unread(byte[]/char[] buf, int off, int len)</code>：将一个数组从off开始，长为len的字节/字符推回到推回缓冲区，从而允许重复读取刚刚读取的内容。</p>
</li>
</ul>
<p>简单地说，Pushback 输入流就是将刚刚从输入流中读出来的内容推回去，再读一遍 —— 不过不是推回到原来的输入流中，而是推回到<strong>推回缓冲区</strong>中。每次 Pushback 输入流调用<code>read()</code>方法时总是先从推回缓冲区中读，读完了以后再从原输入流中读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"D:/a.txt"</span>);</span><br><span class="line">		PushbackReader pr = <span class="keyword">new</span> PushbackReader(reader, <span class="number">32</span>);  <span class="comment">// 推回缓冲区的长度为32</span></span><br><span class="line">		<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];    <span class="comment">// 每次读取16个字符</span></span><br><span class="line">		String lastStr = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = pr.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			String currentStr = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">			<span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>((targetIndex = (lastStr + currentStr).indexOf(<span class="string">"yesterday"</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				pr.unread((lastStr + currentStr).toCharArray());  <span class="comment">// 推回</span></span><br><span class="line">				<span class="keyword">if</span>(targetIndex &gt; <span class="number">16</span>)</span><br><span class="line">					buf = <span class="keyword">new</span> <span class="keyword">char</span>[targetIndex];</span><br><span class="line">				pr.read(buf, <span class="number">0</span>, targetIndex);  <span class="comment">// 再次读取指定长度的内容</span></span><br><span class="line">				System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, targetIndex));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.print(lastStr);</span><br><span class="line">				lastStr = currentStr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序使用<code>PushbackReader</code>输入流，试图在文件中找出 “yesterday” 字符串，然后打印出目标字符串之前的内容。注意：如果push back到推回缓冲区的内容超出了推回缓冲区的大小，会报 IOException。</p>
<hr>
<p><br></p>
<h2 id="5、重定向">5、重定向</h2><p>在Java中，<code>System.in</code>和<code>System.out</code>代表标准输入与输出，默认情况下它们分别代表键盘和显示器。</p>
<p>在 System 类里提供了三个重定向标准输入/输出的方法：</p>
<ul>
<li><code>static void setErr(PrintStream err)</code>：重定向标准错误输出流</li>
<li><code>static void setIn(InputStream in)</code>：重定向标准输入流</li>
<li><code>static void setOut(PrintStream out)</code>：重定向标准输出流</li>
</ul>
<p>示例：将 System.out 重定向到文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/out.txt"</span>));</span><br><span class="line">		System.setOut(ps);  <span class="comment">// 重定向输出到文件</span></span><br><span class="line">		System.out.print(<span class="string">"Hello Java!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<h2 id="6、RandomAccessFile">6、RandomAccessFile</h2><p><code>RandomAccessFile</code>是Java提供的功能最丰富的文件访问类，它只能读写<strong>文件</strong>，不能读写其他IO设备。与普通的输入/输出流不同的是：<code>RandomAccessFile</code>支持“随机访问”的方式，允许自由定位文件记录指针。</p>
<p>它包含了如下2个方法来操作文件记录指针：</p>
<ul>
<li><code>long getFilePointer()</code>：返回文件记录指针的位置；</li>
<li><code>void seek(long pos)</code>：将文件记录指针定位到 pos 位置。</li>
</ul>
<p>RandomAccessFile 有两个构造器：<code>RandomAccessFile(String name, String mode)</code>和<code>RandomAccessFile(File file, String mode)</code>，第二个参数 mode 指定文件的访问模式：</p>
<ul>
<li><code>&quot;r&quot;</code>：以只读的方式打开指定文件；</li>
<li><code>&quot;rw&quot;</code>：以读、写的方式打开指定文件，如果文件不存在，创建该文件；</li>
<li><code>&quot;rws&quot;</code>：以读、写的方式打开指定文件。相对于”rw”，要求对“文件内容”或“元数据”的每个更新都同步写入到底层存储设备。</li>
<li><code>&quot;rwd&quot;</code>：以读、写的方式打开指定文件。相对于”rw”，要求对“文件内容”的每个更新都同步写入到底层存储设备。（不对metadata同步更新）</li>
</ul>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:/a.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">		System.out.println(<span class="string">"文件指针的初始位置："</span> + raf.getFilePointer());</span><br><span class="line">		raf.seek(<span class="number">100</span>);   <span class="comment">// 从100字节处开始读</span></span><br><span class="line">        <span class="comment">//raf.seek(raf.length());   // 定位到文件尾</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = raf.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RandomAccessFile 的 read() 方法、write() 方法与 InputStream/OutputStream 类似。</p>
<hr>
<p><br></p>
<h2 id="7、对象序列化（Serialize）">7、对象序列化（Serialize）</h2><h3 id="&gt;&gt;_序列化的含义和意义"><strong>&gt;&gt; 序列化的含义和意义</strong></h3><ul>
<li><p>含义：<strong>序列化机制</strong>允许将内存中的Java对象转换成<strong>字节序列</strong>，保存到磁盘上或通过网络进行传输；其他程序（从磁盘上或从网络上）获取到这些字节序列，就可以将这些字节序列恢复成原来的Java对象。</p>
</li>
<li><p>意义：序列化使得对象可以脱离程序的运行而独立存在，它是RMI（Remote Method Invoke，即远程方法调用）的参数和返回值必须实现的机制，而 RMI 又是Java EE技术的基础 —— 所有的分布式应用都需要跨平台、跨网络，所以序列化也是分布式技术的基础。</p>
</li>
</ul>
<h3 id="&gt;&gt;_使用”对象流”实现序列化"><strong>&gt;&gt; 使用”对象流”实现序列化</strong></h3><p>若想将某个对象序列化，该对象的类需要实现<code>Serializable</code>接口或<code>Externalizable</code>接口。</p>
<p>这里先讲<code>Serializable</code>，步骤如下：</p>
<ol>
<li>让目标类实现<code>Serializable</code>标记接口即可，无须实现任何方法；</li>
<li>创建一个<code>ObjectOutputStream</code>对象输出流，调用<code>writeObject()</code>方法将目标类的对象输出到磁盘或网络；</li>
</ol>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"带参数的构造器"</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/person.txt"</span>));</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="string">"科比·布莱恩特"</span>,<span class="number">38</span>);</span><br><span class="line">		oos.writeObject(person);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面程序，一个Person对象被序列化输出到文件中，该文件的内容就是<code>person</code>对象。</p>
<p><img src="http://img.blog.csdn.net/20160329230042893" alt=""></p>
<p>可以看到文件的内容是乱码的，因为是二进制。</p>
<p>如果希望从二进制流中恢复Java对象，则需要使用反序列化（Deserialize），步骤如下：</p>
<ol>
<li>创建一个<code>ObjectInputStream</code>输入流（这是一个处理流），从文件中读取二进制流。</li>
<li>调用<code>readObject()</code>方法读取流中的对象，该方法返回一个 Object 类型的对象，再强制类型转换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:/person.txt"</span>));</span><br><span class="line">		Person p = (Person)ois.readObject();</span><br><span class="line">		System.out.println(<span class="string">"名字："</span> + p.getName() + <span class="string">"\n年龄："</span> + p.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li><p>反序列化恢复Java对象时，必须提供该对象所属类的 class 文件，否则将报<code>ClassNotFoundException</code>异常。</p>
</li>
<li><p>反序列化恢复Java对象时，并没有看到程序调用构造器，这表明反序列化机制无须通过构造器来初始化Java对象。</p>
</li>
<li><p>当一个可序列化类有多个父类时，这些父类要么有无参数的构造器，要么也是可序列化的，否则将抛出<code>InvalidClassException</code> —— 父类最好都是可序列化的，因为如果某个父类不可序列化，而只是带有无参数构造器，那么该父类中定义的成员变量值不会序列化到二进制流中。</p>
</li>
</ul>
<h3 id="&gt;&gt;_多次序列化同一个对象"><strong>&gt;&gt; 多次序列化同一个对象</strong></h3><p>如果某个类的成员变量是另一种引用类型，那么这个引用类也必须是可序列化的，否则拥有该类型成员变量的类是不可序列化的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Person student;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, Person student)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此处省略成员变量的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Teacher对象持有一个Person对象的引用，当尝试序列化一个Teacher对象时，程序会顺带将该Person对象也进行序列化，所以Person类也必须是可序列化的，否则Teacher类将不可序列化。</p>
<p>先假设有如下一种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:/a.txt"</span>));</span><br><span class="line">		Person student = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>, <span class="number">500</span>);</span><br><span class="line">		Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">"唐僧"</span>, student);</span><br><span class="line">		Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">"菩提师祖"</span>, student);</span><br><span class="line">		oos.writeObject(t1);</span><br><span class="line">		oos.writeObject(t2);</span><br><span class="line">		oos.writeObject(student);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当序列化 t1 对象时，程序会顺带序列化 student 对象；当序列化 t2 对象时，程序一样会顺带序列化 student 对象；最后再显式序列化了 student 对象 —— 也就是说<code>student</code>对象被序列化了三次。</p>
<p>如果程序向输出流中写入了三个student对象，那么反序列化恢复时将得到三个student对象，也就是说反序列化后，t1 和 t2 所引用的不是同一个Person对象，这显然就出现了Bug！为了避免这种情况的出现，Java采用了一种特殊的序列化算法：</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号；</li>
<li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过了。若没有，系统才会将该对象转换成字节序列输出；</li>
<li>如果某个对象已经序列化过了，程序将直接输出一个序列化编号，不会重复序列化该对象。</li>
</ul>
<p>++所以当多次调用<code>writeObject()</code>输出同一个对象时，只有第一次调用会将该对象转换成字节序列输出。++</p>
<p>验证一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:/a.txt"</span>));</span><br><span class="line">		Teacher t1 = (Teacher)ois.readObject();</span><br><span class="line">		Teacher t2 = (Teacher)ois.readObject();</span><br><span class="line">		Person stu = (Person)ois.readObject();</span><br><span class="line">		System.out.println(t1.getStudent() == stu);  <span class="comment">// true</span></span><br><span class="line">		System.out.println(t2.getStudent() == stu);  <span class="comment">// true</span></span><br><span class="line">		<span class="comment">// 反序列化时读的顺序，必须和序列化时写的顺序一致。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="&gt;&gt;_transient关键字"><strong>&gt;&gt; transient关键字</strong></h3><p>如果一个类中的某些实例变量是敏感信息，或者是不可序列化的，因此不希望对该实例变量进行<strong>递归序列化</strong>，则可以使用<code>transient</code>关键字修饰该实例变量，那么在Java对象序列化时 该变量就会被系统忽略掉。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;   <span class="comment">// transient只能修饰实例变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"带参数的构造器"</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略成员变量的setter方法和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被<code>transient</code>关键字修饰的 age 变量将被完全隔离在序列化机制之外，反序列化恢复后将无法取得该成员变量的值。</p>
<h3 id="&gt;&gt;_Externalizable序列化机制"><strong>&gt;&gt; Externalizable序列化机制</strong></h3><p>前面介绍了要让某个类的对象可序列化，该类只要实现<code>Serializable</code>接口，不用实现任何方法。Java还提供了另一种序列化机制 —— 实现<code>Externalizable</code>接口，并实现下面两个方法：</p>
<ul>
<li><p><code>void writeExternal(ObjectOutput out)</code>：实现序列化，调用ObjectOutput的writeObject()方法；</p>
</li>
<li><p><code>void readExternal(ObjectInput in)</code>：实现反序列化，调用ObjectInput的readObject()方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"带参数的构造器"</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略成员变量的setter方法和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">		out.writeInt(age);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">			ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();</span><br><span class="line">		<span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 Externalizable 接口并重写两个方法以后，其余的步骤跟前面一样。</p>
<p>那么，这两种序列化机制有什么不同呢？</p>
<table>
<thead>
<tr>
<th style="text-align:left">实现Serializable接口</th>
<th style="text-align:left">实现Externalizable接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">系统自动存储必要信息</td>
<td style="text-align:left">程序员决定存储哪些信息</td>
</tr>
<tr>
<td style="text-align:left">Java内建支持，易于实现，只需实现该接口，无须任何代码支持</td>
<td style="text-align:left">仅仅提供两个空方法，实现该接口必须为两个空方法提供实现</td>
</tr>
<tr>
<td style="text-align:left">性能略差</td>
<td style="text-align:left">性能略好</td>
</tr>
</tbody>
</table>
<p>虽然实现 Externalizable 接口能带来一定的性能提升，但导致了编程复杂度的增加，所以大部分时候都采用 Serializable 接口的方式。</p>
<h3 id="&gt;&gt;_版本兼容"><strong>&gt;&gt; 版本兼容</strong></h3><p>前面提到了，反序列化时必须提供对象的所属类的 class 文件。但是，如果类定义被修改导致 class 文件变了呢？</p>
<ul>
<li>如果修改类时仅仅修改了方法，反序列化不受影响</li>
<li>如果修改类时仅仅修改了静态变量或 transient 修饰的变量，反序列化同样不受影响</li>
<li>如果修改类时修改了未被 transient 修饰的实例变量，版本不兼容，则反序列化可能会失败</li>
</ul>
<p>Java序列化机制允许为类提供一个<code>private static final long</code>的<code>serialVersionUID</code>值，该类变量的值用于标识该 Java 类的序列化版本。即便一个类升级了，只要它的 serialVersionUID 类变量值保持不变，序列化机制也会把它们当成同一个序列化版本。</p>
<p>JDK提供了一个<code>serialver</code>命令行工具来生成一个类的 serialVersionUID 版本值：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ serialver com.songlee.test.Person</span><br><span class="line">com.songlee.test.<span class="string">Person:</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="typename">long</span> serialVersionUID = <span class="number">2790932326217855955</span>L;</span><br></pre></td></tr></table></figure></p>
<p>显示指定 serialVersionUID 有利于程序在不同 JVM 之间移植，避免类定义没有改变却因为JVM不同导致版本不兼容的情况出现。</p>
<hr>
<p><br></p>
<h2 id="8、NIO">8、NIO</h2><p>前面介绍的<code>java.io.</code>包下的输入/输出流都是<strong>阻塞式</strong>的，而且，面向流的输入/输出通常效率不高，故 Java 从1.4版本开始，引入了一系列改进的输入/输出处理的新功能，这些新功能统称为<strong>新IO（New IO，简称NIO）</strong>。</p>
<h3 id="&gt;&gt;_Java_NIO概述"><strong>&gt;&gt; Java NIO概述</strong></h3><p>NIO新增了许多IO处理的类，这些类都被放在<code>java.nio</code>包下。与传统IO采用流处理模型不同的是，NIO采用<strong>内存映射文件</strong>的方式来处理输入/输出，即将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了，这种方式比传统IO要快得多。</p>
<table>
<thead>
<tr>
<th style="text-align:left">IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向流（Stream-oriented）</td>
<td style="text-align:left">面向块/缓冲（Buffer-oriented）</td>
</tr>
<tr>
<td style="text-align:left">阻塞IO（Blocking IO）</td>
<td style="text-align:left">非阻塞IO（Non-blocking IO）</td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">选择器（Selectors）</td>
</tr>
</tbody>
</table>
<p>Java NIO主要有3个核心部分：</p>
<ul>
<li><code>Channel</code>（通道）</li>
<li><code>Buffer</code>（缓冲）</li>
<li><code>Selector</code>（选择器）</li>
</ul>
<h3 id="&gt;&gt;_Channel">&gt;&gt; Channel</h3><p>在NIO中所有的输入输出都是从一个<code>Channel</code>开始。Channel（通道）类似于传统的流对象，但与传统的流对象有两个主要的区别：</p>
<ol>
<li>Channel提供了一个<code>map()</code>方法，可以直接将“一块数据”映射到Buffer中；</li>
<li>程序不能直接访问Channel中的数据，读写都不行，Channel只能与Buffer进行交互。</li>
</ol>
<p>也就是说，程序必须通过读写Buffer来访问Channel中的数据。</p>
<p><img src="http://img.blog.csdn.net/20160330115401052" alt=""></p>
<hr>
<p>下面是Java NIO中一些主要的Channel实现：</p>
<ul>
<li>FileChannel</li>
<li>Pipe.SinkChannel、Pipe.SourceChannel</li>
<li>SocketChannel、ServerSocketChannel</li>
<li>DatagramChannel</li>
</ul>
<p>可以看出这些通道涵盖了管道IO、UDP和TCP网络IO，以及文件IO等 —— <strong>除了FileChannel之外，其他的Channel都可以通过</strong><code>configureBlocking(false)</code><strong>方法设置为非阻塞模式</strong>，这也是为什么NIO称为非阻塞IO。</p>
<hr>
<p>所有的Channel都不应该通过构造器来直接创建，而应该通过传统流对象 InputStream/OutputStream 的<code>getChannel()</code>方法返回对应的Channel。通道Channel最常用的有三个方法：</p>
<ul>
<li><code>map()</code>：将Channel中的部分或全部数据映射成 ByteBuffer</li>
<li><code>read()</code>：一系列重载形式，用于读取Channel中的数据到Buffer中</li>
<li><code>write()</code>：一系列重载形式，用于将Buffer中的数据写到Channel中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:/a.txt"</span>);</span><br><span class="line">		FileChannel inChannel = <span class="keyword">new</span> FileInputStream(file).getChannel();</span><br><span class="line">		FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/b.txt"</span>).getChannel();</span><br><span class="line">		<span class="comment">// 将a.txt文件中的全部数据映射成ByteBuffer</span></span><br><span class="line">		ByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, file.length());</span><br><span class="line">		outChannel.write(buffer);  <span class="comment">// 再将数据写到outChannel，输出到b.txt文件</span></span><br><span class="line">		</span><br><span class="line">		buffer.clear();</span><br><span class="line">		CharBuffer charBuf = Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer);</span><br><span class="line">		System.out.println(charBuf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过 map 一次将全部数据映射到 Buffer 中，当然也可以使用Channel的 read/write 方法多次读写，类似于传统IO一样。</p>
<h3 id="&gt;&gt;_Buffer">&gt;&gt; Buffer</h3><p><code>Buffer</code>（缓冲）是一个抽象类，它用于和Channel交互。在Java NIO中的一些常用的Buffer实现有：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>实际使用较多的是<code>ByteBuffer</code>和<code>CharBuffer</code>，其中 ByteBuffer 还有一个子类<code>MappedByteBuffer</code>，它是 Channel.map() 方法的返回类型。</p>
<hr>
<p>在Buffer中有三个重要的概念：</p>
<ul>
<li><strong>容量（capacity）</strong>：该Buffer的最大数据容量，创建后不能改变。</li>
<li><strong>界限（limit）</strong>：该Buffer中的一个位置索引，位于 limit 后的数据不可读也不可写。</li>
<li><strong>位置（position）</strong>：用于指明下一个被读或被写的位置的索引。（类似于传统IO中的记录指针）</li>
</ul>
<p>另外，Buffer还支持一个可选的标记 mark（类似于传统IO流中的mark），通过<code>reset()</code>方法可以将 position 定位到 mark 处。这些值满足大小关系：<code>0 ≤ mark ≤ position ≤ limit ≤ capacity</code>：</p>
<p><img src="http://img.blog.csdn.net/20160330163602708" alt=""></p>
<hr>
<p>Buffer类都没有构造器，需通过各实现类的静态方法<code>XxxBuffer.allocate(int capacity)</code>来创建。 —— 刚创建时 position=0，limit=capacity，当通过 put() 方法或从Channel中读取一些数据放入Buffer中时，position会相应地向后移动。当装入数据结束后：</p>
<ul>
<li><code>flip()</code>：调用Buffer的 flip() 方法，limit置为position，position置0，为从Buffer中取出数据做好准备。</li>
<li><code>clear()</code>：数据读取完以后，调用Buffer的 clear() 方法，该方法将 position置0，limit置为capacity，回到刚创建时的状态，为再次装入数据做好准备。</li>
</ul>
<p>下面的代码可以验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		CharBuffer buffer = CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">		System.out.println(<span class="string">"position:"</span>+buffer.position());</span><br><span class="line">		System.out.println(<span class="string">"limit:"</span>+buffer.limit());</span><br><span class="line">		System.out.println(<span class="string">"capacity:"</span>+buffer.capacity());</span><br><span class="line">		</span><br><span class="line">		buffer.put(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(<span class="string">"放入一些数据后, position："</span>+buffer.position());</span><br><span class="line">		</span><br><span class="line">		buffer.flip();       <span class="comment">// 准备读取数据</span></span><br><span class="line">		System.out.println(<span class="string">"执行flip方法后, position:"</span>+buffer.position());</span><br><span class="line">		System.out.println(<span class="string">"执行flip方法后, limit:"</span>+buffer.limit());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"通过get方法读取数据："</span>+buffer.get()+buffer.get());</span><br><span class="line">		System.out.println(<span class="string">"读取一些数据后，position: "</span>+buffer.position());</span><br><span class="line">		</span><br><span class="line">		buffer.clear();     <span class="comment">// 回到刚创建时的状态</span></span><br><span class="line">		System.out.println(<span class="string">"执行clear方法后, position:"</span>+buffer.position());</span><br><span class="line">		System.out.println(<span class="string">"执行clear方法后, limit:"</span>+buffer.limit());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"绝对位置的get方法: "</span>+buffer.get(<span class="number">3</span>));  <span class="comment">// 通过绝对位置获取数据</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>Buffer提供了一系列重载形式的 put() 和 get() 方法来访问 Buffer 中的数据，分为相对和绝对两种方式：</p>
<ul>
<li>相对（Relative）：从当前 position 处开始读取或写入，然后 position 进行相应的移动。</li>
<li>绝对（Absolute）：直接根据索引（下标）向Buffer中读取或写入数据，不会影响 position 的值。</li>
</ul>
<h3 id="&gt;&gt;_Selector">&gt;&gt; Selector</h3><p>选择器<code>Selector</code>是Java里实现<strong>IO复用</strong>的概念，通过它一个线程可以管理多个Channel通道，从而管理多个网络连接。</p>
<blockquote>
<p>试想一下，如果一个线程负责处理一个网络IO，那么线程占用达到上限的时候怎么办？</p>
</blockquote>
<p>在使用 Selector 时，还涉及到两个重要的概念：</p>
<ol>
<li><p><strong>SelectableChannel</strong>：可选择的通道，使用Selector管理的通道必须都是SelectableChannel，它的特点是存在 阻塞模式 和 非阻塞模式。（除了FileChannel，其他类型的Channel都属于SelectableChannel）</p>
</li>
<li><p><strong>SelectionKey</strong>：当一个SelectableChannel向Selector中注册时，就会创建并返回一个选择键。简单点说，SelectionKey就是通道在 Selector 中的注册的标记。它维护了两个集合：</p>
<ul>
<li>interest集合：表示选择器对该channel的哪些操作感兴趣，只会检测这些操作是否准备就绪。</li>
<li>ready集合：表示该channel已经为这些操作准备就绪。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();       <span class="comment">// 创建一个Selector</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);          <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>
<p>与向Selector注册之前，Channel必须处于非阻塞模式下。注意<code>register()</code>方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听该Channel时对什么操作感兴趣 —— 可监听以下四种类型：</p>
<ul>
<li>SelectionKey.OP_CONNECT：连接</li>
<li>SelectionKey.OP_ACCEPT：接收</li>
<li>SelectionKey.OP_READ：读</li>
<li>SelectionKey.OP_WRITE：写</li>
</ul>
<p>当你向Selector注册了多个通道以后，准备开始工作了，就可以调用几个重载的 select() 方法来检测有哪些channel准备就绪了（该channel至少有一种操作准备就绪）：</p>
<ul>
<li><code>select()</code>：阻塞到至少有一个通道的一个interest操作准备就绪了。</li>
<li><code>select(long timeout)</code>：同样会阻塞，但超时会返回。</li>
<li><code>selectNow()</code>：不会阻塞</li>
</ul>
<p>上述三个方法均返回的是本次执行select时已经准备就绪的channel数；如果不为 0，就可以调用selector的<code>selectedKeys()</code>方法，得到这些已就绪的channel对应的 SelectionKey 对象的集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(selector.select() != <span class="number">0</span>) &#123;</span><br><span class="line">	Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">	Iterator it = keys.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">		SelectionKey k = (SelectionKey)it.next();</span><br><span class="line">		<span class="keyword">if</span>(k.isAcceptable()) &#123;  </span><br><span class="line">	        <span class="comment">// a connection was accepted by a ServerSocketChannel.  </span></span><br><span class="line">	    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(k.isConnectable()</span>) </span>&#123;  </span><br><span class="line">	        <span class="comment">// a connection was established with a remote server.  </span></span><br><span class="line">	    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(k.isReadable()</span>) </span>&#123;  </span><br><span class="line">	        <span class="comment">// the channel is ready for reading  </span></span><br><span class="line">	    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(k.isWritable()</span>) </span>&#123;  </span><br><span class="line">	        <span class="comment">// the channel is ready for writing  </span></span><br><span class="line">	    &#125;</span><br><span class="line">		it.remove();   <span class="comment">// 手动移除</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码遍历已就绪的SelectionKey集合，并检测选择键所对应的channel的就绪事件。</p>
<p>当得到已就绪的SelectionKey集合后，调用<code>SelectionKey.channel()</code>方法就可以得到每个SelectionKey所对应的channel对象，然后就可以对通道进行处理了。通常，我们使用Selector单线程来监控多个通道，而对于select得到的channel和对应的IO操作，就可以开辟新线程或者使用线程池来处理。这也正是IO复用的意义所在。</p>
<h3 id="&gt;&gt;_字符集和Charset">&gt;&gt; 字符集和Charset</h3><p>对于计算机里二进制与字符之间的转换，涉及到两个概念：<strong>编码（Encode）</strong> 和 <strong>解码（Decode）</strong>。</p>
<p><img src="http://img.blog.csdn.net/20160330173916938" alt=""></p>
<p>Java 1.4提供了<code>Charset</code>来处理二进制和字符之间的转换，该类包含了创建解码器和编码器的方法，还提供了一个<code>availableCharsets()</code>静态方法来获取 Charset 所支持的所有字符集。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SortedMap&lt;String, Charset&gt; map = Charset.availableCharsets();</span><br><span class="line">		map.keySet().forEach((str) -&gt; System.out.println(map.get(str))); <span class="comment">// 输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码使用 lambda 表达式遍历输出系统支持的所有字符集 —— Java默认使用 Unicode 字符集，但有些操作系统并不使用 Unicode 字符集，那么程序读取数据时就可能出现乱码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line">CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line">ByteBuffer byteBuf = encoder.encode(charBuf);</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line">CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">CharBuffer charBuf = decoder.decode(byteBuf);</span><br></pre></td></tr></table></figure></p>
<p>Charset对象的<code>newEncoder()</code>和<code>newDecoder()</code>可以创建编码器和解码器，然后就可以进行二进制和字符的相互转换了。</p>
<h3 id="&gt;&gt;_文件锁">&gt;&gt; 文件锁</h3><p>从Java 1.4开始NIO中引入了<code>FileLock</code>文件锁，使用文件锁可以有效地阻止多个进程并发修改同一个文件，文件锁可以控制文件的全部或部分字节的访问。<code>FileChannel</code>中提供了阻塞/非阻塞的两个方法来获取 FileLock 对象：</p>
<ul>
<li><code>lock()</code>：试图锁定某个文件并返回 FileLock 对象，如果无法得到文件锁，程序将一直阻塞。</li>
<li><code>tryLock()</code>：尝试锁定某个文件，它将直接返回而不是阻塞，如果获得了文件锁，返回该 FileLock 对象，否则返回 null。</li>
</ul>
<p>上述两个方法还有两个重载形式，用于对部分文件内容而非整个文件加锁：</p>
<ul>
<li><code>lock(long position, long size, boolean shared)</code>：对文件从 position 开始，长度为 size 的部分内容加锁。参数 shared 为true时，该锁是一个共享锁；shared 为false时，该锁是一个互斥锁。</li>
<li><code>tryLock(long position, long size, boolean shared)</code>：非阻塞式的加锁方法，参数作用同上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FileChannel channel = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/a.txt"</span>).getChannel();</span><br><span class="line">		FileLock lock = channel.tryLock();  <span class="comment">// 使用非阻塞的方式获取文件锁</span></span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		lock.release();   <span class="comment">// 释放文件锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完文件后通过 FileLock 的 release() 方法释放文件锁。</p>
<hr>
<p><br></p>
<h2 id="9、NIO-2">9、NIO.2</h2><p>在Java 4引入了NIO后，Java 7又对原有的NIO进行了重大改进：</p>
<ul>
<li>提供了全面的文件IO和文件系统访问支持，位于<code>java.nio.file</code>包下；</li>
<li>基于异步Channel的IO。</li>
</ul>
<p>Java 7把这种改进称为<strong>NIO.2</strong></p>
<h3 id="&gt;&gt;Path、Paths和Files"><strong>&gt;&gt;Path、Paths和Files</strong></h3><p>早期的Java只提供了一个 File 类来访问文件系统，但 File 类的功能比较有限，方法性能也不高，而且大多数方法在出错时仅返回失败而不会提供异常信息。为了弥补这种不足，NIO.2 引入了<code>Path</code>接口和<code>Files</code>、<code>Paths</code>两个工具类。</p>
<ul>
<li><code>Path</code>：代表一个平台无关的平台路径；</li>
<li><code>Paths</code>：工具类，包含了两个返回 Path 的静态工厂方法，比如<code>Path path = Paths.get(&quot;.&quot;)</code>；</li>
<li><code>Files</code>：工具类，包含了大量的操作文件的静态方法，例如文件复制、文件读写、列出路径下所有文件目录等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"."</span>);                 <span class="comment">// 。表示当前路径</span></span><br><span class="line">		Files.list(path).forEach(p -&gt; System.out.println(p));</span><br><span class="line">		Files.isHidden(Paths.get(<span class="string">"b.txt"</span>));         <span class="comment">// 判断是否是隐藏文件</span></span><br><span class="line">		Files.size(Paths.get(<span class="string">"out.txt"</span>));           <span class="comment">// 获取文件大小</span></span><br><span class="line">		FileStore C = Files.getFileStore(Paths.get(<span class="string">"C:"</span>));   <span class="comment">// C盘</span></span><br><span class="line">		System.out.println(<span class="string">"C盘全部空间:"</span> + C.getTotalSpace());</span><br><span class="line">		System.out.println(<span class="string">"C盘可用空间:"</span> + C.getUsableSpace());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们应该熟悉 Files 工具类，它可以大大简化文件系统的访问。更多请自行查询API。</p>
<h3 id="&gt;&gt;FileVisitor遍历文件和目录"><strong>&gt;&gt;FileVisitor遍历文件和目录</strong></h3><p>早期Java版本中，如果要遍历指定目录下的所有文件和子目录，只能进行递归遍历，复杂且灵活性低。</p>
<p>NIO引入了 Files 工具类以后，现在可以用更优雅的方式遍历文件和子目录了。首先，我们需要实现一个<code>FileVisitor</code>文件访问器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFileVisitor</span> <span class="keyword">implements</span> <span class="title">FileVisitor</span>&lt;<span class="title">Path</span>&gt; </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir,</span><br><span class="line">			BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问子目录之前触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问子目录之后触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问file文件时触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 访问file文件失败时触发本方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述四个方法都返回一个<code>FileVisitorResult</code>对象，它是一个枚举类，代表了访问之后的后续行为。</p>
<ul>
<li><code>CONTINUE</code>：继续访问；</li>
<li><code>SKIP_SIBLINGS</code>：继续访问，但不访问该文件/目录的兄弟文件/目录；</li>
<li><code>SKIP_SUBTREE</code>：继续访问，但不访问该文件/目录的子目录树；</li>
<li><code>TERMINATE</code>：中止访问。</li>
</ul>
<p>实际使用时没必要实现全部的4个方法，所以Java提供了一个 SimpleFileVisitor 简化版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"."</span>);                 <span class="comment">// 。表示当前路径</span></span><br><span class="line">		Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span><br><span class="line">			            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			        System.out.println(<span class="string">"正在访问 "</span>+ file + <span class="string">" 文件"</span>);</span><br><span class="line">			        <span class="keyword">if</span>(file.endsWith(<span class="string">"MyClass.java"</span>)) &#123;</span><br><span class="line">			        	System.out.println(<span class="string">"---已找到目标文件---"</span>);</span><br><span class="line">			        	<span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">			        &#125;</span><br><span class="line">			        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">			    &#125;</span><br><span class="line">				</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">			    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir,</span><br><span class="line">			            BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			        System.out.println(<span class="string">"正在访问 "</span> + dir + <span class="string">" 目录"</span>);</span><br><span class="line">			        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">			    &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上面代码，Files工具类提供了静态方法<code>Files.walkFileTree(Path, FileVisitor)</code>用于遍历指定目录下的所有文件和目录，当找到以 MyClass.java 结尾的目标文件后，程序停止遍历。—— 本程序可用于对指定目录进行搜索。</p>
<h3 id="&gt;&gt;_WatchService监控文件变化">&gt;&gt; WatchService监控文件变化</h3><p>NIO.2的<code>Path</code>类提供了一个方法，可以优雅地监控指定目录下文件的变化：</p>
<ul>
<li><code>register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events)</code></li>
</ul>
<p>其中 WatchService 代表一个文件系统监听服务，它负责监听path目录下的文件变化；event参数指定要监听哪些类型的事件。</p>
<p>一旦使用register()完成注册之后，就可以调用WatchService的三个方法来获取被监听目录的文件变化事件：</p>
<ul>
<li><code>WatchKey poll()</code>:获取下一个WatchKey，如果没有WatchKey发生就立即返回null；</li>
<li><code>WatcheKey poll(long timeout,TimeUnit unit)</code>:尝试等待timeout时间去获取下一个WatchKey；</li>
<li><code>WatchKey take()</code>:获取下一个WatchKey，如果没有发生就一直等待。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		WatchService watcher = FileSystems.getDefault().newWatchService();</span><br><span class="line">		Path path = Paths.get(<span class="string">"D:/"</span>);</span><br><span class="line">		path.register(watcher,         <span class="comment">// 注册</span></span><br><span class="line">				StandardWatchEventKinds.ENTRY_CREATE,</span><br><span class="line">				StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">				StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			WatchKey key = watcher.take();   <span class="comment">// 获取下一个文件变化事件</span></span><br><span class="line">			<span class="keyword">for</span>(WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">				System.out.println(event.context()+<span class="string">" 文件发生了 "</span>+event.kind()+<span class="string">"事件！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!key.reset()) &#123;  <span class="comment">// 重设WatchKey，重设失败则退出监听</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序监听D:盘下文件的新建、修改和删除事件。如果程序需要一直监控，则应该使用<code>take()</code>阻塞式方法；如果只需要监控指定时间，则可以考虑使用<code>poll()</code>方法。</p>
<h3 id="&gt;&gt;_访问文件属性">&gt;&gt; 访问文件属性</h3><p>本章开头介绍了，传统的<code>File</code>类可以获取一些简单的文件属性，比如最后修改时间、文件长度、是否隐藏文件等。</p>
<p>为了获取或修改更多的文件属性，NIO.2在<code>java.nio.file.attribute</code>包下提供了大量的工具类，运用这些工具类，开发者可以非常简单地读取、修改文件属性。这些工具类主要分为以下两类：</p>
<ul>
<li><code>XxxAttributeView</code>：代表某种文件属性的视图。</li>
<li><code>XxxAttributes</code>：代表某种文件属性的集合，程序一般通过 XxxAttributeView 对象获取 XxxAttributes。</li>
</ul>
<p>这里只介绍两种，很多请自行查询：</p>
<ul>
<li>BasicFileAttributeView：它可以获取或修改文件的基本属性，包括文件的最后修改时间，最后访问时间，创建时间，大小，是否为目录，是否为符号链接等。它的readAttribute()方法返回一个BasicFileAttributes对象，对文件夹基本属性的修改是通过BasicFileAtributes对象完成。</li>
<li>DosFileAttributeView：它主要用于获取或修改文件DOS相关属性，比如文件是否只读，是否隐藏，是否是系统文件，是否是存档文件等。它的readAttributes()方法返回一个DosFileAttributes对象对这些属性的修改其实是由DosfileAttributes对象来完成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path=Paths.get(<span class="string">"D:/a.txt"</span>);  </span><br><span class="line">        BasicFileAttributeView attrView = Files.getFileAttributeView(path, BasicFileAttributeView.class);  </span><br><span class="line">        BasicFileAttributes attrs = attrView.readAttributes();  </span><br><span class="line">        System.out.println(<span class="string">"创建时间"</span> + <span class="keyword">new</span> Date(attrs.creationTime().toMillis()));  </span><br><span class="line">        System.out.println(<span class="string">"文件大小"</span> + attrs.size());  </span><br><span class="line">        DosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class);  </span><br><span class="line">        dosView.setHidden(<span class="keyword">true</span>);  </span><br><span class="line">        dosView.setReadOnly(<span class="keyword">true</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第十一章_I/O与序列化">第十一章 I/O与序列化</h1><h2 id="1、File类">1、File类</h2><p>Java中访问本地系统是通过<code>java.io.File</code>类。 File类可以使用 <strong>绝对路径</strong> 或 <strong>相对路径</strong> 来创建 File 对象，然后调用 File 对象的方法来操作文件和目录。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Lang.-Java" scheme="http://yoursite.com/categories/Lang-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java基础笔记（三） 多线程]]></title>
    <link href="http://yoursite.com/2016/03/19/java-basic-note-3/"/>
    <id>http://yoursite.com/2016/03/19/java-basic-note-3/</id>
    <published>2016-03-19T07:21:39.000Z</published>
    <updated>2016-03-19T07:28:30.760Z</updated>
    <content type="html"><![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第十章_多线程">第十章 多线程</h1><h2 id="1、进程和线程的概念">1、进程和线程的概念</h2><p>当一个程序进入内存运行时，即变成一个进程（Process）。进程是系统进行资源分配和调度的一个独立单位。—— 进程三特征：<br><a id="more"></a></p>
<ul>
<li><strong>独立性</strong>：进程是系统中独立存在的实体，拥有自己独立的资源和地址空间；</li>
<li><strong>动态性</strong>：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中执行的指令集合，进程具有自己的生命周期和状态；</li>
<li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行，互不影响。（与<strong>并行</strong>不是一个概念）</li>
</ul>
<p>线程（Thread）是进程的执行单元，独立、并发的执行流，被称为轻量级进程。</p>
<ul>
<li>线程可以拥有自己的堆栈、自己的程序计数器、自己的局部变量，但不拥有系统资源</li>
<li>一个进程中可以有多个线程，它们共享该进程的全部资源</li>
<li>多个线程并发地执行</li>
</ul>
<p><br></p>
<h2 id="2、线程的创建">2、线程的创建</h2><p><strong>&gt;&gt; 继承Thread类</strong></p>
<p>定义<code>Thread</code>类的子类，并重写该类的<code>run()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>( ;i&lt;<span class="number">100</span>;++i) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> MyThread().start();   <span class="comment">// 注意三个线程并不会共享实例变量i</span></span><br><span class="line">		<span class="keyword">new</span> MyThread().start();</span><br><span class="line">		<span class="keyword">new</span> MyThread().start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>&gt;&gt; 实现Runnable接口</strong></p>
<p>定义一个类实现<code>Runnable</code>接口，并重写该接口的<code>run()</code>方法。（将该类对象作为Thread对象的target）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>( ;i&lt;<span class="number">100</span>;++i) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyTarget target = <span class="keyword">new</span> MyTarget();</span><br><span class="line">		<span class="keyword">new</span> Thread(target, <span class="string">"新线程1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(target, <span class="string">"新线程2"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里创建的多个线程共享同一个target，所以它们也共享target对象中的实例变量<code>i</code>。</p>
<p><strong>&gt;&gt; 使用Callable和Future</strong></p>
<p><code>Callable</code>接口可以看作 Runnable 接口的增强版，它提供了一个<code>call()</code>方法作为线程执行体。该方法相比 run 的强大之处在于：① call() 方法可以有返回值；② call() 方法可以声明抛出异常。</p>
<p>但是存在两个问题：</p>
<ul>
<li>Callable 接口并不是 Runnable 接口的子接口，所以 Callable 对象不能直接作为 Thread 的 target</li>
<li>call()方法作为线程执行体被执行，如何获取call方法的返回值</li>
</ul>
<p>为了解决 返回值的获取问题，Java提供了<code>Future</code>接口，用于将 Callable 对象再进行一层包装。<code>Future</code>接口提供了三种功能：</p>
<ol>
<li>判断任务是否完成；</li>
<li>取消任务；</li>
<li>获取任务执行结果，即call方法的返回值。</li>
</ol>
<p><code>FutureTask</code>类是<code>Future</code>接口的典型实现类，同时它还实现了<code>Runnable</code>接口 —— 这就完美的解决了上面的两个问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTarget</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;  <span class="comment">// 泛型，类型实参Integer表示返回值类型</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="annotation">@Override</span>	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>( ;i&lt;<span class="number">100</span>;++i) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyTarget target = <span class="keyword">new</span> MyTarget();</span><br><span class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(target);  <span class="comment">// 包装</span></span><br><span class="line">		<span class="keyword">new</span> Thread(task, <span class="string">"新线程"</span>).start();   <span class="comment">// 以FutureTask对象为target启动线程</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"新线程中call返回值为"</span>+task.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出几点：</p>
<ul>
<li>Callable接口和FutureTask类都有泛型限制，且类型参数表示<strong>返回值类型</strong>；</li>
<li>重写 call() 方法时，可以带返回值、抛出异常；</li>
<li>一般比较耗时的作业可以交给Future对象在后台完成，当主线程将来需要时，再去获取结果。</li>
</ul>
<p><br></p>
<h2 id="3、线程的生命周期">3、线程的生命周期</h2><p><img src="http://img.blog.csdn.net/20160315232556418" alt=""></p>
<p>如上图所示，线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）。</p>
<ul>
<li>当程序<code>new</code>了一个线程对象后，该线程就处于<strong>新建</strong>状态；</li>
<li>当线程对象调用了<code>start()</code>方法之后，该线程将处于<strong>就绪</strong>状态；</li>
<li>当处于就绪状态的线程获得了CPU，开始执行线程执行体，该线程处于<strong>运行</strong>状态；</li>
<li>当处于运行状态的线程调用了sleep/进行阻塞IO/等待同步锁…等时，该线程进入<strong>阻塞</strong>状态；</li>
<li>当处于阻塞状态的线程sleep结束/IO返回/获得同步锁…等时，该线程将重新进入<strong>就绪</strong>状态；</li>
<li>当处于运行状态的线程 执行完任务/抛出异常/调用了stop方法时，线程结束并处于<strong>死亡</strong>状态。</li>
</ul>
<p>注意：线程只能从阻塞状态进入就绪状态，无法直接进入运行状态。</p>
<p><br></p>
<h2 id="4、线程控制">4、线程控制</h2><p><strong>&gt;&gt; join线程</strong></p>
<p>Thread 提供了一个让一个线程等待另一个线程完成的方法 —— <code>join()</code>方法。当在线程A中调用了线程B的 join() 方法，线程A将被阻塞，直到线程B执行完为止：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ThreadB b;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(ThreadB b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="string">"Thread A"</span>);</span><br><span class="line">		<span class="keyword">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			b.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">": "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="string">"Thread B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;	</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">				System.out.println(getName()+<span class="string">": "</span>+i);</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 每次sleep一秒</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadB b = <span class="keyword">new</span> ThreadB();</span><br><span class="line">		ThreadA a = <span class="keyword">new</span> ThreadA(b);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>&gt;&gt; 后台线程（守护线程）</strong></p>
<p>后台线程（Daemon Thread）：又叫“守护线程”或“精灵线程”，它在后台运行，为其他线程提供服务。比如 JVM 的垃圾回收线程。</p>
<p>后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡（JVM退出）。调用<code>Thread</code>对象的<code>setDaemon(true)</code>方法可以将线程设置成后台线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DaemonThread t = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">		t.setDaemon(<span class="keyword">true</span>);  <span class="comment">// 在启动之前设置为后台线程</span></span><br><span class="line">		t.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">			Thread.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//-----前台线程（main线程）结束，后台线程随之结束，将无法运行到999-----</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>&gt;&gt; 线程休眠：sleep</strong></p>
<p>通过调用<code>Thread.sleep()</code>静态方法，可以让正在运行的线程休眠，进入阻塞状态。</p>
<hr>
<p><strong>&gt;&gt; 线程让步：yield</strong></p>
<p>通过调用<code>Thread.yield()</code>静态方法，可以让正在运行的线程停止，进入就绪状态。</p>
<p>完全有可能的情况是：当某个线程调用<code>yield()</code>方法停止之后，系统的线程调度器又立马将其调度出来重新执行。（这样的话该方法的功能效果就不明显了）</p>
<hr>
<p><strong>&gt;&gt; 改变线程优先级</strong></p>
<p>每个线程执行时都具有一定的优先级，优先级高的会优先被线程调度器调度。一个线程默认的优先级与创建它的父线程相同，在默认情况下，<code>main</code>线程具有普通优先级（5）。</p>
<p>Thread 类提供了<code>setPriority(int priority)</code>与<code>getPriority()</code>方法来设置和返回指定线程的优先级，其中，优先级是一个整数（范围0~10），Thread类还提供了三个静态常量：</p>
<ul>
<li><code>MAX_PRIORITY</code>：其值是10</li>
<li><code>MIN_PRIORITY</code>：其值是1</li>
<li><code>NORM_PRIORITY</code>：其值是5</li>
</ul>
<p><br></p>
<h2 id="5、线程同步">5、线程同步</h2><p><strong>&gt;&gt; 什么是线程安全</strong></p>
<p>个人认为最好的解释： 如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的 。</p>
<p>线程安全也是有几个级别的：</p>
<ul>
<li><p><strong>不可变</strong>：不可变的对象一定是线程安全的，并且永远也不需要额外的同步。比如String、Integer等final类型的类。</p>
</li>
<li><p><strong>绝对线程安全</strong>：不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是绝对线程安全的，不过绝对线程安全的类，Java中也有，比如说CopyOnWriteArrayList、CopyOnWriteArraySet .</p>
</li>
<li><p><strong>相对线程安全</strong>：相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现<code>ConcurrentModificationException</code>，也就是 fail-fast机制 。</p>
</li>
<li><p><strong>线程非安全</strong>：这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p>
</li>
</ul>
<hr>
<p><strong>&gt;&gt; 同步代码块</strong></p>
<p>首先看一段示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATM</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ATM</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(balance &gt;= drawMoney) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"取出钞票： "</span>+drawMoney);</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">				balance -= drawMoney;</span><br><span class="line">				System.out.println(<span class="string">"ATM余额："</span>+balance);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"取钱失败！余额不足！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ATM atm;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> drawMoney;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, ATM atm, <span class="keyword">double</span> drawMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.atm = atm;</span><br><span class="line">		<span class="keyword">this</span>.drawMoney = drawMoney;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		atm.draw(drawMoney);	<span class="comment">// 取钱</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ATM atm = <span class="keyword">new</span> ATM(<span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">new</span> DrawThread(<span class="string">"甲"</span>, atm, <span class="number">800</span>).start();</span><br><span class="line">		<span class="keyword">new</span> DrawThread(<span class="string">"乙"</span>, atm, <span class="number">800</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------运行结果-------</span></span><br><span class="line"><span class="comment">// 甲取出钞票： 800.0</span></span><br><span class="line"><span class="comment">// 乙取出钞票： 800.0</span></span><br><span class="line"><span class="comment">// ATM余额：200.0</span></span><br><span class="line"><span class="comment">// ATM余额：-600.0</span></span><br></pre></td></tr></table></figure></p>
<p>由于两个并发线程同时对一个ATM进行修改，而系统恰好在<code>sleep(1)</code>处进行线程切换，这就导致出现了错误。为了解决这个问题，Java多线程引入了<strong>同步监视器</strong>，使用同步监视器的通用方法就是同步代码块 —— 使用<code>synchronized</code>关键字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 此处的代码就是同步代码块：同一时刻最多只有一个线程执行这段代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 obj 对象就是同步监视器，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定，执行完后再释放对该同步监视器的锁定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(atm) &#123;</span><br><span class="line">		atm.draw(drawMoney);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对 run() 中的代码块进行同步以后，运行结果就正确了<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">甲取出钞票： 800.0</span><br><span class="line">ATM余额：200.0</span><br><span class="line">乙取钱失败！余额不足！</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>&gt;&gt; 同步方法</strong></p>
<p>同步方法就是使用<code>synchronized</code>关键字修饰的方法。对于<code>synchronized</code>修饰的非静态方法，同步监视器是<code>this</code>，也就是调用该方法的对象。</p>
<p>通过使用同步方法，可以非常方便地实现<strong>线程安全的类</strong>，只需要对该可变类中可能修改竞争资源的方法进行同步即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATM</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ATM</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(balance &gt;= drawMoney) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"取出钞票： "</span>+drawMoney);</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">				balance -= drawMoney;</span><br><span class="line">				System.out.println(<span class="string">"ATM余额："</span>+balance);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"取钱失败！余额不足！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>draw()</code>方法被<code>synchronized</code>修饰以后，ATM类就变成我们通常意义上的线程安全类了。</p>
<hr>
<p><strong>&gt;&gt; 同步锁（Lock）</strong></p>
<p>除了<code>synchronized</code>，Java 5开始提供了一种功能更强大的线程同步机制 —— 同步锁<code>Lock</code>。</p>
<p>另外，这里稍微提一下，Java 5提供了两种锁的根接口：</p>
<ul>
<li><p><strong>同步锁</strong><code>Lock</code>：提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁。<code>ReentrantLock</code>是Lock接口的实现类。</p>
</li>
<li><p><strong>读写锁</strong><code>ReadWriteLock</code>：虽然写和写、读和写是互斥的，但读和读不是互斥的。如果多个线程同时读数据 却加了同步锁，就降低了程序的性能。<code>ReentrantReadWriteLock</code>是 ReadWriteLock 接口的实现类，它实现了读写的分离， 读锁是共享的，写锁是独占的。</p>
</li>
</ul>
<p>当然，这里只讨论同步锁，下面是一个使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATM</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 同步锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ATM</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawMoney)</span> </span>&#123;</span><br><span class="line">		lock.lock();	<span class="comment">// 加锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(balance &gt;= drawMoney) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"取出钞票： "</span>+drawMoney);</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">				balance -= drawMoney;</span><br><span class="line">				System.out.println(<span class="string">"ATM余额："</span>+balance);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"取钱失败！余额不足！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>&gt;&gt; 死锁</strong></p>
<p>当两个线程相互等待对方释放持有的锁时，就会发生<strong>死锁</strong>。</p>
<p>那么如何编写一个死锁的Java程序呢？</p>
<ol>
<li>两个线程里面分别持有两个Object对象：lock1和lock2；</li>
<li>线程A在 run() 方法中先获取lock1的对象锁，Thread.sleep(50)，然后接着获取lock2的对象锁。</li>
<li>线程B在 run() 方法中先获取lock2的对象锁，接着获取lock1的对象锁。</li>
</ol>
<p>线程A一旦sleep结束，线程B已经获取了lock2的对象锁。线程A尝试获取lock2的对象锁，便被阻塞；线程B尝试获取lock1的对象锁，也被阻塞，这样就形成了死锁。</p>
<p><br></p>
<h2 id="6、线程通信">6、线程通信</h2><p><strong>&gt;&gt; wait()、notify()与notifyAll()</strong></p>
<p><code>Object</code>类提供了以下三个方法，但这三个方法必须由<strong>同步监视器</strong>对象来调用：</p>
<ul>
<li><code>wait()</code>：导致当前线程等待，直到其他线程调用该同步监视器对象的 notify() 或 notifyAll() 方法来唤醒该线程。</li>
<li><code>notify()</code>：唤醒在此（同步监视器）对象上等待的单个线程。如果有多个线程在等待这个对象锁，则任意选择唤醒其中一个线程。当前线程会等待剩余代码执行完毕才释放同步监视器的锁定。</li>
<li><code>notifyAll()</code>：唤醒在此（同步监视器）对象上等待的所有线程。当前线程会等待剩余代码执行完毕才释放同步监视器的锁定。被唤醒的那些线程会争夺对象锁，重新获得对象锁的线程才能从wait方法中返回，继续执行代码。</li>
</ul>
<p>由于这三个方法必须由<strong>同步监视器</strong>对象来调用，所以适用于<code>synchronized</code>修饰的<strong>同步代码块</strong> 或 <strong>同步方法</strong>。所以，我们才可以结合<code>synchronized</code>和这三个方法来实现线程之间的数据传递。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String monitor = <span class="string">"This is a monitor object"</span>;  <span class="comment">// 同步监控器对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> a, b;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">NotifyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">100</span>);     <span class="comment">// 休眠100毫秒</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span>(monitor) &#123;   <span class="comment">// 获取monitor对象锁</span></span><br><span class="line">				System.out.println(getName()+<span class="string">": "</span>+a+<span class="string">" + "</span>+b+<span class="string">" = "</span>+(a+b));</span><br><span class="line">				monitor.notify();     <span class="comment">// 唤醒在monitor对象上wait的线程</span></span><br><span class="line">			&#125;                         <span class="comment">// 同步代码块执行完毕，才释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">WaitThread</span><span class="params">(String name, <span class="keyword">double</span> ax, <span class="keyword">double</span> bx)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">			a = ax;</span><br><span class="line">			b = bx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(monitor) &#123;    <span class="comment">// 获取monitor对象锁</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(getName()+<span class="string">": What's the result of "</span>+a+<span class="string">" + "</span>+b+<span class="string">"?"</span>);	</span><br><span class="line">					monitor.wait();    <span class="comment">// 释放monitor对象锁，并阻塞线程</span></span><br><span class="line">					System.out.println(getName()+<span class="string">": You're right."</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		NotifyTest test = <span class="keyword">new</span> NotifyTest();</span><br><span class="line">		NotifyThread notify = test.new NotifyThread(<span class="string">"notify"</span>);</span><br><span class="line">		WaitThread wait = test.new WaitThread(<span class="string">"waiter"</span>, <span class="number">15</span>, <span class="number">23</span>);</span><br><span class="line">		notify.start();</span><br><span class="line">		wait.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码，当Notify线程sleep的时候，Wait线程获取到了monitor对象的控制权（锁），当调用<code>monitor.wait()</code>时，线程会释放monitor对象的锁并进入阻塞状态。接着Notify线程获取到了对象锁，当调用<code>monitor.notify()</code>时，唤醒一个在monitor对象上等待的线程，并在执行完剩余的同步代码块后，释放对象锁。被唤醒的Wait线程尝试重新获取对象锁，获取到以后线程将继续执行。</p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waiter: <span class="type">What</span>'s the <span class="literal">result</span> <span class="keyword">of</span> <span class="number">15</span>.<span class="number">0</span> + <span class="number">23</span>.<span class="number">0</span>?</span><br><span class="line">notify: <span class="number">15</span>.<span class="number">0</span> + <span class="number">23</span>.<span class="number">0</span> = <span class="number">38</span>.<span class="number">0</span></span><br><span class="line">waiter: <span class="type">You</span>'re right.</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>&gt;&gt; Condition类</strong></p>
<p>当程序不使用 synchronized 而使用<code>Lock</code>对象来线程同步时，就不能使用 wait()、notify()、notifyAll()方法通信了。Java提供了一个<code>Condition</code>类来保持协调，通过 Lock 对象的<code>newCondition()</code>方法可以获取与该 Lock 对象相关联的 Condition 对象。</p>
<p>同样的，<code>Condition</code>类提供了三个方法：</p>
<ul>
<li><code>await()</code>：类似于同步监视器的<code>wait()</code>方法。导致当前线程等待，直到其他现场调用该Condition对象的<code>signal()</code>或<code>signalAll()</code>方法。</li>
<li><code>signal()</code>：类似于同步监控器的<code>notify</code>方法。唤醒在此 Lock 对象上等待的单个线程。</li>
<li><code>signalAll()</code>：类似于同步监视器的<code>notifyAll()</code>方法，唤醒在此 Lock 对象上等待的所有线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition cond = lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> a, b;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">NotifyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			lock.lock();  <span class="comment">// 获得锁</span></span><br><span class="line">			System.out.println(getName()+<span class="string">": "</span>+a+<span class="string">" + "</span>+b+<span class="string">" = "</span>+(a+b));</span><br><span class="line">			cond.signal(); <span class="comment">// 唤醒在lock对象上等待的线程</span></span><br><span class="line">			lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">WaitThread</span><span class="params">(String name, <span class="keyword">double</span> ax, <span class="keyword">double</span> bx)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">			a = ax;</span><br><span class="line">			b = bx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			lock.lock();  <span class="comment">// 获得锁</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(getName()+<span class="string">": What's the result of "</span>+a+<span class="string">" + "</span>+b+<span class="string">"?"</span>);	</span><br><span class="line">				cond.await(); <span class="comment">// 释放锁，并阻塞线程</span></span><br><span class="line">				System.out.println(getName()+<span class="string">": You're right."</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		NotifyTest test = <span class="keyword">new</span> NotifyTest();</span><br><span class="line">		NotifyThread notify = test.new NotifyThread(<span class="string">"notify"</span>);</span><br><span class="line">		WaitThread wait = test.new WaitThread(<span class="string">"waiter"</span>, <span class="number">15</span>, <span class="number">23</span>);</span><br><span class="line">		notify.start();</span><br><span class="line">		wait.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果与前面一样。只是这里显式地使用 Lock 对象来同步，则需要使用 Condition 对象来暂停、唤醒指定线程。</p>
<hr>
<p><strong>&gt;&gt; BlockingQueue（阻塞队列）</strong></p>
<p>阻塞队列<code>BlockingQueue</code>是<code>Queue</code>的子接口，但它的主要用途并不是作为容器，而是作为<strong>线程通信</strong>的工具。 <strong><code>BlockingQueue</code>具有一个特征</strong>：当生产者线程试图向 BlockingQueue 中放入元素（put方法）时，如果该队列已满，则该线程被阻塞；当消费者线程试图从 BlockingQueue 中取出元素（take方法）时，如果该队列已空，则该线程被阻塞。</p>
<p><code>BlockingQueue</code>包含如下5个实现类：</p>
<ul>
<li><code>ArrayBlockingQueue</code>：基于数组实现的 BlockingQueue 队列。</li>
<li><code>LinkedBlockingQueue</code>：基于链表实现的 BlockingQueue 队列。</li>
<li><code>PriorityBlockingQueue</code>：按优先权有序的 BlockingQueue 队列，默认按元素（实现Comparable接口）本身的大小自然排序。</li>
<li><code>SynchronousQueue</code>：同步队列，对该队列的存、取操作必须交替进行。</li>
<li><code>DelayQueue</code>：要求队列元素都实现 Delay 接口，底层基于 PriorityBlockingQueue 实现，不过是根据元素的 getDelay() 方法的返回值进行排序。</li>
</ul>
<p>以 ArrayBlockingQueue 为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;String&gt; bq;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BlockingQueueTest</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">		bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(capacity);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">"Java"</span>,<span class="string">"Python"</span>,<span class="string">"Shell"</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					sleep(<span class="number">200</span>);</span><br><span class="line">					bq.put(strs[i%<span class="number">3</span>]+getName());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(getName()+<span class="string">"生产完成："</span>+bq);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					sleep(<span class="number">400</span>);</span><br><span class="line">					<span class="comment">//bq.take();</span></span><br><span class="line">					System.out.println(getName()+<span class="string">"消费完成："</span>+bq.take());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BlockingQueueTest test = <span class="keyword">new</span> BlockingQueueTest(<span class="number">1</span>);</span><br><span class="line">		test.new Consumer(<span class="string">"Consumer"</span>).start();</span><br><span class="line">		test.new Producer(<span class="string">"Producer-1"</span>).start();</span><br><span class="line">		test.new Producer(<span class="string">"Producer-2"</span>).start();</span><br><span class="line">		test.new Producer(<span class="string">"Producer-3"</span>).start();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里创建了一个容量为1的 ArrayBlockingQueue，三个生产者线程，一个消费者线程。只要其中一个生产者线程向队列中放入元素，其他生产者线程就必须等待，等待消费者线程取出元素。输出结果如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Producer-1</span>生产完成：<span class="attr_selector">[JavaProducer-1]</span></span><br><span class="line"><span class="tag">Consumer</span>消费完成：<span class="tag">JavaProducer-1</span></span><br><span class="line"><span class="tag">Producer-2</span>生产完成：<span class="attr_selector">[JavaProducer-2]</span></span><br><span class="line"><span class="tag">Consumer</span>消费完成：<span class="tag">JavaProducer-2</span></span><br><span class="line"><span class="tag">Producer-3</span>生产完成：<span class="attr_selector">[JavaProducer-3]</span></span><br><span class="line"><span class="tag">Consumer</span>消费完成：<span class="tag">JavaProducer-3</span></span><br><span class="line"><span class="tag">Producer-1</span>生产完成：<span class="attr_selector">[PythonProducer-1]</span></span><br><span class="line"><span class="tag">Consumer</span>消费完成：<span class="tag">PythonProducer-1</span></span><br><span class="line"><span class="tag">Producer-2</span>生产完成：<span class="attr_selector">[PythonProducer-2]</span></span><br><span class="line"><span class="tag">Consumer</span>消费完成：<span class="tag">PythonProducer-2</span></span><br><span class="line"><span class="tag">Producer-3</span>生产完成：<span class="attr_selector">[PythonProducer-3]</span></span><br><span class="line"><span class="tag">Consumer</span>消费完成：<span class="tag">PythonProducer-3</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="7、线程中抛出异常">7、线程中抛出异常</h2><p>在Java多线程程序中，除了通过<code>Callable</code>方式创建线程时可以 throws Exception 之外，通过继承<code>Thread</code>类或实现<code>Runnable</code>接口的方式创建线程都是不能 throws Exception 的。<strong>“线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部。”</strong>基于这样的设计理念，在Java线程中的异常（无论是Checked异常还是Runtime异常），都应该在线程代码边界之内（run方法内）进行 try-catch 并处理掉。</p>
<p>Checked异常我们是都可以进行捕获的，但线程依然有可能抛出 Runtime 异常。当此类异常抛出时，如果我们想在线程代码边界之外（run方法之外）来捕获和处理这个异常的话，java为我们提供了一种线程内发生异常时能够在线程代码边界之外处理异常的回调机制，即Thread对象提供的两个方法来设置异常处理器：</p>
<ul>
<li><code>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code>：为该线程类的所有线程实例设置默认的异常处理器。</li>
<li><code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code>：为指定的线程实例设置异常处理器。</li>
</ul>
<p>当一个线程抛出未处理异常时，JVM在结束该线程之前会自动查找是否有对应的<code>Thread.UncaughtExceptionHandler</code>对象，如果有，则会调用该对象的<code>uncaughtException(Thread t, Throwable e)</code>方法来处理该异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">		System.out.println(t.getName() + <span class="string">"线程出现了异常："</span>+e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExHandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setUncaughtExceptionHandler(<span class="keyword">new</span> MyExHandler());</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span> / <span class="number">0</span>;  <span class="comment">// 这里将抛出未处理异常</span></span><br><span class="line">		System.out.println(<span class="string">"程序正常结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ExHandlerThread().start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>线程出现了异常：java<span class="class">.lang</span><span class="class">.ArithmeticException</span>: / by zero</span><br></pre></td></tr></table></figure></p>
<p>可以看出，虽然异常处理器（MyExHandler对象）对线程抛出的 RuntimeException 进行来了处理，但该线程依然没有正常结束。这说明异常处理器机制与 try-catch 机制是不同的 —— 当catch捕获异常时，异常不会向上传播给上一级调用者；但使用异常处理器对异常进行处理之后，异常依然会传播给上一级调用者。</p>
<p><br></p>
<h2 id="8、线程池">8、线程池</h2><p>系统创建一个新线程是需要成本的，它涉及与操作系统交互。<strong>线程池（Thread Pool）</strong>就是为了降低这种成本，提高性能。—— 线程池在系统启动时即创建大量空闲的线程，当程序将一个 Runnable 对象或 Callable 对象传给线程池，线程池就会启动一个线程来执行它，当执行结束后该线程并不会死亡，而是再次返回线程池变成空闲状态。</p>
<p>Java 提供了一个<code>Executors</code>工厂类来产生线程池，该工厂类包含几个静态工厂方法：</p>
<ol>
<li><p><code>newCachedThreadPool()</code>：创建一个具有缓存功能的线程池，如果线程池大小超过了处理需要，就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又会自动添加新线程来处理任务。</p>
</li>
<li><p><code>newFixedThreadPool(int nThreads)</code>：创建一个可重用的、具有固定线程数的线程池。</p>
</li>
<li><p><code>newSingleThreadExecutor()</code>：创建一个只有单线程的线程池，相当于调用newFixedThreadPool(1)。</p>
</li>
<li><p><code>newScheduledThreadPool(int corePoolSize)</code>：创建具有指定线程数的线程池，它可以在指定延迟后或周期性地执行任务。</p>
</li>
<li><p><code>newSingleThreadScheduledExecutor()</code>：创建只有一个线程的线程池，它可以在指定延迟后或周期性地执行任务。</p>
</li>
<li><p><code>newWorkStealingPool(int parallelism)</code>：创建持有足够线程的线程池来支持给定的并行级别，该线程池拥有多个任务队列。如果不给定参数，则默认的并行级别为CPU的个数。</p>
</li>
</ol>
<p>前三个工厂方法返回一个<code>ExecutorService</code>对象，该对象代表一个线程池。第四第五个方法返回<code>ScheduledExecutorService</code>对象，它是 ExecutorService 的子接口，可以在指定延迟后或周期性地执行任务。最后一个方法是 Java 8新增的，它可以充分利用多CPU并行的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);  <span class="comment">// 线程池</span></span><br><span class="line">		</span><br><span class="line">		Runnable task = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"的i值为："</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		pool.submit(task);  <span class="comment">// 向线程池提交两个任务</span></span><br><span class="line">		pool.submit(task);</span><br><span class="line">		pool.shutdown();    <span class="comment">// 关闭线程池</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService 和 ScheduledExecutorService 提供了以下几个重要的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute()   <span class="comment">// 执行一个任务，返回值为void</span></span><br><span class="line">submit()    <span class="comment">// 提交一个任务，返回值为Future对象</span></span><br><span class="line">schedule()  <span class="comment">// 指定一个任务延迟多久后执行，这是ScheduledExecutorService才有的方法</span></span><br><span class="line">shutdown()  <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>ForkJoinPool</strong></p>
<p><code>ForkJoinPool</code>是一种特殊的线程池，是为了更好地支持在多核CPU上的并行。它可以将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。<code>ForkJoinPool</code>的构造器如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool(<span class="keyword">int</span> parallel)  <span class="comment">//创建一个包含 parallel 个并行线程的线程池，默认为CPU的个数</span></span><br></pre></td></tr></table></figure></p>
<p>创建了实例以后，就可以调用 ForkJoinPool 对象的<code>submit(ForkJoinTask task)</code>来执行指定任务。其中，<code>ForkJoinTask</code>是一个抽象类，代表一个可并行、合并的任务，<code>ForkJoinTask</code>还有两个抽象子类：</p>
<ul>
<li><code>RecursiveAction</code>：代表没有返回值的任务；</li>
<li><code>RecursiveTask</code>：代表有返回值的任务。</li>
</ul>
<p>下面给一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParallelTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> start,end;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParallelTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(end-start &lt; THRESHOLD) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;++i) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"的i值："</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 将大任务分解成小任务</span></span><br><span class="line">			<span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">			ParallelTask left = <span class="keyword">new</span> ParallelTask(start, middle);</span><br><span class="line">			ParallelTask right = <span class="keyword">new</span> ParallelTask(middle, end);</span><br><span class="line">			left.fork();  <span class="comment">// 并行执行两个小任务</span></span><br><span class="line">			right.fork();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		pool.submit(<span class="keyword">new</span> ParallelTask(<span class="number">0</span>, <span class="number">300</span>));  <span class="comment">// 提交可分解的 ParallelTask 任务</span></span><br><span class="line">		pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，打印0~300数字这个“大任务”被拆分成了多个“小任务”并行地执行。每个“小任务”不能打印超过50个数字。</p>
<p><br></p>
<h2 id="9、线程相关类">9、线程相关类</h2><p><strong>&gt;&gt; ThreadLocal类</strong></p>
<p><code>ThreadLocal</code>类是为了解决在多线程中对同一变量的访问冲突。<code>ThreadLocal</code>通过给每一个使用它的线程提供一个变量的副本，这样每个线程都可以独立地改变自己的副本，不会与其他线程冲突。</p>
<p><code>ThreadLocal</code>并不能替代同步机制，它们的功能不同：同步机制是为了同步多个线程对共享资源的并发访问，是线程之间通信的有效方式；而 ThreadLocal 是为了隔离多个线程的数据，从根本上避免多个线程对资源的竞争。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;HashSet&lt;String&gt;&gt; name = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			HashSet&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i) &#123;</span><br><span class="line">				s.add(getName()+<span class="string">"-"</span>+getName().hashCode()+i);</span><br><span class="line">			&#125;</span><br><span class="line">			name.set(s);</span><br><span class="line">			System.out.println(getName()+<span class="string">":\n"</span>+name.get());			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadLocalTest test = <span class="keyword">new</span> ThreadLocalTest();</span><br><span class="line">		test.new MyThread().start();</span><br><span class="line">		test.new MyThread().start();</span><br><span class="line">		test.new MyThread().start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，ThreadLocal使得各线程能够保持各自独立的一个对象，是通过每个线程中的 new 对象 的操作来创建的对象，每个线程创建一个并<code>ThreadLocal.set()</code>添加，不是什么对象的拷贝。<strong>实现的思路</strong>是：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的 key 为线程对象，而 value 对应线程的变量副本。</p>
<hr>
<p><strong>&gt;&gt; 包装非线程安全的集合</strong></p>
<p>在《<a href="http://songlee24.github.io/2016/03/16/java-basic-note-2/" target="_blank" rel="external">Java基础笔记（二）</a>》中介绍的<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>HashMap</code>、<code>TreeMap</code>等等集合都是线程不安全的。当在多线程环境中访问这些集合时，可以使用<code>Collections</code>提供的静态方法将这些集合包装成线程安全的集合：</p>
<ul>
<li><code>synchronizedCollection()</code></li>
<li><code>synchronizedList()</code></li>
<li><code>synchronizedMap()</code></li>
<li><code>synchronizedSet()</code></li>
<li><code>synchronizedSortedMap()</code></li>
<li><code>synchronizedSortedSet()</code></li>
</ul>
<hr>
<p><strong>&gt;&gt; 线程安全的集合类</strong></p>
<p>在<code>java.util.concurrent</code>包下提供了很多支持高效并发访问的集合接口和实现类，这些线程安全的集合类大致可以分为两类：</p>
<ol>
<li><p>以<code>Concurrent</code>开头的集合类，比如<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、<code>ConcurrentLinkedQueue</code>、<code>ConcurrentLinkedDeque</code>。</p>
</li>
<li><p>以<code>CopyOnWrite</code>开头的集合类，比如<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>。</p>
</li>
</ol>
<p>其中以<code>Concurrent</code>开头的集合类支持高效并发访问，它们都是线程安全的，且保证永远不会锁住整个集合。例如<code>ConcurrentHashMap</code>默认支持16个线程并发写入，无须等待。</p>
<p>而以<code>CopyOnWrite</code>开头的集合类，正如名字所暗示的，它们采用复制底层数组的方式实现写操作 —— 例如<code>CopyOnWriteArrayList</code>当执行读操作时，直接读取集合本身，无须加锁与阻塞；当执行写操作时，在底层复制一份新的数组，对新的数组执行写操作，修改完成以后将新数组的引用赋回去。（适用于读操作远远多于写操作的场景）</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第十章_多线程">第十章 多线程</h1><h2 id="1、进程和线程的概念">1、进程和线程的概念</h2><p>当一个程序进入内存运行时，即变成一个进程（Process）。进程是系统进行资源分配和调度的一个独立单位。—— 进程三特征：<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Lang.-Java" scheme="http://yoursite.com/categories/Lang-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java基础笔记（二） 集合、泛型、异常处理]]></title>
    <link href="http://yoursite.com/2016/03/16/java-basic-note-2/"/>
    <id>http://yoursite.com/2016/03/16/java-basic-note-2/</id>
    <published>2016-03-16T08:36:49.000Z</published>
    <updated>2016-03-16T08:39:11.321Z</updated>
    <content type="html"><![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第七章_Java集合（重点）">第七章 Java集合（重点）</h1><p><strong>1、 Java集合概述</strong></p>
<p>Java集合类是一种工具类，主要用来存储数量不定的对象，类似于<strong>容器</strong>。Java主要有四大集合体系：<code>Set</code>、 <code>List</code>、<code>Queue</code>、<code>Map</code>。<br><a id="more"></a><br>所有的集合类都位于<code>java.util</code>包下，后来为了支持多线程又在<code>java.util.concurrent</code>包下提供了一些线程安全的集合类（本章不讨论）。</p>
<p>Java集合类主要派生自两个接口类：<strong>Collection</strong> 和 <strong>Map</strong>，继承树如下图：</p>
<p><img src="http://img.blog.csdn.net/20160311102217317" alt=""></p>
<hr>
<p><img src="http://img.blog.csdn.net/20160311102607475" alt=""></p>
<hr>
<p>图中粗边框的Set、List、Queue、Map仍然是接口，而以灰色覆盖的是常用的实现类，比如<code>HashSet</code>、<code>TreeSet</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>ArrayDeque</code>、<code>HashMap</code>、<code>TreeMap</code>等。</p>
<p><strong>2、如何遍历集合</strong></p>
<p><strong>Iterator接口遍历集合</strong></p>
<p><code>Iterator</code>迭代器提供了遍历Collection集合元素的统一编程接口，它定义了几个方法：</p>
<ul>
<li><code>boolean hasNext()</code>：集合元素是否被遍历完</li>
<li><code>Object next()</code>：返回集合里的下一个元素</li>
<li><code>void remove()</code>：删除集合里上一次next方法返回的元素</li>
<li><code>void forEachRemaining(Consumer action)</code>：Java 8新增方法，用于Lambda表达式遍历集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">"Firstly"</span>);</span><br><span class="line">		set.add(<span class="string">"Secondly"</span>);</span><br><span class="line">		set.add(<span class="string">"Thirdly"</span>);</span><br><span class="line"> </span><br><span class="line">		Iterator it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;	</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Lambda表达式遍历集合</strong></p>
<p>Java 8支持lambda表达式，并且为每个可迭代的集合类新增了一个<code>forEach(Consumer action)</code>方法，参数类型是一个函数式接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">"Firstly"</span>);</span><br><span class="line">		set.add(<span class="string">"Secondly"</span>);</span><br><span class="line">		set.add(<span class="string">"Thirdly"</span>);</span><br><span class="line">		set.forEach(obj -&gt; System.out.println(obj));  <span class="comment">// Lambda表达式</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>foreach循环遍历集合</strong></p>
<p>类似于C++11中的范围循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">"Firstly"</span>);</span><br><span class="line">		set.add(<span class="string">"Secondly"</span>);</span><br><span class="line">		set.add(<span class="string">"Thirdly"</span>);</span><br><span class="line">		<span class="keyword">for</span>(Object obj : set) &#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>3、Set集合</strong></p>
<p><strong>HashSet类</strong></p>
<ul>
<li>采用Hash算法来存储集合中的元素（由hashCode值决定存储位置），故拥有很好的存取和查找性能。</li>
<li>不允许包含相同的元素，相同的标准是<strong>“通过<code>equals()</code>比较相等且<code>hashCode()</code>返回值也相等”</strong></li>
<li>不能保证元素的排列顺序，顺序可能与添加顺序不同。</li>
<li>集合元素值可以是<code>null</code>。</li>
</ul>
<p><strong>TreeSet类</strong></p>
<ul>
<li>采用红黑树来存储集合中的元素。</li>
<li>不允许包含相同的元素，相同的标准是<strong>“通过<code>compareTo(Object obj)</code>比较返回0”</strong></li>
<li>集合中的元素是有序的，默认使用<code>compareTo</code>升序排列，当然你也可以通过<code>Comparator</code>对象自定义排序规则。</li>
<li>集合元素不可以是<code>null</code>。</li>
</ul>
<p><strong>EnumSet类</strong></p>
<ul>
<li>采用位向量的形式存储元素，紧凑高校，运行效率高。</li>
<li>集合中的多个枚举值必须属于同一个枚举类</li>
<li>各元素按Enum类内的定义顺序有序</li>
<li>集合元素不可以是<code>null</code>。</li>
</ul>
<p>结论：上述Set的三个实现类都不是线性安全的。<code>HashSet</code>和<code>TreeSet</code>作为Set类的两个典型实现，前者的性能总是比后者好，因为后者需要额外维护一棵红黑树，但后者是有序的，所以需要根据具体需求来选择。</p>
<hr>
<p><strong>4、Queue集合</strong></p>
<p>Queue用于模拟“先进先出”队列，不允许随机访问。</p>
<p><strong>PriorityQueue类</strong></p>
<ul>
<li>不同于FIFO队列，PriorityQueue是按优先权排列，默认就是按元素大小进行排列。</li>
<li>本质上是一个<strong>最小堆</strong>。</li>
<li>不允许插入null元素</li>
</ul>
<p><strong>Deque接口与ArrayDeque类</strong></p>
<ul>
<li>Deque是Queue的子接口，它代表一个<strong>双端队列</strong>。而<code>ArrayDeque</code>类是Deque的一个典型实现。</li>
<li>ArrayDeque类是基于数组实现的。</li>
<li>ArrayDeque类是一个双端队列，所以即可以作为队列使用，也可以作为栈使用。</li>
</ul>
<hr>
<p><strong>5、List集合</strong></p>
<p><strong>ArrayList类与Vector类</strong></p>
<ul>
<li>ArrayList类和Vector类都是基于数组实现的（<code>Object[]</code>）;</li>
<li>ArrayList类和Vector类在用法上完全相同，但Vector是一个古老的类，有很多缺点，尽量少用；</li>
<li>ArrayList类和Vector类的显著区别：<code>ArrayList</code>是线程不安全的，<code>Vector</code>是线程安全的。</li>
</ul>
<p><strong>LinkedList类</strong></p>
<ul>
<li>同时实现了List接口与Deque接口，所以可以作为List集合、双端队列、栈使用。</li>
<li>LinkedList类是基于<strong>链表</strong>实现的，插入/删除性能好。</li>
</ul>
<hr>
<p><strong>6、Map集合</strong></p>
<p><strong>HashMap类与Hashtable类</strong></p>
<ul>
<li>HashMap与Hashtable的关系完全类似于ArrayList和Vector，<code>Hashtable</code>太古老，尽量少用；<ul>
<li>HashMap线程不安全，Hashtable线程安全</li>
<li>HashMap可以插入null作为key/value，但Hashtable不可以</li>
</ul>
</li>
<li>HashMap/Hashtable不能保证元素的顺序，因为它们的key保存方式与HashSet完全相同。</li>
<li>HashMap/Hashtable判断两个key相等的标准：两个key通过<code>equals()</code>比较返回true时，它们的<code>hashCode()</code>也相等。</li>
</ul>
<p><strong>TreeMap类</strong></p>
<ul>
<li>基于红黑树实现，每个kv对就是红黑树的一个节点。</li>
<li>类似于<code>TreeSet</code>类，<code>TreeMap</code>类根据key保持有序。默认使用 compareTo() 升序排列，当然你也可以通过 Comparator 对象自定义排序规则。</li>
<li>不允许包含相同的元素，相同的标准是<strong>“通过<code>compareTo(Object obj)</code>比较返回0”</strong></li>
</ul>
<p><strong>EnumMap类</strong></p>
<ul>
<li>类似于<code>EnumSet</code>类，<code>EnumMap</code>类的key必须是同一个枚举类的枚举值</li>
<li>根据 key 有序（枚举类中定义的顺序）</li>
<li>不允许null作为key，但允许null作为value。</li>
</ul>
<hr>
<p><strong>7、什么是rehash？</strong></p>
<p>所谓的<code>rehash</code>，是指当hash表中的槽位被填满到一定程度（最大负载因子）时，hash表会自动成倍地增加容量，并将原来的对象重新分配，hash到新的表中。</p>
<p>最大负载因子，即<strong>负载极限</strong>。HashSet、HashMap、Hashtable的默认负载极限是<code>0.75</code>，这是时间和空间上的一种折中，在保证查询性能的同时，尽量减少哈希表的内存开销。</p>
<hr>
<p><strong>8、操作集合的工具类Collections</strong></p>
<p>Java提供了一个操作Set、List和Map等集合的工具类<code>Collections</code>，该工具类里提供了大量方法对集合元素进行排序、查找和修改……另外，还可以对集合对象实现同步控制以及将集合对象设置为不可变。</p>
<p><strong>线程同步控制</strong></p>
<p>上面介绍的集合类中，除了古老的Vector和Hashtable之外，都是线程不安全的。Collections工具类提供了多个<code>synchronizedXxx()</code>方法，用于将指定集合包装成线程安全的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List l = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">		Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line">		Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>设置不可变集合</strong></p>
<p>Collections提供了三个方法来返回一个不可变的集合：</p>
<ul>
<li><code>emptyXxx()</code>：返回一个空的、不可变的集合对象。</li>
<li><code>singletonXxx()</code>：返回一个只有一个元素、且不可改变的集合对象。</li>
<li><code>unmodifiableXxx()</code>：返回指定集合对象的不可变版本（只读）。</li>
</ul>
<h1 id="第八章_泛型">第八章 泛型</h1><p><strong>1、泛型的概念</strong></p>
<p>在Java没有泛型之前，一旦把一个对象“丢进”Java集合中，集合就会忘记对象的类型，把所有对象当成 Object 类型处理。当从集合中取出对象后，就需要进行强制类型转换。这种强制类型转换不仅使代码臃肿，而且容易引起<code>ClassCastException</code>异常。下面就是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList strs = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		strs.add(<span class="string">"one"</span>);</span><br><span class="line">		strs.add(<span class="string">"two"</span>);</span><br><span class="line">		strs.add(<span class="number">3</span>);    <span class="comment">// 把一个Integer对象丢进了集合</span></span><br><span class="line">        <span class="comment">// 遍历输出时报ClassCastException异常</span></span><br><span class="line">		strs.forEach(str -&gt; System.out.println(((String)str).length()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从Java 5以后，Java引入了<strong>“参数化类型”</strong>的概念，允许程序在创建集合时指定集合元素的类型。注意，如果没有传入类型实参，那么类型参数 T 将会当成<code>Object</code>类型处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">// 后面可以只带尖括号</span></span><br></pre></td></tr></table></figure></p>
<p>这种参数化类型就称为<strong>泛型（Generic）</strong></p>
<hr>
<p><strong>2、泛型的好处</strong></p>
<ul>
<li>增加泛型支持之后，集合完全可以记住元素的类型，并可以在<strong>编译时</strong>检查添加元素是否满足类型要求，不满足的话，编译器会提示错误；</li>
<li>泛型可以减少强制类型转换，使代码更加简洁；</li>
<li>泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生<code>ClassCastException</code>异常，使程序更加健壮。</li>
</ul>
<hr>
<p><strong>3、自定义泛型类</strong></p>
<p>相信学过《<a href="http://songlee24.github.io/2014/07/18/cpp-template/" target="_blank" rel="external">C++函数模板与类模板</a>》的，对Java的泛型编程并不难理解，这里就不赘述了。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T info;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		People&lt;String&gt; he = <span class="keyword">new</span> People&lt;&gt;(<span class="string">"James Bond"</span>);</span><br><span class="line">		People&lt;Integer&gt; she = <span class="keyword">new</span> People&lt;&gt;(<span class="number">25</span>);</span><br><span class="line">		System.out.println(<span class="string">"his name is "</span>+he.getInfo()+<span class="string">", her age is "</span>+she.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，Java中还可以对类型参数 T 进行限制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时传入的类型实参 必须是Number类或它的子类。</p>
<hr>
<p><strong>4、类型通配符</strong></p>
<p>将一个问号作为 类型实参 传给支持泛型的集合，比如<code>List&lt;?&gt;</code>，它的元素类型可以匹配任何类型，这个问号<code>？</code>被称为<strong>通配符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">	<span class="comment">// 遍历元素类型未知的List集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">		list.forEach(e -&gt; System.out.println(e));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		myList.add(<span class="string">"Kobe"</span>);</span><br><span class="line">		myList.add(<span class="string">"LeBron"</span>);		</span><br><span class="line">		MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">		myClass.traverse(myList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设定通配符的上限</strong>：</p>
<p><code>List&lt;?&gt;</code>表示匹配所有的类型。<strong>但是</strong>有时候我们希望只匹配一部分，比如只匹配某个类以及它的子类，就可以这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends People&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里的问号<code>?</code>仍代表一个未知类型，但这个未知类型必须是People类或它的子类。</p>
<p><strong>设定通配符的下限</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> People&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里的问号<code>?</code>仍代表一个未知类型，但这个未知类型必须是People类或它的父类。</p>
<hr>
<p><strong>5、自定义泛型方法</strong></p>
<p>语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T, S&gt; 返回值类型 函数名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如下面这个泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(Collection&lt;T&gt; arr, Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(T elem : arr) &#123;</span><br><span class="line">    	c.add(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述泛型方法可以直接调用，编译器会根据实参<strong>推断</strong>类型参数的值。但其实，也可以直接用<strong>类型通配符</strong>替代（两个Collection的元素类型没有依赖关系的情况下）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(Collection&lt;?&gt; arr, Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(T elem : arr) &#123;</span><br><span class="line">    	c.add(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第九章_异常处理">第九章 异常处理</h1><p><strong>1、Java异常的继承体系</strong></p>
<p><img src="http://img.blog.csdn.net/20160315001000655" alt=""></p>
<p>如上图所示，<code>java.lang.Throwable</code>是Java中所有可以错误和异常的父类。Java把所有的非正常情况分为两类：</p>
<ul>
<li><p><strong>Error（错误）</strong>：一般指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，应用程序无法处理这些错误。</p>
</li>
<li><p><strong>Exception（异常）</strong>：指应用程序本身可以处理的异常。</p>
<ul>
<li>运行时异常：指<code>RuntimeException</code>类及其子类异常，编译器不会检查这些异常。</li>
<li>非运行时异常：也叫Checked异常，是指<code>RuntimeException</code>以外的 Exception。这些异常不处理，程序就不能编译通过。如<code>IOException</code>、<code>SQLException</code>等</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2、异常处理机制</strong></p>
<p>Java的异常机制主要依赖于<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>和<code>throws</code>五个关键字。</p>
<p><strong>捕获异常：try-catch语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	statement1</span><br><span class="line">	statement2   <span class="comment">// 出现异常，系统生成异常对象ex</span></span><br><span class="line">	......</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass1 e1) &#123;    <span class="comment">// ex对象是否属于ExceptionClass1类及其子类</span></span><br><span class="line">	exception handler statement1</span><br><span class="line">	......</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass2 e2) &#123;    <span class="comment">// 一旦捕获，try-catch语句结束</span></span><br><span class="line">	exception handler statement</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>如果找不到能捕获该异常的catch块，则运行时环境终止，Java程序也将退出。</p>
<p><strong>捕获异常：try-catch-finally语句</strong></p>
<p>try-catch 语句还可以包括第三部分，就是finally块。无论是否出现异常，finally块总会被执行；甚至在try块或catch块中return了，finally块也会被执行。（除非<code>System.exit()</code>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 业务实现代码</span></span><br><span class="line">	......</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass1 e1) &#123;</span><br><span class="line">	<span class="comment">// 异常处理块1</span></span><br><span class="line">	......</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass2 e2) &#123;</span><br><span class="line">	<span class="comment">// 异常处理块2</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 资源回收块</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>finally块通常用来回收在try块里打开的一些物理资源，例如数据库连接、网络连接、磁盘文件等。</p>
<p><strong>抛出异常：throws</strong></p>
<p><code>throws</code>关键字只能用在<strong>方法签名</strong>中。如果当前函数不知道如何处理这种异常，则应该使用 throws 抛出异常，交由上一级调用者处理 —— 若<code>main</code>方法 throws 异常，该异常将交给JVM处理（打印跟踪栈信息并终止程序运行）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p>
<p><strong>抛出异常：throw</strong></p>
<p>当程序出现错误时，系统会自动抛出异常；除此之外，程序也可以自己抛出异常。<code>throw</code>单独作为语句使用，用于抛出一个具体的异常对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"您输入的格式有误！"</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>3、打印异常信息</strong></p>
<p>当在catch块中捕获了异常，你可能想要获取或打印异常对象的相关信息。所有的异常对象都包含几个常用方法：</p>
<ul>
<li><code>getMessage()</code>：返回该异常的详细描述字符串。</li>
<li><code>printStackTrace()</code>：将该异常的跟踪栈信息输出到标准错误输出。</li>
<li><code>printStackTrace(PrintStream s)</code>：将该异常的跟踪栈信息输出到指定输出流。</li>
<li><code>getStackTrace()</code>：返回该异常的跟踪栈信息。</li>
</ul>
<hr>
<p><strong>4、自定义异常类</strong></p>
<p>用户自定义异常都应该继承<code>Exception</code>基类，当然如果希望自定义运行时异常，则应该继承<code>RuntimeException</code>基类。</p>
<p>定义异常类时通常需要提供两个构造器：一个是无参数的构造器，另一个是带一个字符串参数的构造器（该字符串作为异常对象的描述信息）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InputException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InputException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>5、异常链</strong></p>
<p>对于大型应用而言，通常有严格的分层关系，上层功能的实现依赖下层的API，如图：</p>
<p><img src="http://img.blog.csdn.net/20160315023946974" alt=""></p>
<p>如果当 中间层 访问 持久层出现SQLException异常时，程序不应该把底层的SQLException异常传到用户界面，因为：</p>
<ul>
<li>用户并不想看到底层的SQLException异常，该异常对他们使用该系统没有任何帮助；</li>
<li>将底层异常暴露出来不安全。</li>
</ul>
<p>所以通常的做法就是：程序先捕获原始异常，然后抛出一个新的业务异常。（新的业务异常中包含对用户的提示信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 业务逻辑代码</span></span><br><span class="line">	......</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">	<span class="comment">// 把原始异常记录下来，留给管理员</span></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">"访问数据库出现异常"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">//把原始异常记录下来，留给管理员</span></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">"系统出现未知异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种捕获一个异常然后接着抛出另一个异常，并把原始异常信息保存下来是一种典型的链式处理，也被称作<strong>“异常链”</strong>。</p>
<p>从Java 4以后，所有<code>Throwable</code>子类在构造器中都可以接收一个Exception对象，这样就可以很容易把原始异常作为参数传递给新的异常，创建并抛出新的异常。也能通过异常链追踪到异常最初发生的位置。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">(Throwable t)</span> </span>&#123;  <span class="comment">// 带Throwable参数的构造器</span></span><br><span class="line">    	<span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 业务逻辑代码</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UserException(sqle);  <span class="comment">// 封装原始异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UserException(e);     <span class="comment">// 封装原始异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第七章_Java集合（重点）">第七章 Java集合（重点）</h1><p><strong>1、 Java集合概述</strong></p>
<p>Java集合类是一种工具类，主要用来存储数量不定的对象，类似于<strong>容器</strong>。Java主要有四大集合体系：<code>Set</code>、 <code>List</code>、<code>Queue</code>、<code>Map</code>。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Lang.-Java" scheme="http://yoursite.com/categories/Lang-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java基础笔记（一） 数据类型、面向对象、基础类库]]></title>
    <link href="http://yoursite.com/2016/03/16/java-basic-note-1/"/>
    <id>http://yoursite.com/2016/03/16/java-basic-note-1/</id>
    <published>2016-03-16T08:20:00.000Z</published>
    <updated>2016-03-16T08:32:24.051Z</updated>
    <content type="html"><![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第一章_Java概述">第一章 Java概述</h1><p><img src="http://img.blog.csdn.net/20141124190237680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<a id="more"></a>
<p><strong>Java SE</strong>：（Java Platform, Standard Edition）整个Java技术的核心和基础，它是Java ME和Java EE编程的基础。<br><strong>Java ME</strong>：（Java Platform, Micro Edition）主要用于控制移动设备和信息家电等有限存储的设备。<br><strong>Java EE</strong>：（Java Platform，Enterprise Edition）提供了企业应用开发相关的完整解决方案，是Java技术中应用最广泛的部分。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20141124190252203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><strong>JVM</strong>：（Java Virtual Machine）Java虚拟机，负责解释执行字节码文件。（JVM是Java程序跨平台的关键）</p>
<hr>
<p><strong>1、Java程序的组织形式</strong></p>
<p>Java是一种纯粹的面向对象的程序设计语言，即必须以<strong>类（class）</strong>的形式存在。类是Java程序的最小程序单位。（Java程序不允许可执行语句、方法等成分独立存在，所有的程序部分都必须放在类定义里）</p>
<p>Java程序的入口是一个类中的<strong>main方法</strong>：<code>public static void main(String[] args)</code></p>
<p><strong>2、源文件的命名规则</strong></p>
<p><img src="http://img.blog.csdn.net/20141124190331328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><strong>3、垃圾回收机制</strong></p>
<p>Java不需要程序员直接控制内存回收，程序的内存分配和回收都是由JRE在后台自动进行的。JRE会负责回收那些不再使用的内存，这种机制称为<strong>垃圾回收（Garbage Collection）</strong>。</p>
<p><br></p>
<h1 id="第二章_Java数据类型">第二章 Java数据类型</h1><p>Java中的所有关键字（都是小写）：</p>
<p><img src="http://img.blog.csdn.net/20141124190344479?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>除了上面48个关键字之外，Java还包含<code>goto</code>和<code>const</code>两个保留字（未来可能用作关键字）与 三个特殊的字面值：<code>true</code>、<code>false</code>、<code>null</code>。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20141124190356335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><strong>引用类型</strong>就是对一个对象的引用。实际上，引用类型变量就是一个指针，只是Java语言里不再使用指针这个说法。</p>
<p><br></p>
<h1 id="第三章_深入Java数组">第三章 深入Java数组</h1><p><strong>1、数组的定义与初始化</strong></p>
<p>在Java中，<strong>数组</strong>也是一种数据类型，而且是一种引用数据类型。</p>
<p><strong>定义数组</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName;  <span class="comment">// 建议使用这种形式</span></span><br><span class="line">type arrayName[];</span><br></pre></td></tr></table></figure></p>
<p>注意：定义一个数组时，仅仅是定义了一个引用变量（也就是一个指针），它还未指向任何有效的内存，因此，定义数组时不能指定数组的长度。</p>
<p><img src="http://img.blog.csdn.net/20141124190823766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<hr>
<p><strong>2、数组在内存中的运行机制</strong></p>
<p>数组是一种引用数据类型，所以数组变量只是一个引用。通过这个引用访问它所指向的有效内存（数组对象本身）。</p>
<p>通常，如果数组引用变量是一个局部变量，它会被存储在<strong>栈（stack）内存</strong>中，而实际的数组对象被存储在<strong>堆（heap）内存</strong>中，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20141124190847260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20141124190948412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从上面的例子可以看出，Java的引用类型就相当于C/C++中的指针类型。</p>
<hr>
<p><strong>3、栈内存与堆内存</strong></p>
<p><strong>栈内存</strong>：当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，内存栈也将自然销毁。</p>
<p><strong>堆内存</strong>：当我们在程序中创建（new）一个对象时，该对象会被保存到<strong>运行时数据区</strong>中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是<strong>堆内存</strong>。堆内存中的对象不会随方法的结束而销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收器才会在合适的时候回收它。</p>
<p>操作数组的工具类：<code>java.util.Arrays</code></p>
<p><br></p>
<h1 id="第四章_面向对象（上）">第四章 面向对象（上）</h1><p>定义类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名</span><br><span class="line"></span>&#123;</span><br><span class="line">    零到多个构造器定义</span><br><span class="line">    零到多个Field</span><br><span class="line">    零到多个方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的修饰符可以是<code>public</code>、<code>final</code>、<code>abstract</code>或省略。</p>
<hr>
<ol>
<li><p>类也是引用数据类型，用类定义的变量也只是一个引用（或者说指针），里面只是存放了一个地址值。</p>
</li>
<li><p><code>static</code>修饰的方法不能直接访问没有<code>static</code>修饰的成员。（理由很简单：静态成员是独立于具体对象而存在，属于类本身，而非静态成员是依赖于具体的对象的）</p>
</li>
<li><p>Java里方法的参数传递方式只有一种：<strong>值传递</strong>。基本数据类型和引用数据类型都是将实参的一个副本传给形参，只不过引用数据类型拷贝的是地址值！</p>
</li>
</ol>
<hr>
<p><strong>可变参数函数：</strong></p>
<p>JDK 1.5之后，Java允许为方法指定数量不确定的形参，通过在最后一个形参的类型后增加三个点（…），代码实例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 可变参数的方法</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, String... str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String s : str) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 程序入口-main</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		func(<span class="number">15</span>, <span class="string">"第一个字符串"</span>,<span class="string">"第二个字符串"</span>,<span class="string">"第三个字符串"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，如果你觉得这样麻烦，可以直接用一个数组代替</p>
<hr>
<p><strong>方法重载：</strong></p>
<p>Java允许同一个类里定义多个同名方法，只要形参列表不同就行。</p>
<hr>
<p>在Java中，根据变量定义位置的不同，可以将变量分为两大类：成员变量 和 局部变量</p>
<p><img src="http://img.blog.csdn.net/20141124191846332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>1、成员变量的初始化和内存中的运行机制</p>
<ul>
<li>当系统加载类、或者创建该类的实例时，系统自动为成员变量分配内存空间，并自动指定初始值。</li>
<li><strong>类 Field</strong>（静态成员变量），系统会在类加载时为其分配内存空间，并指定默认初始值。</li>
<li><strong>实例 Field</strong> 是在创建实例时分配内存空间并指定初始值的，注意：实例变量指向的是这部分内存。</li>
</ul>
<p>2、局部变量的初始化和内存中的运行机制</p>
<ul>
<li>局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。</li>
<li>也就是说，定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初值时才分配，并将初值保存在这块内存中。</li>
<li>局部变量总是保存在其所在方法的栈内存中，所以它不属于任何类或实例。</li>
<li>如果是基本类型的局部变量，则栈内存中是变量的值；如果是引用类型的局部变量，则栈内存中存放的是地址，引用堆内存中的实际对象。</li>
</ul>
<hr>
<p><strong>类的封装</strong></p>
<p>封装是面向对象的三大特征之一。为了实现良好的封装，需要：</p>
<ul>
<li>将 Field 和实现细节隐藏起来，不允许外部直接访问。</li>
<li>把方法作为外部接口暴露出来，让方法来控制对 Field 进行安全的访问和操作。</li>
</ul>
<p>Java中提供了4个访问控制级别：<code>private</code>、<code>protected</code>、<code>public</code>和不加任何访问控制符（<code>default</code>），它们的访问控制级别由小到大：</p>
<p><img src="http://img.blog.csdn.net/20141124191904225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="http://img.blog.csdn.net/20141124191917656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<hr>
<p><strong>package、import 和 import static</strong></p>
<p><strong>包（package）</strong>：为了解决类的命名冲突，Java引入了包机制，提供了类的多层命名空间。</p>
<p>如果一个类被放于某个包中，则我们应该在该Java源文件的第一个非注释行添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> packageName;</span><br></pre></td></tr></table></figure></p>
<p><code>import</code>语句可以导入指定包下某个类或全部类，但<code>import</code>语句并不是必需的，只要坚持在类里面使用其他类的全名，则可以无须使用<code>import</code>语句。</p>
<p>注意：在JDK 1.5以后增加了一种静态导入（<code>import static</code>）的语法，用于导入指定类的某个静态 Field、方法或该类全部的静态 Field、方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.subpackage...className.fieldName;  <span class="comment">// 导入某一静态变量</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.subpackage...className.methodName; <span class="comment">// 导入某一静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.subpackage...className.*;  <span class="comment">// 导入该类的所有静态Field、方法</span></span><br></pre></td></tr></table></figure></p>
<p>用一句话归纳<code>import</code>和<code>import static</code>的作用：使用import可以省略写包名，而使用import static则可以连类名都省略。</p>
<hr>
<p><strong>Java的常用包</strong></p>
<p>Java的核心类都放在<code>java</code>这个包及其子包下，Java扩展的许多类都放在<code>javax</code>包及其子包下。下面几个包是Java语言中的常用包：</p>
<ul>
<li><code>java.lang</code>：这个包下包含了Java语言的核心类，如 String、Math、System 和 Thread 类等，使用这个包下的类无须使用 import 语句导入，系统会自动导入这个包下的所有类。</li>
<li><code>java.util</code>：这个包下包含了Java的大量工具类/接口和集合框架类/接口，例如 Arrays、List 和 Set 等。</li>
<li><code>java.net</code>：这个包下包含了一些Java网络编程相关的类/接口。</li>
<li><code>java.io</code>：这个包下包含了一些Java输入/输出编程相关的类/接口。</li>
<li><code>java.text</code>：这个包下包含了一些Java格式化相关的类。</li>
<li><code>java.sql</code>：这个包下包含了Java进行 JDBC 数据库编程的相关类/接口。</li>
<li><code>java.awt</code>：这个包下包含了抽象窗口工具集（Abstract Window Toolkits）的相关类/接口，这些类主要用于构建 GUI 程序。</li>
<li><code>java.swing</code>：这个包下包含了 Swing 图形用户界面编程的相关类/接口，这些类可用于构建平台无关的 GUI 程序。</li>
</ul>
<hr>
<p><strong>构造器</strong></p>
<p>构造器也就是构造函数！！！</p>
<p>Java类可以包含一个或一个以上的构造器。一旦程序员提供了自定义的构造器，系统就不再提供默认的无参构造器了。（所以如果为一个类编写了有参数的构造器，通常建议为该类也额外提供一个无参数的构造器）</p>
<hr>
<p><strong>类的继承</strong></p>
<p>继承是面向对象的三大特征之一。Java的继承具有<strong>单继承</strong>的特点，每个子类只有一个直接父类。</p>
<p>继承的语法格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> <span class="title">Derive</span> <span class="keyword">extends</span> <span class="title">Base</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 类定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java使用<code>extends</code>作为继承的关键字，<code>extends</code>在英文中是扩展的意思。</p>
<p>重写父类的方法要遵循<strong>“两同两小一大”</strong>的规则：</p>
<ul>
<li><strong>“两同”</strong>：方法名相同，形参列表相同。</li>
<li><strong>“两小”</strong>：子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等。</li>
<li><strong>“一大”</strong>：子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>如果需要在子类方法中调用父类中被覆盖的方法，若被覆盖的是实例方法，使用<code>super</code>作为调用者；若被覆盖的是类方法，使用<strong>父类类名</strong>作为调用者。</p>
<hr>
<p><strong>构造器的执行顺序</strong></p>
<p>子类不会获得父类的构造器，但子类构造器里可以调用父类构造器。有如下几种情况：</p>
<ul>
<li>子类构造器函数体的第一行使用<code>super</code>显式调用父类构造器。</li>
<li>子类构造器函数体的第一行使用<code>this</code>显示调用本类中重载的构造器，执行本类中另一个构造器时即会调用父类构造器。</li>
<li>子类构造器函数体中既没有<code>super</code>调用，也没有<code>this</code>调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器。</li>
</ul>
<p>不管上面哪种情况，当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行；不仅如此，执行父类构造器时，系统会再次上溯执行其父类构造器……依此类推，创建任何Java对象，最先执行的总是<code>java.lang.Object</code>类的构造器。</p>
<hr>
<p><strong>多态</strong></p>
<p>多态是面向对象的三大特征之一。</p>
<p>Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。<strong>编译时类型</strong>由声明该变量时的类型决定，<strong>运行时类型</strong>由实际赋给该变量的对象决定。两个类型不一致时，就可能出现多态。</p>
<p>当把一个子类对象直接赋给父类引用变量时，这个引用变量的编译时类型是 BaseClass，而运行时类型是 SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征。也就是说：相同类型的变量 调用同一个方法时，呈现出多种不同的行为特征，这就是多态。</p>
<p>多态的两个前提： 要有<strong>继承（inheritance）</strong>，要有<strong>方法重写（override）</strong>。</p>
<hr>
<p><strong>instanceof 运算符</strong></p>
<p><code>instanceof</code>是Java中的一个二元运算符，它的作用是在运行时判断左边对象是否是右边类（或其子类）的实例。如果是，返回<code>true</code>，否则返回<code>false</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">""</span>;   <span class="comment">// str 是String类型引用变量</span></span><br><span class="line">		Object obj = <span class="string">""</span>;   <span class="comment">// obj 的编译时类型是 Object，但实际类型是 String </span></span><br><span class="line">		System.out.println(<span class="string">"str 是 String 的实例："</span> + (str <span class="keyword">instanceof</span> String)); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"str 是 Object 的实例："</span> + (str <span class="keyword">instanceof</span> Object)); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"obj 是 String 的实例："</span> + (obj <span class="keyword">instanceof</span> String)); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"obj 是 Object 的实例："</span> + (obj <span class="keyword">instanceof</span> Object)); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"obj 是 Math 的实例："</span> + (obj <span class="keyword">instanceof</span> Math)); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意：<code>instanceof</code>运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误。</p>
<p><code>instanceof</code>运算符的常用之处：在进行强制类型转换之前，首先判断前一个对象是否是后一个类的实例，是否可以成功转换，从而保证代码更加健壮。</p>
<hr>
<p><strong>初始化块</strong></p>
<p>初始化块是Java类里可出现的第4种成员（前面依次有 Field、方法和构造器）。与构造器的作用类似，初始化块也可以对Java对象进行初始化操作。</p>
<p>初始化块的语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] &#123;</span><br><span class="line">	<span class="comment">// 可执行代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化块的修饰符只能是<code>static</code>，使用 static 修饰的初始化块被称为<strong>静态初始化块</strong>。</p>
<p>一个类里可以有多个初始化块，先定义的初始化块先执行，后定义的初始化块后执行，下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">		System.out.println(<span class="string">"第一个初始化块！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"第二个初始化块！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类的无参数构造器！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> MyClass();   <span class="comment">// 创建一个对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个初始化块！</span><br><span class="line">第二个初始化块！</span><br><span class="line">类的无参数构造器！</span><br></pre></td></tr></table></figure></p>
<p>可以看出，初始化块是在构造器之前执行的。创建一个 Java 对象时，不仅会执行该类的普通初始化块和构造器，而且系统会一直上溯到<code>java.lang.Object</code>类，先执行 java.lang.Object 类的初始化块，开始执行 java.lang.Object 的构造器，依次向下执行其父类的初始化块，开始执行其父类的构造器……最后才执行该类的初始化块和构造器，返回该类的对象。</p>
<p>虽然 Java 允许一个类中定义多个的普通初始化块，但这没有任何意义，所以如果要使用初始化块的话定义一个就行了。</p>
<hr>
<p><strong>初始化块和构造器的区别</strong></p>
<p>初始化块总是在构造器之前执行。虽然它们的作用非常相似，但依然存在一些差异的。</p>
<p>与构造器不同的是，初始化块是一段固定执行的代码，它不能接受任何参数。因此，如果有一段初始化的代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化代码提取到初始化块中。</p>
<p><img src="http://img.blog.csdn.net/20141124192430734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>通过把多个构造器中的相同代码提取到初始化块中，能更好地提高初始化代码的复用，提高整个应用的可维护性。</p>
<hr>
<p><strong>静态初始化块</strong></p>
<p>初始化块的修饰符只能是<code>static</code>，使用 static 修饰的初始化块被称为<strong>静态初始化块</strong>。</p>
<p>静态初始化块，也属于类的静态成员，因此静态初始化块不能访问非静态成员（包括实例Field和实例方法）。静态初始化块用于对整个类进行初始化处理，通常用于对类Field执行初始化处理。</p>
<p>系统将在类初始化阶段执行静态初始化块，而不是在创建对象时才执行。因此，静态初始化块总是比普通初始化块先执行。与普通初始化块类似的是，系统在类初始化阶段不仅会执行本类的静态初始化块，还会一直上溯到 java.lang.Object 类（如果它包含静态初始化块），从上往下依次执行其父类的静态初始化块……最后才执行该类的静态初始化块。经过这个过程，才完成了该类的初始化。而只有类完成初始化以后，才可以在系统中使用这个类，包括访问这个类的类Field、类方法，或者用这个类来创建实例。</p>
<p><br></p>
<h1 id="第五章_面向对象（下）">第五章 面向对象（下）</h1><p><strong>包装类</strong></p>
<p>Java 是面向对象的编程语言，但它也包含了 8 种基本数据类型。基本数据类型的数据不具备“对象”的特性：没有Field、方法可以被调用。</p>
<p>所有引用类型的变量都继承了<code>Object</code>类，都可当成 Object 类型变量使用，但基本数据类型的变量却不可以。为了解决这个问题，Java 提供了<strong>包装类（Wrapper Class）</strong>，可以把 8 个基本类型的值包装成对象使用。</p>
<p><img src="http://img.blog.csdn.net/20141124192458156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>把基本数据类型变量 包装成 对应的包装类对象 是通过对应包装类的构造器来实现的，不仅如此，8个包装类中除了 Character 之外，还可以通过传入一个字符串来构建包装类对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">int</span> i1 = <span class="number">5</span>;</span><br><span class="line">		</span><br><span class="line">		Boolean <span class="number">_</span>b = <span class="keyword">new</span> Boolean(b1);</span><br><span class="line">		Integer <span class="number">_</span>i = <span class="keyword">new</span> Integer(i1);</span><br><span class="line">		Float <span class="number">_f</span> = <span class="keyword">new</span> Float(<span class="string">"3.14"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 取出包装类对象里的值</span></span><br><span class="line">		<span class="keyword">boolean</span> b2 = <span class="number">_</span>b.booleanValue();</span><br><span class="line">		<span class="keyword">int</span> i2 = <span class="number">_</span>i.intValue();</span><br><span class="line">		<span class="keyword">float</span> f2 = <span class="number">_f</span>.floatValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能你会觉得，这样的转换有些繁琐。但从 JDK 1.5 开始提供了<strong>自动装箱（Autoboxing）</strong> 和 <strong>自动拆箱（AutoUnboxing）</strong>功能，即可以把一个基本类型变量直接赋给对应的包装类变量或 Object 变量（自动装箱），也可以把包装类对象直接赋给一个对应的基本类型变量。</p>
<hr>
<p><strong>基本类型变量与字符串的转换</strong></p>
<p><img src="http://img.blog.csdn.net/20141124192816810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<hr>
<p><strong>toString( )方法</strong></p>
<p><code>toString()</code>方法是 Object 类里的一个实例方法，而所有的 Java 类都是 Object 类的子类，因此所有的 Java 对象都具有 toString() 方法。</p>
<p>不仅如此，所有的 Java 对象都可以和字符串进行连接运算，也可以使用<code>System.out.println()</code>进行输出。当进行上面的操作时，系统会自动调用 Java 对象的 <code>toString()</code>方法，使用其返回的字符串。</p>
<p>Object 类的<code>toString</code>方法是一个“自我描述”的方法，它总是返回该对象实现类的“类名@hashCode”值。但是这个返回值并不能真正实现“自我描述”的功能，这时可以对这个方法进行重写。</p>
<hr>
<p><strong>==和equals的区别</strong></p>
<p>Java 程序中判断两个变量是否相等有两种方式：一种是使用<code>==</code>运算符，另一种是使用<code>equals</code>方法。</p>
<ul>
<li>对于基本类型变量来说，它们并没有<code>equals</code>方法，只能使用<code>==</code>判断两个变量的值是否相等。</li>
<li>对于引用类型变量来说，<code>==</code>运算符是判断两个引用变量是否指向内存中的同一个对象，也就是比较对象的内存地址；而<code>equals</code>是比较两个对象的值是否相等（String类，Integer类等等）。</li>
</ul>
<p>需要知道的是，equals 方法是 Object 类的一个实例方法。在 Object 类中<code>equals</code>方法和<code>==</code>没有任何区别，都是判断两个变量是否指向同一个对象。而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==”不同。</p>
<p>所以，当自己创建类时，想要自定义相等的标准，必须重写equals方法。</p>
<hr>
<p><strong>final修饰符</strong></p>
<p>Java 提供了<code>final</code>关键字来修饰变量、方法和类。系统不允许为 <code>final</code>变量重新赋值，子类不允许覆盖父类的<code>final</code>方法，不允许继承<code>final</code>类。</p>
<ul>
<li><p>final 成员变量必须由程序员显式地指定初始值，系统不会对 final 成员变量进行隐式初始化。对于 final 修饰的类 Field，必须在声明该Field时或在静态初始化块中指定初始值；对于 final 修饰的实例 Field，必须在声明该Field时、普通初始化块或构造器中指定初始值。</p>
</li>
<li><p>前面说过，系统不会为局部变量执行隐式初始化，必须由程序员显式指定。对于 final 修饰的局部变量，可以在声明时指定初始值，也可以在后面的代码中对其赋值，但只能一次。</p>
</li>
<li><p>final 修饰基本类型变量时，表示变量的值不能被改变；final 修饰引用类型变量时，表示该变量所引用的地址不能被改变，即一直引用同一个对象，但这个对象是可以改变的。</p>
</li>
<li><p>当定义 final 变量时就为该变量指定了初始值，而且该初始值可以在编译时就被确定下来，那么这个变量就变成了“宏变量”。编译器会把程序中所有用到该变量的地方直接替换成该变量的值。</p>
</li>
</ul>
<hr>
<p><strong>抽象类与抽象方法</strong></p>
<p>Java 中使用<code>abstract</code>修饰符来定义抽象类和抽象方法。有抽象方法的类必须定义成抽象类，但抽象类里可以没有抽象方法。</p>
<p>抽象类不能被实例化，只能当作父类被其他子类继承。抽象方法没有函数体，必须由子类提供实现（即重写）。</p>
<p>与<code>abstract</code>不能同时使用的关键字：</p>
<ol>
<li>final和abstract不能同时使用，因为它们是对立的。</li>
<li>static和abstract不能同时修饰某个方法，因为如果一个抽象方法被定义成静态方法，通过类名调用该方法将出现错误。</li>
<li>private和abstract不能同时修饰某个方法，因为抽象方法必须被子类重写才有意义，而子类不能访问和重写父类的 private 方法。</li>
</ol>
<hr>
<p><strong>接口（interface）</strong></p>
<p>上面说到，抽象类既可以包含抽象方法，也可以普通方法。而接口（interface）是一种更彻底的抽象，接口里的所有方法都是抽象方法。</p>
<p>接口定义的是多个类共同的公共行为规范，故它里面通常是定义一组公用方法。基本语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1,父接口2...</span><br><span class="line"></span>&#123;</span><br><span class="line">    零个到多个常量定义...</span><br><span class="line">    零个到多个抽象方法定义...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符。另外，与类继承不同的是，接口继承中一个接口可以有多个直接父接口（接口只能继承接口而不能继承类）。</p>
<p>由于接口是一种规范，因此接口里不能包含构造器和初始化块。接口里可以包含3种成员： Field（只能是常量）、方法（只能是抽象方法）、内部类（包括内部接口、枚举）。</p>
<ul>
<li>接口里所有成员都是<code>public</code>访问权限。</li>
<li>接口里的常量 Field 是使用<code>public static final</code>修饰符来修饰，不管定义时是否指定。</li>
<li>接口里的方法是自动使用<code>public abstract</code>修饰符修饰，不管定义方法时是否指定。</li>
<li>接口里的内部类（接口、枚举类）是自动使用<code>public static</code>修饰符修饰，不管定义时是否指定。</li>
</ul>
<p>接口不能用于创建实例，其主要用途是被实现类实现。实现使用<code>implements</code>关键字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1,接口2...</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 类体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个类只能有一个直接父类，但一个类可以实现多个接口。实现接口与继承父类相似，也可以获得所实现的接口里定义的成员，因此可以把实现接口理解为一种特殊的继承。</p>
<hr>
<p><strong>接口与抽象类的比较</strong></p>
<p>相同点：</p>
<ul>
<li>接口和抽象类都不能被实例化，它们都用于被其他类实现或继承。</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li>
</ul>
<p>不同点：</p>
<ul>
<li>接口里只能包含抽象方法，而抽象类既可以抽象方法也可以包含普通方法，还可以没有抽象方法。</li>
<li>接口里不能定义静态方法（因为全部是抽象方法），抽象类里可以定义静态方法。</li>
<li>接口里只能定义静态常量 Field，而抽象类既可以定义普通 Field，也可以定义静态常量 Field。</li>
<li>接口里不包含构造器和初始化块，而抽象类里完全可以包含。</li>
<li>一个类最多只能有一个直接父类，但却可以直接实现多个接口（弥补Java单继承的不足）。</li>
</ul>
<hr>
<p><strong>内部类</strong></p>
<p>在Java类里只能包含5种成员：Field、方法、构造器、初始化块、内部类（包括接口和枚举类）。前四种类成员已经介绍过了，下面介绍一下内部类。</p>
<p>内部类也叫嵌套类，语法格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 此处可以定义内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，我们把内部类作为成员内部类来定义，而不是作为局部内部类（在方法里定义的内部类）。</p>
<p><img src="http://img.blog.csdn.net/20141124193040860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>非静态内部类里不允许定义静态成员，而静态内部类里可以定义静态成员，也可以定义非静态成员。</p>
<p>根据静态成员不能访问非静态成员的规则，外部类的静态方法不能使用非静态内部类，静态内部类也不能访问外部类的非static成员。</p>
<hr>
<p><strong>枚举类</strong></p>
<p>枚举类是一种不能自由创建对象的类，它的对象在定义类时已经固定下来。枚举类特别适合定义像行星、季节这样的类，它们能创建的实例是有限且确定的。</p>
<p>在 Java 1.5 以前，要定义一个枚举类，必须手动去实现。下面就是一个 Season 枚举类的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>,<span class="string">"春暖花开"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>,<span class="string">"夏日炎炎"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season FALL = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>,<span class="string">"秋高气爽"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>,<span class="string">"围炉赏雪"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name, String description)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.description = description;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 只为两个 Field 提供 getter 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> description;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的 Season 类是一个不可变类，它只能创建4种对象，可以通过Season.SPRING的方式来取得 Season 对象。</p>
<p>Java 1.5 新增了一个<code>enum</code>关键字，用以定义枚举类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">	SPRING,SUMMER,FALL,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>枚举类（enum）</strong>是一种特殊的类，它一样可以有自己的 Field、方法和构造器，可以实现一个或者多个接口。因为它特殊，所以有几点需要注意：</p>
<ol>
<li>用<code>enum</code>定义的枚举类默认继承了<code>java.lang.Enum</code>类，而不是继承 Object 类。</li>
<li>用<code>enum</code>定义的非抽象的枚举类默认使用 final 修饰，因此枚举类不能派生子类。</li>
<li>枚举类的构造器默认使用且只能使用<code>private</code>访问控制符修饰。</li>
<li>枚举类的所有实例必须在枚举类的第一行显式列出，并且系统会自动添加<code>public static final</code>修饰。</li>
</ol>
<p><br></p>
<h1 id="第六章_Java基础类库">第六章 Java基础类库</h1><p><strong>1、与用户交互</strong></p>
<p><strong>main 方法详解</strong></p>
<p>我们知道Java程序的入口是<code>public static void main(String[] args)</code></p>
<ul>
<li><p>public：因为main方法是由 JVM 调用，所以使用 public 修饰符把这个方法暴露出来。</p>
</li>
<li><p>static：JVM 调用主方法时，是直接通过该类名来调用主方法，所以使用 static 修饰。</p>
</li>
<li><p>void：因为主方法被JVM调用，该方法的返回值将返回给JVM，这没有任何意义，因此main方法没有返回值。</p>
</li>
</ul>
<p>main方法有一个字符串数组形参，当通过命令行运行Java程序时，在类名后紧跟一个或多个字符串，JVM就会把这些字符串依次赋给<code>args</code>数组元素，例如下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(args.length);  <span class="comment">// 输出args数组长度</span></span><br><span class="line">		<span class="keyword">for</span>(String arg : args) &#123;    <span class="comment">// 遍历</span></span><br><span class="line">			System.out.println(arg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在CMD窗口中编译、运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[master<span class="annotation">@localhost</span> ~]$ javac MyClass.java     <span class="comment">// 编译</span></span><br><span class="line">[master<span class="annotation">@localhost</span> ~]$ java MyClass           <span class="comment">// 运行，无参数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[master<span class="annotation">@localhost</span> ~]$ java MyClass first second third   <span class="comment">// 运行，后跟三个参数</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br><span class="line">[master<span class="annotation">@localhost</span> ~]$ java MyClass <span class="string">"first second third"</span>   <span class="comment">// 运行，双引号内是一个整体</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">first second third</span><br></pre></td></tr></table></figure></p>
<p>从上面的运行结果可以看出，如果某参数本身包含了空格，则应该将该参数用双引号（“”）括起来，否则JVM会把这个空格当成参数分隔符。</p>
<p><img src="file:///C:\Users\SongLee\Desktop\Java笔记\java\Java笔记（二）001.png" alt=""></p>
<hr>
<p><strong>使用 Scanner 获取键盘输入</strong></p>
<p><code>Scanner</code>是一个基于正则表达式的文本扫描器，它可以从文件、输入流、字符串中解析出基本类型值和字符串值。</p>
<p>Scanner主要提供了两个方法来扫描输入：</p>
<ul>
<li><p><code>hasNextXxx()</code>：是否还有下一个输入项，其中 Xxx 可以是 Int、Long 等。如果判断字符串则直接用 hasNext。</p>
</li>
<li><p><code>nextXxx()</code>：获取下一个输入项，Xxx 含义同上。获取字符串直接用 next。</p>
</li>
</ul>
<p>下面是用Scanner读取键盘输入的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// System.in 代表标准输入，即键盘输入</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">// 判断是否还有下一个输入项</span></span><br><span class="line">		<span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"键盘输入的内容是："</span> + sc.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Scanner使用空格作为多个输入项之间的分隔符。如果我们想一次读取一行，可以把Scanner的分隔符设置为回车符，使用函数<code>sc.useDelimiter(&quot;\n&quot;)</code>。事实上，Scanner提供了两个更简单的方法逐行读取，即<code>hasNextLine()</code>和<code>nextLine()</code>。</p>
<p>Scanner还可以读取文件输入，只要在创建Scanner对象时传入一个<code>File</code>对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 读取文件</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://MyClass.java"</span>));</span><br><span class="line">		<span class="comment">// 逐行输出</span></span><br><span class="line">		<span class="keyword">while</span>(sc.hasNextLine()) &#123;</span><br><span class="line">			System.out.println(sc.nextLine());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>使用 BufferedReader 获取键盘输入</strong></p>
<p>Scanner是Java 5新增的工具类。在此之前，程序通常通过<code>BufferedReader</code>类来读取键盘输入。</p>
<p>BufferedReader 是Java IO流中的一个字符缓存流，它必须建立在另一个字符流的基础之上。但标准输入（System.in）是字节流，程序需要使用转换流<code>InputStreamReader</code>将其包装成字符流。故通过 BufferedReader 读取键盘输入的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 逐行读取</span></span><br><span class="line">		<span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"键盘输入的是："</span> + line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，BufferedReader 也可以用来读取文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"D://MyClass.java"</span>);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 逐行读取</span></span><br><span class="line">		<span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>2、系统相关</strong></p>
<p>Java程序在不同的操作系统上运行时，可能需要取得平台相关的属性，或者调用平台命令完成特定功能。Java提供了<code>System</code>类和<code>Runtime</code>类来与程序的运行平台进行交互。</p>
<p><strong>System类</strong></p>
<p>System 类代表了当前 Java 程序的运行平台，程序不能创建该类对象，但可以调用它的类Field和类方法。System类提供了：</p>
<ul>
<li><p>标准输入（in）/标准输出（out）/错误输出（err），它们都是类Field。</p>
</li>
<li><p>访问程序所在平台的环境变量、系统属性的方法。请看示例代码</p>
</li>
<li><p>加载文件和动态链接库的方法（<code>load()</code>/<code>loadLibrary()</code>）。</p>
</li>
<li><p>获取系统当前时间。</p>
</li>
</ul>
<p>获取环境变量/系统属性的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 获取系统所有的环境变量</span></span><br><span class="line">		Map&lt;String,String&gt; env = System.getenv();</span><br><span class="line">		<span class="keyword">for</span>(String name : env.keySet()) &#123; <span class="comment">// 遍历输出</span></span><br><span class="line">			System.out.println(name + <span class="string">"---&gt;"</span> + env.get(name));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(System.getenv(<span class="string">"JAVA_HOME"</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取系统属性</span></span><br><span class="line">		System.out.println(System.getProperty(<span class="string">"os.name"</span>)); <span class="comment">// Linux</span></span><br><span class="line">		System.out.println(System.getProperty(<span class="string">"os.arch"</span>)); <span class="comment">// amd64</span></span><br><span class="line">		System.out.println(System.getProperty(<span class="string">"user.timezone"</span>)); <span class="comment">// Asia/Shanghai</span></span><br><span class="line">		System.out.println(System.getProperty(<span class="string">"user.name"</span>));  <span class="comment">// SongLee</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想查看能够获取哪些属性，我们可以获取所有的系统属性并保存到本地文件中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties props = System.getProperties();</span><br><span class="line">props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://props.txt"</span>), <span class="string">"System Properties"</span>);</span><br></pre></td></tr></table></figure></p>
<p>至于 System 类中两个获取系统当前时间的方法：<code>currentTimeMillis()</code>和<code>nanoTime()</code>，它们都返回 long 型整数（与1970.1.1的时间差），前者以毫秒为单位，后者以纳秒为单位。</p>
<hr>
<p><strong>Runtime类</strong></p>
<p><code>Runtime</code>类代表Java程序的运行时环境，每个Java程序都有一个与之对应的Runtime实例，通过<code>getRuntime()</code>方法可获取该Runtime对象。Runtime类提供了：</p>
<ul>
<li><p>获取JVM相关信息，如处理器数量、内存信息等。</p>
</li>
<li><p>加载文件和动态链接库的方法（<code>load()</code>/<code>loadLibrary()</code>）</p>
</li>
<li><p>运行操作系统命令（<code>exec()</code>）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    		Runtime rt = Runtime.getRuntime();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"处理器数量："</span> + rt.availableProcessors());</span><br><span class="line">		System.out.println(<span class="string">"空闲内存数："</span> + rt.freeMemory());</span><br><span class="line">		System.out.println(<span class="string">"总的内存数："</span> + rt.totalMemory());</span><br><span class="line">		System.out.println(<span class="string">"最大可用内存数："</span> + rt.maxMemory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>3、常用类</strong></p>
<p><strong>Object类</strong></p>
<p><code>Object</code>类是所有类/数组/枚举类的父类。当定义一个类时没有使用<code>extends</code>时，则该类默认继承Object父类。 Object类提供了几个常用方法：</p>
<ul>
<li><code>boolean equals(Object obj)</code>：判断两个对象地址是否相同</li>
<li><code>protected void finalize()</code>：强制执行垃圾回收</li>
<li><code>Class&lt;?&gt; getClass()</code>：返回该对象的运行时类</li>
<li><code>int hashCode()</code>：返回该对象的hashCode值</li>
<li><code>String toString()</code>：返回”运行时类名@十六进制hashCode值”</li>
</ul>
<hr>
<p><strong>String、StringBuffer、StringBuilder的区别</strong></p>
<ul>
<li><p><code>String</code>类：它是不可变类，一旦创建，字符序列不可改变。</p>
</li>
<li><p><code>StringBuffer</code>类：它代表一个字符序列可变的字符串，通过<code>append()</code>/<code>insert()</code>/<code>reverse()</code>等方法可以改变对象的字符序列，并且<strong>线程安全</strong>。一旦生成了最终想要的字符串，可以toString()导出String对象。</p>
</li>
<li><p><code>StringBuilder</code>类：和StringBuffer相同，只不过StringBuilder不是线程安全的，所以性能略高。</p>
</li>
</ul>
<hr>
<p><strong>Math类</strong></p>
<p>Math类中提供了大量的静态方法用来完成复杂的数学运算，请自行查询API。另外，Math类还有两个静态变量：PI（π）和E（e）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Math.PI);   <span class="comment">// 3.141592653589793</span></span><br><span class="line">		System.out.println(Math.E);    <span class="comment">// 2.718281828459045</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>Random 与 ThreadLocalRandom类</strong></p>
<ol>
<li><p><code>Random</code>类：用于生产一个伪随机数，默认使用当前时间作为种子，也可以指定种子。</p>
</li>
<li><p><code>ThreadLocalRandom</code>类：它是Random的增强版，在并发环境下线程安全。且需通过<code>current()</code>静态方法获取实例对象。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadLocalRandom rand = ThreadLocalRandom.current();</span><br><span class="line">		<span class="keyword">int</span> num1 = rand.nextInt(<span class="number">4</span>, <span class="number">20</span>);</span><br><span class="line">		<span class="keyword">double</span> num2 = rand.nextDouble(<span class="number">4.0</span>, <span class="number">20.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>BigDecimal类</strong></p>
<p>我们知道float、double两种基本浮点类型在进行运算时容易发生<strong>精度丢失</strong>。为了能精确表示和计算浮点数，Java提供了<code>BigDecimal</code>类。该类有add/subtract/multiply/divide/pow等方法……<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"0.05 + 0.01 = "</span> + (<span class="number">0.05</span>+<span class="number">0.01</span>));</span><br><span class="line">		</span><br><span class="line">		BigDecimal f1 = BigDecimal.valueOf(<span class="number">0.05</span>);</span><br><span class="line">		BigDecimal f2 = BigDecimal.valueOf(<span class="number">0.01</span>);</span><br><span class="line">		System.out.println(<span class="string">"0.05 + 0.01 = "</span> + f1.add(f2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0.05 + 0.01 = 0.060000000000000005</span></span><br><span class="line"><span class="comment">// 0.05 + 0.01 = 0.06</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>时间和日期类</strong></p>
<ul>
<li><p><code>Date</code>类：java.util.Date类是一个设计糟糕的类，而且从JDK 1.0就开始存在，已经过时，官方推荐尽量少用。</p>
</li>
<li><p><code>Calendar</code>类：这是一个抽象类，不能创建对象。但可以通过几个静态方法<code>getInstance()</code>方法获取GregorianCalendar类的对象，可以指定TimeZone、Locale，不指定则使用系统默认的。</p>
</li>
<li><p><code>java.time.*</code>类：Java 8专门新增了一个<strong>java.time</strong>包，包含了<code>Clock</code>/<code>Duration</code>/<code>LocalDate</code>/<code>LocalTime</code>/<code>Year</code>/<code>Month</code>/<code>DayOfWeek</code>等等类。</p>
</li>
</ul>
<hr>
<p><strong>正则类</strong></p>
<p>在String类中提供了几个正则匹配的方法，比如<code>matches(String regex)</code>和<code>split(String regex)</code>。除此之外，Java还提供了Pattern和Matcher两个类专门用于正则表达式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Pattern pattern = Pattern.compile(<span class="string">"\\s.*a"</span>);</span><br><span class="line">		Matcher match = pattern.matcher(<span class="string">"Hello Java!"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(match.find()) &#123;	</span><br><span class="line">			System.out.println(match.group());   <span class="comment">// 输出 Java</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要是我在看《疯狂Java讲义》时的读书笔记，阅读的比较仓促，就用 markdown 写了个概要。</p>
<h1 id="第一章_Java概述">第一章 Java概述</h1><p><img src="http://img.blog.csdn.net/20141124190237680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Lang.-Java" scheme="http://yoursite.com/categories/Lang-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识Elasticsearch]]></title>
    <link href="http://yoursite.com/2016/02/24/hello-Elasticsearch/"/>
    <id>http://yoursite.com/2016/02/24/hello-Elasticsearch/</id>
    <published>2016-02-24T03:58:18.000Z</published>
    <updated>2016-02-24T06:05:36.527Z</updated>
    <content type="html"><![CDATA[<p>本文仅是个人的学习笔记，有问题请指正。</p>
<h2 id="一、简介">一、简介</h2><p>在大数据领域，自从有了 Hadoop 以后，大家渐渐习惯收集日志到 HDFS 中，然后每天运行 MapReduce 任务做统计报表。<strong>但是</strong>，面对诸如“新上线的版本过去几分钟在各地反馈如何”,“昨天23:40左右这个投诉用户有没有异常”这种即时的开放性问题，传统的日志处理方案显得非常的笨拙和低效。复杂多变的实时数据分析需求，需要的是灵活快捷的响应处理，Elasticsearch的出现让这个问题得到了很好的解决！<br><a id="more"></a><br><strong>Elasticsearch</strong>是一个基于<strong>Apache Lucene</strong>的实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。</p>
<p>Elasticsearch以全文搜索、结构化搜索、分析或将这三者混合使用来提供强大的功能，目前已经有很多企业在使用它：</p>
<ol>
<li><p>国外有Wikipedia、StackOverflow、Github、Facebook、Quora、LinkedIn、Netflix等公司都在使用Elasticsearch。</p>
<ul>
<li><strong>Wikipedia</strong>使用 ES 提供全文搜索并高亮关键字，以及输入实时搜索(search-as-you-type)和搜索纠错(did-you-mean)等搜索建议功能。</li>
<li>StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。</li>
<li>Github使用Elasticsearch检索1300亿行的代码。</li>
<li>……</li>
</ul>
</li>
<li><p>国内像百度、阿里巴巴、腾讯、新浪等公司都在使用</p>
<ul>
<li>百度在casio、云分析、网盟、预测、文库、直达号、钱包、风控等业务上都应用了ES，单集群每天导入30TB+数据，总共每天60TB+。</li>
<li>……</li>
</ul>
</li>
</ol>
<p>Elasticsearch，简单点理解，就是在Lucene的基础上封装了一层分布式架构，它有如下特点：</p>
<ul>
<li>处理方式灵活。Elasticsearch 是实时全文索引，不需要像 storm 那样预先编程才能使用；</li>
<li>配置简易上手。Elasticsearch 全部采用 JSON 接口，目前业界通用的配置语法设计；</li>
<li>集群线性扩展。Elasticsearch 集群可以扩展到上百台服务器，处理PB级结构化或非结构化数据；</li>
<li>检索性能高效。虽然每次查询都是实时计算，但是优秀的设计和实现基本可以达到百亿级数据查询的秒级响应；</li>
</ul>
<h2 id="二、基本概念">二、基本概念</h2><h3 id="2-1_索引（Index）">2.1 索引（Index）</h3><p>ElasticSearch把数据存放到一个或者多个索引中。如果用关系型数据库模型对比，索引的地位与数据库实例(Database)相当。索引存放和读取的基本单元是文档（Document）。ElasticSearch内部用Apache Lucene实现索引中数据的读写。要知道，在ElasticSearch中被视为单独的一个索引，在Lucene中可能不止一个。这是因为在分布式体系中，ElasticSearch会用到分片（shards）和备份（replicas）机制将一个索引存储多份。</p>
<h3 id="2-2_文档（Document）">2.2 文档（Document）</h3><p>在ElasticSearch的世界中，文档(Document)是主要的存在实体(在Lucene中也是如此)。所有的ElasticSearch应用需求到最后都可以统一建模成一个检索模型：检索相关文档。文档(Document)由一个或者多个域(Field)组成，每个域(Field)由一个域名(此域名非彼域名)和一个或者多个值组成(有多个值的值称为多值域(multi-valued))。在ElasticSeach中，每个文档(Document)都可能会有不同的域(Field)集合；也就是说文档(Document)是没有固定的模式和统一的结构。文档(Document)之间保持结构的相似性即可(Lucene中的文档(Document)也秉持着相同的规定)。实际上，ElasticSearch中的文档(Document)就是Lucene中的文档(Document)。从客户端的角度来看，文档(Document)就是一个JSON对象(关于JSON格式的相关信息,请参看hhtp://en.wikipedia.org/wiki/JSON)。</p>
<h3 id="2-3_文档类型（Type）">2.3 文档类型（Type）</h3><p>每个文档在ElasticSearch中都必须设定它的类型。文档类型使得同一个索引中在存储结构不同文档时，只需要依据文档类型就可以找到对应的参数映射(Mapping)信息，方便文档的存取。</p>
<h3 id="2-4_节点（Node）">2.4 节点（Node）</h3><p>单独一个ElasticSearch服务器实例称为一个节点。对于许多应用场景来说，部署一个单节点的ElasticSearch服务器就足够了。但是考虑到容错性和数据过载，配置多节点的ElasticSearch集群是明智的选择。</p>
<h3 id="2-5_集群（Cluster）">2.5 集群（Cluster）</h3><p>集群是多个ElasticSearch节点的集合。这些节点齐心协力应对单个节点无法处理的搜索需求和数据存储需求。集群同时也是应对由于部分机器(节点)运行中断或者升级导致无法提供服务这一问题的利器。ElasticSearch提供的集群各个节点几乎是无缝连接(所谓无缝连接，即集群对外而言是一个整体，增加一个节点或者去掉一个节点对用户而言是透明的&lt;个人理解，仅供参考&gt;)。在ElasticSearch中配置一个集群非常简单，在我们看来，这是在与同类产品中竞争所体现出的最大优势。</p>
<h3 id="2-6_分片（Shard）">2.6 分片（Shard）</h3><p>前面已经提到，集群能够存储超出单机容量的信息。为了实现这种需求，ElasticSearch把数据分发到多个存储Lucene索引的物理机上。这些Lucene索引称为分片索引，这个分发的过程称为索引分片(Sharding)。在ElasticSearch集群中，索引分片(Sharding)是自动完成的，而且所有分片索引(Shard)是作为一个整体呈现给用户的。需要注意的是，尽管索引分片这个过程是自动的，但是在应用中需要事先调整好参数。因为集群中分片的数量需要在索引创建前配置好，而且服务器启动后是无法修改的，至少目前无法修改。</p>
<h3 id="2-7_副本（Replica）">2.7 副本（Replica）</h3><p>通过索引分片机制(Sharding)可以向ElasticSearch集群中导入超过单机容量的数据，客户端操作任意一个节点即可实现对集群数据的读写操作。当集群负载增长，用户搜索请求阻塞在单个节点上时，通过索引副本(Replica)机制就可以解决这个问题。索引副本(Replica)机制的的思路很简单：为索引分片创建一份新的拷贝，它可以像原来的主分片一样处理用户搜索请求。同时也顺便保证了数据的安全性。即如果主分片数据丢失，ElasticSearch通过索引副本使得数据不丢失。索引副本可以随时添加或者删除，所以用户可以在需要的时候动态调整其数量。</p>
<h3 id="2-8_时间之门（Gateway）">2.8 时间之门（Gateway）</h3><p>在运行的过程中，ElasticSearch会收集集群的状态、索引的参数等信息。这些数据被存储在Gateway中。</p>
<h2 id="三、文档操作">三、文档操作</h2><h3 id="3-1_插入Doc">3.1 插入Doc</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -<span class="type">XPUT</span> 'http://localhost:<span class="number">9200</span>/&#123;index&#125;/&#123;<span class="typedef"><span class="keyword">type</span>&#125;/<span class="container">&#123;<span class="title">id</span>&#125;</span>' -d </span></span><br><span class="line">'&#123;</span><br><span class="line">    <span class="string">"field"</span> : <span class="string">"content"</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>在插入的过程中index会自动创建，一个Doc由<code>_index</code>、<code>_type</code>、<code>_id</code>唯一指定（如果不指定ID，则会自动生成）。另外，在插入的过程中可以通过<code>?version=</code>、<code>?timestamp=</code>、<code>?ttl=</code>指定一些参数。具体参看《<a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-index_.html" target="_blank" rel="external">Index API</a>》</p>
<h3 id="3-2_获取Doc">3.2 获取Doc</h3><p>一个Document是由<code>_index</code>、<code>_type</code>、<code>_id</code>三个属性唯一标识。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XGET <span class="string">'http://localhost:9200/website/blog/001'</span></span><br></pre></td></tr></table></figure></p>
<p>还可以通过<code>/_source</code>只显示Doc的内容:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http:<span class="comment">//localhost:9200/website/blog/1/_source'</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">  <span class="string">"text"</span>:  <span class="string">"Just trying this out..."</span>,</span><br><span class="line">  <span class="string">"date"</span>:  <span class="string">"2014/01/01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>pretty</strong><br>在任意的查询字符串中增加pretty参数。会让Elasticsearch美化输出JSON结果以便更加容易阅读</p>
</blockquote>
<h3 id="3-3_删除Doc">3.3 删除Doc</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XDELETE <span class="string">'http://localhost:9200/twitter/tweet/1'</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4_更新Doc">3.4 更新Doc</h3><p>执行PUT操作，如果已经存在，就相当于更新操作：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'http:<span class="comment">//localhost:9200/website/blog/001' -d</span></span><br><span class="line">'&#123;</span><br><span class="line">  <span class="string">"field"</span>: <span class="string">"value"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure></p>
<p>可以看到输出结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"<span class="attribute">_index</span>": <span class="value"><span class="string">"website"</span></span>,</span><br><span class="line">"<span class="attribute">_type</span>": <span class="value"><span class="string">"blog"</span></span>,</span><br><span class="line">"<span class="attribute">_id</span>": <span class="value"><span class="string">"001"</span></span>,</span><br><span class="line">"<span class="attribute">_version</span>": <span class="value"><span class="number">2</span></span>,</span><br><span class="line">"<span class="attribute">created</span>": <span class="value"><span class="literal">false</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>created: false</code>创建失败， 是因为已经存在指定文档。</p>
<p>在内部，Elasticsearch已经标记旧文档为删除并添加了一个完整的新文档。旧版本文档不会立即消失，但你也不能去访问它。Elasticsearch会在你继续索引更多数据时清理被删除的文档。</p>
<h3 id="3-5_检查文档是否存在">3.5 检查文档是否存在</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -XHEAD <span class="string">'http://localhost:9200/website/blog/001'</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="string">Type:</span> text/plain; charset=UTF-<span class="number">8</span></span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6_Multi_Get">3.6  Multi Get</h3><p><strong>Multi Get</strong>使用关键字<code>_mget</code>，可以一次获取多个文档，而且这些文档可以跨索引、跨类型。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/_mget'</span> -d <span class="string">'&#123;</span><br><span class="line">    "</span>docs<span class="string">" : [</span><br><span class="line">        &#123;</span><br><span class="line">            "</span>_index<span class="string">" : "</span>INDEX1<span class="string">",</span><br><span class="line">            "</span>_type<span class="string">" : "</span>type<span class="string">",</span><br><span class="line">            "</span>_id<span class="string">" : "</span><span class="number">3</span><span class="string">"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "</span>_index<span class="string">" : "</span>INDEX2<span class="string">",</span><br><span class="line">            "</span>_type<span class="string">" : "</span>type<span class="string">",</span><br><span class="line">            "</span>_id<span class="string">" : "</span><span class="number">1</span><span class="string">"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/&#123;index&#125;/_mget'</span> -d <span class="string">'&#123;</span><br><span class="line">    "</span>docs<span class="string">" : [</span><br><span class="line">        &#123;</span><br><span class="line">            "</span>_type<span class="string">" : "</span>type<span class="string">",</span><br><span class="line">            "</span>_id<span class="string">" : "</span><span class="number">1</span><span class="string">"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "</span>_type<span class="string">" : "</span>type<span class="string">",</span><br><span class="line">            "</span>_id<span class="string">" : "</span><span class="number">2</span><span class="string">"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="symbol">'localhost</span>:<span class="number">9200</span>/&#123;index&#125;/&#123;<span class="class"><span class="keyword">type</span>&#125;<span class="title">/_mget</span>' <span class="title">-d</span> '&#123;</span></span><br><span class="line">    <span class="string">"ids"</span> : [<span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="3-7_Bulk">3.7 Bulk</h3><p>Bulk API使用关键字<code>_bulk</code>，允许我们通过一次请求来实现多个文档的create、index、update或delete。</p>
<p>bulk的请求结构如下：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">action</span>: &#123; metadata &#125;&#125;<span class="string">\n</span></span><br><span class="line">&#123; request body        &#125;<span class="string">\n</span></span><br><span class="line">&#123; <span class="attribute">action</span>: &#123; metadata &#125;&#125;<span class="string">\n</span></span><br><span class="line">&#123; request body        &#125;<span class="string">\n</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>加入我们把一个批量请求写在一个文件<code>bulk_format</code>中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">create</span>":<span class="value">&#123;"<span class="attribute">_index</span>":<span class="value"><span class="string">"website"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"blog"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="string">"004"</span></span>&#125;</span>&#125;</span><br><span class="line">&#123;"<span class="attribute">title</span>":<span class="value"><span class="string">"The Hero"</span></span>,"<span class="attribute">text</span>":<span class="value"><span class="string">"I have been watching the TV Series..."</span></span>,"<span class="attribute">date</span>":<span class="value"><span class="string">"2015/09/11"</span></span>&#125;</span><br><span class="line">&#123;"<span class="attribute">delete</span>":<span class="value">&#123;"<span class="attribute">_index</span>":<span class="value"><span class="string">"website"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"blog"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="string">"001"</span></span>&#125;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行批量请求（<code>--data-binary</code>保留换行符）：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl -s -<span class="constant">XPOST </span><span class="symbol">localhost:</span><span class="number">9200</span>/<span class="constant">_bulk </span>--data-binary <span class="variable">@bulk_format</span></span><br></pre></td></tr></table></figure></p>
<h2 id="四、索引操作">四、索引操作</h2><h3 id="4-1_创建索引">4.1 创建索引</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XPUT 'http:<span class="comment">//localhost:9200/twitter/'</span></span><br><span class="line"></span><br><span class="line">$ curl -XPUT 'http:<span class="comment">//localhost:9200/twitter/' -d '&#123;</span></span><br><span class="line">    <span class="string">"settings"</span> : &#123;</span><br><span class="line">        <span class="string">"number_of_shards"</span> : <span class="number">3</span>,</span><br><span class="line">        <span class="string">"number_of_replicas"</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br><span class="line"></span><br><span class="line">curl -XPUT localhost:<span class="number">9200</span>/test -d '&#123;</span><br><span class="line">    <span class="string">"settings"</span> : &#123;</span><br><span class="line">        <span class="string">"number_of_shards"</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"mappings"</span> : &#123;</span><br><span class="line">        <span class="string">"type1"</span> : &#123;</span><br><span class="line">            <span class="string">"_source"</span> : &#123; <span class="string">"enabled"</span> : <span class="keyword">false</span> &#125;,</span><br><span class="line">            <span class="string">"properties"</span> : &#123;</span><br><span class="line">                <span class="string">"field1"</span> : &#123; <span class="string">"type"</span> : <span class="string">"string"</span>, <span class="string">"index"</span> : <span class="string">"not_analyzed"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="4-2_删除索引">4.2 删除索引</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl -<span class="constant">XDELETE </span><span class="string">'http://localhost:9200/twitter/'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3_获取索引信息">4.3 获取索引信息</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET <span class="string">localhost:</span><span class="number">9200</span>/movie</span><br><span class="line"></span><br><span class="line">$ curl -XGET <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/movie/</span>_aliases</span><br><span class="line"></span><br><span class="line">$ curl -XGET <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/movie/</span>_mapping</span><br><span class="line"></span><br><span class="line">$ curl -XGET <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/movie/</span>_setting</span><br></pre></td></tr></table></figure>
<p>Get到的是索引的<code>aliases</code>、<code>mappings</code>、<code>setting</code>等信息。</p>
<h3 id="4-4_Open/Close索引">4.4 Open/Close索引</h3><p>关闭一个索引之后，将不能read/write。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="type">XPOST</span> <span class="symbol">'localhost</span>:<span class="number">9200</span>/my_index/_close'</span><br><span class="line"></span><br><span class="line">curl -<span class="type">XPOST</span> <span class="symbol">'localhost</span>:<span class="number">9200</span>/my_index/_open'</span><br></pre></td></tr></table></figure></p>
<h2 id="五、检索">五、检索</h2><h3 id="5-1_概述">5.1  概述</h3><p>ElasticSearch中的检索主要分为两类：确切值、全文检索</p>
<ul>
<li>确切值：这类检索就是给定某个field的一个确定的值或一个范围，进行完全匹配。</li>
<li>全文检索：全文检索会计算每个文档与查询语句的相关性，会给出一个相关性评分<code>_score</code>。</li>
</ul>
<p>在Elasticsearch中，每一个字段的数据都是默认被索引的，用于快速检索。字段是否被索引由<code>&quot;index&quot;</code>参数控制，它的取值有三个：</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">analyzed</td>
<td style="text-align:center">首先分析这个字符串，然后索引。换言之，以全文形式索引此字段。</td>
</tr>
<tr>
<td style="text-align:center">not_analyzed</td>
<td style="text-align:center">索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段。</td>
</tr>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:center">不索引这个字段。这个字段不能为搜索到。</td>
</tr>
</tbody>
</table>
<p><code>string</code>类型字段默认值是<code>analyzed</code>，用于全文检索。其他简单类型——<code>long</code>、<code>double</code>、<code>date</code>等只能取<code>no</code>和<code>not_analyzed</code>，它们的值不能被分析。</p>
<p><img src="http://img.blog.csdn.net/20160224101136930" alt=""></p>
<p>对于string型字段，在被分析之后，所得的结果（单词）会用来建立<strong>倒排索引</strong>。在进行检索时，检索字符串也会经过相同的<strong>分析器</strong>，然后用所得的结果在倒排索引中进行匹配，匹配的越多相关性<code>_score</code>打分越高。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -<span class="type">XGET</span> <span class="symbol">'localhost</span>:<span class="number">9200</span>/_analyze?analyzer=standard&amp;pretty' -d <span class="symbol">'The</span> quick brown foxes jumped over the <span class="keyword">lazy</span> dog'</span><br></pre></td></tr></table></figure>
<h3 id="5-2_检索API">5.2 检索API</h3><p>搜索的关键字是<code>_search</code>，我们可以跨索引、跨类型进行搜索（假设<code>gb</code>，<code>us</code>是索引，<code>user</code>,<code>tweet</code>是类型）：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/_search         <span class="comment"># 在所有索引的所有类型中搜索</span></span><br><span class="line"></span><br><span class="line">/gb/_search      <span class="comment"># 在索引gb的所有类型中搜索</span></span><br><span class="line"></span><br><span class="line">/gb,us/_search   <span class="comment"># 在索引gb和us的所有类型中搜索</span></span><br><span class="line"></span><br><span class="line">/g*,u*/_search   <span class="comment"># 在以g或u开头的索引的所有类型中搜索</span></span><br><span class="line"></span><br><span class="line">/gb/<span class="built_ins">user</span>/_search  <span class="comment"># 在索引gb的类型user中搜索</span></span><br><span class="line"></span><br><span class="line">/gb,us/<span class="built_ins">user</span>,tweet/_search  <span class="comment"># 在索引gb和us的类型为user和tweet中搜索</span></span><br><span class="line"></span><br><span class="line">/_all/<span class="built_ins">user</span>,tweet/_search   <span class="comment"># 在所有索引中的搜索类型user和tweet的文档</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>利用字符串查询</strong></p>
</blockquote>
<p>通过查询字符串进行搜索就是 通过HTTP参数传递查询的关键字：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/movie/</span>_search?q=runtime:<span class="number">90</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>q：查询</li>
<li>fields：指定返回的字段</li>
<li>timeout：指定超时时间</li>
<li>size：指定返回的结果数</li>
<li>sort：指定按某字段排序，<code>fieldName:desc/asc</code></li>
<li>analyzer：指定分析器</li>
</ul>
<blockquote>
<p><strong>利用DSL查询（结构化查询语句）</strong></p>
</blockquote>
<p>所谓<strong>结构化查询语句</strong>是指通过JSON请求体来指定查询条件。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:<span class="number">9200</span>/movie/info/_search -d <span class="string">'&#123;</span><br><span class="line">  "</span>query<span class="string">": &#123;</span><br><span class="line">    "</span>term<span class="string">": &#123;</span><br><span class="line">      "</span>runtime<span class="string">": 90</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>Elasticsearch检索分为两部分：<strong>Query</strong> 和 <strong>Filter</strong>。两者的区别在于：filter是不计算相关性的，同时可以cache。因此，filter速度要快于query。</p>
<ul>
<li><strong>from/size</strong>：用于结果分页，默认from 0 , size 10</li>
<li><strong>sort</strong>：根据一个或多个字段进行排序</li>
<li><strong>fields</strong>：只返回每个结果的指定字段</li>
</ul>
<p>常用的查询过滤语句:</p>
<ul>
<li><p><strong>query</strong>：</p>
<ul>
<li>term : 主要用于精确匹配哪些值，比如数字，日期，布尔值或 not_analyzed的字符串(未经分析的文本数据类型)</li>
<li>terms : 跟 term 类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去做匹配。</li>
<li>match : 标准查询，不管你需要全文本查询还是精确查询基本上都可以用它。</li>
<li>multi_match：在match查询的基础上同时搜索多个字段</li>
<li>match_all : 空查询，返回所有文档</li>
<li>range ： 范围查询</li>
<li>regexp ：正则匹配</li>
<li>prefix ： 前缀匹配</li>
<li>ids：根据id查询文档</li>
<li>filtered：通过 filtered 可以在请求体中同时包含 <code>&quot;query&quot;</code> 和 <code>&quot;filter&quot;</code> 子句。</li>
<li>bool ： 一种复合查询，把其余类型的查询包裹进来。支持<code>must</code>（相当于<code>AND</code>），<code>must_not</code>（相当于<code>NOT</code>），<code>should</code>（相当于<code>OR</code>）。</li>
</ul>
</li>
<li><p><strong>filter</strong>：</p>
<ul>
<li>同上</li>
<li>and</li>
<li>or</li>
<li>not</li>
</ul>
</li>
</ul>
<h3 id="5-3-_聚合（Aggregation）">5.3. 聚合（Aggregation）</h3><p>假设有一个索引 movie 存储了一组电影相关信息，格式如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">name</span>": <span class="value"><span class="string">"Avengers: Age of Ultron"</span></span>,</span><br><span class="line">    "<span class="attribute">rating</span>": <span class="value"><span class="number">7.8</span></span>,</span><br><span class="line">    "<span class="attribute">description</span>": <span class="value"><span class="string">"When Tony Stark and Bruce Banner try to jump-start a dormant peacekeeping..."</span></span>,</span><br><span class="line">    "<span class="attribute">stars</span>": <span class="value">[<span class="string">"Joss Whedon"</span>,<span class="string">"Robert Downey Jr"</span>,<span class="string">"Chris Evans"</span>,<span class="string">"Mark Ruffalo"</span>]</span>,</span><br><span class="line">    "<span class="attribute">type</span>": <span class="value">[<span class="string">"Action"</span>,<span class="string">"Adventure"</span>,<span class="string">"Sci-Fi"</span>]</span>,</span><br><span class="line">    "<span class="attribute">runtime</span>": <span class="value"><span class="number">141</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>Min Aggregation</strong>：找出播放时间最短的电影</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>min_runtime<span class="string">": &#123; </span><br><span class="line">			"</span><span class="built_in">min</span><span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>runtime<span class="string">"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Max Aggregation</strong>：找出评分最高的电影</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>max_rating<span class="string">": &#123; </span><br><span class="line">			"</span>max<span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>rating<span class="string">"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Sum Aggregation</strong>：求所有电影的播放时间的总和</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>intraday_return<span class="string">": &#123; </span><br><span class="line">			"</span><span class="built_in">sum</span><span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>runtime<span class="string">"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Avg Aggregation</strong>：求所有电影的平均评分</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>avg_rating<span class="string">": &#123; </span><br><span class="line">			"</span>avg<span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>rating<span class="string">"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Stats Aggregation</strong>：统计所有电影的rating字段，包括min，max，sum，avg.</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>ratings_stats<span class="string">": &#123; </span><br><span class="line">			"</span>stats<span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>rating<span class="string">"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Filter Aggregation</strong>：先条件过滤再求平均。（搜索+聚合）</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>runtime_products<span class="string">": &#123;</span><br><span class="line">			"</span>filter<span class="string">":&#123;"</span>term<span class="string">":&#123;"</span>runtime<span class="string">":90&#125;&#125;, </span><br><span class="line">			"</span>aggs<span class="string">" : &#123;</span><br><span class="line">				"</span>avg_rating<span class="string">":&#123;</span><br><span class="line">					"</span>avg<span class="string">":&#123;"</span>field<span class="string">":"</span>rating<span class="string">"&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Terms Aggregation</strong>：统计各种类型的电影的数量。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>types<span class="string">": &#123; </span><br><span class="line">			"</span>terms<span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>type<span class="string">"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Range Aggregation</strong>：统计评分在小于3、3到5、5到8、8到10的电影的数量。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>rating_ranges<span class="string">": &#123; </span><br><span class="line">			"</span>range<span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>rating<span class="string">",</span><br><span class="line">				"</span>ranges<span class="string">":[</span><br><span class="line">					&#123;"</span>to<span class="string">":3&#125;,</span><br><span class="line">					&#123;"</span>from<span class="string">":3,"</span>to<span class="string">":5&#125;,</span><br><span class="line">					&#123;"</span>from<span class="string">":5,"</span>to<span class="string">":8&#125;,</span><br><span class="line">					&#123;"</span>from<span class="string">":8,"</span>to<span class="string">":10&#125;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Histogram Aggregation</strong>：以3为步长，统计评分在0-3、3-6、6-9、9-12的电影的数量。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/movie/_search?fields=aggregations&amp;pretty'</span> -d <span class="string">'</span><br><span class="line">&#123;</span><br><span class="line">	"</span>aggs<span class="string">" : &#123;</span><br><span class="line">		"</span>ratings<span class="string">": &#123; </span><br><span class="line">			"</span>histogram<span class="string">" : &#123;</span><br><span class="line">				"</span>field<span class="string">":"</span>rating<span class="string">",</span><br><span class="line">				"</span>interval<span class="string">":3</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="六、集群管理与监控">六、集群管理与监控</h2><h3 id="6-1_监控">6.1 监控</h3><p>cluster级别的API总是以<code>http://localhost:9200/_cluster/</code>开头。</p>
<p><strong>6.1.1、查看集群 health 状态</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http:<span class="comment">//localhost:9200/_cluster/health?pretty'</span></span><br><span class="line"></span><br><span class="line">#也可以查看某个索引的 health 状态：</span><br><span class="line"></span><br><span class="line">curl -XGET 'http:<span class="comment">//localhost:9200/_cluster/health/movie'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6.1.2、查看集群state</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http://localhost:<span class="number">9200</span>/_cluster/<span class="keyword">state</span>'</span><br></pre></td></tr></table></figure>
<p>该命令会输出所有的nodes和shards的状态信息，但是由于太多，可读性不高。</p>
<p><strong>6.1.3. 查看集群的stats</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/_cluster/</span>stats</span><br></pre></td></tr></table></figure>
<p>统计信息包括shards、nodes、docs、store、还有操作系统CPU、内存、进程、JVM、文件系统等相关统计信息。</p>
<p><strong>6.1.4. 查看节点的stats</strong><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XGET <span class="string">'http://localhost:9200/_nodes/stats'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6.1.5. 查看节点信息</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XGET <span class="string">'http://localhost:9200/_nodes'</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2_格式化输出">6.2 格式化输出</h3><p>ElasticSearch提供了<code>_cat</code>命令用以格式化输出，将JSON结果以列表的形式输出。</p>
<p><strong>输出集群健康状态：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/health'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出当前的master节点：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/master'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出所有的nodes信息：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/nodes'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出所有doc数：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/count'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出索引别名：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/aliases?v'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出所有索引的状态和统计数据：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/indices'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出每个节点的shards分配情况：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/allocation'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出每个shard的统计信息：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/shards'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出当前recovery的进度：</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl <span class="string">'localhost:9200/_cat/recovery'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-3_集群管理">6.3 集群管理</h3><p><strong>6.3.1、重定向（reroute）</strong></p>
<p>重定向是指手动控制shard的分布，包括三种操作：</p>
<ul>
<li><strong>移动（move）</strong>:把分片从一节点移动到另一个节点。可以指定索引名和分片号。 </li>
<li><strong>取消（cancel）</strong>:取消分配一个分片。可以指定索引名和分片号。node参数可以指定在那个节点取消正在分配的分片。allow_primary参数支持取消分配主分片。 </li>
<li><strong>分配（allocate）</strong>:分配一个未分配的分片到指定节点。可以指定索引名和分片号。node参数指定分配到那个节点。allow_primary参数可以强制分配主分片，不过这样可能导致数据丢失。 <figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XPOST <span class="string">'localhost:9200/_cluster/reroute'</span> -d <span class="string">'</span><br><span class="line">    &#123;"</span>commands<span class="string">":[&#123;</span><br><span class="line">        "</span>move<span class="string">":&#123;</span><br><span class="line">            "</span>index<span class="string">":"</span>movie<span class="string">",</span><br><span class="line">            "</span>shard<span class="string">":2,</span><br><span class="line">            "</span>from_node<span class="string">":"</span><span class="transposed_variable">eng1.</span><span class="transposed_variable">lycc.</span><span class="transposed_variable">eseng2.</span><span class="number">09</span><span class="string">",</span><br><span class="line">            "</span>to_node<span class="string">":"</span><span class="transposed_variable">eng1.</span><span class="transposed_variable">lycc.</span><span class="transposed_variable">eseng2.</span><span class="number">08</span><span class="string">"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>6.3.2、关闭（shutdown）</strong></p>
<p>关闭所有节点<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XPOST <span class="string">'http://localhost:9200/_shutdown'</span></span><br></pre></td></tr></table></figure></p>
<p>关闭指定节点<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XPOST <span class="string">'http://localhost:9200/_cluster/nodes/nodeId1,nodeId2/_shutdown'</span></span><br></pre></td></tr></table></figure></p>
<p>延迟关闭<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curl</span> -XPOST <span class="string">'http://localhost:9200/_cluster/nodes/_local/_shutdown?delay=10s'</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文仅是个人的学习笔记，有问题请指正。</p>
<h2 id="一、简介">一、简介</h2><p>在大数据领域，自从有了 Hadoop 以后，大家渐渐习惯收集日志到 HDFS 中，然后每天运行 MapReduce 任务做统计报表。<strong>但是</strong>，面对诸如“新上线的版本过去几分钟在各地反馈如何”,“昨天23:40左右这个投诉用户有没有异常”这种即时的开放性问题，传统的日志处理方案显得非常的笨拙和低效。复杂多变的实时数据分析需求，需要的是灵活快捷的响应处理，Elasticsearch的出现让这个问题得到了很好的解决！<br>]]>
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://yoursite.com/tags/Elasticsearch/"/>
    
      <category term="Lucene" scheme="http://yoursite.com/tags/Lucene/"/>
    
      <category term="大数据-Elasticsearch" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用linux系统监控命令]]></title>
    <link href="http://yoursite.com/2015/09/05/linux-monitor-tools/"/>
    <id>http://yoursite.com/2015/09/05/linux-monitor-tools/</id>
    <published>2015-09-05T15:49:40.000Z</published>
    <updated>2015-09-05T16:28:51.793Z</updated>
    <content type="html"><![CDATA[<h1 id="一、内存监控">一、内存监控</h1><p>监控内存的使用状态是非常重要的，通过监控有助于了解内存的使用状态，比如内存占用是否正常，内存是否紧缺等等，监控内存最常使用的命令有free、vmstat、top等</p>
<h2 id="1-1_free">1.1 free</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="string">Mem:</span>      <span class="number">32872632</span>   <span class="number">12393128</span>   <span class="number">20479504</span>          <span class="number">0</span>      <span class="number">23308</span>    <span class="number">7496048</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="string">cache:</span>    <span class="number">4873772</span>   <span class="number">27998860</span></span><br><span class="line"><span class="string">Swap:</span>            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第一行（Mem）：<a id="more"></a></p>
<ul>
<li><strong>total</strong>：内存总数 32872632 KB</li>
<li><strong>used</strong>：已使用的内存数 12393128 KB</li>
<li><strong>free</strong>：空闲的内存数 20479504 KB</li>
<li><strong>shared</strong>：多个进程共享的内存，总是0</li>
<li><strong>buffers</strong>：缓存内存数 23308 KB</li>
<li><strong>cached</strong>：缓存内存数 7496048 KB</li>
</ul>
<p>第二行（-/+ buffers/cache）：</p>
<ul>
<li><strong>used</strong>：第一行Mem中的 <strong>used - buffers - cached</strong> = 12393128 - 23308 - 7496048 = <strong>4873772</strong> KB</li>
<li><strong>free</strong>：第一行Mem中的 <strong>free + buffers + cached</strong> = 20479504 + 23308 + 7496048 = <strong>27998860</strong> KB</li>
<li>可见这一行【used-buffers/cache】反映的是被程序实实在在吃掉的内存，【used+buffers/cache】反映的是可以挪用的内存总数。</li>
</ul>
<p>第三行（Swap）：表示交换分区的内存使用状态。</p>
<blockquote>
<p>第一行内存状态是对于<strong>操作系统</strong>来说的，buffers/cached 都是属于被使用。</p>
<p>第二行内存状态是对于<strong>应用程序</strong>来说的，对于应用程序来说，buffers/cached占有的内存是可用的，因为buffers/cached是为了提高程序执行的性能，当应用程序需要用到内存的时候buffers/cached会很快地被回收，以供应用程序使用。</p>
<p>通常我们是从应用的角度来看的，所以只看第二行就行了。</p>
</blockquote>
<p>另外，我们可以使用参数<code>-m</code>、<code>-g</code>来以<code>MB</code>、<code>GB</code>单位显示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="string">Mem:</span>         <span class="number">32102</span>      <span class="number">12104</span>      <span class="number">19998</span>          <span class="number">0</span>         <span class="number">22</span>       <span class="number">7320</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="string">cache:</span>       <span class="number">4760</span>      <span class="number">27341</span></span><br><span class="line"><span class="string">Swap:</span>            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-2_vmstat">1.2 vmstat</h2><p><strong>vmstat（Virtual Meomory Statistics，虚拟内存统计）</strong>是对系统的整体情况进行统计，包括内核进程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vmstat <span class="number">2</span> <span class="number">100</span>      <span class="comment"># 2表示刷新间隔，100表示输出次数</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">procs</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">memory</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">swap</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">io</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">system</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">cpu</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"> <span class="comment">r</span>  <span class="comment">b</span>   <span class="comment">swpd</span>   <span class="comment">free</span>   <span class="comment">buff</span>  <span class="comment">cache</span>   <span class="comment">si</span>   <span class="comment">so</span>    <span class="comment">bi</span>    <span class="comment">bo</span>   <span class="comment">in</span>   <span class="comment">cs</span> <span class="comment">us</span> <span class="comment">sy</span> <span class="comment">id</span> <span class="comment">wa</span> <span class="comment">st</span></span><br><span class="line"> <span class="comment">2</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192532</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">2</span>     <span class="comment">1</span>   <span class="comment">20</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">31</span>   <span class="comment">35</span>  <span class="comment">0</span>  <span class="comment">1</span> <span class="comment">99</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">23</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">22</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">22</span>   <span class="comment">31</span>  <span class="comment">0</span>  <span class="comment">1</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">21</span>   <span class="comment">29</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">21</span>   <span class="comment">30</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0	</span></span><br><span class="line"> <span class="comment">0</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">192492</span>  <span class="comment">91788</span>  <span class="comment">88812</span>    <span class="comment">0</span>    <span class="comment">0</span>     <span class="comment">0</span>     <span class="comment">0</span>   <span class="comment">21</span>   <span class="comment">28</span>  <span class="comment">0</span>  <span class="comment">0</span> <span class="comment">100</span>  <span class="comment">0</span>  <span class="comment">0</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1）procs</strong></p>
<ul>
<li><strong>r列</strong>表示运行和等待CPU时间片的进程数，这个值如果长期大于系统CPU个数，就说明CPU资源不足，可以考虑增加CPU；</li>
<li><strong>b列</strong>表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</li>
</ul>
<p><strong>2）memory</strong></p>
<ul>
<li><strong>swpd列</strong>表示切换到内存交换区的内存数量（以KB为单位）。如果swpd的值不为0或者比较大，而且si、so的值长期为0，那么这种情况一般不用担心，不会影响系统性能；</li>
<li><strong>free列</strong>表示当前空闲的物理内存数量（以KB为单位）；</li>
<li><strong>buff列</strong>表示buffers cache的内存数量，一般对块设备的读写才需要缓冲；</li>
<li><strong>cache列</strong>表示page cached的内存数量，一般作文件系统的cached，频繁访问的文件都会被cached。如果cached值较大，就说明cached文件数较多。如果此时IO中的bi比较小，就说明文件系统效率比较好。</li>
</ul>
<p><strong>3）swap</strong></p>
<ul>
<li><strong>si列</strong>表示由磁盘调入内存，也就是内存进入内存交换区的数量；</li>
<li><strong>so列</strong>表示由内存调入磁盘，也就是内存交换区进入内存的数量</li>
<li>一般情况下，si、so的值都为0，如果si、so的值长期不为0，则表示系统内存不足，需要考虑是否增加系统内存。</li>
</ul>
<p><strong>4）IO</strong></p>
<ul>
<li><strong>bi列</strong>表示从块设备读入的数据总量（即读磁盘，单位KB/秒）</li>
<li><strong>bo列</strong>表示写入到块设备的数据总量（即写磁盘，单位KB/秒）<br>这里设置的bi+bo参考值为1000，如果超过1000，而且wa值比较大，则表示系统磁盘IO性能瓶颈。</li>
</ul>
<p><strong>5）system</strong></p>
<ul>
<li><strong>in列</strong>表示在某一时间间隔中观察到的每秒设备中断数；</li>
<li><strong>cs列</strong>表示每秒产生的上下文切换次数。<br>上面这两个值越大，会看到内核消耗的CPU时间就越多。</li>
</ul>
<p><strong>6）CPU</strong></p>
<ul>
<li><strong>us列</strong>显示了用户进程消耗CPU的时间百分比。us的值比较高时，说明用户进程消耗的CPU时间多，如果长期大于50%，需要考虑优化程序啥的。</li>
<li><strong>sy列</strong>显示了内核进程消耗CPU的时间百分比。sy的值比较高时，说明内核消耗的CPU时间多；如果us+sy超过80%，就说明CPU的资源存在不足。</li>
<li><strong>id列</strong>显示了CPU处在空闲状态的时间百分比；</li>
<li><strong>wa列</strong>表示IO等待所占的CPU时间百分比。wa值越高，说明IO等待越严重。如果wa值超过20%，说明IO等待严重。</li>
<li><strong>st列</strong>一般不关注，虚拟机占用的时间百分比。</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat -s      <span class="comment"># 查看内存使用的详细信息</span></span><br><span class="line"></span><br><span class="line">     <span class="number">32872632</span>  total memory</span><br><span class="line">     <span class="number">25946240</span>  used memory</span><br><span class="line">     <span class="number">21298968</span>  active memory</span><br><span class="line">      <span class="number">3228124</span>  inactive memory</span><br><span class="line">      <span class="number">6926392</span>  free memory</span><br><span class="line">        <span class="number">79764</span>  buffer memory</span><br><span class="line">      <span class="number">6767888</span>  swap cache</span><br><span class="line">            <span class="number">0</span>  total swap</span><br><span class="line">            <span class="number">0</span>  used swap</span><br><span class="line">            <span class="number">0</span>  free swap</span><br><span class="line">   <span class="number">5625247020</span> non-nice user cpu <span class="built_in">ticks</span></span><br><span class="line">        <span class="number">75476</span> nice user cpu <span class="built_in">ticks</span></span><br><span class="line">   <span class="number">3961269668</span> <span class="keyword">system</span> cpu <span class="built_in">ticks</span></span><br><span class="line"> <span class="number">228172341381</span> idle cpu <span class="built_in">ticks</span></span><br><span class="line">   <span class="number">1685706618</span> IO-<span class="built_in">wait</span> cpu <span class="built_in">ticks</span></span><br><span class="line">        <span class="number">11227</span> IRQ cpu <span class="built_in">ticks</span></span><br><span class="line">    <span class="number">537233093</span> softirq cpu <span class="built_in">ticks</span></span><br><span class="line">            <span class="number">0</span> stolen cpu <span class="built_in">ticks</span></span><br><span class="line"> <span class="number">817859502644</span> pages paged <span class="operator">in</span></span><br><span class="line"> <span class="number">874791545051</span> pages paged out</span><br><span class="line">            <span class="number">0</span> pages swapped <span class="operator">in</span></span><br><span class="line">            <span class="number">0</span> pages swapped out</span><br><span class="line">   <span class="number">1845948435</span> interrupts</span><br><span class="line">   <span class="number">2656703667</span> CPU context switches</span><br><span class="line">   <span class="number">1341191961</span> boot <span class="built_in">time</span></span><br><span class="line">   <span class="number">1691075642</span> forks</span><br></pre></td></tr></table></figure>
<p>上面的信息主要来自于<code>/proc/meminfo</code>，<code>/proc/stat</code>和<code>/proc/vmstat</code>。</p>
<p><br></p>
<h1 id="二、CPU监控">二、CPU监控</h1><h2 id="2-1_top">2.1 top</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况及总体状况，类似于Windows的任务管理器。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">20</span>:<span class="number">32</span>:<span class="number">28</span> up <span class="number">1149</span> days, <span class="number">11</span>:<span class="number">13</span>,  <span class="number">2</span> users,  load average: <span class="number">2.97</span>, <span class="number">2.42</span>, <span class="number">1.67</span></span><br><span class="line">Tasks: <span class="number">671</span> total,   <span class="number">1</span> running, <span class="number">669</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">1</span> zombie</span><br><span class="line">Cpu(s):  <span class="number">0.2</span><span class="variable">%us</span>,  <span class="number">0.1</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Mem:  <span class="number">32872632</span>k total, <span class="number">12336240</span>k used, <span class="number">20536392</span>k free,    <span class="number">23064</span>k buffers</span><br><span class="line">Swap:        <span class="number">0</span>k total,        <span class="number">0</span>k used,        <span class="number">0</span>k free,  <span class="number">7441684</span>k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S <span class="variable">%CPU</span> <span class="variable">%MEM</span>    TIME+  COMMAND</span><br><span class="line"> <span class="number">2543</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">9204</span>  <span class="number">636</span>  <span class="number">396</span> S  <span class="number">0.7</span>  <span class="number">0.0</span> <span class="number">614</span>:<span class="number">57.76</span> irqbalance</span><br><span class="line"> <span class="number">4279</span> work      <span class="number">20</span>   <span class="number">0</span> <span class="number">15.8</span>g <span class="number">1.4</span>g  <span class="number">10</span>m S  <span class="number">0.7</span>  <span class="number">4.6</span> <span class="number">121</span>:<span class="number">19.27</span> java  </span><br><span class="line"><span class="number">11761</span> work      <span class="number">20</span>   <span class="number">0</span>  <span class="number">153</span>m <span class="number">7192</span> <span class="number">1080</span> S  <span class="number">0.7</span>  <span class="number">0.0</span> <span class="number">642</span>:<span class="number">26.65</span> <span class="keyword">python</span></span><br></pre></td></tr></table></figure>
<p>第一行：</p>
<ul>
<li><strong>20:32:28</strong>： 当前时间</li>
<li><strong>up 1149 days, 11:13</strong>：系统运行时间，系统已经运行了1149天11小时13分钟了。</li>
<li><strong>2 users</strong>：当前登录用户数</li>
<li><strong>load average</strong>：系统负载，即任务队列的平均长度。三个数值分别为最近1分钟、最近5分钟、最近15分钟的平均负载 —— 超过N（CPU核数）说明系统满负荷运行。也可以通过<code>$w</code>或<code>$uptime</code>命令查看load average。</li>
</ul>
<p>第二行：</p>
<ul>
<li>显示进程总数、正在运行的进程数、休眠的进程数、停止的进程数、僵尸进程数</li>
</ul>
<p>第三行：</p>
<ul>
<li><strong>%us</strong>：用户进程消耗的CPU百分比</li>
<li><strong>%sy</strong>：内核进程消耗的CPU百分比</li>
<li><strong>%ni</strong>：改变过优先级的进程占用CPU的百分比</li>
<li><strong>%id</strong>：空闲CPU的百分比</li>
<li><strong>%wa</strong>：IO等待消耗的CPU百分比</li>
</ul>
<p>按”1”查看单个CPU的状况：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">20</span>:<span class="number">32</span>:<span class="number">49</span> up <span class="number">1149</span> days, <span class="number">11</span>:<span class="number">13</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks: <span class="number">671</span> total,   <span class="number">1</span> running, <span class="number">669</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">1</span> zombie</span><br><span class="line">Cpu0  :  <span class="number">1.0</span><span class="variable">%us</span>,  <span class="number">0.7</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">98.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu1  :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu2  :  <span class="number">0.7</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu3  :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu4  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu5  :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu6  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu7  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu8  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu9  :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu10 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu11 :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu12 :  <span class="number">1.0</span><span class="variable">%us</span>,  <span class="number">0.3</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">98.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu13 :  <span class="number">0.3</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.7</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu14 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu15 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu16 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu17 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu18 :  <span class="number">0.7</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">99.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu19 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu20 :  <span class="number">0.7</span><span class="variable">%us</span>,  <span class="number">1.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>, <span class="number">98.3</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu21 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu22 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Cpu23 :  <span class="number">0.0</span><span class="variable">%us</span>,  <span class="number">0.0</span><span class="variable">%sy</span>,  <span class="number">0.0</span><span class="variable">%ni</span>,<span class="number">100.0</span><span class="variable">%id</span>,  <span class="number">0.0</span><span class="variable">%wa</span>,  <span class="number">0.0</span><span class="variable">%hi</span>,  <span class="number">0.0</span><span class="variable">%si</span>,  <span class="number">0.0</span><span class="variable">%st</span></span><br><span class="line">Mem:  <span class="number">32872632</span>k total, <span class="number">12336360</span>k used, <span class="number">20536272</span>k free,    <span class="number">23080</span>k buffers</span><br><span class="line">Swap:        <span class="number">0</span>k total,        <span class="number">0</span>k used,        <span class="number">0</span>k free,  <span class="number">7441976</span>k cached</span><br></pre></td></tr></table></figure></p>
<p>另外，下面的命令可以查看CPU的核数：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep 'model name' /<span class="keyword">proc</span>/cpuinfo | wc -l</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-2_mpstat">2.2 mpstat</h2><p><strong>mpstat（Multiprocessor Statistics，多处理器统计）</strong>是实时系统监控工具，它会报告与CPU相关的统计信息，这些信息存放在/proc/stat文件中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mpstat -<span class="constant">P ALL </span><span class="number">2</span>        <span class="comment"># ALL表示显示所有CPUs，也可以指定某个CPU；2表示刷新间隔</span></span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Linux <span class="number">2.6</span>.32-<span class="number">2.0</span>.0.1 (localhost) 	<span class="number">2015</span>年<span class="number">09</span>月<span class="number">05</span>日 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">35</span>秒  CPU    <span class="variable">%usr</span>   <span class="variable">%nice</span>    <span class="variable">%sys</span> <span class="variable">%iowait</span>    <span class="variable">%irq</span>   <span class="variable">%soft</span>  <span class="variable">%steal</span>  <span class="variable">%guest</span>   <span class="variable">%idle</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒  all    <span class="number">0.23</span>    <span class="number">0.00</span>    <span class="number">0.12</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.65</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">0</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">1</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">2</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">3</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">4</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">5</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">6</span>    <span class="number">1.01</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">98.99</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">7</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">8</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒    <span class="number">9</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">10</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">11</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">12</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">13</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">14</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">15</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">16</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">17</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">18</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">19</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">20</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">21</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">1.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">98.00</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">22</span>    <span class="number">0.50</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">99.50</span></span><br><span class="line"><span class="number">18</span>时<span class="number">52</span>分<span class="number">37</span>秒   <span class="number">23</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>  <span class="number">100.00</span></span><br></pre></td></tr></table></figure>
<p>至于各百分比的含义前面已经介绍过了，这里就不再赘述。</p>
<p><br></p>
<h1 id="三、网络监控">三、网络监控</h1><h2 id="3-1_ethtool">3.1 ethtool</h2><p>使用<code>ethtool</code>查看网卡带宽，需要root权限：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># ethtool eth0</span><br><span class="line">Settings <span class="keyword">for</span> <span class="string">eth0:</span></span><br><span class="line">	Supported <span class="string">ports:</span> [ TP ]</span><br><span class="line">	Supported link <span class="string">modes:</span>   <span class="number">10</span>baseT<span class="regexp">/Half 10baseT/</span>Full </span><br><span class="line">	                        <span class="number">100</span>baseT<span class="regexp">/Half 100baseT/</span>Full </span><br><span class="line">	                        <span class="number">1000</span>baseT/Full </span><br><span class="line">	Supports auto-<span class="string">negotiation:</span> Yes</span><br><span class="line">	Advertised link <span class="string">modes:</span>  <span class="number">10</span>baseT<span class="regexp">/Half 10baseT/</span>Full </span><br><span class="line">	                        <span class="number">100</span>baseT<span class="regexp">/Half 100baseT/</span>Full </span><br><span class="line">	                        <span class="number">1000</span>baseT/Full </span><br><span class="line">	Advertised pause frame <span class="string">use:</span> No</span><br><span class="line">	Advertised auto-<span class="string">negotiation:</span> Yes</span><br><span class="line"><span class="label">	Speed:</span> <span class="number">1000</span>Mb/s</span><br><span class="line"><span class="label">	Duplex:</span> Full</span><br><span class="line"><span class="label">	Port:</span> Twisted Pair</span><br><span class="line"><span class="label">	PHYAD:</span> <span class="number">1</span></span><br><span class="line"><span class="label">	Transceiver:</span> internal</span><br><span class="line">	Auto-<span class="string">negotiation:</span> on</span><br><span class="line">	MDI-<span class="string">X:</span> Unknown</span><br><span class="line">	Supports Wake-<span class="string">on:</span> pumbg</span><br><span class="line">	Wake-<span class="string">on:</span> g</span><br><span class="line">	Current message <span class="string">level:</span> <span class="number">0x00000003</span> (<span class="number">3</span>)</span><br><span class="line">	Link <span class="string">detected:</span> yes</span><br></pre></td></tr></table></figure></p>
<p>可以看出网卡<code>eth0</code>的带宽为1000Mbps（兆比特每秒），所以理论上的网速极限为<strong>1000÷8 = 125MB/s</strong>。</p>
<h2 id="3-2_sar">3.2 sar</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sar -n <span class="constant">DEV </span><span class="number">3</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV <span class="number">3</span> <span class="number">100</span></span><br><span class="line">Linux <span class="number">2.6</span>.32-<span class="number">2.0</span>.0.1 (localhost) 	<span class="number">08</span><span class="regexp">/25/</span><span class="number">2015</span> 	_x86_64_	(<span class="number">24</span> CPU)</span><br><span class="line"><span class="label"></span><br><span class="line">08:</span><span class="number">37</span>:<span class="number">55</span> PM     IFACE   rxpck<span class="regexp">/s   txpck/</span>s    rxkB<span class="regexp">/s    txkB/</span>s   rxcmp<span class="regexp">/s   txcmp/</span>s  rxmcst/s</span><br><span class="line"><span class="number">08</span>:<span class="number">37</span>:<span class="number">58</span> PM        lo      <span class="number">2.01</span>      <span class="number">2.01</span>      <span class="number">0.44</span>      <span class="number">0.44</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">37</span>:<span class="number">58</span> PM      eth0      <span class="number">5.35</span>      <span class="number">0.00</span>      <span class="number">0.49</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">37</span>:<span class="number">58</span> PM      eth1     <span class="number">12.04</span>      <span class="number">3.01</span>      <span class="number">0.95</span>      <span class="number">0.86</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="label"></span><br><span class="line">08:</span><span class="number">37</span>:<span class="number">58</span> PM     IFACE   rxpck<span class="regexp">/s   txpck/</span>s    rxkB<span class="regexp">/s    txkB/</span>s   rxcmp<span class="regexp">/s   txcmp/</span>s  rxmcst/s</span><br><span class="line"><span class="number">08</span>:<span class="number">38</span>:<span class="number">01</span> PM        lo      <span class="number">9.00</span>      <span class="number">9.00</span>      <span class="number">2.52</span>      <span class="number">2.52</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">38</span>:<span class="number">01</span> PM      eth0     <span class="number">17.33</span>      <span class="number">0.00</span>      <span class="number">1.02</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">08</span>:<span class="number">38</span>:<span class="number">01</span> PM      eth1     <span class="number">24.33</span>     <span class="number">12.67</span>      <span class="number">3.04</span>      <span class="number">6.48</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<ul>
<li>IFACE：网络设备的名称</li>
<li>rxpck/s：每秒钟接收到的包数目</li>
<li>txpck/s：每秒钟发送出去的包数目</li>
<li>rxkB/s：每秒钟接收到的字节数</li>
<li>txkB/s：每秒钟发送出去的字节数</li>
</ul>
<h2 id="3-3_netstat">3.3 netstat</h2><p><code>netstat</code>命令一般用于检验本机各端口的网络连接情况，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据。</p>
<p>部分选项如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a, --all, --listening     显示所有连接中的<span class="constant">Socket</span>。</span><br><span class="line"></span>-<span class="ruby">n, --numeric              以数字形式显示地址和端口号。</span><br><span class="line"></span>-<span class="ruby">t, -–tcp                  显示<span class="constant">TCP</span>传输协议的连线状况。</span><br><span class="line"></span>-<span class="ruby">u, -–udp                  显示<span class="constant">UDP</span>传输协议的连线状况。</span><br><span class="line"></span>-<span class="ruby">p, --programs             显示正在使用socket的程序名/进程<span class="constant">ID</span></span><br><span class="line"></span>-<span class="ruby">l, --listening            显示监控中的服务器的<span class="constant">Socket</span>。</span><br><span class="line"></span>-<span class="ruby">o, --timers               显示计时器。</span><br><span class="line"></span>-<span class="ruby">s, --statistics           显示每个网络协议的统计信息(比如<span class="constant">SNMP</span>)</span><br><span class="line"></span>-<span class="ruby">i, --interfaces           显示网络界面信息表单（网卡列表）</span><br><span class="line"></span>-<span class="ruby">r, --route                显示路由表</span></span><br></pre></td></tr></table></figure></p>
<p>常用的几种：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -aup        <span class="comment"># 输出所有UDP连接状况</span></span><br><span class="line"><span class="variable">$ </span>netstat -atp        <span class="comment"># 输出所有TCP连接状况</span></span><br><span class="line"><span class="variable">$ </span>netstat -s          <span class="comment"># 显示各个协议的网络统计信息</span></span><br><span class="line"><span class="variable">$ </span>netstat -i          <span class="comment"># 显示网卡列表</span></span><br><span class="line"><span class="variable">$ </span>netstat -r          <span class="comment"># 显示路由表信息</span></span><br></pre></td></tr></table></figure></p>
<p>找出程序运行的端口：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ap <span class="string">| grep ssh</span></span><br></pre></td></tr></table></figure></p>
<p>找出运行在指定端口的进程：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -anp <span class="string">| grep 60010</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="四、磁盘监控">四、磁盘监控</h1><h2 id="4-1_df">4.1 df</h2><p><code>df</code>命令的功能是用来检查linux的文件系统的磁盘空间占用情况。如果没有文件名被指定，则显示当前所有被挂载的文件系统，默认以 KB 为单位。</p>
<p>常用选项如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a  全部文件系统列表</span><br><span class="line"></span>-<span class="ruby">h  以方便阅读的方式显示</span><br><span class="line"></span>-<span class="ruby">i  显示inode信息</span><br><span class="line"></span>-<span class="ruby"><span class="constant">T</span>  显示文件系统类型</span><br><span class="line"></span>-<span class="ruby">l  只显示本地文件系统</span><br><span class="line"></span>-<span class="ruby">k  以<span class="constant">KB</span>为单位</span><br><span class="line"></span>-<span class="ruby">m  以<span class="constant">MB</span>为单位</span></span><br></pre></td></tr></table></figure></p>
<p>最常用的就是<code>$ df -h</code>。</p>
<h2 id="4-2_iostat">4.2 iostat</h2><p>上面在介绍CPU监控时，就可以看到<code>%wa</code>或<code>%iowait</code>这一项，它表示I/O等待所占用CPU的百分比。为了得到关于磁盘IO更详细的状态信息，可以使用 <strong>iostat（I/O statistics，输入输出统计）</strong>命令：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">c 显示<span class="constant">CPU</span>使用情况</span><br><span class="line"></span>-<span class="ruby">d 显示磁盘使用情况</span><br><span class="line"></span>-<span class="ruby">k 以 <span class="constant">KB</span> 为单位显示</span><br><span class="line"></span>-<span class="ruby">m 以 <span class="constant">M</span> 为单位显示</span><br><span class="line"></span>-<span class="ruby">x 显示详细信息</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ iostat -<span class="keyword">x</span> -k <span class="number">2</span> <span class="number">100</span>        <span class="comment"># 2表示刷新间隔，100表示刷新次数</span></span><br><span class="line"></span><br><span class="line">Linux <span class="number">2.6</span>.<span class="number">32</span>-<span class="number">2.0</span>.<span class="number">0</span>.<span class="number">1</span> (localhost) 	<span class="number">2015</span>年09月<span class="number">05</span>日 	_x86_64<span class="number">_</span>	(<span class="number">24</span> CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  <span class="variable">%user</span>   <span class="variable">%nice</span> <span class="variable">%system</span> <span class="variable">%iowait</span>  <span class="variable">%steal</span>   <span class="variable">%idle</span></span><br><span class="line">           <span class="number">2.34</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">1.87</span>    <span class="number">0</span>.<span class="number">70</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">95.08</span></span><br><span class="line"></span><br><span class="line">Device:         rrqm/<span class="keyword">s</span>   wrqm/<span class="keyword">s</span>     r/<span class="keyword">s</span>     w/<span class="keyword">s</span>    rkB/<span class="keyword">s</span>    wkB/<span class="keyword">s</span> avgrq-sz avgqu-sz   await  svctm  <span class="variable">%util</span></span><br><span class="line">sdj               <span class="number">0</span>.<span class="number">06</span>     <span class="number">0</span>.<span class="number">13</span>    <span class="number">6.18</span>    <span class="number">2.20</span>   <span class="number">708.94</span>   <span class="number">740.47</span>   <span class="number">345.95</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">5.32</span>   <span class="number">2.63</span>   <span class="number">2.20</span></span><br><span class="line">sdd               <span class="number">0</span>.<span class="number">06</span>     <span class="number">0</span>.<span class="number">13</span>    <span class="number">6.34</span>    <span class="number">2.15</span>   <span class="number">716.75</span>   <span class="number">722.91</span>   <span class="number">339.00</span>     <span class="number">0</span>.<span class="number">02</span>    <span class="number">2.07</span>   <span class="number">2.73</span>   <span class="number">2.32</span></span><br><span class="line">sdb               <span class="number">0</span>.<span class="number">05</span>     <span class="number">0</span>.<span class="number">12</span>    <span class="number">3.01</span>    <span class="number">1.68</span>   <span class="number">365.89</span>   <span class="number">581.01</span>   <span class="number">404.05</span>     <span class="number">0</span>.<span class="number">02</span>    <span class="number">3.26</span>   <span class="number">2.19</span>   <span class="number">1.03</span></span><br><span class="line">sdf               <span class="number">0</span>.<span class="number">06</span>     <span class="number">0</span>.<span class="number">14</span>    <span class="number">6.25</span>    <span class="number">2.21</span>   <span class="number">712.99</span>   <span class="number">741.76</span>   <span class="number">343.92</span>     <span class="number">0</span>.<span class="number">00</span>    <span class="number">5.20</span>   <span class="number">2.62</span>   <span class="number">2.22</span></span><br><span class="line">sda               <span class="number">0</span>.<span class="number">30</span>     <span class="number">1.86</span>    <span class="number">9.34</span>    <span class="number">5.54</span>   <span class="number">705.95</span>   <span class="number">766.81</span>   <span class="number">197.98</span>     <span class="number">0</span>.<span class="number">03</span>    <span class="number">1.88</span>   <span class="number">2.72</span>   <span class="number">4.05</span></span><br></pre></td></tr></table></figure>
<p><code>iostat</code>主要是用来监控磁盘I/O，首先输出了CPUs的平均数据（avg-cpu），我们可以看<code>%iowait</code>这一项，除此之外iostat还提供了一些更详细的I/O状态数据，比如</p>
<ul>
<li>r/s:           每秒完成的读 I/O 设备次数。</li>
<li>w/s:         每秒完成的写 I/O 设备次数。</li>
<li>rkB/s:      每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节。</li>
<li>wkB/s:    每秒写K字节数.是 wsect/s 的一半。</li>
<li>avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。</li>
<li>avgqu-sz: 平均I/O队列长度。</li>
<li>await:    平均每次设备I/O操作的等待时间 (毫秒)。</li>
<li>svctm:   平均每次设备I/O操作的服务时间 (毫秒)。</li>
<li>%util:      一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的。</li>
</ul>
<p><br></p>
<h1 id="五、进程监控">五、进程监控</h1><h2 id="5-1_top">5.1 top</h2><p>前面介绍过的top命令中可以对进程进行监控，其中一行就输出了进程的总体情况：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Tasks</span>: <span class="string">661 total,   1 running, 659 sleeping,   0 stopped,   1 zombie</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，top按照CPU使用率对各个进程进行排序。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">PID</span> <span class="tag">USER</span>      <span class="tag">PR</span>  <span class="tag">NI</span>  <span class="tag">VIRT</span>  <span class="tag">RES</span>  <span class="tag">SHR</span> <span class="tag">S</span> %<span class="tag">CPU</span> %<span class="tag">MEM</span>    <span class="tag">TIME</span>+  <span class="tag">COMMAND</span></span><br><span class="line"> 2543 <span class="tag">root</span>      20   0  9204  636  396 <span class="tag">S</span>  0<span class="class">.7</span>  0<span class="class">.0</span> 614<span class="pseudo">:57</span><span class="class">.76</span> <span class="tag">irqbalance</span></span><br><span class="line"> 4279 <span class="tag">work</span>      20   0 15<span class="class">.8g</span> 1<span class="class">.4g</span>  10<span class="tag">m</span> <span class="tag">S</span>  0<span class="class">.7</span>  4<span class="class">.6</span> 121<span class="pseudo">:19</span><span class="class">.27</span> <span class="tag">java</span></span><br><span class="line">11761 <span class="tag">work</span>      20   0  153<span class="tag">m</span> 7192 1080 <span class="tag">S</span>  0<span class="class">.7</span>  0<span class="class">.0</span> 642<span class="pseudo">:26</span><span class="class">.65</span> <span class="tag">python</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>RES</strong>：进程使用的物理内存大小</li>
<li><strong>SHR</strong>：进程共享内存大小</li>
<li><strong>S</strong>：进程状态（R表示运行 ，S表示睡眠，Z表示僵死，D表示不可中断的睡眠）</li>
</ul>
<p>在top运行状态下，输入<code>M</code>按内存使用率排序、输入<code>P</code>按CPU占用率排序、输入<code>T</code>按累计时间排序、输入<code>c</code>显示进程的启动命令，输入<code>u</code>显示指定用户的进程。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">top</span> -<span class="tag">p</span> &lt;pid&gt;</span><br></pre></td></tr></table></figure></p>
<p>动态显示进程号为pid的进程的状态。</p>
<h2 id="5-2_ps">5.2 ps</h2><p><strong>ps（Process Status，进程状态）</strong>命令是最基本同时也是非常强大的进程查看命令，最常用的命令就是<code>ps aux</code>——显示当前所有进程<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ps</span> aux | grep <span class="literal">root</span>       <span class="comment"># 输出root用户的所有进程</span></span><br><span class="line">$ <span class="built_in">ps</span> -p &lt;pid&gt; -<span class="constant">L</span>            <span class="comment"># 显示进程&lt;pid&gt;的所有线程</span></span><br><span class="line">$ <span class="built_in">ps</span> -e -o pid,uname,pcpu,pmem,comm  <span class="comment"># 定制显示的列</span></span><br><span class="line">$ <span class="built_in">ps</span> -o lstart &lt;pid&gt;        <span class="comment"># 显示进程的启动时间</span></span><br></pre></td></tr></table></figure></p>
<p>ps命令的输出可以按任意某一列进行排序，通过使用内部排序键（列的别名），例如：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux --<span class="keyword">sort</span>=+rss         <span class="comment"># 按内存升序排列</span></span><br><span class="line">$ ps aux --<span class="keyword">sort</span>=-rss        <span class="comment"># 按内存降序排列</span></span><br><span class="line">$ ps aux --<span class="keyword">sort</span>=+<span class="variable">%cpu</span>        <span class="comment"># 按cpu升序排列</span></span><br><span class="line">$ ps aux --<span class="keyword">sort</span>=-<span class="variable">%cpu</span>       <span class="comment"># 按cpu降序排列</span></span><br></pre></td></tr></table></figure></p>
<p><code>ps</code>命令的用法太多了，掌握一些常用的用法就好。如需了解更多的可选项，可以查看man手册。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、内存监控">一、内存监控</h1><p>监控内存的使用状态是非常重要的，通过监控有助于了解内存的使用状态，比如内存占用是否正常，内存是否紧缺等等，监控内存最常使用的命令有free、vmstat、top等</p>
<h2 id="1-1_free">1.1 free</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="string">Mem:</span>      <span class="number">32872632</span>   <span class="number">12393128</span>   <span class="number">20479504</span>          <span class="number">0</span>      <span class="number">23308</span>    <span class="number">7496048</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="string">cache:</span>    <span class="number">4873772</span>   <span class="number">27998860</span></span><br><span class="line"><span class="string">Swap:</span>            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第一行（Mem）：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[-ROOT-表和.META.表结构详解]]></title>
    <link href="http://yoursite.com/2015/08/15/root-and-meta-table-structure/"/>
    <id>http://yoursite.com/2015/08/15/root-and-meta-table-structure/</id>
    <published>2015-08-15T14:29:27.000Z</published>
    <updated>2015-08-15T14:36:10.792Z</updated>
    <content type="html"><![CDATA[<p>在《<a href="http://songlee24.github.io/2015/07/24/hbase-introduction/" target="_blank" rel="external">HBase技术简介</a>》中我们知道，HBase中有两个特殊的表：<code>-ROOT-</code>和<code>.META.</code>。</p>
<p>由于HBase中的表可能非常大，故HBase会将表按行分成多个region，然后分配到多台RegionServer上。数据访问的整个流程如下图所示：<a id="more"></a></p>
<center><br><img src="http://img.blog.csdn.net/20150815181211282" alt=""><br></center>

<p>注意两点：</p>
<ol>
<li>Client端在访问数据的过程中并没有涉及到Master节点，也就是说HBase日常的数据操作并不需要Master，不会造成Master的负担。</li>
<li>并不是每次数据访问都要执行上面的整个流程，因为很多数据都会被Cache起来。</li>
</ol>
<hr>
<p>从存储结构和操作方法的角度来说，<code>-ROOT-</code>、<code>.META.</code>与其他表没有任何区别。它们与众不同的地方是HBase用它们来存贮一个重要的系统信息：</p>
<ul>
<li>-ROOT-：记录.META.表的Region信息。</li>
<li>.META.：记录用户表的Region信息。</li>
</ul>
<p>其中-ROOT-表本身只会有一个region，这样保证了只需要三次跳转，就能定位到任意region，</p>
<p><br></p>
<h1 id="一、META表结构">一、META表结构</h1><p>在 HBase Shell 里对<code>.META.</code>表进行 scan 和 describe ：</p>
<p><img src="http://img.blog.csdn.net/20150812143409121" alt=""></p>
<p>可以看出，<code>.META.</code>表的结构如下：</p>
<p><img src="http://img.blog.csdn.net/20150812121857591" alt=""></p>
<p><code>.META.</code>表中每一行记录了一个Region的信息。</p>
<p><strong>1)  RowKey</strong></p>
<p>RowKey就是Region Name，它的命名形式是<code>TableName,StartKey,TimeStamp.Encoded.</code>。</p>
<p>其中 Encoded 是<code>TableName,StartKey,TimeStamp</code>的md5值。</p>
<p>例如：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mytable,,<span class="number">1438832261249</span>.ea2b47e1eba6dd9a7121315cdf0e4f67.</span><br></pre></td></tr></table></figure></p>
<p>表名是<code>mytable</code>，StartKey为空，时间戳是<code>1438832261249</code>，前面三部分的md5是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">"mytable,,1438832261249"</span> | md5sum   <span class="comment"># -n选项表示不输出换行符</span></span><br><span class="line">ea2b47e1eba6dd9a7121315cdf0e4f67  -</span><br></pre></td></tr></table></figure></p>
<p><strong>2)  Column Family</strong></p>
<p><code>.META.</code>表有两个Column Family：<code>info</code> 和 <code>historian</code>。</p>
<p>其中<code>info</code>包含了三个Column：</p>
<ul>
<li><code>regioninfo</code>：region的详细信息，包括StartKey、EndKey以及Table信息等等。</li>
<li><code>server</code>：管理该region的 RegionServer 的地址。</li>
<li><code>serverstartcode</code>：RegionServer 开始托管该region的时间。</li>
</ul>
<p>至于<code>historian</code>：</p>
<blockquote>
<p>That was a family used to keep track of region operations like open,<br>close, compact, etc. It proved to be more troublesome than handy so we<br>disabled this feature until coming up with a better solution. The<br>family stayed for backward compatibility.</p>
</blockquote>
<p>大致的意思是：这个Column Family是用来追踪一些region操作的，例如open、close、compact等。事实证明这非常的麻烦，所以在想出一个更好的解决方案之前我们禁用了此功能。这个列族会保持向后兼容。</p>
<p><strong>综上所述</strong>，<code>.META.</code>表中保存了所有用户表的region信息，在进行数据访问时，它是必不可少的一个环节。当Region被拆分、合并或者重新分配的时候，都需要来修改这张表的内容 来保证访问数据时能够正确地定位region。</p>
<p><br></p>
<h1 id="二、ROOT表结构">二、ROOT表结构</h1><p>当用户表特别大时，用户表的region也会非常多。<code>.META.</code>表存储了这些region信息，也变得非常大，这时<code>.META.</code>自己也需要划分成多个Region，托管到多个RegionServer上。</p>
<p>这时就出现了一个问题：<strong>当<code>.META.</code>被托管在多个RegionServer上，如何去定位<code>.META.</code>呢？</strong> HBase的做法是用另外一个表来记录<code>.META.</code>的Region信息，就和<code>.META.</code>记录用户表的Region信息一样，这个表就是<strong><code>-ROOT-</code></strong>表。</p>
<p>在 HBase Shell 里对<code>-ROOT-</code>表进行 scan 和 describe ：</p>
<p><img src="http://img.blog.csdn.net/20150815194826244" alt=""></p>
<p><code>-ROOT-</code>表的结构如下：</p>
<p><img src="http://img.blog.csdn.net/20150815200306658" alt=""></p>
<p>可以看出，除了没有<code>historian</code>列族之外，<code>-ROOT-</code>表的结构与<code>.META.</code>表的结构是一样的。另外，<code>-ROOT-</code>表的 RowKey 没有采用时间戳，也没有Encoded值，而是直接指定一个数字。</p>
<p><code>-ROOT-</code>表永远只有一个Region，也就只会存放在一台RegionServer上。—— 在进行数据访问时，需要知道管理<code>-ROOT-</code>表的RegionServer的地址。这个地址被存在 <strong>ZooKeeper</strong> 中。</p>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
<hr>
<p>参考：www.greatwqs.iteye.com/blog/1838904</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在《<a href="http://songlee24.github.io/2015/07/24/hbase-introduction/">HBase技术简介</a>》中我们知道，HBase中有两个特殊的表：<code>-ROOT-</code>和<code>.META.</code>。</p>
<p>由于HBase中的表可能非常大，故HBase会将表按行分成多个region，然后分配到多台RegionServer上。数据访问的整个流程如下图所示：]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MapReduce将HDFS文本数据导入HBase中]]></title>
    <link href="http://yoursite.com/2015/08/13/hdfs-import-to-hbase/"/>
    <id>http://yoursite.com/2015/08/13/hdfs-import-to-hbase/</id>
    <published>2015-08-12T23:40:33.000Z</published>
    <updated>2015-08-12T23:42:57.706Z</updated>
    <content type="html"><![CDATA[<p>HBase本身提供了很多种数据导入的方式，通常有两种常用方式：</p>
<ol>
<li>使用HBase提供的TableOutputFormat，原理是通过一个Mapreduce作业将数据导入HBase</li>
<li>另一种方式就是使用HBase原生Client API</li>
</ol>
<p>本文就是示范如何通过MapReduce作业从一个文件读取数据并写入到HBase中。</p>
<p>首先启动Hadoop与HBase，然后创建一个空表，用于后面导入数据：<a id="more"></a><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">006</span>:<span class="number">0</span>&gt; create <span class="string">'mytable'</span>,<span class="string">'cf'</span></span><br><span class="line"><span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">10.8310</span> seconds</span><br><span class="line"></span><br><span class="line">=&gt; Hbase::Table - mytable</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">007</span>:<span class="number">0</span>&gt; list</span><br><span class="line">TABLE                                                                                                   </span><br><span class="line">mytable                                                                                                 </span><br><span class="line"><span class="number">1</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.1220</span> seconds</span><br><span class="line"></span><br><span class="line">=&gt; [<span class="string">"mytable"</span>]</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">008</span>:<span class="number">0</span>&gt; scan <span class="string">'mytable'</span></span><br><span class="line">ROW                         COLUMN+CELL                                                                 </span><br><span class="line"><span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.2130</span> seconds</span><br></pre></td></tr></table></figure></p>
<h1 id="一、示例程序">一、示例程序</h1><p>下面的示例程序通过<code>TableOutputFormat</code>将HDFS上具有一定格式的文本数据导入到HBase中。</p>
<p>首先创建MapReduce作业，目录结构如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hdfs2HBase/</span><br><span class="line">├── classes</span><br><span class="line">└── src</span><br><span class="line">    ├── Hdfs2HBase<span class="class">.java</span></span><br><span class="line">    ├── Hdfs2HBaseMapper<span class="class">.java</span></span><br><span class="line">    └── Hdfs2HBaseReducer.java</span><br></pre></td></tr></table></figure></p>
<p><strong>Hdfs2HBaseMapper.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBaseMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text line, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">                String lineStr = line.toString();</span><br><span class="line">                <span class="keyword">int</span> index = lineStr.indexOf(<span class="string">":"</span>);</span><br><span class="line">                String rowkey = lineStr.substring(<span class="number">0</span>, index);</span><br><span class="line">                String left = lineStr.substring(index+<span class="number">1</span>);</span><br><span class="line">                context.write(<span class="keyword">new</span> Text(rowkey), <span class="keyword">new</span> Text(left));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hdfs2HBaseReducer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBaseReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">Put</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text rowkey, Iterable&lt;Text&gt; value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">                String k = rowkey.toString();</span><br><span class="line">                <span class="keyword">for</span>(Text val : value) &#123;</span><br><span class="line">                        Put put = <span class="keyword">new</span> Put(k.getBytes());</span><br><span class="line">                        String[] strs = val.toString().split(<span class="string">":"</span>);</span><br><span class="line">                        String family = strs[<span class="number">0</span>];</span><br><span class="line">                        String qualifier = strs[<span class="number">1</span>];</span><br><span class="line">                        String v = strs[<span class="number">2</span>];</span><br><span class="line">                        put.add(family.getBytes(), qualifier.getBytes(), v.getBytes());</span><br><span class="line">                        context.write(<span class="keyword">new</span> ImmutableBytesWritable(k.getBytes()), put);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hdfs2HBase.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBase</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;infile&gt; &lt;table&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"hdfs2hbase"</span>);</span><br><span class="line">		job.setJarByClass(Hdfs2HBase.class);</span><br><span class="line">		job.setMapperClass(Hdfs2HBaseMapper.class);</span><br><span class="line">		job.setReducerClass(Hdfs2HBaseReducer.class);</span><br><span class="line">		</span><br><span class="line">		job.setOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">		job.setOutputValueClass(Put.class);</span><br><span class="line">		</span><br><span class="line">		job.setOutputFormatClass(TableOutputFormat.class);</span><br><span class="line">		</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, otherArgs[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置<code>javac</code>编译依赖环境：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar</span><br></pre></td></tr></table></figure>
<p>这里要操作HBase，故除了上面三个jar包，还需要<code>$HBASE_HOME/lib</code>目录下的jar包。为了方便，我们在<code>/etc/profile</code>的<strong><code>CLASSPATH</code></strong>里包含所有的依赖包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEMP=`ls /home/hadoop/hbase/lib/*.jar`</span><br><span class="line">HBASE_JARS=`<span class="built_in">echo</span> <span class="variable">$TEMP</span> | sed <span class="string">'s/ /:/g'</span>`</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:/home/hadoop/hadoop/share/hadoop/common/hadoop-common-<span class="number">2.6</span>.<span class="number">0</span>.jar:/home/hadoop/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.6</span>.<span class="number">0</span>.jar:/home/hadoop/hadoop/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar:<span class="variable">$HBASE_JARS</span></span><br></pre></td></tr></table></figure></p>
<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac <span class="operator">-d</span> classes/ src/*.java</span><br></pre></td></tr></table></figure>
<p><strong>打包</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar -cvf hdfs2hbase<span class="class">.jar</span> classes</span><br></pre></td></tr></table></figure>
<p><strong>运行</strong></p>
<p>创建一个<code>data.txt</code>文件，内容如下（列族是建表时创建的列族<code>cf</code>）：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">r1</span><span class="pseudo">:cf</span><span class="pseudo">:c1</span><span class="pseudo">:value1</span> </span><br><span class="line"><span class="tag">r2</span><span class="pseudo">:cf</span><span class="pseudo">:c2</span><span class="pseudo">:value2</span> </span><br><span class="line"><span class="tag">r3</span><span class="pseudo">:cf</span><span class="pseudo">:c3</span><span class="pseudo">:value3</span></span><br></pre></td></tr></table></figure></p>
<p>将文件复制到hdfs上：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop fs -put <span class="typedef"><span class="keyword">data</span>.txt /hbase</span></span><br></pre></td></tr></table></figure></p>
<p>运行MapReduce作业：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar Hdfs2HBase/hdfs2hbase<span class="class">.jar</span> com<span class="class">.lisong</span><span class="class">.hdfs2hbase</span><span class="class">.Hdfs2HBase</span> /hbase/data<span class="class">.txt</span> mytable</span><br></pre></td></tr></table></figure></p>
<p>报错<code>NoClassDefFoundError</code>找不到类定义：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="class">.lang</span><span class="class">.NoClassDefFoundError</span>: org/apache/hadoop/hbase/io/ImmutableBytesWritable</span><br><span class="line">	at com<span class="class">.lisong</span><span class="class">.hdfs2hbase</span><span class="class">.Hdfs2HBase</span><span class="class">.main</span>(Hdfs2HBase<span class="class">.java</span>:<span class="number">30</span>)</span><br><span class="line">	at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke0</span>(Native Method)</span><br><span class="line">	...</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.util</span><span class="class">.RunJar</span><span class="class">.run</span>(RunJar<span class="class">.java</span>:<span class="number">221</span>)</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.util</span><span class="class">.RunJar</span><span class="class">.main</span>(RunJar<span class="class">.java</span>:<span class="number">136</span>)</span><br><span class="line">Caused by: java<span class="class">.lang</span><span class="class">.ClassNotFoundException</span>: org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.hbase</span><span class="class">.io</span><span class="class">.ImmutableBytesWritable</span></span><br><span class="line">	at java<span class="class">.net</span><span class="class">.URLClassLoader</span><span class="class">.findClass</span>(URLClassLoader<span class="class">.java</span>:<span class="number">381</span>)</span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.ClassLoader</span><span class="class">.loadClass</span>(ClassLoader<span class="class">.java</span>:<span class="number">424</span>)</span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.ClassLoader</span><span class="class">.loadClass</span>(ClassLoader<span class="class">.java</span>:<span class="number">357</span>)</span><br><span class="line">	... <span class="number">7</span> more</span><br></pre></td></tr></table></figure></p>
<p>原因是我没有把HBase的jar包加到<code>hadoop-env.sh</code>中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEMP=`ls /home/hadoop/hbase/lib/*.jar`</span><br><span class="line">HBASE_JARS=`<span class="built_in">echo</span> <span class="variable">$TEMP</span> | sed <span class="string">'s/ /:/g'</span>`</span><br><span class="line">HADOOP_CLASSPATH=<span class="variable">$HBASE_JARS</span></span><br></pre></td></tr></table></figure></p>
<p>再次运行发现又报了<code>Unable to initialize MapOutputCollector</code>的错误：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> WARN mapred<span class="class">.MapTask</span>: Unable to initialize MapOutputCollector org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="variable">$MapOutputBuffer</span></span><br><span class="line">java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="variable">$MapOutputBuffer</span>.<span class="function"><span class="title">init</span><span class="params">(MapTask.java:<span class="number">1008</span>)</span></span></span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="class">.createSortingCollector</span>(MapTask<span class="class">.java</span>:<span class="number">401</span>)</span><br><span class="line">	...</span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> INFO mapred<span class="class">.LocalJobRunner</span>: map task executor complete.</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> WARN mapred<span class="class">.LocalJobRunner</span>: job_local2138114942_0001</span><br><span class="line">java<span class="class">.lang</span><span class="class">.Exception</span>: java<span class="class">.io</span><span class="class">.IOException</span>: Unable to initialize any output collector</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.LocalJobRunner</span><span class="variable">$Job</span>.<span class="function"><span class="title">runTasks</span><span class="params">(LocalJobRunner.java:<span class="number">462</span>)</span></span></span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.LocalJobRunner</span><span class="variable">$Job</span>.<span class="function"><span class="title">run</span><span class="params">(LocalJobRunner.java:<span class="number">522</span>)</span></span></span><br><span class="line">Caused by: java<span class="class">.io</span><span class="class">.IOException</span>: Unable to initialize any output collector</span><br><span class="line">	at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.MapTask</span><span class="class">.createSortingCollector</span>(MapTask<span class="class">.java</span>:<span class="number">412</span>)</span><br><span class="line">	...</span><br><span class="line">	at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadPoolExecutor.java:<span class="number">617</span>)</span></span></span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">44</span> INFO mapreduce<span class="class">.Job</span>: Job job_local2138114942_0001 failed with state FAILED due to: NA</span><br><span class="line"><span class="number">15</span>/<span class="number">08</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">45</span> INFO mapreduce<span class="class">.Job</span>: Counters: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>原因是我没有指明Map输出的Key/Value类型，在<code>Hdfs2HBase.java</code>中添加以下两句：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.setMapOutputKeyClass(<span class="keyword">Text</span>.<span class="keyword">class</span>);</span><br><span class="line">job.setMapOutputValueClass(<span class="keyword">Text</span>.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果没有专门定义Mapper输出类型的话，<code>job.setOutputKeyClass</code>和<code>job.setOutputValueClass</code>设置的是Mapper和Reducer两个的输出类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.setOutputKeyClass(ImmutableBytesWritable.<span class="keyword">class</span>);</span><br><span class="line">job.setOutputValueClass(Put.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>而Hdfs2HBaseMapper输出类型是Text/Text，所以这里需要单独指定。</p>
<hr>
<p><strong>修改Hdfs2HBase.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBase</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;infile&gt; &lt;table&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"hdfs2hbase"</span>);</span><br><span class="line">		job.setJarByClass(Hdfs2HBase.class);</span><br><span class="line">		job.setMapperClass(Hdfs2HBaseMapper.class);</span><br><span class="line">		job.setReducerClass(Hdfs2HBaseReducer.class);</span><br><span class="line">		</span><br><span class="line">		job.setMapOutputKeyClass(Text.class);    <span class="comment">// +</span></span><br><span class="line">		job.setMapOutputValueClass(Text.class);  <span class="comment">// +</span></span><br><span class="line">	</span><br><span class="line">		job.setOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">		job.setOutputValueClass(Put.class);</span><br><span class="line">		</span><br><span class="line">		job.setOutputFormatClass(TableOutputFormat.class);</span><br><span class="line">		</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, otherArgs[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次编译、打包，然后运行成功！</p>
<p>查询HBase表，验证数据是否已导入：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt; scan 'mytable'</span><br><span class="line">ROW                         COLUMN+CELL                                                                 </span><br><span class="line"> r1                         <span class="variable">column=</span>cf:c1, <span class="variable">timestamp=</span><span class="number">1439223857492</span>, <span class="variable">value=</span>value1                         </span><br><span class="line"> r2                         <span class="variable">column=</span>cf:c2, <span class="variable">timestamp=</span><span class="number">1439223857492</span>, <span class="variable">value=</span>value2                         </span><br><span class="line"> r3                         <span class="variable">column=</span>cf:c3, <span class="variable">timestamp=</span><span class="number">1439223857492</span>, <span class="variable">value=</span>value3                         </span><br><span class="line"><span class="number">3</span> row(s) <span class="keyword">in</span> <span class="number">1.3820</span> seconds</span><br></pre></td></tr></table></figure></p>
<p>可以看到，数据导入成功！</p>
<p>由于需要频繁的与存储数据的RegionServer通信，占用资源较大，一次性入库大量数据时，TableOutputFormat效率并不好。</p>
<p><br></p>
<h1 id="二、拓展-TableReducer">二、拓展-TableReducer</h1><p>我们可以将<code>Hdfs2HBaseReducer.java</code>代码改成下面这样，作用是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hdfs2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HBaseReducer</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text rowkey, Iterable&lt;Text&gt; value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		String k = rowkey.toString();</span><br><span class="line">		<span class="keyword">for</span>(Text val : value) &#123;</span><br><span class="line">			Put put = <span class="keyword">new</span> Put(k.getBytes());</span><br><span class="line">			String[] strs = val.toString().split(<span class="string">":"</span>);</span><br><span class="line">			String family = strs[<span class="number">0</span>];</span><br><span class="line">			String qualifier = strs[<span class="number">1</span>];</span><br><span class="line">			String v = strs[<span class="number">2</span>];</span><br><span class="line">			put.add(family.getBytes(), qualifier.getBytes(), v.getBytes());</span><br><span class="line">			context.write(<span class="keyword">new</span> ImmutableBytesWritable(k.getBytes()), put);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接继承了<code>TableReducer</code>，<code>TableReducer</code>是部分特例化的<code>Reducer</code>，它只有三个类型参数：输入Key/Value是对应Mapper的输出，输出Key可以是任意的类型，但是输出Value必须是一个<code>Put</code>或<code>Delete</code>实例。</p>
<p><img src="http://img.blog.csdn.net/20150812105912587" alt=""></p>
<p>编译打包运行，结果与前面的一样！</p>
<p><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HBase本身提供了很多种数据导入的方式，通常有两种常用方式：</p>
<ol>
<li>使用HBase提供的TableOutputFormat，原理是通过一个Mapreduce作业将数据导入HBase</li>
<li>另一种方式就是使用HBase原生Client API</li>
</ol>
<p>本文就是示范如何通过MapReduce作业从一个文件读取数据并写入到HBase中。</p>
<p>首先启动Hadoop与HBase，然后创建一个空表，用于后面导入数据：]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一个MapReduce程序——WordCount]]></title>
    <link href="http://yoursite.com/2015/07/29/mapreduce-word-count/"/>
    <id>http://yoursite.com/2015/07/29/mapreduce-word-count/</id>
    <published>2015-07-29T13:34:39.000Z</published>
    <updated>2015-07-29T13:42:18.298Z</updated>
    <content type="html"><![CDATA[<p>通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个程序就是词频统计<code>WordCount</code>程序。</p>
<h1 id="一、MapReduce简介">一、MapReduce简介</h1><h2 id="1-1_MapReduce编程模型">1.1 MapReduce编程模型</h2><p>MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。</p>
<p>在Hadoop中，用于执行MapReduce任务的机器角色有两个：<a id="more"></a></p>
<ul>
<li>JobTracker用于调度工作的，一个Hadoop集群中只有一个JobTracker，位于master。</li>
<li>TaskTracker用于执行工作，位于各slave上。</li>
</ul>
<p>在分布式计算中，MapReduce框架负责处理了并行编程中分布式存储、工作调度、负载均衡、容错均衡、容错处理以及网络通信等复杂问题，把处理过程高度抽象为两个函数：map和reduce，map负责把任务分解成多个任务，reduce负责把分解后多任务处理的结果汇总起来。</p>
<p>需要注意的是，用MapReduce来处理的数据集（或任务）必须具备这样的特点：待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理。</p>
<h2 id="1-2_MapReduce处理过程">1.2 MapReduce处理过程</h2><p>在Hadoop中，每个MapReduce任务都被初始化为一个Job，每个Job又可以分为两种阶段：map阶段和reduce阶段。</p>
<ul>
<li>map：<code>(K1, V1)</code> ——&gt; <code>list(K2, V2)</code></li>
<li>reduce：<code>(K2, list(V2))</code> ——&gt; <code>list(K3, V3)</code></li>
</ul>
<p>如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150728184403091" alt=""></p>
<p><br></p>
<h1 id="二、运行WordCount程序">二、运行WordCount程序</h1><p>在运行程序之前，需要先搭建好Hadoop集群环境，参考《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/46974723" target="_blank" rel="external">Hadoop+HBase+ZooKeeper分布式集群环境搭建</a>》。</p>
<h2 id="2-1_源代码">2.1 源代码</h2><p>WordCount可以说是最简单的MapReduce程序了，只包含三个文件：一个 Map 的 Java 文件，一个 Reduce 的 Java 文件，一个负责调用的主程序 Java 文件。</p>
<p>我们在当前用户的主文件夹下创建<code>wordcount_01/</code>目录，在该目录下再创建<code>src/</code>和<code>classes/</code>。 src 目录存放 Java 的源代码，classes 目录存放编译结果。</p>
<p><strong>TokenizerMapper.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">	Text word = <span class="keyword">new</span> Text();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">		<span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">			word.set(itr.nextToken());</span><br><span class="line">			context.write(word, one);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IntSumReducer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(IntWritable val:values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WordCount.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"wordcount"</span>);</span><br><span class="line">		job.setJarByClass(WordCount.class);</span><br><span class="line">		job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">		job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">		job.setReducerClass(IntSumReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个.java源文件均置于 src 目录下。</p>
<h2 id="2-2_编译">2.2 编译</h2><p>Hadoop 2.x 版本中jar不再集中在一个 hadoop-core-*.jar 中，而是分成多个 jar。编译WordCount程序需要如下三个 jar：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="number">2.4</span>.<span class="number">1</span><span class="class">.jar</span></span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-cli-<span class="number">1.2</span>.jar</span><br></pre></td></tr></table></figure></p>
<p>使用<code>javac</code>命令进行编译：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd wordcount_01</span><br><span class="line"></span><br><span class="line">$ javac -<span class="keyword">classpath</span> <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop/</span>share<span class="regexp">/hadoop/</span>common<span class="regexp">/hadoop-common-2.6.0.jar:/</span>home<span class="regexp">/hadoop/</span>hadoop<span class="regexp">/share/</span>hadoop<span class="regexp">/mapreduce/</span>hadoop-mapreduce-client-core-<span class="number">2.6</span>.<span class="number">0</span>.jar:<span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop/</span>share<span class="regexp">/hadoop/</span>common<span class="regexp">/lib/</span>commons-cli-<span class="number">1.2</span>.jar -d classes<span class="regexp">/ src/</span>*.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-classpath，设置源代码里使用的各种类库所在的路径，多个路径用<code>&quot;:&quot;</code>隔开。</li>
<li>-d，设置编译后的 class 文件保存的路径。</li>
<li>src/*.java，待编译的源文件。</li>
</ul>
<h2 id="2-3_打包">2.3 打包</h2><p>将编译好的 class 文件打包成 Jar 包，jar 命令是 JDK 的打包命令行工具。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar -cvf wordcount<span class="class">.jar</span> classes</span><br></pre></td></tr></table></figure>
<p>打包结果是 wordcount.jar 文件，放在当前目录下。</p>
<h2 id="2-4_执行">2.4 执行</h2><p>执行hadoop程序的时候，输入文件必须先放入hdfs文件系统中，不能是本地文件。</p>
<p><strong>1 . 先查看hdfs文件系统的根目录：</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop<span class="regexp">/bin/hadoop fs -ls /</span></span><br><span class="line">Found <span class="number">1</span> items</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          <span class="number">0</span> <span class="number">2015</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">14</span>:<span class="number">38</span> /hbase</span><br></pre></td></tr></table></figure></p>
<p>可以看出，hdfs的根目录是一个叫<code>/hbase</code>的目录。</p>
<p><strong>2 . 然后利用<code>put</code>将输入文件（多个输入文件位于<code>input</code>文件夹下）复制到hdfs文件系统中：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop fs -put <span class="tag">input</span> /hbase</span><br></pre></td></tr></table></figure></p>
<p><strong>3 . 运行wordcount程序</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount_01/wordcount<span class="class">.jar</span> WordCount /hbase/<span class="tag">input</span> /hbase/output</span><br></pre></td></tr></table></figure>
<p>提示找不到 WordCount 类：<code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: WordCount</code>…</p>
<p>因为程序中声明了 package ，所以在命令中也要 com.lisong.hadoop.WordCount 写完整：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount_01/wordcount<span class="class">.jar</span> com<span class="class">.lisong</span><span class="class">.hadoop</span><span class="class">.WordCount</span> /hbase/<span class="tag">input</span> /hbase/output</span><br></pre></td></tr></table></figure></p>
<p>其中 “jar” 参数是指定 jar 包的位置，com.lisong.hadoop.WordCount 是主类。运行程序处理 input 目录下的多个文件，将结果写入 /hbase/output 目录。</p>
<p><strong>4 . 查看运行结果</strong></p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">hadoop/bin/hadoop</span> <span class="comment">fs</span> <span class="literal">-</span><span class="comment">ls</span> <span class="comment">/hbase/output</span></span><br><span class="line"><span class="comment">Found</span> <span class="comment">2</span> <span class="comment">items</span></span><br><span class="line"><span class="literal">-</span><span class="comment">rw</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span>   <span class="comment">3</span> <span class="comment">hadoop</span> <span class="comment">supergroup</span>          <span class="comment">0</span> <span class="comment">2015</span><span class="literal">-</span><span class="comment">07</span><span class="literal">-</span><span class="comment">28</span> <span class="comment">18:05</span> <span class="comment">/hbase/output/_SUCCESS</span></span><br><span class="line"><span class="literal">-</span><span class="comment">rw</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="literal">-</span>   <span class="comment">3</span> <span class="comment">hadoop</span> <span class="comment">supergroup</span>         <span class="comment">33</span> <span class="comment">2015</span><span class="literal">-</span><span class="comment">07</span><span class="literal">-</span><span class="comment">28</span> <span class="comment">18:05</span> <span class="comment">/hbase/output/part</span><span class="literal">-</span><span class="comment">r</span><span class="literal">-</span><span class="comment">00000</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>/hbase/output/</code>目录下有两个文件，结果就存在<code>part-r-00000</code>中：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop<span class="regexp">/bin/</span>hadoop fs -cat <span class="regexp">/hbase/</span>output/part-r-<span class="number">00000</span></span><br><span class="line">Google	<span class="number">6</span></span><br><span class="line">Java	<span class="number">2</span></span><br><span class="line">baidu	<span class="number">3</span></span><br><span class="line">hadoop	<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="三、WordCount程序分析">三、WordCount程序分析</h1><h2 id="3-1_Hadoop数据类型">3.1 Hadoop数据类型</h2><p>Hadoop MapReduce操作的是键值对，但这些键值对并不是Integer、String等标准的Java类型。为了让键值对可以在集群上移动，Hadoop提供了一些实现了<code>WritableComparable</code>接口的基本数据类型，以便用这些类型定义的数据可以被<strong>序列化</strong>进行网络传输、文件存储与大小比较。</p>
<ul>
<li>值：仅会被简单的传递，必须实现<code>Writable</code>或<code>WritableComparable</code>接口。</li>
<li>键：在Reduce阶段排序时需要进行比较，故只能实现<code>WritableComparable</code>接口。</li>
</ul>
<p>下面是8个预定义的Hadoop基本数据类型，它们均实现了<code>WritableComparable</code>接口：</p>
<table>
<thead>
<tr>
<th>类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BooleanWritable</td>
<td style="text-align:left">标准布尔型数值</td>
</tr>
<tr>
<td>ByteWritable</td>
<td style="text-align:left">单字节数值</td>
</tr>
<tr>
<td>DoubleWritable</td>
<td style="text-align:left">双字节数</td>
</tr>
<tr>
<td>FloatWritable</td>
<td style="text-align:left">浮点数</td>
</tr>
<tr>
<td>IntWritable</td>
<td style="text-align:left">整型数</td>
</tr>
<tr>
<td>LongWritable</td>
<td style="text-align:left">长整型数</td>
</tr>
<tr>
<td>Text</td>
<td style="text-align:left">使用UTF8格式存储的文本</td>
</tr>
<tr>
<td>NullWritable</td>
<td style="text-align:left">当<code>&lt;key,value&gt;</code>中的key或value为空时使用</td>
</tr>
</tbody>
</table>
<h2 id="3-2_源代码分析">3.2 源代码分析</h2><p><strong>3.2.1 Map过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">	Text word = <span class="keyword">new</span> Text();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">		<span class="keyword">while</span>(itr.hasMoreTokens()) &#123;</span><br><span class="line">			word.set(itr.nextToken());</span><br><span class="line">			context.write(word, one);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map过程需要继承<code>org.apache.hadoop.mapreduce</code>包中 Mapper 类，并<strong>重写</strong>其map方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的模板参数：第一个Object表示输入key的类型；第二个Text表示输入value的类型；第三个Text表示表示输出键的类型；第四个IntWritable表示输出值的类型。</p>
<p>作为map方法输入的键值对，其value值存储的是文本文件中的一行（以回车符为行结束标记），而key值为该行的首字母相对于文本文件的首地址的偏移量。然后StringTokenizer类将每一行拆分成为一个个的单词，并将<code>&lt;word,1&gt;</code>作为map方法的结果输出，其余的工作都交有 MapReduce框架 处理。</p>
<p><strong>注：</strong><code>StringTokenizer</code>是Java工具包中的一个类，用于将字符串进行拆分——默认情况下使用空格作为分隔符进行分割。</p>
<p><strong>3.2.2 Reduce过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(IntWritable val:values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reduce过程需要继承<code>org.apache.hadoop.mapreduce</code>包中 Reducer 类，并 <strong>重写</strong> reduce方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中模板参数同Map一样，依次表示是输入键类型，输入值类型，输出键类型，输出值类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text	key, Iterable&lt;IntWritable&gt; values, Context context)</span></span></span><br></pre></td></tr></table></figure>
<p>reduce 方法的输入参数 key 为单个单词，而 values 是由各Mapper上对应单词的计数值所组成的列表（一个实现了 Iterable 接口的变量，可以理解成 values 里包含若干个 IntWritable 整数，可以通过迭代的方式遍历所有的值），所以只要遍历 values 并求和，即可得到某个单词出现的总次数。</p>
<p><strong>3.2.3 执行作业</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lisong.hadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">		<span class="keyword">if</span>(otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">			System.exit(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"wordcount"</span>);</span><br><span class="line">		job.setJarByClass(WordCount.class);</span><br><span class="line">		job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">		job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">		job.setReducerClass(IntSumReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MapReduce中，由Job对象负责管理和运行一个计算任务，并通过Job的一些方法对任务的参数进行相关的设置，此处：</p>
<ul>
<li>设置了使用<code>TokenizerMapper.class</code>完成Map过程中的处理，使用<code>IntSumReducer.class</code>完成Combine和Reduce过程中的处理。</li>
<li>还设置了Map过程和Reduce过程的输出类型：key的类型为Text，value的类型为IntWritable。</li>
<li><p>任务的输出和输入路径则由命令行参数指定，并由FileInputFormat和FileOutputFormat分别设定。</p>
<ol>
<li>FileInputFormat类的很重要的作用就是将文件进行切分 split，并将 split 进一步拆分成key/value对</li>
<li>FileOutputFormat类的作用是将处理结果写入输出文件。</li>
</ol>
</li>
<li><p>完成相应任务的参数设定后，即可调用 <code>job.waitForCompletion()</code> 方法执行任务。</p>
</li>
</ul>
<p><strong>3.2.4 WordCount流程</strong></p>
<p>1）将文件拆分成splits，由于测试用的文件较小，所以每个文件为一个split，并将文件按行分割形成<code>&lt;key,value&gt;</code>对，key为偏移量（包括了回车符），value为文本行。这一步由MapReduce框架自动完成，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729173938301" alt=""></p>
<p>2）将分割好的<code>&lt;key,value&gt;</code>对交给用户定义的map方法进行处理，生成新的<code>&lt;key,value&gt;</code>对，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150729174039812" alt=""></p>
<p>3）得到map方法输出的<code>&lt;key,value&gt;</code>对后，Mapper会将它们按照key值进行排序，并执行Combine过程，将key值相同的value值累加，得到Mapper的最终输出结果。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729174057622" alt=""></p>
<p>4）Reducer先对从Mapper接收的数据进行排序，再交由用户自定义的reduce方法进行处理，得到新的<code>&lt;key,value&gt;</code>对，并作为WordCount的输出结果，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150729174400615" alt=""></p>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<hr>
<p>参考： 实战Hadoop：开启通向云计算的捷径</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个程序就是词频统计<code>WordCount</code>程序。</p>
<h1 id="一、MapReduce简介">一、MapReduce简介</h1><h2 id="1-1_MapReduce编程模型">1.1 MapReduce编程模型</h2><p>MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。</p>
<p>在Hadoop中，用于执行MapReduce任务的机器角色有两个：]]>
    
    </summary>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
      <category term="大数据-Hadoop" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase技术简介]]></title>
    <link href="http://yoursite.com/2015/07/24/hbase-introduction/"/>
    <id>http://yoursite.com/2015/07/24/hbase-introduction/</id>
    <published>2015-07-23T16:49:08.000Z</published>
    <updated>2016-02-23T12:32:28.981Z</updated>
    <content type="html"><![CDATA[<h1 id="一、HBase简介">一、HBase简介</h1><p>HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，类似Google BigTable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。<a id="more"></a></p>
<p><img src="http://img.blog.csdn.net/20150723155042611" alt=""></p>
<p>上图描述了Hadoop EcoSystem中的各层系统，其中HBase位于结构化存储层，Hadoop HDFS为HBase提供了高可靠性的底层存储支持，Hadoop MapReduce为HBase提供了高性能的计算能力，Zookeeper为HBase提供了稳定服务和failover机制。</p>
<p>此外，Pig和Hive还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单。 Sqoop则为HBase提供了方便的RDBMS数据导入功能，使得传统数据库数据向HBase中迁移变的非常方便。</p>
<p><br></p>
<h1 id="二、HBase访问接口">二、HBase访问接口</h1><ol>
<li><p>Native Java API，最常规和高效的访问方式，适合Hadoop MapReduce Job并行批处理HBase表数据</p>
</li>
<li><p>HBase Shell，HBase的命令行工具，最简单的接口，适合HBase管理使用</p>
</li>
<li><p>Thrift Gateway，利用Thrift序列化技术，支持C++，PHP，Python等多种语言，适合其他异构系统在线访问HBase表数据</p>
</li>
<li><p>REST Gateway，支持REST 风格的Http API访问HBase, 解除了语言限制</p>
</li>
<li><p>Pig，可以使用Pig Latin流式编程语言来操作HBase中的数据，和Hive类似，本质最终也是编译成MapReduce Job来处理HBase表数据，适合做数据统计</p>
</li>
<li><p>Hive，当前Hive的Release版本尚没有加入对HBase的支持，但在下一个版本Hive 0.7.0中将会支持HBase，可以使用类似SQL语言来访问HBase。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、HBase数据模型">三、HBase数据模型</h1><h2 id="3-1_Table_&amp;_Column_Family">3.1 Table &amp; Column Family</h2><p><img src="http://img.blog.csdn.net/20150724005727007" alt=""></p>
<p><strong>Row Key：</strong> </p>
<p>行键，Table的主键，用来检索记录。访问HBase table中的行，只有三种方式：</p>
<ul>
<li>通过单个row key访问</li>
<li>通过row key的range</li>
<li>全表扫描</li>
</ul>
<p>row key可以是任意字符串（最大长度是 64KB，实际应用中长度一般为 10-100bytes左右），在HBase内部，row key保存为字节数组。数据按照row key的字典序（byte order）排序存储，因此设计key时要充分排序存储这个特性，将经常一起读取的行存储放到一起。</p>
<p>HBase支持单行事务，行的一次读写是原子操作 （不论一次读写多少列），这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。</p>
<p><strong>Column Family</strong>：</p>
<p>列簇，Table在水平方向有一个或者多个Column Family组成，一个Column Family中可以由任意多个Column组成，即Column Family支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。</p>
<p>列名都以列族作为前缀。例如’courses:history’，’courses:math’，都属于courses 这个列族。<br>访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族上的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</p>
<p><strong>Timestamp</strong>: </p>
<p>时间戳，每次数据操作对应的时间戳，可以看作是数据的version number。时间戳的类型是 64位整型。时间戳可以由HBase在数据写入时自动赋值，此时时间戳是精确到毫秒的当前系统时间；时间戳也可以由客户显式赋值，如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。</p>
<p>为了避免数据存在过多版本造成的的管理 （包括存储和索引）负担，HBase提供了两种数据版本回收方式：一是保存数据的最后n个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<p><strong>Cell：</strong></p>
<p>由 {<code>row key</code>, <code>column family</code>, <code>column qualifier</code>, <code>version</code>} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存贮。</p>
<h2 id="3-2_Table_&amp;_Region">3.2 Table &amp; Region</h2><p>当Table随着记录数不断增加而变大后，会逐渐分裂成多份splits，成为regions，一个region由[startkey,endkey)表示，不同的region会被Master分配给相应的RegionServer进行管理：</p>
<p><img src="http://img.blog.csdn.net/20150723171646985" alt=""></p>
<h2 id="3-3_-ROOT-_&amp;&amp;_-META-_Table">3.3 -ROOT- &amp;&amp; .META. Table</h2><p>HBase中有两张特殊的Table，-ROOT-和.META.</p>
<ul>
<li><p>.META.：记录了用户表的Region信息，.META.可以有多个regoin</p>
</li>
<li><p>-ROOT-：记录了.META.表的Region信息，-ROOT-只有一个region</p>
</li>
<li><p>Zookeeper中记录了-ROOT-表的location</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150723172102610" alt=""></p>
<p>Client访问用户数据之前需要首先访问zookeeper，然后访问-ROOT-表，接着访问.META.表，最后才能找到User Table的位置去访问，中间需要多次网络操作，不过Client端会做cache缓存。</p>
<p><br></p>
<h1 id="四、HBase系统架构">四、HBase系统架构</h1><p><img src="http://img.blog.csdn.net/20150723173041385" alt=""></p>
<p><strong>Client</strong></p>
<p>HBase Client使用HBase的RPC机制与HMaster和HRegionServer进行通信，对于管理类操作，Client与HMaster进行RPC；对于数据读写类操作，Client与HRegionServer进行RPC</p>
<p><strong>Zookeeper</strong></p>
<p>Zookeeper Quorum中除了存储了-ROOT-表的地址和HMaster的地址，HRegionServer也会把自己以Ephemeral方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的健康状态。此外，Zookeeper也避免了HMaster的单点问题，见下文描述。</p>
<p><strong>HMaster</strong></p>
<p>HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行，HMaster在功能上主要负责Table和Region的管理工作：</p>
<ol>
<li><p>管理用户对Table的增、删、改、查操作</p>
</li>
<li><p>管理HRegionServer的负载均衡，调整Region分布</p>
</li>
<li><p>在Region Split后，负责新Region的分配</p>
</li>
<li><p>在HRegionServer停机后，负责失效HRegionServer 上的Regions迁移</p>
</li>
<li><p>HDFS的垃圾文件回收 </p>
</li>
</ol>
<p>注意：Client访问HBase上数据的过程并不需要HMaster参与（寻址访问Zookeeper和HRegionServer，数据读写访问HRegioneServer），HMaster仅仅维护者table和region的元数据信息，负载很低。</p>
<p><strong>HRegionServer</strong></p>
<p>HRegionServer主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。</p>
<p><img src="http://img.blog.csdn.net/20150723174212472" alt=""></p>
<p><strong>注意，每个HRegsionServer维护一个HLog文件</strong></p>
<p>HRegionServer内部管理了一系列HRegion对象，每个HRegion对应了Table中的一个Region，HRegion中由多个HStore组成。每个HStore对应了Table中的一个Column Family的存储，可以看出每个Column Family其实就是一个集中的存储单元，因此最好将具备共同IO特性的column放在一个Column Family中，这样最高效。</p>
<p><strong>HStore</strong></p>
<p>HStore 是HBase存储的核心，其中由两部分组成：</p>
<ul>
<li>MemStore</li>
<li>StoreFiles。</li>
</ul>
<p>MemStore是Sorted Memory Buffer，用户写入的数据首先会放入MemStore，当MemStore满了以后会Flush成一个StoreFile（底层实现是HFile）。</p>
<p>Compaction：当StoreFile文件数量增长到一定阈值，会触发Compact合并操作，将多个StoreFiles合并成一个StoreFile，合并过程中会进行版本合并和数据删除，因此可以看出HBase其实只有增加数据，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的写操作只要进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
<p>Split：当StoreFiles Compact后，会逐步形成越来越大的StoreFile，当单个StoreFile大小超过一定阈值后，会触发Split操作，同时把当前Region Split成2个Region，父Region会下线，新Split出的2个孩子Region会被HMaster分配到相应的HRegionServer上，使得原先1个Region的压力得以分流到2个Region上。下图描述了Compaction和Split的过程：</p>
<p><img src="http://img.blog.csdn.net/20150723175721133" alt=""></p>
<p><strong>HLog</strong></p>
<p>在理解了上述HStore的基本原理后，还必须了解一下HLog的功能，因为上述的HStore在系统正常工作的前提下是没有问题的，但是在分布式系统环境中，无法避免系统出错或者宕机，因此一旦HRegionServer意外退出，MemStore中的内存数据将会丢失，这就需要引入HLog了。</p>
<p>每个HRegionServer中都有一个HLog对象，HLog是一个实现Write Ahead Log的类，在每次用户操作写入MemStore的同时，也会写一份数据到HLog文件中（HLog文件格式见后续），HLog文件定期会滚动出新的，并删除旧的文件（已持久化到StoreFile中的数据）。当HRegionServer意外终止后，HMaster会通过Zookeeper感知到，HMaster首先会处理遗留的 HLog文件，将其中不同Region的Log数据进行拆分，分别放到相应region的目录下，然后再将失效的region重新分配，领取 到这些region的HRegionServer在Load Region的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后flush到StoreFiles，完成数据恢复。</p>
<p><br></p>
<h1 id="五、HBase存储格式">五、HBase存储格式</h1><p>HBase中的所有数据文件都存储在Hadoop HDFS文件系统上，主要包括上述提出的两种文件类型：</p>
<ol>
<li><p>HFile， HBase中KeyValue数据的存储格式，HFile是Hadoop的二进制格式文件，实际上StoreFile就是对HFile做了轻量级包装，即StoreFile底层就是HFile</p>
</li>
<li><p>HLog File，HBase中WAL（Write Ahead Log） 的存储格式，物理上是Hadoop的Sequence File</p>
</li>
</ol>
<p><strong>HFile</strong></p>
<p>下图是HFile V2的存储格式：</p>
<p><img src="http://img.blog.csdn.net/20150724000300134" alt=""></p>
<p>HFile的组成分成四部分，分别是Scanned Block（数据block）、Non-Scanned block（元数据block）、Load-on-open（在hbase运行时，HFile需要加载到内存中的索引、bloom filter和文件信息）以及trailer（文件尾）。</p>
<p>在HFile中根据一个key搜索一个data的过程： </p>
<ol>
<li><p>先内存中对HFile的root index进行二分查找。如果支持多级索引的话，则定位到的是leaf/intermediate index，如果是单级索引，则定位到的是data block</p>
</li>
<li><p>如果支持多级索引，则会从缓存/hdfs（分布式文件系统）中读取leaf/intermediate index chunk，在leaf/intermediate chunk根据key值进行二分查找（leaf/intermediate index chunk支持二分查找），找到对应的data block。</p>
</li>
<li><p>从缓存/hdfs中读取data block。</p>
</li>
<li><p>在data block中遍历查找key。</p>
</li>
</ol>
<p>Data Block是HBase I/O的基本单元，为了提高效率，HRegionServer中有基于LRU的 Block Cache 机制。每个Data块的大小可以在创建一个Table的时候通过参数指定（默认64K），大号的Block有利于顺序Scan，小号Block利于随机查询。在DataBlock中存储的是一系列KeyValue，在KeyValue后面跟一个timestamp，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150724000710687" alt=""></p>
<p>HFile里面的每个KeyValue对就是一个简单的byte数组。但是这个byte数组里面包含了很多项，并且有固定的结构。KV结构图如下：</p>
<p><img src="http://img.blog.csdn.net/20150724000728042" alt=""></p>
<p>可以看出KeyValue格式分为四个部分：KeyLength、ValueLength、Key、Value。</p>
<p>其中KeyLength和ValueLength都是整型，表示长度。Key有固定的格式，KeyType有四种类型，分别是Put、Delete、 DeleteColumn和DeleteFamily。Value部分没有这么复杂的结构，就是纯粹的二进制数据了。</p>
<p><strong>HLogFile</strong></p>
<p><img src="http://img.blog.csdn.net/20150724000757602" alt=""></p>
<p>上图中示意了HLog文件的结构，其实HLog文件就是一个普通的Hadoop Sequence File，Sequence File 的Key是HLogKey对象，HLogKey中记录了写入数据的归属信息，除了table和region名字外，同时还包括 sequence number和timestamp，timestamp是“写入时间”，sequence number的起始值为0，或者是最近一次存入文件系统中sequence number。</p>
<p>HLog Sequece File的Value是HBase的KeyValue对象，即对应HFile中的KeyValue，可参见上文描述。</p>
<p><br></p>
<h1 id="六、关键流程">六、关键流程</h1><h2 id="6-1_region定位">6.1 region定位</h2><p>HBase如何找到某个row key （或者某个row key的range）所在的region？使用三层类似B+树的结构来保存region位置：</p>
<ul>
<li>第一层：Zookeeper保存了-ROOT-表的位置。</li>
<li>第二层：-ROOT- 表保存了.META.表所有region的位置，通过-ROOT-表，可以访问.META.表的数据。</li>
<li>第三层：.META.是一个特殊的表，保存了HBase中所有数据表的region位置信息。</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li>-ROOT-表永远不会被split，保证了只需要三次跳转，就能定位到任意region</li>
<li>META.表每行保存一个region的位置信息，row key采用表名+表的最后一行编码而成</li>
<li>为了加快访问，.META.表的全部region都保存在内存中</li>
<li>Client会将查询过的位置信息保存缓存起来，缓存不会主动失效</li>
</ol>
<h2 id="6-2_region分配">6.2 region分配</h2><p>任何时刻，一个region只能分配给一个HRegionServer。HMaster记录了当前有哪些可用的HRegionServer。以及当前哪些region分配给了哪些HRegionServer，哪些region还没有分配。当存在未分配的region，并且有一个HRegionServer上有可用空间时，HMaster就给这个HRegionServer发送一个装载请求，把region分配给这个HRegionServer。HRegionServer得到请求后，就开始对此region提供服务。</p>
<h2 id="6-3_写请求处理">6.3 写请求处理</h2><p>数据在更新时首先写入Log（WAL log）和内存（MemStore）中，MemStore中的数据是排序的，当MemStore累计到一定阈值时，就会创建一个新的MemStore，并且将老的MemStore添加到flush队列，由单独的线程flush到磁盘上，成为一个StoreFile。与此同时，系统会在Zookeeper中记录一个redo point，表示这个时刻之前的变更已经持久化了。</p>
<p>当系统出现意外时，可能导致内存（MemStore）中的数据丢失，此时使用Log（WAL log）来恢复checkpoint之后的数据。</p>
<p>前面提到过StoreFile是只读的，一旦创建后就不可以再修改。因此HBase的更新其实是不断追加的操作，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的写操作只要 进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
<h2 id="6-4_读请求处理">6.4 读请求处理</h2><p>如果想快速读取数据，通用的原则是数据保持有序 并 尽可能保存在内存里。HBase实现了这两个目标。</p>
<ol>
<li>HBase提供三维有序存储，首先以rowkey字典序，然后以column family + column qualifier字典序，最后单元格是以timestamp时间戳降序排序。</li>
<li>HBase读操作使用了LRU缓存技术，这种缓存叫做BlockCache，用来保存从HFile里读入内存的频繁访问的数据。</li>
</ol>
<p>从HBase读数据，会依次访问三个地方：首先检查MemStore，然后检查BlockCache，最后才会访问硬盘上的对应HFile。</p>
<h2 id="6-5_Compact/Split">6.5 Compact/Split</h2><p>上文已经讲到，当StoreFile文件数量达到一定阈值，会触发compaction；当单个StoreFile大小超过一定阈值后，会触发split。</p>
<p>Compaction分为两种：major compaction（大合并）和 minor compaction（小合并）</p>
<ol>
<li><p>minor compaction把多个小HFile合并成一个大HFile，主要是为了提高读效率（因为一个row可能散布在多个HFile文件中）。minor compaction不做任何删除数据、过期数据的清理工作。</p>
</li>
<li><p>major compaction是把给定region的一个列族的所有HFile合并成一个文件，major compaction会丢弃有删除标记的或过期的内容，释放占用的空间。</p>
</li>
<li><p>minor合并是轻量级的，可以频繁发生；major合并相当耗资源，不要经常使用，且通常需要手工触发。</p>
</li>
</ol>
<p>Split操作过程完成的非常快，因为原始的数据文件并不会被改变，系统只是简单的创建两个Reference文件指向原始的数据文件，每个Reference文件管理原始文件一半的数据。Reference文件名字是一个ID，它使用被参考的region的名字的hash作为前缀，例如：1278437856009925445.3323223323。Reference文件只含有非常少量的信息，这些信息包括被分割的原始region的key以及这个文件管理前半段还是后半段。只有当系统做compaction的时候原始数据文件才会被分割成两个独立的文件并放到相应的region目录下面，同时原始数据文件和那些Reference文件也会被清除。</p>
<h2 id="6-6_HRegionServer上线和下线">6.6 HRegionServer上线和下线</h2><p>HMaster使用Zookeeper来跟踪HRegionServer状态。当某个HRegionServer启动时，会首先在Zookeeper上的server目录下建立代表自己的文件，并获得该文件的独占锁。由于HMaster订阅了server目录上的变更消息，当server目录下的文件出现新增或删除操作时，HMaster可以得到来自Zookeeper的实时通知。因此一旦HRegionServer上线，HMaster能马上得到消息。</p>
<p>当HRegionServer下线时，它和Zookeeper的会话断开，Zookeeper自动释放代表这台server的文件上的独占锁。而HMaster不断轮询server目录下文件的锁状态，如果发现某个HRegionServer丢失了它自己的独占锁（或者HMaster连续几次和HRegionServer通信都无法成功），HMaster就会去尝试获取代表这个HRegionServer的读写锁，一旦获取成功，就可以确定：</p>
<ul>
<li>可能性一：HRegionServer和Zookeeper之间的网络断开了;</li>
<li>可能性二：HRegionServer挂了;</li>
</ul>
<p>的其中一种情况发生了，无论哪种情况，HRegionServer都无法继续为它的region提供服务了，此时HMaster会删除server目录下代表这台HRegionServer的文件，并将这台HRegionServer的region分配给其它还活着的HRegionServer。</p>
<p>如果网络短暂出现问题导致HRegionServer丢失了它的锁，那么HRegionServer重新连接到Zookeeper之后，只要代表它的文件还在，它就会不断尝试获取这个文件上的锁，一旦获取到了，就可以继续提供服务。</p>
<h2 id="6-7_HMaster上线和下线">6.7 HMaster上线和下线</h2><p>HMaster启动会依次进行以下步骤:</p>
<ol>
<li>从Zookeeper上获取唯一一个master的锁，用来阻止其它HMaster成为工作HMaster。</li>
<li>扫描Zookeeper上的server目录，获得当前可用的HRegionServer列表。</li>
<li>和2中的每个HRegionServer通信，获得当前已分配的region和HRegionServer的对应关系。</li>
<li>扫描.META.中region的集合，计算得到当前还未分配的region，将他们放入待分配region列表。</li>
</ol>
<p>由于HMaster只维护表和region的元数据，而不参与表数据IO的过程，因此HMaster下线仅导致所有元数据的修改被冻结（无法创建删除表，无法修改表的schema，无法进行region的负载均衡，无法处理region上下线，无法进行region的合并，唯一例外的是region的split可以正常进行，因为只有HRegionServer参与），表的数据读写还可以正常进行。因此HMaster下线短时间内对整个HBase集群没有影响。</p>
<p>从上线过程可以看到，HMaster保存的信息全是可以冗余信息（都可以从系统其它地方收集到或者计算出来），因此，一般HBase集群中总是有一个HMaster在提供服务，还有一个以上的HMaster在等待时机抢占它的位置。</p>
<p><br></p>
<h1 id="七、结束">七、结束</h1><p>本文对HBase技术在功能和设计上进行了大致的介绍，由于篇幅有限，本文没有过多深入地描述HBase的一些细节技术。</p>
<p><br><br><br><br><br></p>
<hr>
<p>转自：</p>
<p>[1] www.searchtb.com/2011/01/understanding-hbase.html<br>[2] blog.csdn.net/john_f_lau/article/category/1832241<br>[3] my.oschina.net/zhengyang841117/blog/188723</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、HBase简介">一、HBase简介</h1><p>HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，类似Google BigTable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop+HBase+ZooKeeper分布式集群环境搭建]]></title>
    <link href="http://yoursite.com/2015/07/20/hadoop-hbase-zookeeper-distributed-mode/"/>
    <id>http://yoursite.com/2015/07/20/hadoop-hbase-zookeeper-distributed-mode/</id>
    <published>2015-07-20T14:52:53.000Z</published>
    <updated>2015-07-21T14:28:56.535Z</updated>
    <content type="html"><![CDATA[<h2 id="一、环境说明">一、环境说明</h2><p>集群环境至少需要3个节点（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通，下面举例说明，配置节点IP分配如下：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">User</th>
<th style="text-align:left">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td style="text-align:left">192.168.59.133</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave1</td>
<td style="text-align:left">192.168.59.134</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave2</td>
<td style="text-align:left">192.168.59.135</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
</tbody>
</table>
<a id="more"></a>三个节点均使用<code>CentOS 6.5</code>系统，为了便于维护，集群环境配置项最好使用相同用户名、用户密码、相同hadoop、hbase、zookeeper目录结构。<br><br><strong>注：</strong> 可以通过编辑<code>/etc/sysconfig/network</code>文件来修改 hostname 。<br><br>##二、准备工作<br><br>###2.1 安装JDK<br><br>在三台机器上配置JDK环境，下载 <code>jdk-8u51-linux-x64.rpm</code> 文件直接安装：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh jdk-<span class="number">8u</span>51-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p>修改配置文件 <code>vim /etc/profile</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.<span class="number">8.0</span>_51</span><br><span class="line">export PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">export CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/<span class="tag">dt</span><span class="class">.jar</span>:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>然后重新加载配置文件使之生效：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2_添加Hosts映射关系">2.2 添加Hosts映射关系</h3><p>分别在三个节点上添加hosts映射关系：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vim /etc/hosts</span><br></pre></td></tr></table></figure></p>
<p>添加的内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.59.133 master</span><br><span class="line">192.168.59.134 slave1</span><br><span class="line">192.168.59.135 slave2</span><br></pre></td></tr></table></figure>
<h3 id="2-3_集群之间SSH无密码登陆">2.3 集群之间SSH无密码登陆</h3><p>CentOS默认安装了ssh，如果没有你需要先安装ssh 。</p>
<p>集群环境的使用必须通过ssh无密码登陆来执行，本机登陆本机必须无密码登陆，主机与从机之间必须可以双向无密码登陆，从机与从机之间无限制。</p>
<p><strong>2.3.1 设置master无密码自登陆</strong></p>
<p>主要有三步：①生成公钥和私钥、②导入公钥到认证文件、③更改权限<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="prompt">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">700</span> ~<span class="regexp">/.ssh &amp;&amp; chmod 600 ~/</span>.ssh/*</span><br></pre></td></tr></table></figure></p>
<p>测试，第一次登录可能需要yes确认，之后就可以直接登录了：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br><span class="line">Last login: Sat Jul <span class="number">18</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">44</span> <span class="number">2015</span> <span class="keyword">from</span> localhost</span><br></pre></td></tr></table></figure></p>
<p>对于 slave1 和 slave2，进行无密码自登陆设置，操作同上。</p>
<p><strong>2.3.2 设置主机-&gt;从机的无密码登录</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@slave1</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@slave2</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>ssh hadoop<span class="variable">@slave1</span></span><br><span class="line"><span class="constant">Last </span><span class="symbol">login:</span> <span class="constant">Sat Jul </span><span class="number">18</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">41</span> <span class="number">2015</span> from master</span><br><span class="line"></span><br><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>ssh hadoop<span class="variable">@slave2</span></span><br><span class="line"><span class="constant">Last </span><span class="symbol">login:</span> <span class="constant">Sat Jul </span><span class="number">18</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">14</span> <span class="number">2015</span> from master</span><br></pre></td></tr></table></figure></p>
<p><strong>2.3.3 设置从机-&gt;主机的无密码登录</strong></p>
<p>分别在slave1、slave2上执行：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh hadoop<span class="variable">@master</span> <span class="string">'cat - &gt;&gt; ~/.ssh/authorized_keys'</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="三、Hadoop集群安装配置">三、Hadoop集群安装配置</h2><p>这里会将hadoop、hbase、zookeeper的安装包都解压到<code>/home/hadoop/</code>个人主文件夹下，并重命名为hadoop、hbase、zookeeper。</p>
<h3 id="3-1_修改hadoop配置">3.1 修改hadoop配置</h3><p>配置文件都在<code>~/hadoop/etc/</code>目录下</p>
<p><strong>3.1.1 core-site.xml</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;configuration&gt;</span></span><br><span class="line">	<span class="variable">&lt;property&gt;</span></span><br><span class="line">		<span class="variable">&lt;name&gt;</span>fs.<span class="keyword">default</span>.name<span class="variable">&lt;/name&gt;</span></span><br><span class="line">		<span class="variable">&lt;value&gt;</span>hdfs://master:<span class="number">9000</span><span class="variable">&lt;/value&gt;</span></span><br><span class="line">	<span class="variable">&lt;/property&gt;</span></span><br><span class="line"><span class="variable">&lt;/configuration&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.2 hadoop-env.sh</strong></p>
<p>添加JDK路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>
<p><strong>3.1.3 hdfs-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hadoop/name<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hadoop/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>3<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.4 mapred-site.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1.5 修改masters文件</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master</span><br></pre></td></tr></table></figure>
<p><strong>3.1.6 修改slaves文件</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave1</span></span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
<p>注意：三台机器上都进行相同的配置，都放在相同的路径下。</p>
<p>使用<code>scp</code>命令进行从本地到远程（或远程到本地）的文件拷贝操作：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop     slave1:/</span>home/hadoop</span><br><span class="line">scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hadoop     slave2:/</span>home/hadoop</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2_启动hadoop集群">3.2 启动hadoop集群</h3><p>进入master的<code>~/hadoop</code>目录，执行以下操作：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hadoop namenode -<span class="built_in">format</span></span><br></pre></td></tr></table></figure></p>
<p>格式化namenode，第一次启动服务前执行的操作，以后不需要执行。</p>
<p>然后启动hadoop：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sbin/<span class="operator"><span class="keyword">start</span>-<span class="keyword">all</span>.sh</span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>jps</code>命令能看到除jps外有5个进程：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>jps</span><br><span class="line"><span class="number">4866</span> <span class="constant">NodeManager</span></span><br><span class="line"><span class="number">4370</span> <span class="constant">NameNode</span></span><br><span class="line"><span class="number">4899</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">4648</span> <span class="constant">SecondaryNameNode</span></span><br><span class="line"><span class="number">4779</span> <span class="constant">ResourceManager</span></span><br><span class="line"><span class="number">4460</span> <span class="constant">DataNode</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="四、ZooKeeper集群安装配置">四、ZooKeeper集群安装配置</h2><p>解压zookeeper-3.3.2.tar.gz并重命名为zookeeper。</p>
<h3 id="4-1_修改配置文件zoo-cfg">4.1 修改配置文件zoo.cfg</h3><p>进入<code>~/zookeeper/conf</code>目录：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp zoo_sample<span class="class">.cfg</span> zoo.cfg</span><br></pre></td></tr></table></figure></p>
<p>拷贝<code>zoo_sample.cfg</code>文件为<code>zoo.cfg</code>，并编辑如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/hadoop/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span>.1=<span class="number">192.168</span>.59.133:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="keyword">server</span>.2=<span class="number">192.168</span>.59.134:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="keyword">server</span>.3=<span class="number">192.168</span>.59.135:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-2_新建并编辑myid文件">4.2 新建并编辑myid文件</h3><p>在dataDir目录下新建myid文件，输入一个数字（master为<code>1</code>，slave1为<code>2</code>，slave2为<code>3</code>）：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir /home/hadoop/zookeeper/data</span><br><span class="line"><span class="variable">$ </span>echo <span class="string">"1"</span> &gt; <span class="regexp">/home/hadoop</span><span class="regexp">/zookeeper/data</span><span class="regexp">/myid</span></span><br></pre></td></tr></table></figure></p>
<p>同样使用<code>scp</code>命令进行远程复制，只不过要修改每个节点上<code>myid</code>文件中的数字。</p>
<h3 id="4-3_启动ZooKeeper集群">4.3 启动ZooKeeper集群</h3><p>在ZooKeeper集群的每个结点上，执行启动ZooKeeper服务的脚本：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>~<span class="regexp">/zookeeper/bin</span><span class="regexp">/zkServer.sh start</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果启动报类似异常:QuorumCnxManager@384] - Cannot open channel to 2 at election address slave-02/192.168.0.178:3888 是可以忽略的,因为该服务启动时会尝试连接所有节点,而其他节点尚未启动。通过后面部分可以看到，集群在选出一个Leader后，最后稳定 了。其他结点可能也出现类似问题，属于正常。</p>
</li>
<li><p>关闭防火墙。在hadoop集群环境(linux系统)中最好关闭防火墙，不然会出现很多问题，例如namenode找不到datanode等。如果不关闭防火墙，客户端使用API操作HDFS以及ZooKeeper，可能就会出现下面常见的两种异常：</p>
<ul>
<li>使用API操作HDFS时会出现异常：java.net.NoRouteToHostException: No route to host</li>
<li>使用API操作ZK时会出现异常：org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss for xxxx</li>
</ul>
</li>
<li><p>使用root权限登陆后，输入关闭防火墙命令：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/iptables <span class="literal">stop</span></span><br><span class="line">$ <span class="keyword">service</span> iptables <span class="literal">stop</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改禁用selinux：     /etc/selinux/config文件，设置<code>&quot;SELINUX=disabled&quot;</code></p>
</li>
</ol>
<p><br></p>
<h2 id="五、HBase集群安装配置">五、HBase集群安装配置</h2><p>解压hbase-1.0.1.1-bin.tar.gz并重命名为hbase。</p>
<h3 id="5-1_hbase-env-sh">5.1 hbase-env.sh</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1.8.0_51</span><br><span class="line"><span class="keyword">export</span> HBASE_CLASSPATH=<span class="regexp">/home/</span>hadoop/hadoop/etc/hadoop/</span><br><span class="line"><span class="keyword">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2_hbase-site-xml">5.2 hbase-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.master<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>master,slave1,slave2<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>zookeeper.session.timeout<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.support.append<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3_更改_regionservers">5.3 更改 regionservers</h3><p>在 regionservers 文件中添加slave列表：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">slave1</span></span><br><span class="line">slave2</span><br></pre></td></tr></table></figure></p>
<p><strong>5.4 分发并同步安装包</strong></p>
<p>将整个hbase安装目录都拷贝到所有slave服务器：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hbase  slave1:/</span>home/hadoop</span><br><span class="line">$ scp -r <span class="regexp">/home/</span>hadoop<span class="regexp">/hbase  slave2:/</span>home/hadoop</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="六、启动集群">六、启动集群</h3><p> <strong>1. 启动ZooKeeper</strong></p>
<p>~/zookeeper/bin/zkServer.sh start</p>
<p><strong>2. 启动hadoop</strong></p>
<p>~/hadoop/sbin/start-all.sh</p>
<p><strong>3. 启动hbase</strong></p>
<p>~/hbase/bin/start-base.sh</p>
<p><strong>4. 启动后，master上进程和slave进程列表</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>jps</span><br><span class="line"><span class="number">6225</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">2897</span> <span class="constant">SecondaryNameNode </span>  <span class="comment"># hadoop进程</span></span><br><span class="line"><span class="number">2710</span> <span class="constant">NameNode </span>           <span class="comment"># hadoop master进程</span></span><br><span class="line"><span class="number">3035</span> <span class="constant">ResourceManager </span>    <span class="comment"># hadoop进程</span></span><br><span class="line"><span class="number">5471</span> <span class="constant">HMaster </span>            <span class="comment"># hbase master进程</span></span><br><span class="line"><span class="number">2543</span> <span class="constant">QuorumPeerMain </span>     <span class="comment"># zookeeper进程</span></span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@slave1</span> ~]<span class="variable">$ </span>jps</span><br><span class="line"><span class="number">4689</span> <span class="constant">Jps</span></span><br><span class="line"><span class="number">2533</span> <span class="constant">QuorumPeerMain </span>      <span class="comment"># zookeeper进程</span></span><br><span class="line"><span class="number">2589</span> <span class="constant">DataNode </span>            <span class="comment"># hadoop slave进程</span></span><br><span class="line"><span class="number">4143</span> <span class="constant">HRegionServer </span>       <span class="comment"># hbase slave进程</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 进入hbase shell进行验证</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="variable">@master</span> ~]<span class="variable">$ </span>hbase/bin/hbase shell</span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">42</span><span class="symbol">:</span><span class="number">11</span>,<span class="number">725</span> <span class="constant">WARN</span>  [main] util.<span class="constant">NativeCodeLoader</span><span class="symbol">:</span> <span class="constant">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="constant">HBase</span> <span class="constant">Shell</span>; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.</span><br><span class="line"><span class="constant">Type</span> <span class="string">"exit&lt;RETURN&gt;"</span> to leave the <span class="constant">HBase</span> <span class="constant">Shell</span></span><br><span class="line"><span class="constant">Version</span> <span class="number">1.0</span>.<span class="number">1.1</span>, re1dbf4df30d214fca14908df71d038081577ea46, <span class="constant">Sun</span> <span class="constant">May</span> <span class="number">17</span> <span class="number">12</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">26</span> <span class="constant">PDT</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">hbase(main):001:0&gt;</span> list</span><br><span class="line"><span class="constant">TABLE</span>                                                                                </span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.6950</span> seconds</span><br><span class="line"><span class="status"></span><br><span class="line">=&gt;</span> []</span><br><span class="line"><span class="prompt">hbase(main):002:0&gt;</span> status</span><br><span class="line"><span class="number">2</span> servers, <span class="number">0</span> dead, <span class="number">1.0000</span> average load</span><br><span class="line"></span><br><span class="line"><span class="prompt">hbase(main):003:0&gt;</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br></p>
<hr>
<p>参考：<br>[1] www.smalldeng.blog.51cto.com/1038075/1329290<br>[2] www.marysee.blog.51cto.com/1000292/629405<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、环境说明">一、环境说明</h2><p>集群环境至少需要3个节点（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通，下面举例说明，配置节点IP分配如下：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">User</th>
<th style="text-align:left">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td style="text-align:left">192.168.59.133</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave1</td>
<td style="text-align:left">192.168.59.134</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td>slave2</td>
<td style="text-align:left">192.168.59.135</td>
<td style="text-align:left">hadoop</td>
<td style="text-align:left">123456</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-Hadoop" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase单机环境搭建]]></title>
    <link href="http://yoursite.com/2015/07/20/hbase-standalone-mode/"/>
    <id>http://yoursite.com/2015/07/20/hbase-standalone-mode/</id>
    <published>2015-07-20T14:37:48.000Z</published>
    <updated>2015-07-20T14:44:41.307Z</updated>
    <content type="html"><![CDATA[<p>在搭建HBase单机环境之前，首先你要保证你已经搭建好Java环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version&#10;java version &#34;1.8.0_51&#34;&#10;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)&#10;Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p><code>JAVA_HOME</code>路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME&#10;/usr/java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>在单机模式中，HBase并不使用 HDFS，仅使用本地文件系统 —— ZooKeeper程序与HBase程序运行在同一个JVM进程中。<br><br>#一、下载HBase<br><br>虚拟机：VMware-workstation-11.1.0<br>操作系统：CentOS 6.5<br>JDK：jdk1.8.0_51<br>HBase：hbase-1.0.1.1<br><br>1、 下载的是HBase最新稳定版<code>hbase-1.0.1.1-bin.tar.gz</code>，地址 <a href="http://apache.fayea.com/hbase/" target="_blank" rel="external">http://apache.fayea.com/hbase/</a><br><br>2、 解压到个人主目录下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxf hbase-1.0.1.1-bin.tar.gz&#10;$ cd hbase-1.0.1.1</span><br></pre></td></tr></table></figure>
<h1 id="二、配置HBase">二、配置HBase</h1><p>需要配置两个文件。</p>
<p>1、hbase-env.sh</p>
<p>编辑文件<code>vim conf/hbase-env.sh</code>，去掉#注释，<code>JAVA_HOME</code>改成jdk对应的路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_51&#10;export HBASE_MANAGES_ZK=true</span><br></pre></td></tr></table></figure></p>
<p>Hbase依赖于zookeeper，所有的节点和客户端都必须能够访问zookeeper。</p>
<p>HBase的安装包里面有自带的ZooKeeper，<code>HBASE_MANAGES_ZK</code>环境变量用来设置是使用HBase默认自带的 Zookeeper还是使用独立的ZooKeeper。</p>
<ul>
<li><code>HBASE_MANAGES_ZK</code>为 false 时使用独立的.</li>
<li><code>HBASE_MANAGES_ZK</code>为 true 时表示使用默认自带的，让Hbase启动的时候同时也启动自带的ZooKeeper。</li>
</ul>
<p>2、hbase-site.xml</p>
<p>编辑文件<code>vim conf/hbase-site.xml</code>，设置数据保存的目录：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:///home/songlee/hbase-1.0.1.1/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下Hbase是写到/tmp的，在重启的时候/tmp会被清空，数据就会丢失。</p>
<h1 id="三、启动HBase">三、启动HBase</h1><p>使用HBase提供的脚本启动HBase：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/start-hbase.sh &#10;starting master, logging to /home/songlee/hbase-1.0.1.1/bin/../logs/hbase-songlee-master-songlee.out</span><br></pre></td></tr></table></figure></p>
<p>查看Java进程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps&#10;5464 HMaster&#10;5561 Jps</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>HMaster</code>进程已经启动了。</p>
<h1 id="四、HBase_Shell交互">四、HBase Shell交互</h1><p>HBase Shell是一个封装了Java API的JRuby应用软件，通过它可以与HBase集群进行交互。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hbase <span class="built_in">shell</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">07</span>,<span class="number">171</span> WARN  [main] util.NativeCodeLoader: Unable <span class="built_in">to</span> <span class="built_in">load</span> native-hadoop library <span class="keyword">for</span> your <span class="built_in">platform</span>... <span class="keyword">using</span> builtin-java classes where applicable</span><br><span class="line">HBase Shell; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list <span class="operator">of</span> supported commands.</span><br><span class="line">Type <span class="string">"exit&lt;RETURN&gt;"</span> <span class="built_in">to</span> leave <span class="operator">the</span> HBase Shell</span><br><span class="line">Version <span class="number">1.0</span>.1.1, re1dbf4df30d214fca14908df71d038081577ea46, Sun May <span class="number">17</span> <span class="number">12</span>:<span class="number">34</span>:<span class="number">26</span> PDT <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>建表：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):006:0&#62; create &#39;mytable&#39;,&#39;cf&#39;&#10;0 row(s) in 0.3090 seconds</span><br></pre></td></tr></table></figure></p>
<p>添加数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):008:0&#62; put &#39;mytable&#39;,&#39;first&#39;,&#39;cf:message&#39;,&#39;hello HBase!&#39;&#10;0 row(s) in 0.1420 seconds&#10;&#10;hbase(main):009:0&#62; put &#39;mytable&#39;,&#39;second&#39;,&#39;cf:foo&#39;,0x0&#10;0 row(s) in 0.0220 seconds&#10;&#10;hbase(main):010:0&#62; put &#39;mytable&#39;,&#39;third&#39;,&#39;cf:bar&#39;,3.14159&#10;0 row(s) in 0.0180 seconds</span><br></pre></td></tr></table></figure></p>
<p>获取数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):011:0&#62; get &#39;mytable&#39;,&#39;first&#39;&#10;COLUMN                          CELL                                                                                      &#10; cf:message                     timestamp=1437015412793, value=hello HBase!                                               &#10;1 row(s) in 0.0540 seconds</span><br></pre></td></tr></table></figure></p>
<p>扫描表：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):012:0&#62; scan &#39;mytable&#39;&#10;ROW                             COLUMN+CELL                                                                               &#10; first                          column=cf:message, timestamp=1437015412793, value=hello HBase!                            &#10; second                         column=cf:foo, timestamp=1437015468629, value=0                                           &#10; third                          column=cf:bar, timestamp=1437015511565, value=3.14159                                     &#10;3 row(s) in 0.0650 seconds</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在搭建HBase单机环境之前，首先你要保证你已经搭建好Java环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version&#10;java version &#34;1.8.0_51&#34;&#10;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)&#10;Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p><code>JAVA_HOME</code>路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME&#10;/usr/java/jdk1.8.0_51</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
      <category term="大数据-HBase" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-HBase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015实习生求职季总结]]></title>
    <link href="http://yoursite.com/2015/05/23/intern-seeking-experience/"/>
    <id>http://yoursite.com/2015/05/23/intern-seeking-experience/</id>
    <published>2015-05-23T01:40:05.000Z</published>
    <updated>2015-05-23T07:14:57.577Z</updated>
    <content type="html"><![CDATA[<p style="font-size:15pt;font-weight:bold">一、实习季Timeline</p>

<p>从2015年4月开始找实习，前后历时两个月，参加了很多的笔试/面试。这是一个焦虑又美好的学期，我在这段时间里学到了很多东西。</p>
<iframe src="http://timelinejs.sinaapp.com/" width="100%" height="500" frameborder="0"></iframe>

<a id="more"></a>
<p>这一个学期就这么磕磕绊绊的过了一半了，决定去360实习以后，也终于能安下心来。因为等待（笔试/面试通知）真的是很痛苦的一件事。</p>
<p>参加的笔试/面试越多，越发现自己有很多的不足。求职难免碰壁，这两个月我被虐了好几次，导致我的自信心直线下降。但现在来看，我觉得被虐反而更好，它让我不断总结和反思：哪一块的知识不知道就补哪一块，然后不断地提高自己。</p>
<p><br></p>
<p style="font-size:15pt;font-weight:bold">二、经验之谈</p>

<p>我在本科时就决定要进互联网行业，在做过的项目中是C++开发居多，所以也自然而然的走向了服务端开发方向。从这两个月的笔试/面试经历来看，其实做后台服务端开发主要就是要掌握5个方面的基础知识，而且需要较深入。</p>
<ol>
<li><p><strong>语言：</strong>编程语言必然要掌握一门的，而且需要熟练的掌握。从笔试/面试的情况来看，基本就是 C/C++/Java 熟练掌握一门，最好还会一门脚本语言（Perl/Python/Shell）。因为我是C++党，所以这里推荐一下学习C++要看的书：</p>
<ul>
<li>《C++ Primer》不用多说，入门必看。</li>
<li>《Effective C++》《More Effective C++》《深度探索C++对象模型》进阶。</li>
<li>《Effective STL》《STL源码剖析》了解C++ STL。</li>
</ul>
</li>
<li><p><strong>算法与数据结构：</strong>这个就不用多说，不管什么岗位都要有算法基础的。</p>
<ul>
<li>《算法导论》最经典，但有人说上面讲的太繁琐，其实我也觉得，可能是水平还不够。</li>
<li>《程序员面试金典》《编程之美》《剑指offer》</li>
<li>刷题：LeetCode</li>
</ul>
</li>
<li><p><strong>操作系统：</strong>做服务端开发，对操作系统一定要很了解。通常考的最多的是进程线程、内存管理、I/O管理。</p>
<ul>
<li>《现代操作系统》《深入理解计算机系统》这是原理方面的。</li>
<li>《UNIX环境高级编程》服务端是比较偏Unix/Linux的。</li>
<li>如果你还要了解Linux内核的话…</li>
</ul>
</li>
<li><p><strong>网络：</strong>主要是指TCP/IP，做服务端必须熟练掌握TCP/IP，这点不需要解释什么。</p>
<ul>
<li>《TCP/IP协议详解》卷1，必看网络协议经典书籍。</li>
<li>《计算机网络：自顶向下方法》也是讲原理的。</li>
<li>《Unix网络编程》了解了原理，需要实战一下。</li>
</ul>
</li>
<li><p><strong>数据库：</strong>不论什么样的应用，都需要数据库的支持，数据库无处不在。而现在主流的还是关系型数据库，建议学MySQL。</p>
<ul>
<li>《数据库系统概念》了解数据库。</li>
<li>《SQL Cookbook》《SQL入门经典》了解SQL结构化查询语言。</li>
<li>《高性能MySQL》《MySQL技术内幕》学习MySQL本身。</li>
</ul>
</li>
</ol>
<p>当然，上面推荐的书籍是各领域评分较高的书籍，我目前也就看了一部分（要是都看完了，我就不是这个水平了）。除了打好基础，你还可以了解某一些领域的知识，比如《Linux高性能服务器编程》帮你从整体上了解服务端开发，《分布式系统原理与范型》了解分布式，或者看一些经典的论文，比如Google三大论文，或者学习Hadoop/Spark分布式计算框架等等。</p>
<p>下面是百度公司分享的一个技术能力模型：</p>
<center><br><img src="http://img.blog.csdn.net/20150523134332379" alt=""><br></center>

<p>对于基础知识，必然是要全部掌握的；而对于技术领域，可以择其一而攻之。</p>
<p><br></p>
<p style="font-size:15pt;font-weight:bold">三、计划和展望</p>

<p>这个实习生招聘季，经过多个<code>笔试-&gt;总结-&gt;面试-&gt;总结</code>的循环，我学到了很多，提高了很多。同时，也更加明确了自己将来要做什么，要往哪个方向走。</p>
<p>我会记住并保持这段时间的这种心态，在接下来一年的实习时间里，看完还没看完的书，了解并学习一些新的领域，完成给自己制定的<code>To-Do-List</code>。相信在一年后的毕业招聘季中，我能更加地得心应手。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p style="font-size:15pt;font-weight:bold">一、实习季Timeline</p>

<p>从2015年4月开始找实习，前后历时两个月，参加了很多的笔试/面试。这是一个焦虑又美好的学期，我在这段时间里学到了很多东西。</p>
<iframe src='http://timelinejs.sinaapp.com/' width='100%' height='500' frameborder='0'></iframe>]]>
    
    </summary>
    
      <category term="非技术-杂谈" scheme="http://yoursite.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF-%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求最长回文子串]]></title>
    <link href="http://yoursite.com/2015/05/12/longest-palindromic-substring/"/>
    <id>http://yoursite.com/2015/05/12/longest-palindromic-substring/</id>
    <published>2015-05-12T12:53:19.000Z</published>
    <updated>2015-05-12T13:11:43.312Z</updated>
    <content type="html"><![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。<a id="more"></a></p>
<h3 id="解法二：动态规划法$O(n^2)$">解法二：动态规划法$O(n^2)$</h3><p>动态规划法是在暴力解法上进行的优化。通过记录一些我们需要的东西，来避免暴力解法中很多重复的判断。</p>
<p>假设 $dp[i][j]$ 表示子串 $s[i…j]$ 是否是回文，那么对于动态规划表 $dp$ 的打表方式如下：</p>
<ul>
<li><p>初始化：<br>$$\begin{cases}<br>dp[i][i] = true  &amp; \text{(0 &lt;= i &lt;= n-1)}\\<br>dp[i][i-1] = true &amp; \text{(1 &lt;= i &lt;= n-1) }\\<br>others = fasle<br>\end{cases}$$</p>
</li>
<li><p>动态规划的状态转移方程：<br>$$<br>dp[i][j] =<br>\begin{cases}<br>dp[i+1][j-1], &amp; \text{if s[i] == s[j]} \\<br>false, &amp; \text{if s[i] ≠ s[j]}<br>\end{cases}<br>$$</p>
</li>
</ul>
<p>C++代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="comment">// 动态规划表，全部初始化为true</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=len; ++k) &#123;    <span class="comment">// 枚举子串的长度</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-k; ++i) &#123;  <span class="comment">// 枚举子串起始位置</span></span><br><span class="line">			<span class="keyword">int</span> j = i+k-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">				start = i;      <span class="comment">// 记录回文子串的起点和长度</span></span><br><span class="line">				maxlen = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解法三：中心扩展法$O(n^2)$">解法三：中心扩展法$O(n^2)$</h3><p>这个算法思想其实很简单，就是对给定的字符串S，分别以该字符串S中的每一个字符 c 为中心，向两边扩展，记录下以字符 c 为中心的回文子串的长度。时间复杂度为$O(n^2)$，空间复杂度仅为$O(1)$。</p>
<p>但有一点需要注意的是，回文的情况可能是 a b a，也可能是 a b b a。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别向左右扩展，返回扩展后的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right]) </span><br><span class="line">	&#123;</span><br><span class="line">		left--;</span><br><span class="line">		right++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substr(left+<span class="number">1</span>, right-left-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最长回文子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> longest;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> p1 = expand(s, i, i);  <span class="comment">// 奇数</span></span><br><span class="line">		<span class="keyword">if</span> (p1.size() &gt; longest.size())</span><br><span class="line">			longest = p1;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">string</span> p2 = expand(s, i, i+<span class="number">1</span>);  <span class="comment">// 偶数</span></span><br><span class="line">		<span class="keyword">if</span> (p2.size() &gt; longest.size())</span><br><span class="line">			longest = p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br>另外，据说还有一个很巧妙的算法，叫Manacher算法，可以在 $O(n)$ 的时间复杂度里求出最长回文子串。由于这个算法我没有研究过，在这里就不介绍了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计并实现一个LRU Cache]]></title>
    <link href="http://yoursite.com/2015/05/10/design-LRU-Cache/"/>
    <id>http://yoursite.com/2015/05/10/design-LRU-Cache/</id>
    <published>2015-05-10T12:33:13.000Z</published>
    <updated>2015-05-10T13:23:03.702Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。<a id="more"></a></p>
<h4 id="2_原理">2 原理</h4><p>Cache 技术所依赖的原理是”程序执行与数据访问的<strong>局部性原理</strong>“，这种局部性表现在两个方面：</p>
<ol>
<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令或数据通常是顺序存放的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到Cache中实现。空间局部性通常是使用较大的高速缓存，并将 预取机制 集成到高速缓存控制逻辑中来实现。</p>
<h4 id="3_替换策略">3 替换策略</h4><p>Cache的容量是有限的，当Cache的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。常用的替换策略有以下几种：</p>
<ol>
<li><p><strong>随机算法（Rand）</strong>：随机法是随机地确定替换的存储块。设置一个随机数产生器，依据所产生的随机数，确定替换块。这种方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p><strong>先进先出算法（FIFO, First In First Out）</strong>：先进先出法是选择那个最先调入的那个块进行替换。当最先调入并被多次命中的块，很可能被优先替换，因而不符合局部性规律。这种方法的命中率比随机法好些，但还不满足要求。</p>
</li>
<li><p><strong>最久未使用算法（LRU, Least Recently Used）</strong>：LRU法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。</p>
</li>
<li><p><strong>最不经常使用算法（LFU, Least Frequently Used）</strong>：将最近一段时期内，访问次数最少的块替换出Cache。</p>
</li>
</ol>
<h4 id="4_概念的扩充">4 概念的扩充</h4><p>如今高速缓存的概念已被扩充，不仅在CPU和主内存之间有Cache，而且在内存和硬盘之间也有Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的Cache──称为Internet临时文件夹或网络内容缓存等。<strong>凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。</strong></p>
<p><br></p>
<h3 id="二、LRU_Cache的实现">二、LRU Cache的实现</h3><p><strong>Google的一道面试题：</strong></p>
<p>Design an LRU cache with all the operations to be done in $O(1)$ .</p>
<h4 id="1_思路分析">1 思路分析</h4><p>对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。</p>
<p>为了能够快速删除最久没有访问的数据项和插入最新的数据项，我们使用 <strong>双向链表</strong> 连接Cache中的数据项，并且保证链表维持数据项从最近访问到最旧访问的顺序。</p>
<ul>
<li><p><strong>插入</strong>：当Cache未满时，新的数据项只需插到双链表头部即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>替换</strong>：当Cache已满时，将新的数据项插到双链表头部，并删除双链表的尾结点即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>查找</strong>：每次数据项被查询到时，都将此数据项移动到链表头部。</p>
</li>
</ul>
<p>经过分析，我们知道使用双向链表可以保证插入和替换的时间复杂度是$O(1)$，但查询的时间复杂度是$O(n)$，因为需要对双链表进行遍历。为了让查找效率也达到$O(1)$，很自然的会想到使用 <strong>hash table</strong> 。</p>
<h4 id="2_代码实现">2 代码实现</h4><p>从上述分析可知，我们需要使用两种数据结构：</p>
<ol>
<li><strong>双向链表（Doubly Linked List）</strong></li>
<li><strong>哈希表（Hash Table）</strong></li>
</ol>
<p>下面是LRU Cache的 C++ 实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的节点结构</span></span><br><span class="line"><span class="keyword">struct</span> LRUCacheNode &#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	LRUCacheNode* prev;</span><br><span class="line">	LRUCacheNode* next;</span><br><span class="line">	LRUCacheNode():key(<span class="number">0</span>),value(<span class="number">0</span>),prev(NULL),next(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LRUCache</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, LRUCacheNode*&gt; m;  <span class="comment">// 代替hash_map</span></span><br><span class="line">	LRUCacheNode* head;     <span class="comment">// 指向双链表的头结点</span></span><br><span class="line">	LRUCacheNode* tail;     <span class="comment">// 指向双链表的尾结点</span></span><br><span class="line">	<span class="keyword">int</span> capacity;           <span class="comment">// Cache的容量</span></span><br><span class="line">	<span class="keyword">int</span> count;              <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> capacity);       <span class="comment">// 构造函数</span></span><br><span class="line">	~LRUCache();                  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;             <span class="comment">// 查询数据项</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>; <span class="comment">// 未满时插入,已满时替换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeLRUNode</span><span class="params">()</span></span>;                 <span class="comment">// 删除尾结点（最久未使用）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">detachNode</span><span class="params">(LRUCacheNode* node)</span></span>;    <span class="comment">// 分离当前结点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertToFront</span><span class="params">(LRUCacheNode* node)</span></span>; <span class="comment">// 节点插入到头部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LRUCache::LRUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	<span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">	head = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	tail = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	head-&gt;prev = NULL;</span><br><span class="line">	head-&gt;next = tail;</span><br><span class="line">	tail-&gt;prev = head;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~LRUCache()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">	<span class="keyword">delete</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LRUCache::get(<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);      <span class="comment">// 命中，移至头部 </span></span><br><span class="line">		insertToFront(node);</span><br><span class="line">		<span class="keyword">return</span> node-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::<span class="built_in">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">		<span class="keyword">if</span>(count == capacity)   <span class="comment">// Cache已满</span></span><br><span class="line">			removeLRUNode();</span><br><span class="line"></span><br><span class="line">		node-&gt;key = key;</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		m[key] = node;          <span class="comment">// 插入哈希表</span></span><br><span class="line">		insertToFront(node);    <span class="comment">// 插入链表头部</span></span><br><span class="line">		++count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		insertToFront(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::removeLRUNode()</span><br><span class="line">&#123;</span><br><span class="line">	LRUCacheNode* node = tail-&gt;prev;</span><br><span class="line">	detachNode(node);</span><br><span class="line">	m.erase(node-&gt;key);</span><br><span class="line">	--count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::detachNode(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">	node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::insertToFront(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = head-&gt;next;</span><br><span class="line">	node-&gt;prev = head;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">	node-&gt;next-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trie树|前缀树的介绍与实现]]></title>
    <link href="http://yoursite.com/2015/05/09/prefix-tree/"/>
    <id>http://yoursite.com/2015/05/09/prefix-tree/</id>
    <published>2015-05-09T12:17:12.000Z</published>
    <updated>2015-05-10T12:30:30.917Z</updated>
    <content type="html"><![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center><a id="more"></a></p>
<p>上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li>
<li>从根节点到<strong>某一个节点</strong>，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符互不相同。</li>
</ol>
<p>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p>
<p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做<strong>前缀树（Prefix Tree）</strong>。</p>
<p><br></p>
<h1 id="二、Trie树的优缺点">二、Trie树的优缺点</h1><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p>
<h2 id="优点">优点</h2><ol>
<li><p>插入和查询的效率很高，都为$O(m)$，其中 $m$ 是待插入/查询的字符串的长度。</p>
<ul>
<li>关于查询，会有人说 hash 表时间复杂度是$O(1)$不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。</li>
</ul>
</li>
<li><p>Trie树中不同的关键字不会产生冲突。</p>
</li>
<li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p>
</li>
<li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p>
</li>
<li><p>Trie树可以对关键字按<strong>字典序</strong>排序。</p>
</li>
</ol>
<h2 id="缺点">缺点</h2><ol>
<li><p>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</p>
</li>
<li><p>空间消耗比较大。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、Trie树的应用">三、Trie树的应用</h1><h2 id="1、字符串检索">1、字符串检索</h2><p>检索/查询功能是Trie树最原始的功能。<strong>思路</strong>就是从根节点开始一个一个字符进行比较：</p>
<ul>
<li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li>
<li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、词频统计">2、词频统计</h2><p>Trie树常被搜索引擎系统用于文本词频统计    。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量<code>count</code>来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后<code>count</code>置1。</p>
<p><strong>注意：第一、第二种应用也都可以用 hash table 来做。</strong></p>
<h2 id="3、字符串排序">3、字符串排序</h2><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p>
<h2 id="4、前缀匹配">4、前缀匹配</h2><p>例如：找出一个字符串集合中所有以<code>ab</code>开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以<code>a-&gt;b-&gt;</code>开头的路径上的关键字即可。</p>
<p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h2 id="5、作为其他数据结构和算法的辅助结构">5、作为其他数据结构和算法的辅助结构</h2><p>如后缀树，AC自动机等。</p>
<p><br></p>
<h1 id="四、Trie树的实现">四、Trie树的实现</h1><p>这里为了方便，我们假设所有的关键字都由 a-z 的字母组成。下面是 trie 树的一种典型实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ALPHABET_SIZE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">	trie_node *children[ALPHABET_SIZE]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;*trie;</span><br><span class="line"></span><br><span class="line">trie_node* create_trie_node()</span><br><span class="line">&#123;</span><br><span class="line">	trie_node* pNode = <span class="keyword">new</span> trie_node();</span><br><span class="line">	pNode-&gt;count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ALPHABET_SIZE; ++i)</span><br><span class="line">		pNode-&gt;children[i] = NULL;</span><br><span class="line">	<span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trie_insert</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;children[*p-<span class="string">'a'</span>] == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;children[*p-<span class="string">'a'</span>] = create_trie_node();</span><br><span class="line">		&#125;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 查询：不存在返回0，存在返回出现的次数</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trie_search</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p &amp;&amp; node!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(node == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 关键字集合</span></span><br><span class="line">	<span class="keyword">char</span> keys[][<span class="number">8</span>] = &#123;<span class="string">"the"</span>, <span class="string">"a"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>, <span class="string">"any"</span>, <span class="string">"by"</span>, <span class="string">"bye"</span>, <span class="string">"their"</span>&#125;;</span><br><span class="line">	trie root = create_trie_node();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建trie树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		trie_insert(root, keys[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检索字符串</span></span><br><span class="line">	<span class="keyword">char</span> s[][<span class="number">32</span>] = &#123;<span class="string">"Present in trie"</span>, <span class="string">"Not present in trie"</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"the"</span>, trie_search(root, <span class="string">"the"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"these"</span>, trie_search(root, <span class="string">"these"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"their"</span>, trie_search(root, <span class="string">"their"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"thaw"</span>, trie_search(root, <span class="string">"thaw"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于Trie树，我们一般只需要插入和搜索操作。上面这段代码实现了一棵Trie树，该Trie树可以用来检索单词和统计词频。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center>]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑排序（Topological Sorting）]]></title>
    <link href="http://yoursite.com/2015/05/07/topological-sorting/"/>
    <id>http://yoursite.com/2015/05/07/topological-sorting/</id>
    <published>2015-05-07T15:23:52.000Z</published>
    <updated>2015-05-10T12:13:59.727Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。<a id="more"></a></p>
<p>例如，下面这个图：</p>
<center><br><img src="http://img.blog.csdn.net/20150507001028284" alt=""><br></center>

<p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环。</li>
</ol>
<center><br><img src="http://img.blog.csdn.net/20150507001759702" alt=""><br></center>

<p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p>
<p>通常，一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</p>
<p><br></p>
<h3 id="二、拓扑排序的应用">二、拓扑排序的应用</h3><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p>
<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 <a, b=""> 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</a,></p>
<p><br></p>
<h3 id="三、拓扑排序的实现">三、拓扑排序的实现</h3><p>根据上面讲的方法，我们关键是要<strong>维护一个入度为0的顶点的集合</strong>。</p>
<p>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用<strong>邻接表</strong>来存储图，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类声明************************/</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;             <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;    <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;      <span class="comment">// 维护一个入度为0的顶点的集合</span></span><br><span class="line">	<span class="keyword">int</span>* indegree;     <span class="comment">// 记录每个顶点的入度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                   <span class="comment">// 构造函数</span></span><br><span class="line">	~Graph();                       <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;     <span class="comment">// 添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">topological_sort</span><span class="params">()</span></span>;        <span class="comment">// 拓扑排序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类定义************************/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line"></span><br><span class="line">	indegree = <span class="keyword">new</span> <span class="keyword">int</span>[V];  <span class="comment">// 入度全部初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		indegree[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph::~Graph()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] adj;</span><br><span class="line">	<span class="keyword">delete</span> [] indegree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w); </span><br><span class="line">	++indegree[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Graph::topological_sort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">			q.push(i);         <span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;             <span class="comment">// 计数，记录当前已经输出的顶点数 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = q.front();      <span class="comment">// 从队列中取出一个顶点</span></span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;      <span class="comment">// 输出该顶点</span></span><br><span class="line">		++count;</span><br><span class="line">		<span class="comment">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class="line">		<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator beg = adj[v].begin();</span><br><span class="line">		<span class="keyword">for</span>( ; beg!=adj[v].end(); ++beg)</span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[*beg]))</span><br><span class="line">				q.push(*beg);   <span class="comment">// 若入度为0，则入栈</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(count &lt; V)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;           <span class="comment">// 没有输出全部顶点，有向图中有回路</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;            <span class="comment">// 拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下DAG图：</p>
<p><img src="http://img.blog.csdn.net/20150507013500102" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(6)</span></span>;   <span class="comment">// 创建图</span></span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	g.topological_sort();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>
<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的<code>queue</code>。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为$O(V+E)$。</p>
<p><br><br><br><br><br><br><br><br><br>另外，拓扑排序还可以采用 <a href="http://songlee24.github.io/2014/07/04/depth-first-search/" target="_blank" rel="external">深度优先搜索（DFS）</a>的思想来实现，详见《<a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank" rel="external">topological sorting via DFS</a>》。</p>
<p><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解公钥与私钥]]></title>
    <link href="http://yoursite.com/2015/05/03/public-key-and-private-key/"/>
    <id>http://yoursite.com/2015/05/03/public-key-and-private-key/</id>
    <published>2015-05-03T05:05:36.000Z</published>
    <updated>2015-05-10T12:08:33.440Z</updated>
    <content type="html"><![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/" target="_blank" rel="external">AES加密算法</a>》。<a id="more"></a></p>
<p><strong>2、公钥算法</strong></p>
<p><strong>公钥加密算法</strong>，也就是 <strong>非对称加密算法</strong>，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥：</p>
<ul>
<li>公钥和私钥成对出现</li>
<li>公开的密钥叫公钥，只有自己知道的叫私钥</li>
<li>用公钥加密的数据只有对应的私钥可以解密</li>
<li>用私钥加密的数据只有对应的公钥可以解密</li>
<li>如果可以用公钥解密，则必然是对应的私钥加的密</li>
<li>如果可以用私钥解密，则必然是对应的公钥加的密</li>
</ul>
<p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p>
<p><br></p>
<h3 id="二、实现数据的安全传输">二、实现数据的安全传输</h3><p>要实现数据的安全传输，当然就要对数据进行加密了。</p>
<p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用<strong>非对称算法</strong>，过程如下：</p>
<ol>
<li>首先 接收方 生成一对密钥，即私钥和公钥；</li>
<li>然后，接收方 将公钥发送给 发送方；</li>
<li>发送方用收到的公钥对数据加密，再发送给接收方；</li>
<li>接收方收到数据后，使用自己的私钥解密。</li>
</ol>
<p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p>
<p><img src="http://img.blog.csdn.net/20150502122610368" alt=""></p>
<p><br></p>
<h3 id="三、对信息进行数字签名">三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常<strong>“数字签名”</strong>是用来验证发送方的身份并帮助保护数据的完整性。</p>
<p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p>
<ol>
<li>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</li>
<li>保证信息自签发后到收到为止未曾作过任何修改。</li>
</ol>
<p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p>
<p><br></p>
<h3 id="四、公钥算法的缺点">四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是<strong>效率非常低</strong>，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p>
<ol>
<li>首先，发送方使用对称算法对原始信息进行加密。</li>
<li>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</li>
<li>接收方 将公钥发送给 发送方。</li>
<li>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</li>
<li>接收方用私钥进行解密得到对称算法的密钥。</li>
<li>发送方再把已加密的原始信息发送给接收方。</li>
<li>接收方使用对称算法的密钥进行解密。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150502122733376" alt=""></p>
<p><br><br><br><br><br><strong>总结：</strong></p>
<ol>
<li><p>每个用户都有一对私钥和公钥。  </p>
<ul>
<li>私钥用来进行解密和签名，是给自己用的。</li>
<li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li>
</ul>
</li>
<li><p>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。  </p>
</li>
<li><p>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。</p>
</li>
</ol>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<p>图片来源：www.cnblogs.com/chnking/archive/2007/08/30/875947.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/">AES加密算法</a>》。]]>
    
    </summary>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字节序：Big Endian 和 Little Endian]]></title>
    <link href="http://yoursite.com/2015/05/02/endianess/"/>
    <id>http://yoursite.com/2015/05/02/endianess/</id>
    <published>2015-05-02T04:56:43.000Z</published>
    <updated>2015-05-10T12:03:45.446Z</updated>
    <content type="html"><![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：<a id="more"></a></p>
<ul>
<li><p>Motorola 6800，PowerPC 970，SPARC（除V9外）等处理器采用 Big Endian方式存储数据；</p>
</li>
<li><p>x86系列，VAX，PDP-11等处理器采用Little Endian方式存储数据。</p>
</li>
</ul>
<p>另外，还有一些处理器像ARM, DEC Alpha的字节序是可配置的。</p>
<p><br></p>
<h3 id="二、大端与小端">二、大端与小端</h3><p>那么，到底什么是大端，什么是小端？ 如下图：</p>
<center><br><img src="http://img.blog.csdn.net/20150501200116979" alt=""><br></center>

<p>我相信上面的图已经够直观了。也就是说：</p>
<ul>
<li>Big Endian 是指低地址端 存放 高位字节。</li>
<li>Little Endian 是指低地址端 存放 低位字节。</li>
</ul>
<p><strong>各自的优势：</strong></p>
<ol>
<li>Big Endian：符号位的判定固定为第一个字节，容易判断正负。</li>
<li>Little Endian：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。</li>
</ol>
<p><br></p>
<h3 id="三、为什么要注意字节序">三、为什么要注意字节序</h3><p>如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。</p>
<p>但是，如果你的程序要跟别人的程序产生交互呢？ 比如，当一个 C/C++ 的程序要与一个 Java 程序交互时：</p>
<ul>
<li><p>C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的 x86 处理器是 Little Endian</p>
</li>
<li><p>JAVA编写的程序则唯一采用 Big Endian 方式来存储数据</p>
</li>
</ul>
<p>试想，如果你的C/C++程序将变量 <code>a = 0x12345678</code> 的首地址传递给了Java程序，由于Java采取 Big Endian 方式存储数据，很自然的它会将你的数据翻译为 <code>0x78563412</code>。显然，问题就出现了！！！</p>
<p>另外，网络传输一般采用 Big Endian，也被称之为<strong>网络字节序</strong>，或<strong>网络序</strong>。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p>
<p><br></p>
<h3 id="四、判断机器的字节序">四、判断机器的字节序</h3><p>由于 C/C++ 存储数据时的字节序依赖所在平台的CPU，所以我们可以通过C/C++程序判定机器的端序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Endianness</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span>( *((<span class="keyword">char</span>*)&amp;a) == <span class="number">0x12</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Big Endian"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Little Endian"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="五、网络序和主机序">五、网络序和主机序</h3><p><strong>网络字节序</strong>：TCP/IP各层协议将字节序定义为 Big Endian，因此TCP/IP协议中使用的字节序是大端序。</p>
<p><strong>主机字节序</strong>：整数在内存中存储的顺序，现在 Little Endian 比较普遍。（不同的 CPU 有不同的字节序）</p>
<p>在进行网络通信时 通常需要调用相应的函数进行主机序和网络序的转换。Berkeley socket API 定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】三个经典同步问题]]></title>
    <link href="http://yoursite.com/2015/04/30/linux-three-syn-problems/"/>
    <id>http://yoursite.com/2015/04/30/linux-three-syn-problems/</id>
    <published>2015-04-30T13:37:46.000Z</published>
    <updated>2015-05-10T11:58:29.924Z</updated>
    <content type="html"><![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/" target="_blank" rel="external">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。<a id="more"></a></p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。</p>
</li>
<li><p>整理思路：这里比较简单，只有生产者和消费者两个进程，且这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步的PV操作的位置。</p>
</li>
<li><p>信号量设置：信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量<code>full</code>用于记录当前缓冲池中“满”缓冲区数，初值为 0；信号量<code>empty</code>用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
</li>
</ol>
<p><strong>代码示例：</strong>（semaphore类的封装见下文）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;           <span class="comment">// 临界区互斥信号量</span></span><br><span class="line"><span class="function">semaphore <span class="title">empty</span><span class="params">("/home", N)</span></span>;       <span class="comment">// 记录空缓冲区数，初值为N</span></span><br><span class="line"><span class="function">semaphore <span class="title">full</span><span class="params">("/home/songlee",0)</span></span>; <span class="comment">// 记录满缓冲区数，初值为0</span></span><br><span class="line"><span class="keyword">int</span> buffer[N];                     <span class="comment">// 缓冲区，大小为N</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* producer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	empty.P();                 <span class="comment">// empty减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	buffer[i] = <span class="number">10</span> + rand() % <span class="number">90</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Producer %d write Buffer[%d]: %d\n"</span>,arg,i+<span class="number">1</span>,buffer[i]);</span><br><span class="line">	i = (i+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	full.V();                  <span class="comment">// full加1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* consumer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	full.P();                  <span class="comment">// full减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"                               \033[1;31m"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Consumer %d read Buffer[%d]: %d\n"</span>,arg,j+<span class="number">1</span>,buffer[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\033[0m"</span>);</span><br><span class="line">	j = (j+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	empty.V();                 <span class="comment">// empty加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开10个生产者线程，10个消费者线程</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, producer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, consumer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行输出结果：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Producer <span class="number">1</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">2</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">Producer <span class="number">3</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">Producer <span class="number">5</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">4</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">1</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">6</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">2</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">                               Consumer <span class="number">3</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">                               Consumer <span class="number">4</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">5</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">6</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">7</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">Producer <span class="number">8</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">10</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">9</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">                               Consumer <span class="number">10</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">9</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br><span class="line">                               Consumer <span class="number">7</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">8</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、读者-写者问题">二、读者-写者问题</h3><p><strong>问题描述：</strong></p>
<p>有读者和写者两组并发线程，共享一个文件，当两个或以上的读线程同时访问共享数据时不会产生副作用，但若某个写线程和其他线程（读线程或写线程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：由题目分析可知，读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
</li>
<li><p>整理思路：写者是比较简单的，它与任何线程互斥，用互斥信号量的 PV 操作即可解决。读者的问题比较复杂，它必须实现与写者的互斥，多个读者还可以同时读。所以，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时，不同的读者对计数器的访问也应该是互斥的。</p>
</li>
<li><p>信号量设置：首先设置一个计数器<code>count</code>，用来记录当前的读者数量，初值为0；设置互斥信号量<code>mutex</code>，用于保护更新 count 变量时的互斥；设置互斥信号量<code>rw</code>用于保证读者和写者的互斥访问。</p>
</li>
</ol>
<p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;           <span class="comment">// 记录当前的读者数量</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/",1)</span></span>;  <span class="comment">// 用于保护更新count变量时的互斥</span></span><br><span class="line"><span class="function">semaphore <span class="title">rw</span><span class="params">("/home",1)</span></span>; <span class="comment">// 用于保证读者和写者的互斥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* writer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	rw.P();              <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d start writing...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d finish writing...\n"</span>, arg);</span><br><span class="line">	</span><br><span class="line">	rw.V();              <span class="comment">// 释放共享文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* reader(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当第一个读线程读文件时</span></span><br><span class="line">		rw.P();          <span class="comment">// 阻止写线程写</span></span><br><span class="line">	++count;             <span class="comment">// 读者计数器加1</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d start reading...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d finish reading...\n"</span>, arg);</span><br><span class="line"></span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	--count;             <span class="comment">// 读者计数器减1</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当最后一个读线程读完文件</span></span><br><span class="line">		rw.V();          <span class="comment">// 允许写线程写</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">8</span>];     <span class="comment">// 开6个读线程，2个写线程</span></span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">2</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">3</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">4</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">3</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">5</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">4</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">6</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">5</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">7</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Reader</span> <span class="number">2</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">2</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> finish reading...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> finish writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> finish writing...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> finish reading...</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、哲学家进餐问题">三、哲学家进餐问题</h3><p><strong>问题描述：</strong></p>
<p>一张圆桌上坐着 5 名哲学家，桌子上每两个哲学家之间摆了<strong>一根</strong>筷子，桌子的中间是一碗米饭，如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150430145440864" alt=""></p>
<p>哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li><p>整理思路：显然这里有 5 个线程，那么要如何让一个哲学家拿到左右两个筷子而不造成死锁或饥饿现象？解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或死锁现象的发生。</p>
</li>
<li><p>信号量设置：定义互斥信号量数组<code>chopstick[5] = {1,1,1,1,1}</code>用于对 5 根筷子的互斥访问。</p>
</li>
</ol>
<p><strong>示例代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;  <span class="comment">// 信号量数组</span></span><br><span class="line">Pi()                                  <span class="comment">// i号哲学家的线程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		P(chopstick[i]);              <span class="comment">// 取左边筷子</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 取右边筷子</span></span><br><span class="line">		eat;                          <span class="comment">// 进餐</span></span><br><span class="line">		V(chopstick[i]);              <span class="comment">// 放回左边筷子</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 放回右边筷子</span></span><br><span class="line">		think;                        <span class="comment">// 思考</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的伪代码存在一个问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完<code>P(chopstick[i])</code>），筷子已经被拿光了，等到他们再想拿右边的筷子的时候，就全被阻塞了，这就出现了死锁。</p>
<p>为了防止死锁的发生，可以对哲学家线程施加一些限制条件，比如：</p>
<ul>
<li>至多允许四个哲学家同时进餐；</li>
<li>仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子；</li>
<li>对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再抓他右边的筷子，而偶数号哲学家刚好相反。</li>
</ul>
<p>这里，我们采用第二种方法来改进上面的算法，即当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;semaphore*&gt; chopstick;   <span class="comment">// 信号量数组</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;  <span class="comment">// 设置取左右筷子的信号量 &lt;-- 关键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P1(<span class="keyword">void</span>* arg)  <span class="comment">// 第1个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 1 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P2(<span class="keyword">void</span>* arg)  <span class="comment">// 第2个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 2 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P3(<span class="keyword">void</span>* arg)  <span class="comment">// 第3个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 3 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P4(<span class="keyword">void</span>* arg)  <span class="comment">// 第4个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 4 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P5(<span class="keyword">void</span>* arg)  <span class="comment">// 第5个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 5 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	semaphore *sem1 = <span class="keyword">new</span> semaphore(<span class="string">"/home"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem2 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem3 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/java"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem4 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/ADT"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem5 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/Test"</span>, <span class="number">1</span>);</span><br><span class="line">	chopstick.push_back(sem1);</span><br><span class="line">	chopstick.push_back(sem2);</span><br><span class="line">	chopstick.push_back(sem3);</span><br><span class="line">	chopstick.push_back(sem4);</span><br><span class="line">	chopstick.push_back(sem5);</span><br><span class="line"></span><br><span class="line">	pthread_t id;</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id, NULL, P1, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P2, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P3, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P4, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P5, NULL);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">delete</span> sem1;</span><br><span class="line">	<span class="keyword">delete</span> sem2;</span><br><span class="line">	<span class="keyword">delete</span> sem3;</span><br><span class="line">	<span class="keyword">delete</span> sem4;</span><br><span class="line">	<span class="keyword">delete</span> sem5;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Philosopher</span> <span class="number">2</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">1</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">3</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">4</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">5</span> eat.</span><br></pre></td></tr></table></figure></p>
<p>注意：创建信号量时的 路径参数 请改成你的系统中存在的路径！！！</p>
<p><br><br><br><br></p>
<h3 id="附：semaphore类的封装">附：semaphore类的封装</h3><p>上面的代码中都使用了这个<code>semaphore</code>类，实现如下：</p>
<ul>
<li><strong>semaphore.h</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> semaphore &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	semaphore(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>); <span class="comment">/*构造函数*/</span></span><br><span class="line">	~semaphore();                <span class="comment">/*析构函数*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>;                    <span class="comment">/*P操作*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>;                    <span class="comment">/*V操作*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>semaphore.cpp</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"></span><br><span class="line">semaphore::semaphore(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">semaphore::~semaphore()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::P()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::V()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">int</span> semaphore::init_sem(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，要创建不同的信号量，必须传递不同的路径参数（这样获取的 key 值才会不一样）。</p>
<p>注意，本文的关注点并不在于 linux 下如何创建信号量以及如何封装起来才更方便，而是通过几个经典的同步实例，了解在多线程环境下如何解决这类线程同步问题。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
</feed>