<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Man]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-09T17:55:21.142Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++学习之继承中的访问控制]]></title>
    <link href="http://yoursite.com/2014/07/16/cpp-access-control/"/>
    <id>http://yoursite.com/2014/07/16/cpp-access-control/</id>
    <published>2014-07-16T05:16:59.000Z</published>
    <updated>2015-05-09T17:55:21.142Z</updated>
    <content type="html"><![CDATA[<p>我们通常认为一个类有两种不同的用户：<strong>普通用户</strong> 和 <strong>类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。如果进一步考虑继承的话就会出现第三种用户，即<strong>派生类</strong>。派生类可以访问基类的公有（public）成员和受保护（protected）成员，但不能访问基类的私有（private）成员。<br><a id="more"></a><br>继承相关点：</p>
<ul>
<li>大多数类都只继承自一个类，这种形式的继承叫做<strong>“单继承”</strong>。本文主要讲的是单继承。</li>
<li>一个派生类的对象中，包含继承自基类的部分和派生类自定义的部分。正因为派生类含有基类部分，所以可以进行<strong>派生类到基类的类型转换</strong>，这种转换是隐式的。</li>
<li>不存在从基类向派生类的隐式类型转换。</li>
<li>派生类向基类的自动类型转换只对指针或引用有效，对象之间不存在类型转换。</li>
<li>如果基类定义了静态成员，则不论派生出多少个派生类，每个静态成员都只存在唯一实例。</li>
<li>防止一个类被继承可以使用关键字final，这时C++11新标准中提供的。</li>
<li>继承中的<a href="http://songlee24.github.io/blog/2014/07/16/c-plus-plus-xue-xi-zhi-xu-han-shu-yu-chun-xu-han-shu/" target="_blank" rel="external">虚函数与纯虚函数</a>（见文章）。<br><br><br><h3 id="公有、私有和受保护成员">公有、私有和受保护成员</h3></li>
</ul>
<p><strong>1 . 访问说明符</strong></p>
<p>在C++中通过使用访问说明符<strong>public、protected、private</strong>来对类的成员进行访问控制，控制成员对于普通用户或派生类来说是否可访问：</p>
<ul>
<li><p><strong>public</strong>：定义为public的成员对普通用户、类的实现者、派生类都是可访问的。public通常用于定义类的外部接口。</p>
</li>
<li><p><strong>protected</strong>：定义protected成员的目的是让派生类可以访问而禁止其他用户访问。所以类的实现者和派生类可以访问，而普通用户不能访问。</p>
</li>
<li><p><strong>private</strong>：定义为private的成员只能被类的实现者（成员和友元）访问。private部分通常用于封装（即隐藏）类的实现细节。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> People&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(Student &amp;s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(People &amp;p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，可以通过派生类对象访问基类的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Student &amp;s)</span></span>&#123; s.name=<span class="string">"Songlee"</span>; <span class="built_in">cout</span>&lt;&lt; s.name &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// 错误，不能通过基类对象访问基类的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(People &amp;p)</span></span>&#123; p.name=<span class="string">"Songlee"</span>; <span class="built_in">cout</span>&lt;&lt; p.name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，派生类的成员或友元只能通过<strong>派生类对象</strong>来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p><strong>2 . 改变成员的可访问性</strong></p>
<p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using</strong>声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> People&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> People::name;  <span class="comment">// 将继承来的name成员的访问权限改为public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Student me;</span><br><span class="line">	me.name = <span class="string">"SongLee"</span>;     <span class="comment">// 可以访问name了</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; me.name &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何<strong>可访问成员</strong>（非私有成员）标记出来，改变其访问权限。</p>
<h3 id="公有、私有和受保护继承">公有、私有和受保护继承</h3><p>我们注意到，在类的<strong>派生列表</strong>中用到了访问说明符public、protected和private，它们分别表示不同的继承方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> B &#123; <span class="comment">/*  */</span> &#125;;     <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">private</span> B &#123; <span class="comment">/*  */</span> &#125;;    <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">protected</span> B &#123; <span class="comment">/*  */</span> &#125;;  <span class="comment">// 受保护继承</span></span><br></pre></td></tr></table></figure></p>
<p>派生类的派生列表中的访问说明符<strong>对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响</strong>。派生类的成员（及友元）对基类成员的访问权限只与基类中的访问说明符有关。</p>
<p>那么派生列表中的访问说明符有什么作用呢？<br><strong>派生列表中访问说明符的作用</strong>是<em>控制派生类<strong>用户</strong>对于基类成员的访问权限</em>，注意是派生类的用户。下面给出不同的继承方式导致的访问权限的变化：</p>
<ul>
<li><p><strong>public继承</strong>：如果继承是公有的，则成员将遵循其原有的访问说明符。父类中的public、protected和private属性在子类中不发生改变。</p>
</li>
<li><p><strong>protected继承</strong>：比protected级别高的访问权限会变成protected。即父类中的public属性在子类中变为protected，父类中的protected和private属性在子类中不变。</p>
</li>
<li><p><strong>private继承</strong>：比private级别高的访问权限会变成private。即父类中的三种访问属性在子类中都会变成private。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;   <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> A_public;      <span class="comment">// 公有成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> A_protected;   <span class="comment">// 受保护成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">private</span> A &#123;    <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123; A_public=<span class="string">"public"</span>; A_protected=<span class="string">"protected"</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	B b;   <span class="comment">// 通过B的对象访问</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.A_public &lt;&lt;<span class="string">" "</span>&lt;&lt; b.A_protected &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在派生列表中不使用访问说明符，则struct关键字默认的是公有继承，class关键字默认的是私有继承。不过建议在继承时最好显式地将访问说明符写出来。<br><br><br><br>另外，不同的继承方式也会影响派生类向基类的转换，假定Derive继承自Base：</p>
<ul>
<li><p>只有当Derive公有地继承自Base时，用户代码才能使用派生类向基类的转换；如果Derive继承Base的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>
</li>
<li><p>不论Derive以什么方式继承Base，Derive的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</p>
</li>
<li><p>如果Derive继承Base的方式是公有的或者受保护的，则Derive的派生类的成员和友元可以使用Derive向Base的类型转换；反之，如果Derive继承Base的方式是私有的，则不能使用。<br><br><br></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们通常认为一个类有两种不同的用户：<strong>普通用户</strong> 和 <strong>类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。如果进一步考虑继承的话就会出现第三种用户，即<strong>派生类</strong>。派生类可以访问基类的公有（public）成员和受保护（protected）成员，但不能访问基类的私有（private）成员。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++与C的那些差异]]></title>
    <link href="http://yoursite.com/2014/07/06/difference-between-c-and-cpp/"/>
    <id>http://yoursite.com/2014/07/06/difference-between-c-and-cpp/</id>
    <published>2014-07-06T10:27:21.000Z</published>
    <updated>2015-05-09T17:52:03.555Z</updated>
    <content type="html"><![CDATA[<p>虽说C++是向后兼容C的，但C++与C还是存在许多差异。这里举了几个例子，也是我们很容易忽略的地方。如果你还知道其他的更多的Differences，或者发现什么错误，可以评论告诉我，大家一起学习进步。另外，随着学习的进行，本文会持续更新……</p>
<p><strong>C编译通过但C++编译不通过</strong><br><a id="more"></a><br><strong>1、C++中编译器不允许在一个函数声明之前调用它，但C中编译器是允许的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   foo();     <span class="comment">// foo()在它的声明/定义之前被调用</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、C++中不能用一个普通指针指向一个常量，但C中可以。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> j = <span class="number">20</span>;  </span><br><span class="line">    <span class="comment">/* C++编译会报错，C中编译会有warning，但可以通过 */</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;j; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*ptr: %d\n"</span>, *ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、在C语言中，void指针可以直接赋给其他类型的指针，如int*, char*等。但在C++中，void指针必须要明确地进行类型转换。（malloc函数返回值为void *类型）</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vptr;</span><br><span class="line">    <span class="keyword">int</span> *iptr = vptr; <span class="comment">// C++中必须用int *iptr = (int *)vptr;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>C和C++输出结果不相同</strong></p>
<p><strong>4、字符常量在C和C++被当作不同地类型看待：在C中，字符常量如’a’,’b’被当作int型，而在C++中被当作char型。所以，在C中sizeof(‘A’)相当于sizeof(int)，输出为4；在C++中sizeof(‘A’)仍相当于sizeof(char)，输出为1。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(<span class="string">'a'</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5、在C中定义结构体必须使用<code>struct</code>关键字，但在C++中可以省略。在C++中局部变量会覆盖同名的全局变量，但在C中却不会。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> T &#123; <span class="keyword">double</span> x; &#125;; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(T));  <span class="comment">// C输出4，C++输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>6、布尔结果在C++和C中的表示是不同的。因为C语言不直接支持布尔型，所以其实返回的是int型，而C++则返回的是bool类型。所以</strong>sizeof(1==1)<strong>在C中是sizeof(int)，在C++中是sizeof(bool)。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="number">1</span>==<span class="number">1</span>));  <span class="comment">// C输出4，C++输出1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽说C++是向后兼容C的，但C++与C还是存在许多差异。这里举了几个例子，也是我们很容易忽略的地方。如果你还知道其他的更多的Differences，或者发现什么错误，可以评论告诉我，大家一起学习进步。另外，随着学习的进行，本文会持续更新……</p>
<p><strong>C编译通过但C++编译不通过</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之extern关键字]]></title>
    <link href="http://yoursite.com/2014/07/05/C-extern-C/"/>
    <id>http://yoursite.com/2014/07/05/C-extern-C/</id>
    <published>2014-07-05T14:08:05.000Z</published>
    <updated>2015-05-09T17:45:24.885Z</updated>
    <content type="html"><![CDATA[<p>我们知道，extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。另外，extern还可以与”C”连用，作为链接指示。</p>
<h3 id="C++名字修饰（Name_Mangling）">C++名字修饰（Name Mangling）</h3><a id="more"></a>
<p>这就要从C++的重载说起了，在C++中<strong>函数重载</strong>指的是几个函数的函数名相同，参数列表不同。那么当生成obj中间文件/目标文件的时候，C++编译器如何区分这几个重载函数呢？——<strong>通过把原函数名与参数信息结合，产生一个独特的内部名字</strong>，这种技术叫做<a href="http://zh.wikipedia.org/zh/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">名字修饰</a>（Name Mangling）。名字修饰规则没有一个标准，所以不同的编译器的名字修饰规则也不一样。</p>
<p>下面是一组函数，其中f()函数重载了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">f</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">f</span> <span class="params">(<span class="keyword">int</span>)</span>  </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">int</span> i = f(), j = f(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>f(void)和f(int)是不同的函数，除了函数名相同以外没有任何关系。当生成obj目标文件时，为了区分它们，C++编译器根据参数信息进行了名字修饰：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  __f_v (<span class="keyword">void</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">int</span>  __f_i (<span class="keyword">int</span>)  &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> __g_v (<span class="keyword">void</span>) &#123; <span class="keyword">int</span> i = __f_v(), j = __f_i(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意g()也被名字修饰了，虽然没有任何名字冲突。名字修饰应用于C++的任何符号。</p>
<h3 id="为什么要使用extern_“C”？">为什么要使用extern “C”？</h3><p>C语言中没有名字修饰，因为C语言不支持函数重载。但是如果C++中含有C代码，在编译时C++编译器对C代码的函数也会进行名字修饰，函数名变了以后，将导致在C运行库中找不到对应函数，发生链接错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下面的代码保存为.cpp文件，并用C++编译器编译</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GeeksforGeeks"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccQBO9Im.o：在函数‘main’中：</span><br><span class="line">test<span class="class">.cpp</span>:(.text+<span class="number">0</span>xf)：对‘<span class="function"><span class="title">printf</span><span class="params">(char const*, ...)</span></span>’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>为了防止C++编译器对C代码进行名字修饰，我们将C代码用<strong>extern “C”</strong>进行链接指定，<strong>告诉编译器，在生成中间文件时，不要对这部分代码进行名字修饰，而是生成符合C规则的中间符号名。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello!"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加了extern “C”链接指示后，上面的代码就能够正常运行了。<br><br><br><br><br><strong>附</strong>：所有的C风格的头文件（stdio.h, string.h, … 等等）都有在extern “C”下声明，形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Declarations of this file */</span></span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们知道，extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。另外，extern还可以与”C”连用，作为链接指示。</p>
<h3 id="C++名字修饰（Name_Mangling）">C++名字修饰（Name Mangling）</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深度优先搜索的实现]]></title>
    <link href="http://yoursite.com/2014/07/04/depth-first-search/"/>
    <id>http://yoursite.com/2014/07/04/depth-first-search/</id>
    <published>2014-07-04T03:53:09.000Z</published>
    <updated>2015-05-09T17:41:24.830Z</updated>
    <content type="html"><![CDATA[<p>图的遍历是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：广度优先搜索（Breadth-First-Search）和深度优先搜索（Depth-First-Search）。</p>
<h3 id="深度优先搜索（DFS）的算法思想">深度优先搜索（DFS）的算法思想</h3><a id="more"></a>
<p>深度优先搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。它的基本思想就是：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<p><img src="http://img.blog.csdn.net/20140704111631015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，从顶点2开始深度优先遍历图，结果为：2，0，1，3。</p>
<h3 id="DFS算法实现">DFS算法实现</h3><p>和<a href="http://songlee24.github.io/2014/07/03/breadth-first-search/" target="_blank" rel="external">广度优先搜索</a>一样，为了防止顶点被多次访问，需要使用一个访问标记数组visited[]来标记顶点是否已经被访问过。</p>
<p>这里使用邻接表表示图。对于一个<strong>有向图</strong>，<strong>假设从给定顶点可以访问到图的所有其他顶点</strong>，则DFS递归算法的C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: DFS.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年07月04日 星期五 10时38分26秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图 */</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;                               <span class="comment">// 顶点数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                      <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>; <span class="comment">// 从顶点v深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                        <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;          <span class="comment">// 向图中添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;                     <span class="comment">// 从v开始深度优先遍历图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);                 <span class="comment">// 将w添加到v的链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从v开始深度优先遍历 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::DFSUtil(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 访问顶点v并输出</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=adj[v].begin(); i!=adj[v].end(); ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[*i])              <span class="comment">// 若邻接点尚未访问</span></span><br><span class="line">			DFSUtil(*i, visited);     <span class="comment">// 递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对图进行深度优先遍历，调用递归函数DFSUtil() */</span></span><br><span class="line"><span class="keyword">void</span> Graph::DFS(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设从给定顶点v可以到达图的所有顶点</span></span><br><span class="line">	DFSUtil(v, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(4)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Depth First Traversal (starting from vertex 2) \n"</span>;</span><br><span class="line">	g.DFS(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是假设从给定顶点可以访问到图的所有其他顶点。<strong>如果没有这个假设，为了对图作一个完整的深度优先遍历，我们需要对每个顶点调用DFSUtil()</strong>。当然那之前需要先检查顶点是否已经访问过。所以我们只需要修改<strong>DFS()</strong>函数部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::DFS()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对每个顶点调用DFSUtil()，从0开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			DFSUtil(i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<strong>无向图</strong>的深度优先搜索，只是邻接表不一样，其他的都是一样的。我们只需要修改addEdge(v, w)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">  adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">  adj[w].push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：图的邻接矩阵表示是唯一的，但对于邻接表来说，如果边的输入次序不同，生成的邻接表也不同。因此，对于同一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。</p>
<h3 id="DFS算法性能分析">DFS算法性能分析</h3><p>1 . <strong>空间复杂度</strong></p>
<p>DFS算法是一个递归算法，需要借助一个递归工作栈，故它的空间复杂度为O(|V|)。</p>
<p>2 . <strong>时间复杂度</strong></p>
<ul>
<li><p>当以<strong>邻接表</strong>存储时，时间复杂度为<strong>O(|V|+|E|)</strong>。</p>
</li>
<li><p>当以<strong>邻接矩阵</strong>存储时，时间复杂度为<strong>O(|V|^2)</strong>。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>图的遍历是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：广度优先搜索（Breadth-First-Search）和深度优先搜索（Depth-First-Search）。</p>
<h3 id="深度优先搜索（DFS）的算法思想">深度优先搜索（DFS）的算法思想</h3>]]>
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广度优先搜索的实现]]></title>
    <link href="http://yoursite.com/2014/07/03/breadth-first-search/"/>
    <id>http://yoursite.com/2014/07/03/breadth-first-search/</id>
    <published>2014-07-03T13:20:36.000Z</published>
    <updated>2015-05-09T17:36:47.414Z</updated>
    <content type="html"><![CDATA[<p><strong>图的遍历</strong>是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：<strong>广度优先搜索</strong>（Breadth-First-Search）和<strong>深度优先搜索</strong>（Depth-First-Search）。</p>
<h3 id="广度优先搜索（BFS）的算法思想">广度优先搜索（BFS）的算法思想</h3><a id="more"></a>
<p>广度优先搜索类似于二叉树的<strong>层序遍历</strong>，它的基本思想就是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，…，wi，然后再依次访问w1，w2，…，wi的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点……依次类推，直到图中所有顶点都被访问过为止。</p>
<p>广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此<strong>它不是一个递归的算法</strong>。为了实现逐层的访问，算法必须借助一个辅助队列，以记录正在访问的顶点的下一层顶点。</p>
<p><img src="http://img.blog.csdn.net/20140703195044578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，为一个有向图，从顶点2开始广度优先遍历整个图，可知结果为2，0，3，1。</p>
<h3 id="BFS算法实现">BFS算法实现</h3><p>与树相比，图的不同之处在于<strong>它存在回路/环</strong>，因此在遍历时一个顶点可能被访问多次。为了防止这种情况出现，我们使用一个访问标记数组visited[]来标记顶点是否已经被访问过。</p>
<p>在广度优先搜索一个图之前，我们首先要构造一个图，<strong>图的存储方式</strong>主要有两种：<strong>邻接矩阵、邻接表</strong>。这里我们使用邻接表来存储图：</p>
<p><img src="http://img.blog.csdn.net/20140703201818812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>简单起见，我们先假设从起始顶点可以达到其他所有顶点。</strong>以有向图为例，C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BFS.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年07月03日 星期四 18时37分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表存储有向图 */</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;                       <span class="comment">// 顶点的数量</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;              <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;  <span class="comment">// 向图中添加一条边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;             <span class="comment">// BFS遍历</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 构造函数 *****/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];      <span class="comment">// 初始化V条链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从顶点v出发广度优先搜索 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::BFSUtil(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// BFS辅助队列</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">queue</span>.push_back(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 出队</span></span><br><span class="line">		v = <span class="built_in">queue</span>.front();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测已出队的顶点s的所有邻接顶点</span></span><br><span class="line">		<span class="comment">// 若存在尚未访问的邻接点，访问它并压入队列</span></span><br><span class="line">		<span class="keyword">for</span>(i = adj[v].begin(); i!=adj[v].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 广度优先搜索 **/</span></span><br><span class="line"><span class="keyword">void</span> Graph::BFS(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化访问标记数组</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 假设从给定顶点可以到达图的所有顶点</span></span><br><span class="line">	BFSUtil(v, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建图</span></span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(4)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Following is BFS Traversal (starting from vertex 2) \n"</span>;</span><br><span class="line">	g.BFS(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是假设从起始顶点开始能够到达图的所有顶点。如果不能到达所有顶点，即存在多个连通分量呢？那么<strong>我们就要对每个连通分量都进行一次广度优先搜索</strong>。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEXT_NUM];   <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G)</span>        <span class="comment">// 设访问函数为visit()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;      <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)    <span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[i])          <span class="comment">// 对每个连通分量调用一次BFS</span></span><br><span class="line">			BFS(G,i);            <span class="comment">// Vi未访问过，从Vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSUtil</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	visit(v);                    <span class="comment">// 访问初始顶点</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;           <span class="comment">// v已访问</span></span><br><span class="line">	Enqueue(Q, v);               <span class="comment">// 顶点v入队列</span></span><br><span class="line">	<span class="keyword">while</span>(!isEmpty(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		Dequeue(Q, v);           <span class="comment">// 顶点v出队列</span></span><br><span class="line">		<span class="keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,v))</span><br><span class="line">			<span class="keyword">if</span>(!visited[w])      <span class="comment">// 检测v的所有邻接点</span></span><br><span class="line">			&#123;</span><br><span class="line">				visit(w);        <span class="comment">// 若w未访问，访问之</span></span><br><span class="line">				visited[w]=<span class="keyword">true</span>; <span class="comment">// 标记</span></span><br><span class="line">				Enqueue(Q, w);   <span class="comment">// 顶点w入队列</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据伪代码，相信不难写出对于多个连通分量的图的广度优先搜索，我们只需要修改<strong>BFS()</strong>函数部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::BFS()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化访问标记数组</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对每个连通分量调用一次BFSUtil()，从0号顶点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			BFSUtil(i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<strong>无向图</strong>的广度优先搜索，只是邻接表不一样，其他的都是一样的。我们只需要修改addEdge(v, w)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">	adj[w].push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BFS算法性能分析">BFS算法性能分析</h3><p>1 . <strong>空间复杂度</strong></p>
<p>无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点都需要入队一次，在最坏的情况下，空间复杂度为<strong>O(|V|)</strong>。</p>
<p>2 . <strong>时间复杂度</strong></p>
<ul>
<li><p>当采用<strong>邻接表</strong>存储时，每个顶点均需搜索一次，故时间复杂度为O(|V|)，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(|E|)，算法总的时间复杂度为<strong>O(|V|+|E|)</strong>。</p>
</li>
<li><p>当采用<strong>邻接矩阵</strong>存储时，查找每个顶点的邻接点所需的时间为O(|V|)，故算法总的时间复杂度为<strong>O(|V|^2)</strong>。</p>
</li>
</ul>
<p> <br><br><br><br><br><strong>注</strong>：广度优先搜索（BFS）算法思想有很多应用，比如Dijkstra单源最短路径算法和Prim最小生成树算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>图的遍历</strong>是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：<strong>广度优先搜索</strong>（Breadth-First-Search）和<strong>深度优先搜索</strong>（Depth-First-Search）。</p>
<h3 id="广度优先搜索（BFS）的算法思想">广度优先搜索（BFS）的算法思想</h3>]]>
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos2d-JS入门之2048游戏]]></title>
    <link href="http://yoursite.com/2014/06/30/cocos2d-js-2048/"/>
    <id>http://yoursite.com/2014/06/30/cocos2d-js-2048/</id>
    <published>2014-06-30T11:47:41.000Z</published>
    <updated>2015-05-09T17:28:30.194Z</updated>
    <content type="html"><![CDATA[<h3 id="介绍">介绍</h3><p><strong>Cocos2d-JS</strong>是Cocos2d-x的Javascript版本，它的前身是<strong>Cocos2d-html5</strong>。在3.0版本以前叫做Cocos2d-html5，从3.0版本开始叫做Cocos2d-JS。我们知道Cocos2d-x支持使用C++、Lua、Javascript来进行程序开发，其所内置的是一个Javascript引擎，通过用C++解析Javascript去执行；而Cocos2d-html5是使用Javascript进行开发，最终运行在浏览器里的。那么在v3.0的时候，Cocos2d-html5和Cocos2d-x JSBinding被合到了一起，称作<strong>Cocos2d-JS</strong>。<a id="more"></a></p>
<p><strong>和Cocos2d-html5不同的是</strong>，Cocos2d-JS开发的程序不仅可以运行在浏览器里，还可以编译运行在Mac OSX, Windows, iOS, Android的原生平台上，真正做到“一次开发，全平台运行”。Cocos2d-JS支持Cocos2d-x的所有特性并提供更简单易用的Javascript风格API，它还自带了Cocos Console，一个用于简化项目创建和不同目标平台编译发布流程的终端工具。</p>
<h3 id="Cocos2d-html5目录结构">Cocos2d-html5目录结构</h3><p>为了快速入门，所以决定开发一个最近比较热门的2048小游戏。当然，首先需要去<a href="http://www.cocos2d-x.org/download" target="_blank" rel="external">Cocos2d-x官网</a>下载Cocos2d-html5-v2.2.3引擎，下载后解压就行了。Cocos2d-html5的目录结构如下：</p>
<p><img src="http://img.blog.csdn.net/20140630200715781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ul>
<li>cocos2d：游戏引擎的主要文件</li>
<li>extensions：包含一些扩展的功能，且支持自定义扩展</li>
<li>external：包含box2d和chipmunk这两个物理引擎</li>
<li>HelloHTML5World：一个最简单的HelloWorld项目</li>
<li>samples：官网例子和几款小游戏</li>
<li>template：项目模板</li>
</ul>
<p>我们可以通过拷贝 HelloHTML5World 或 template中的项目模板，然后基于它编写自己的代码程序。</p>
<p>这里使用<strong>WebStorm</strong>作为IDE进行游戏开发，WebStorm有非常强大的智能补全功能，提高了开发效率。还能与 Google Chrome 浏览器配合，完成实时编辑和调试。只需要下载WebStorm然后载入引擎目录稍微配置一下就可以了，不知道怎么做的可以看看<a href="http://www.tairan.com/archives/4857" target="_blank" rel="external">快速搭建 Cocos2d-HTML5 开发调试环境</a>这篇博文。</p>
<h3 id="2048游戏开发">2048游戏开发</h3><p><strong>1、创建项目</strong></p>
<p>Cocos2d-html5中创建项目很简单，只需要拷贝HelloHTML5World项目（当然你也可以复制template下的文件夹），然后重命名就行了。</p>
<ul>
<li>res：资源文件夹（图片、音频等）</li>
<li>src：js脚本存放目录(我们自己的项目源码目录)</li>
<li>index.html：主页面</li>
<li>build.xml：文件的引用，包括引擎库文件和自己写的文件</li>
<li>cocos2d.js：定义了程序运行需要的一些参数，如 是否显示FPS，是否加载扩展库等</li>
<li>main.js：定义程序的入口，初始化导演类等等。</li>
</ul>
<p>我们需要在src文件夹里编写我们自己的代码，首先我们删除<strong>myApp.js</strong>中的所有代码，开始写我们自己的2048游戏。</p>
<p><strong>2、创建游戏场景</strong></p>
<p>由于2048游戏很简单，它只需要一个场景，下面我们来创建一个场景：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层</span></span><br><span class="line"><span class="keyword">var</span> Helloworld = cc.Layer.extend(&#123;</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景</span></span><br><span class="line"><span class="keyword">var</span> HelloWorldScene = cc.Scene.extend(&#123;</span><br><span class="line">    onEnter:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="keyword">var</span> layer = <span class="keyword">new</span> Helloworld();</span><br><span class="line">        layer.init();</span><br><span class="line">        <span class="keyword">this</span>.addChild(layer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>很简单吧！我们只需要创建一个<strong>Layer</strong>类，然后将它的一个实例加入<strong>Scene</strong>中，程序运行时main.js会创建一个Scene的实例作为程序入口。</p>
<p><strong>3、创建卡片类</strong></p>
<p>我们把2048游戏中的每一个方格看作一个卡片，上面的数字是它的属性。也就是说我们需要4x4=16个卡片类的对象。新建一个CardSprite.js文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CardSprite = cc.Layer.extend(&#123;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    number:<span class="number">0</span>,</span><br><span class="line">    labelCardNumber:<span class="literal">null</span>,</span><br><span class="line">    cardColorBG:<span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ctor:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 初始化卡牌</span></span><br><span class="line">    initCard:<span class="function"><span class="keyword">function</span><span class="params">(num, width, height, positionX, positionY)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = num;</span><br><span class="line">        <span class="comment">// 背景层，也就是一个小正方形</span></span><br><span class="line">        <span class="keyword">this</span>.cardColorBG = cc.LayerColor.create(<span class="keyword">new</span> cc.Color4B(<span class="number">200</span>, <span class="number">190</span>, <span class="number">180</span>, <span class="number">255</span>), width-<span class="number">15</span>, height-<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">this</span>.cardColorBG.setPosition(positionX, positionY);</span><br><span class="line">        <span class="comment">// 添加数字，大于0显示，否则不显示</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber = cc.LabelTTF.create(<span class="keyword">this</span>.number,<span class="string">"Arial"</span>, <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setPosition(<span class="keyword">this</span>.cardColorBG.getContentSize().width/<span class="number">2</span>, <span class="keyword">this</span>.cardColorBG.getContentSize().height/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setTag(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">this</span>.cardColorBG.addChild(<span class="keyword">this</span>.labelCardNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber = cc.LabelTTF.create(<span class="string">""</span>,<span class="string">"Arial"</span>, <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setPosition(<span class="keyword">this</span>.cardColorBG.getContentSize().width/<span class="number">2</span>, <span class="keyword">this</span>.cardColorBG.getContentSize().height/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setTag(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">this</span>.cardColorBG.addChild(<span class="keyword">this</span>.labelCardNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">this</span>.cardColorBG);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取数字</span></span><br><span class="line">    getNumber:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 重置卡片数字</span></span><br><span class="line">    setNumber:<span class="function"><span class="keyword">function</span><span class="params">(num)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = num;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setString(<span class="keyword">this</span>.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.labelCardNumber.setString(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line">CardSprite.createCardSprite = <span class="function"><span class="keyword">function</span><span class="params">(num, width, height, positionX, positionY)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> card = <span class="keyword">new</span> CardSprite();</span><br><span class="line">    <span class="keyword">if</span>(card)</span><br><span class="line">    &#123;</span><br><span class="line">        card.initCard(num, width, height, positionX, positionY);</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将CardSprite类继承自Layer，然后初始化卡片背景和上面的数字，还定义了number的set/get方法。这里需要注意几点：</p>
<ul>
<li>新建.js文件以后需要在build.xml和cocos2d.js相关位置添加文件路径。</li>
<li>继承都需要有 <code>this._super();</code>，一般写在构造函数<code>ctor:function()</code>中。</li>
<li>注意静态函数的写法，<code>类名.函数名 = function(){}</code>。</li>
</ul>
<p><strong>4、初始化界面</strong></p>
<p>下面我们来初始化游戏界面，主要是在Layer的init()函数中初始化，我们使用一个4x4的二维组来放置在主界面创建16个卡片：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Helloworld = cc.Layer.extend(&#123;</span><br><span class="line">    cardArr:<span class="literal">null</span>,  <span class="comment">// 存放4x4=16个卡片</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    init:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="keyword">var</span> size = cc.Director.getInstance().getWinSize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主界面背景层-&gt;设置颜色</span></span><br><span class="line">        <span class="keyword">var</span> lazyLayer = cc.LayerColor.create(<span class="keyword">new</span> cc.Color4B(<span class="number">180</span>, <span class="number">170</span>, <span class="number">160</span>, <span class="number">255</span>) , <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.addChild(lazyLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建卡片数组</span></span><br><span class="line">        <span class="keyword">this</span>.cardArr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cardArr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化所有卡片，数字为0，不显示</span></span><br><span class="line">        <span class="keyword">this</span>.createCards(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始的时候，随机生成两个数字</span></span><br><span class="line">        <span class="keyword">this</span>.autoCreateCardNumber();</span><br><span class="line">        <span class="keyword">this</span>.autoCreateCardNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化卡片数组*******************************</span></span><br><span class="line">    createCards:<span class="function"><span class="keyword">function</span><span class="params">(size)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> unitSize = (size.height - <span class="number">80</span>)/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">var</span> card = CardSprite.createCardSprite(<span class="number">0</span>, unitSize, unitSize, unitSize*i + <span class="number">210</span>, unitSize*j + <span class="number">30</span>);</span><br><span class="line">                <span class="keyword">this</span>.cardArr[i][j] = card;</span><br><span class="line">                <span class="keyword">this</span>.addChild(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成新的2或4的卡片****************</span></span><br><span class="line">    autoCreateCardNumber:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">4</span>);  <span class="comment">// 随机生成0～3</span></span><br><span class="line">            <span class="keyword">var</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[i][j].getNumber() == <span class="number">0</span>) &#123;   </span><br><span class="line">                <span class="comment">// 4与2生成的概率比为1:9</span></span><br><span class="line">                <span class="keyword">this</span>.cardArr[i][j].setNumber(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) &lt; <span class="number">1</span> ? <span class="number">4</span> : <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.shouldCreateCardNumber()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否还有空位******************</span></span><br><span class="line">    shouldCreateCardNumber:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> should = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[i][j].getNumber() == <span class="number">0</span>) &#123;</span><br><span class="line">                    should = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> should;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>通过调用<code>this.createCards(size);</code>初始化所有16个卡片，由于0不显示，所以卡片上都没有数字。然后调用<code>this.autoCreateCardNumber();</code>在随机的两个卡片上生成数字，在随机生成的时候我们应该<strong>先判断还有没有空位</strong>，否则有可能会陷入死循环。<br>初始化的界面如下图：<br><img src="http://img.blog.csdn.net/20140701125010750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>5、定义手势动作</strong></p>
<p>我们需要通过触摸滑动来操作游戏，所以就需要定义上下左右的手势动作。这就要用到引擎的触摸响应机制，Cocos2d-html5与Cocos2d-x一样，有<strong>多点触控</strong> 和 <strong>单点触控</strong>。默认情况下是多点触控，要使用单点触控，我们要使用<code>addTargetedDelegate()</code>方法设置代理。<br>那么如何判断上下左右呢？当然是根据起始触摸点和结束触摸点的坐标变化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Helloworld = cc.Layer.extend(&#123;</span><br><span class="line">    firstX:<span class="literal">null</span>,</span><br><span class="line">    firstY:<span class="literal">null</span>,</span><br><span class="line">    cardArr:<span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    init:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">        <span class="comment">// 设置单点触摸</span></span><br><span class="line">        cc.Director.getInstance().getTouchDispatcher()._addTargetedDelegate(<span class="keyword">this</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 打开触摸</span></span><br><span class="line">        <span class="keyword">this</span>.setTouchEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// onTouchBegan函数，需要返回true</span></span><br><span class="line">    onTouchBegan:<span class="function"><span class="keyword">function</span> <span class="params">(touch, event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> touchPoint = touch.getLocation();</span><br><span class="line">        <span class="keyword">this</span>.firstX = touchPoint.x;</span><br><span class="line">        <span class="keyword">this</span>.firstY = touchPoint.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// onTouchEnded函数</span></span><br><span class="line">    onTouchEnded:<span class="function"><span class="keyword">function</span> <span class="params">(touch, event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> touchPoint = touch.getLocation();</span><br><span class="line">        <span class="keyword">var</span> offsetX = <span class="keyword">this</span>.firstX - touchPoint.x;</span><br><span class="line">        <span class="keyword">var</span> offsetY = <span class="keyword">this</span>.firstY - touchPoint.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(offsetX) &gt; <span class="built_in">Math</span>.abs(offsetY)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(offsetX &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doLeft();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(offsetX &lt; -<span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doRight();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(offsetY &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doDown();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(offsetY &lt; -<span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doUp();</span><br><span class="line">                <span class="comment">//this.doCheckGameOver();</span></span><br><span class="line">                <span class="comment">//this.setScore(this.score);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...other methods</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>6、卡片合并</strong></p>
<p>游戏2048主要玩法就是通过合并相同数字的卡片以达到2048。通过手势动作往一个方向进行合并。我们的思路就是根据手势方向，遍历每一行或每一列，将在这个方向上相邻（中间没有其他数字）且数字相同的卡片合并加倍。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上***************************************</span></span><br><span class="line">doUp:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y=<span class="number">3</span>; y&gt;=<span class="number">0</span>; --y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y1=y-<span class="number">1</span>; y1&gt;=<span class="number">0</span>; --y1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y1].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y1].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    ++y;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y1].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber(); </span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向下***************************************</span></span><br><span class="line">doDown:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y=<span class="number">0</span>; y&lt;<span class="number">4</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y1=y+<span class="number">1</span>; y1&lt;<span class="number">4</span>; ++y1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y1].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y1].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    --y;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y1].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y1].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber(); </span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向左***************************************</span></span><br><span class="line">doLeft:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> y=<span class="number">0</span>; y&lt;<span class="number">4</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x1=x+<span class="number">1</span>; x1&lt;<span class="number">4</span>; ++x1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x1][y].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x1][y].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    --x;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x1][y].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber();</span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向右***************************************</span></span><br><span class="line">doRight:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isdo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; ++y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">3</span>; x &gt;= <span class="number">0</span>; --x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x1 = x - <span class="number">1</span>; x1 &gt;= <span class="number">0</span>; --x1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x1][y].getNumber() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[x][y].getNumber() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x1][y].getNumber());</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    ++x;</span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x1][y].getNumber())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x][y].setNumber(<span class="keyword">this</span>.cardArr[x][y].getNumber()*<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">this</span>.cardArr[x1][y].setNumber(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//this.score += this.cardArr[x][y].getNumber(); </span></span><br><span class="line">                    isdo = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isdo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>7、添加分数</strong></p>
<p>添加两个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score:<span class="number">0</span>,  <span class="comment">// 分数</span></span><br><span class="line">scoreLabel:<span class="literal">null</span>,  <span class="comment">// 显示分数的控件</span></span><br></pre></td></tr></table></figure></p>
<p>然后初始化分数显示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示分数</span></span><br><span class="line"><span class="keyword">var</span> label = cc.LabelTTF.create(<span class="string">"Score : "</span>, <span class="string">"Arial"</span>, <span class="number">20</span>);</span><br><span class="line">label.setAnchorPoint(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">label.setPosition(size.width/<span class="number">2</span> - <span class="number">50</span>, size.height-<span class="number">50</span>);</span><br><span class="line"><span class="keyword">this</span>.addChild(label);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.scoreLabel = cc.LabelTTF.create(<span class="string">"0"</span>, <span class="string">"Arial"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">this</span>.scoreLabel.setAnchorPoint(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.scoreLabel.setPosition(size.width/<span class="number">2</span> + <span class="number">20</span>, size.height-<span class="number">50</span>);</span><br><span class="line"><span class="keyword">this</span>.addChild(<span class="keyword">this</span>.scoreLabel);</span><br></pre></td></tr></table></figure></p>
<p>卡片合并的时候要增加分数，然后更新分数显示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新分数 -&gt; this.setScore(this.score);</span></span><br><span class="line">setScore:<span class="function"><span class="keyword">function</span><span class="params">(s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.scoreLabel.setString(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>8、判断游戏结束和胜利</strong></p>
<p>每一次卡片合并操作后，我们都需要判断游戏是否胜利或者结束。利用五个条件判断游戏是否还能够继续：（1）还有空卡片 （2）还可以向右滑 （3）还可以向左滑 （4）还可以向上滑 （5）还可以向下滑。只要以上条件满足一个，游戏就可以再继续。否则，游戏不能再继续了。判断胜利则是看卡片中有没有数字达到2048。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断游戏是否结束*******************************</span></span><br><span class="line">doCheckGameOver:<span class="function"><span class="keyword">function</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> size = cc.Director.getInstance().getWinSize();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> isGameOver = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> y=<span class="number">0</span>; y&lt;<span class="number">4</span>; ++y)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>; x&lt;<span class="number">4</span>; ++x)</span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="number">0</span> ||</span><br><span class="line">		    (x&gt;<span class="number">0</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x-<span class="number">1</span>][y].getNumber())) ||</span><br><span class="line">		    (x&lt;<span class="number">3</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x+<span class="number">1</span>][y].getNumber())) ||</span><br><span class="line">		    (y&gt;<span class="number">0</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y-<span class="number">1</span>].getNumber())) ||</span><br><span class="line">		    (y&lt;<span class="number">3</span>&amp;&amp;(<span class="keyword">this</span>.cardArr[x][y].getNumber() == <span class="keyword">this</span>.cardArr[x][y+<span class="number">1</span>].getNumber())))</span><br><span class="line">		&#123;</span><br><span class="line">		    isGameOver = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isGameOver)  &#123;     <span class="comment">// if the game is over</span></span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"The Game Is Over!"</span>);</span><br><span class="line">	    cc.Director.getInstance().replaceScene(cc.TransitionFade.create(<span class="number">1</span>, <span class="keyword">new</span> HelloWorldScene()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="keyword">this</span>.shouldCreateCardNumber()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.autoCreateCardNumber();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWin())  &#123;     <span class="comment">// if win</span></span><br><span class="line">	    cc.Director.getInstance().replaceScene(cc.TransitionFade.create(<span class="number">1</span>, <span class="keyword">new</span> HelloWorldScene()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否胜利**********************</span></span><br><span class="line">isWin:<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> Win = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) &#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.cardArr[i][j].getNumber() == <span class="number">2048</span>) &#123;</span><br><span class="line">		    Win = <span class="literal">true</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>9、界面优化</strong></p>
<p>在一个卡片里面，当数字变成两位数、三位数的时候，就需要调整一下数字的大小，在CardSprite的setNumber方法中添加代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数字大小</span></span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">55</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">128</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.labelCardNumber.setFontSize(<span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还需要给不同的数字设置不同的卡片颜色，同样在setNumber方法中添加代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数字的大小来调整颜色</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.number == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">200</span>,<span class="number">190</span>,<span class="number">180</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">230</span>,<span class="number">220</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">220</span>,<span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">180</span>,<span class="number">120</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">140</span>,<span class="number">90</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">120</span>,<span class="number">90</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">64</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">90</span>,<span class="number">60</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">90</span>,<span class="number">60</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">256</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">200</span>,<span class="number">70</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">512</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">240</span>,<span class="number">200</span>,<span class="number">70</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">1024</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">0</span>,<span class="number">130</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.number == <span class="number">2048</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cardColorBG.setColor(<span class="keyword">new</span> cc.Color3B(<span class="number">0</span>,<span class="number">130</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>10、最终游戏截图</strong></p>
<p><img src="http://img.blog.csdn.net/20140701140423187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="结语">结语</h2><ul>
<li><p>2048源码：<a href="https://github.com/SongLee24/2048-js" target="_blank" rel="external">https://github.com/SongLee24/2048-js</a></p>
</li>
<li><p>在线试玩：<a href="http://2048m.sinaapp.com" target="_blank" rel="external">http://2048m.sinaapp.com</a> （新浪云）</p>
</li>
</ul>
<p>采用Cocos2D-HTML5引擎进行游戏开发，开发效率更高，加上丰富的工具集支持、实时的各种调试手段和云合作开发手段，更加直接的效果调校方式，完全没有开发环境依赖，各种优势的叠加，可以大幅度降低开发成本，提升游戏的上架速度。</p>
<p>如果觉得这样还不够，我们可以使用Cocos2d-JS-v3.0，同一份JavaScript游戏代码不用修改或者小范围修改，配合Cocos2D-X JavaScript-Binding就能以Hybrid的方式直接作为本地应用发布，也可以编译到Android、iOS等移动平台。</p>
<p>通过Cocos2D-HTML5或Cocos2d-JS，开发者能以一个更快、更惬意的方式实现自己的想法。</p>
<hr>
<p>参考：<a href="http://blog.csdn.net/column/details/love2048.html" target="_blank" rel="external">http://blog.csdn.net/column/details/love2048.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="介绍">介绍</h3><p><strong>Cocos2d-JS</strong>是Cocos2d-x的Javascript版本，它的前身是<strong>Cocos2d-html5</strong>。在3.0版本以前叫做Cocos2d-html5，从3.0版本开始叫做Cocos2d-JS。我们知道Cocos2d-x支持使用C++、Lua、Javascript来进行程序开发，其所内置的是一个Javascript引擎，通过用C++解析Javascript去执行；而Cocos2d-html5是使用Javascript进行开发，最终运行在浏览器里的。那么在v3.0的时候，Cocos2d-html5和Cocos2d-x JSBinding被合到了一起，称作<strong>Cocos2d-JS</strong>。]]>
    
    </summary>
    
      <category term="Cocos2dx" scheme="http://yoursite.com/tags/Cocos2dx/"/>
    
      <category term="应用-Cocos2dx" scheme="http://yoursite.com/categories/%E5%BA%94%E7%94%A8-Cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第K顺序统计量的求解]]></title>
    <link href="http://yoursite.com/2014/06/22/Kth-Order-Statistic/"/>
    <id>http://yoursite.com/2014/06/22/Kth-Order-Statistic/</id>
    <published>2014-06-22T14:33:20.000Z</published>
    <updated>2015-05-09T17:30:39.391Z</updated>
    <content type="html"><![CDATA[<p>一个n个元素组成的集合中，第K个<strong>顺序统计量（Order Statistic）</strong>指的是该集合中第K小的元素，我们要讨论的是如何在线性时间（linear time）里找出一个数组的第K个顺序统计量。</p>
<h3 id="问题描述">问题描述</h3><p><strong>问题</strong>：给定一个含有n个元素的无序数组，找出第k小的元素。</p>
<ul>
<li>k = 1 ：最小值</li>
<li>k = n ：最大值</li>
<li>k = ⌊(n+1)/2⌋ or ⌈(n+1)/2⌉ ：中位数</li>
</ul>
<a id="more"></a>
<p>找最大值或最小值很简单，只需要遍历一次数组并记录下最大值或最小值就可以了。我们在这里要解决的问题是一般性的选择问题。</p>
<p>一种原始的解决方案是，用堆排序或归并排序将输入数据进行排序，然后返回第k个元素。这样在Θ(nlgn)时间内一定可以解决。但是我们希望有更好的方案，最好是线性时间。</p>
<h3 id="期望线性时间的解决方案">期望线性时间的解决方案</h3><p>为了在线性时间内解决这个选择问题，我们使用一个随机的分治算法，即RANDOMIZED-SELECT算法。此算法是使用随机化的快速排序中的随机划分子程序，对输入数组进行随机划分操作，然后判断第k小元素在划分后的哪个区域，对所在区域进行递归划分，最后找到第k小元素。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A,p,q,i)  <span class="comment">// i-th smallest in A[p..q]</span></span><br><span class="line">	<span class="keyword">if</span> p = q</span><br><span class="line">		then <span class="keyword">return</span> A[p]</span><br><span class="line">	r = RANDOMIZED-PARTITION(A, p, q)</span><br><span class="line">	k = r-p+<span class="number">1</span>   <span class="comment">// A[r] is k-th smallest</span></span><br><span class="line">	<span class="keyword">if</span> i=k</span><br><span class="line">		then <span class="keyword">return</span> A[r]</span><br><span class="line">	<span class="keyword">if</span> i&lt;k</span><br><span class="line">		then <span class="keyword">return</span> RANDOMIZED-SELECT(A, p, r-<span class="number">1</span>, i)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		then <span class="keyword">return</span> RANDOMIZED-SELECT(A, r+<span class="number">1</span>, q, i-k)</span><br></pre></td></tr></table></figure></p>
<p>这里的RANDOMIZED-PARTITION()是随机版的划分操作（<a href="http://songlee24.github.io/blog/2014/06/21/kuai-su-pai-xu-de-xing-neng-fen-xi-yu-you-hua/" target="_blank" rel="external">快速排序的分析与优化</a>），可见本算法是一个随机算法，它的<strong>期望时间</strong>是Θ(n)（假设元素的值是不同的）。</p>
<p><strong>1、Lucky-Case</strong>：最好的情况是在正中划分，划分的右边和右边的元素数量相等，但是1/10和9/10的划分也几乎一样好。可以这么说，任何常数比例的划分都和1/2:1/2的划分一样好。这里以1/10和9/10的划分为例，算法运行时间递归式为<code>T(n) &lt;= T(9n/10) + Θ(n)</code>，根据主定理得到<code>T(n) &lt;= Θ(n)</code>。</p>
<p><strong>2、Unlucky-Case</strong>：虽然主元的选取是随机的，但是如果你运气足够差，每次都得到0：n-1的划分，这就是最坏的情况。此时递归式为<code>T(n) = T(n-1) + Θ(n)</code>，则时间复杂度为<code>T(n) = Θ(n^2)</code>。</p>
<p><strong>3、Expected-Time</strong>：期望运行时间为Θ(n)，即线性时间。这里就不证明了，证明需要用到指示器随机变量。</p>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: RandomizedSelect.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月22日 星期日 20时20分08秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=low+<span class="number">1</span>; j&lt;=high; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt;= pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			swap(A[i], A[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i], A[low]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Randomized_Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">int</span> i = rand() % (high+<span class="number">1</span>);</span><br><span class="line">	swap(A[low], A[i]);</span><br><span class="line">	<span class="keyword">return</span> Partition(A, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Randomized_Select</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> i)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p == q)</span><br><span class="line">		<span class="keyword">return</span> A[p];</span><br><span class="line">	<span class="keyword">int</span> r = Randomized_Partition(A, p, q);</span><br><span class="line">	<span class="keyword">int</span> k = r-p+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">		<span class="keyword">return</span> A[r];</span><br><span class="line">	<span class="keyword">if</span>(i &lt; k)</span><br><span class="line">		<span class="keyword">return</span> Randomized_Select(A, p, r-<span class="number">1</span>, i);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> Randomized_Select(A, r+<span class="number">1</span>, q, i-k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[] = &#123;<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">int</span> result = Randomized_Select(A, <span class="number">0</span>, <span class="number">7</span>, i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The "</span> &lt;&lt; i &lt;&lt; <span class="string">"th smallest element is "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最坏情况线性时间的解决方案">最坏情况线性时间的解决方案</h3><p>虽然最坏情况Θ(n^2)出现的概率非常非常小，但是不代表它不会出现。这里就介绍一个非同一般的算法，以保证在最坏情况下也能达到线性时间。</p>
<p>这个SELECT算法的基本思想就是要保证对数组的划分是一个好的划分，它通过自己的方法选取主元（pivot），然后将pivot作为参数传递给快速排序的确定性划分操作PARTITION。</p>
<p>基本步骤：</p>
<ol>
<li><p>将输入数组的n个元素划分为n/5（上取整）组，每组5个元素，且至多只有一个组有剩下的n%5个元素组成。</p>
</li>
<li><p>寻找每个组织中中位数。首先对每组中的元素（至多为5个）进行插入排序，然后从排序后的序列中选择出中位数。</p>
</li>
<li><p>对第2步中找出的n/5（上取整）个中位数，递归调用SELECT以找出其中位数x。（如果是偶数取下中位数）</p>
</li>
<li><p>调用PARTITION过程，按照中位数x对输入数组进行划分。确定中位数x的位置k。</p>
</li>
<li><p>如果i=k，则返回x。否则，如果i &lt; k，则在地区间递归调用SELECT以找出第i小的元素，若干i &gt; k，则在高区找第(i-k)个最小元素。</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20140622221504062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>总结</strong>：RANDOMIZED-SELECT和SELECT算法是基于比较的。我们知道，在比较模型中，排序时间不会优于Ω(nlgn)。之所以这里的选择算法达到了线性时间，是因为它们没有使用排序就解决了选择问题。另外，我们没有使用线性时间排序算法（计数排序/桶排序/基数排序），是因为它们要达到线性时间对输入有很高的要求，而这里不需要关于输入的任何假设。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个n个元素组成的集合中，第K个<strong>顺序统计量（Order Statistic）</strong>指的是该集合中第K小的元素，我们要讨论的是如何在线性时间（linear time）里找出一个数组的第K个顺序统计量。</p>
<h3 id="问题描述">问题描述</h3><p><strong>问题</strong>：给定一个含有n个元素的无序数组，找出第k小的元素。</p>
<ul>
<li>k = 1 ：最小值</li>
<li>k = n ：最大值</li>
<li>k = ⌊(n+1)/2⌋ or ⌈(n+1)/2⌉ ：中位数</li>
</ul>]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间的排序算法]]></title>
    <link href="http://yoursite.com/2014/06/22/linear-sorting-algorithms/"/>
    <id>http://yoursite.com/2014/06/22/linear-sorting-algorithms/</id>
    <published>2014-06-22T03:09:25.000Z</published>
    <updated>2015-05-09T17:20:43.918Z</updated>
    <content type="html"><![CDATA[<p>前面已经介绍了几种排序算法，像插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序（见我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/03/ge-chong-nei-bu-pai-xu-suan-fa-de-shi-xian/" target="_blank" rel="external">各种内部排序算法的实现</a>）等，这些排序算法都有一个共同的特点，就是基于比较。本文将介绍三种非比较的排序算法：计数排序，基数排序，桶排序。它们将突破比较排序的Ω(nlgn)下界，以线性时间运行。<a id="more"></a></p>
<h3 id="比较排序算法的时间下界">比较排序算法的时间下界</h3><p>所谓的<strong>比较排序</strong>是指通过比较来决定元素间的相对次序。</p>
<blockquote>
<p><strong>定理</strong>：对于含n个元素的一个输入序列，任何比较排序算法在最坏情况下，都需要做Ω(nlgn)次比较。</p>
</blockquote>
<p>也就是说，比较排序算法的运行速度不会快于nlgn，这就是基于比较的排序算法的<strong>时间下界</strong>。</p>
<p>通过<strong>决策树（Decision-Tree）</strong>可以证明这个定理，关于决策树的定义以及证明过程在这里就不赘述了。你可以自己去查找资料，推荐观看《<a href="http://v.163.com/movie/2010/12/7/V/M6UTT5U0I_M6V2TBK7V.html" target="_blank" rel="external">MIT公开课：线性时间排序</a>》。</p>
<p>根据上面的定理，我们知道任何比较排序算法的运行时间不会快于nlgn。那么我们是否可以突破这个限制呢？当然可以，接下来我们将介绍三种线性时间的排序算法，它们都不是通过比较来排序的，因此，下界Ω(nlgn)对它们不适用。</p>
<h3 id="计数排序（Counting_Sort）">计数排序（Counting Sort）</h3><p>计数排序的基本思想就是对每一个输入元素x，确定小于x的元素的个数，这样就可以把x直接放在它在最终输出数组的位置上，例如：</p>
<p><img src="http://img.blog.csdn.net/20140622105946593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>算法的步骤大致如下：</p>
<ul>
<li><p>找出待排序的数组中最大和最小的元素</p>
</li>
<li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p>
</li>
<li><p>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p>
</li>
<li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</li>
</ul>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: CountingSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月11日 星期三 00时08分55秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *计数排序：A和B为待排和目标数组，k为数组中最大值,len为数组长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C[k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k+<span class="number">1</span>; ++i)</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">        C[A[i]] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;k+<span class="number">1</span>; ++i)</span><br><span class="line">        C[i] = C[i] + C[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        B[C[A[i]]-<span class="number">1</span>] = A[i];</span><br><span class="line">        C[A[i]] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> origin[<span class="number">8</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">8</span>];</span><br><span class="line">    print(origin, <span class="number">8</span>);</span><br><span class="line">    CountingSort(origin, result, <span class="number">15</span>, <span class="number">8</span>);</span><br><span class="line">    print(result, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>当输入的元素是0到k之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)。</strong>当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。计数排序是一个稳定的排序算法。</p>
<p>可能你会发现，计数排序似乎饶了点弯子，比如当我们刚刚统计出C，C[i]可以表示A中值为i的元素的个数，此时我们直接顺序地扫描C，就可以求出排序后的结果。的确是这样，不过这种方法不再是计数排序，而是桶排序，确切地说，是桶排序的一种特殊情况。</p>
<h3 id="桶排序（Bucket_Sort）">桶排序（Bucket Sort）</h3><p>桶排序（Bucket Sort）的思想是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法）。当要被排序的数组内的数值是均匀分配的时候，桶排序可以以线性时间运行。桶排序过程动画演示：<a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="external">Bucket Sort</a>，桶排序原理图如下：</p>
<p><img src="http://img.blog.csdn.net/20140622110534328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BucketSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月11日 星期三 09时17分32秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 节点 */</span></span><br><span class="line"><span class="keyword">struct</span> node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> max, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    node bucket[len];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bucket[i].value = <span class="number">0</span>;</span><br><span class="line">        bucket[i].next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        node *ist = <span class="keyword">new</span> node();</span><br><span class="line">        ist-&gt;value = A[i];</span><br><span class="line">        ist-&gt;next = NULL;</span><br><span class="line">        <span class="keyword">int</span> idx = A[i]*len/(max+<span class="number">1</span>); <span class="comment">// 计算索引</span></span><br><span class="line">        <span class="keyword">if</span>(bucket[idx].next == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            bucket[idx].next = ist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 按大小顺序插入链表相应位置 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            node *p = &amp;bucket[idx];</span><br><span class="line">            node *q = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(q!=NULL &amp;&amp; q-&gt;value &lt;= A[i])</span><br><span class="line">            &#123;</span><br><span class="line">                p = q;</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ist-&gt;next = q;</span><br><span class="line">            p-&gt;next = ist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        node *p = bucket[i].next;</span><br><span class="line">        <span class="keyword">if</span>(p == NULL)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!= NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            A[count++] = p-&gt;value;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row[<span class="number">11</span>] = &#123;<span class="number">24</span>,<span class="number">37</span>,<span class="number">44</span>,<span class="number">12</span>,<span class="number">89</span>,<span class="number">93</span>,<span class="number">77</span>,<span class="number">61</span>,<span class="number">58</span>,<span class="number">3</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    print(row, <span class="number">11</span>);</span><br><span class="line">    BucketSort(row, <span class="number">235</span>, <span class="number">11</span>);</span><br><span class="line">    print(row, <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基数排序（Radix_Sort）">基数排序（Radix Sort）</h3><p>基数排序（Radix Sort）是一种非比较型排序算法，它将整数按位数切割成不同的数字，然后按每个位分别进行排序。基数排序的方式可以采用MSD（Most significant digital）或LSD（Least significant digital），MSD是从最高有效位开始排序，而LSD是从最低有效位开始排序。</p>
<p>当然我们可以采用MSD方式排序，按最高有效位进行排序，将最高有效位相同的放到一堆，然后再按下一个有效位对每个堆中的数递归地排序，最后再将结果合并起来。但是，这样会产生很多中间堆。所以，通常基数排序采用的是LSD方式。</p>
<p>LSD基数排序实现的基本思路是<strong>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</strong>需要注意的是，对每一个数位进行排序的算法必须是<strong>稳定</strong>的，否则就会取消前一次排序的结果。通常我们使用<code>计数排序</code>或者<code>桶排序</code>作为基数排序的辅助算法。基数排序过程动画演示：<a href="http://www.cs.usfca.edu/~galles/visualization/RadixSort.html" target="_blank" rel="external">Radix Sort</a></p>
<p><strong>C++实现（使用计数排序）</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: RadixSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月22日 星期日 12时04分37秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求num在n位上的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIt</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> power = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        power *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num % power) * <span class="number">10</span> / power;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序（使用计数排序作为辅助）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> C[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 计数数组</span></span><br><span class="line">		<span class="keyword">int</span> B[len];        <span class="comment">// 结果数组</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = findIt(A[j], i);</span><br><span class="line">			C[d] += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;<span class="number">10</span>; ++j)</span><br><span class="line">			C[j] = C[j] + C[j-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>; j&gt;=<span class="number">0</span>; --j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = findIt(A[j], i);</span><br><span class="line">			C[d] -= <span class="number">1</span>;</span><br><span class="line">			B[C[d]] = A[j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将B中排好序的拷贝到A中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; ++j)</span><br><span class="line">			A[j] = B[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">8</span>] = &#123;<span class="number">332</span>, <span class="number">653</span>, <span class="number">632</span>, <span class="number">5</span>, <span class="number">755</span>, <span class="number">433</span>, <span class="number">722</span>, <span class="number">48</span>&#125;;</span><br><span class="line">	print(A, <span class="number">8</span>);</span><br><span class="line">	RadixSort(A, <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">	print(A, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>基数排序的时间复杂度是 O(k·n)，其中n是排序元素个数，k是数字位数。</em></strong>注意这不是说这个时间复杂度一定优于O(nlgn)，因为n可能具有比较大的系数k。</p>
<p>另外，基数排序不仅可以对整数排序，也可以对有多个关键字域的记录进行排序。例如，根据三个关键字年、月、日来对日期进行排序。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面已经介绍了几种排序算法，像插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序（见我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/03/ge-chong-nei-bu-pai-xu-suan-fa-de-shi-xian/">各种内部排序算法的实现</a>）等，这些排序算法都有一个共同的特点，就是基于比较。本文将介绍三种非比较的排序算法：计数排序，基数排序，桶排序。它们将突破比较排序的Ω(nlgn)下界，以线性时间运行。]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速排序的分析与优化]]></title>
    <link href="http://yoursite.com/2014/06/21/quick-sort-analysis/"/>
    <id>http://yoursite.com/2014/06/21/quick-sort-analysis/</id>
    <published>2014-06-21T06:53:39.000Z</published>
    <updated>2015-05-09T17:13:57.590Z</updated>
    <content type="html"><![CDATA[<h3 id="快速排序的介绍">快速排序的介绍</h3><p>快速排序是一种排序算法，对包含n个数的输入数组，最坏的情况运行时间为<strong>Θ(n^2)</strong>[Θ读作theta]。虽然这个最坏情况的运行时间比较差，但快速排序通常是用于排序的最佳的实用选择。这是因为其平均情况下的性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，它还能够进行就地排序，在虚拟内存环境中也能很好的工作。</p>
<p>和归并排序一样，快速排序也是基于<strong>分治法</strong>（Divide and conquer）：<a id="more"></a></p>
<ul>
<li><strong>分解</strong>：数组A[p..r]被划分成两个(可能为空)的子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A[q]，A[q+1..r]中的每个元素都大于等于A[q]。这样元素A[q]就位于其最终位置上了。</li>
<li><strong>解决</strong>：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]排序。</li>
<li><strong>合并</strong>：因为两个子数组是就地排序，不需要合并，整个数组已有序。</li>
</ul>
<p><strong>伪代码</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	x = A[p]</span><br><span class="line">	<span class="tag">i</span> = <span class="tag">p</span></span><br><span class="line">	<span class="keyword">for</span> j=p+<span class="number">1</span> to r</span><br><span class="line">		do <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">			then <span class="tag">i</span> = i+<span class="number">1</span></span><br><span class="line">				 <span class="function"><span class="title">exchange</span><span class="params">(A[i],A[j])</span></span></span><br><span class="line">	<span class="function"><span class="title">exchange</span><span class="params">(A[p], A[i])</span></span></span><br><span class="line">	return i</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">QUICKSORT</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="tag">p</span> &lt; r</span><br><span class="line">		then <span class="tag">q</span> = <span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">			 <span class="function"><span class="title">QUICKSORT</span><span class="params">(A, p, q-<span class="number">1</span>)</span></span></span><br><span class="line">			 <span class="function"><span class="title">QUICKSORT</span><span class="params">(A, q+<span class="number">1</span>, r)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3><p><strong>1、最坏情况</strong></p>
<p>快速排序的最坏情况发生在当<strong>数组已经有序或者逆序排好</strong>的情况下。这样的话划分过程产生的两个区域中有一个没有元素，另一个包含n-1个元素。此时算法的运行时间可以递归地表示为：<code>T(n) = T(n-1)+T(0)+Θ(n)</code>，递归式的解为<code>T(n)=Θ(n^2)</code>。可以看出，快速排序算法最坏情况运行时间并不比插入排序的更好。</p>
<p><strong>2、最好情况</strong></p>
<p>如果我们足够幸运，在每次划分操作中做到最平衡的划分，即将数组划分为n/2:n/2。此时得到的递归式为<code>T(n) = 2T(n/2)+Θ(n)</code>，根据主定理的情况二可得<code>T(n)=Θ(nlgn)</code>。</p>
<p><strong>3、平均情况</strong></p>
<p>假设一：快排中的划分点非常偏斜，比如每次都将数组划分为1/10 : 9/10的两个子区域，这种情况下运行时间是多少呢？运行时间递归式为<code>T(n) = T(n/10)+T(9n/10)+Θ(n)</code>，使用递归树解得<code>T(n)=Θ(nlgn)</code>。可以看出，当划分点非常偏斜的时候，运行时间仍然是Θ(nlgn)。</p>
<p>假设二：Partition所产生的划分既有“好的”，也有“差的”，它们交替出现。这种平均情况下运行时间又是多少呢？这时的递归式为（G表示Good，B表示Bad）：</p>
<blockquote>
<p>G(n) = 2B(n/2) + Θ(n)</p>
<p>B(n) = G(n-1) + Θ(n)</p>
<p>解：G(n) = 2(G(n/2-1) + Θ(n/2)) + Θ(n) = 2G(n/2-1) + Θ(n) = Θ(nlgn)  </p>
</blockquote>
<p>可以看出，当好、差划分交替出现时，快排的运行时间就如全是好的划分一样，仍然是Θ(nlgn) 。</p>
<h3 id="快排的优化">快排的优化</h3><p>经过上面的分析可以知道，在输入有序或逆序时快速排序很慢，在其余情况则表现良好。如果输入本身已被排序，那么就糟了。那么我们如何确保对于所有输入，它均能够获得较好的平均情况性能呢？前面的快速排序我们默认使用数组中第一个元素作为主元。假设随机选择数组中的元素作为主元，则快排的运行时间将不依赖于输入序列的顺序。我们把<strong>随机选择主元</strong>的快速排序叫做Randomized Quicksort。</p>
<p>在随机化的快速排序中，我们不是始终选择第一个元素作为主元，而是从数组A[p…r]中随机选择一个元素，然后将其与第一个元素交换。由于主元元素是随机选择的，我们期望在平均情况下，对输入数组的划分能够比较对称。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">RANDOMIZED-PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="tag">i</span> = <span class="function"><span class="title">RANDOM</span><span class="params">(p, r)</span></span></span><br><span class="line">	<span class="function"><span class="title">exchange</span><span class="params">(A[p], A[i])</span></span></span><br><span class="line">	return <span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="tag">p</span> &lt; r</span><br><span class="line">		then <span class="tag">q</span> = <span class="function"><span class="title">RANDOMIZED-PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">			<span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, p, q-<span class="number">1</span>)</span></span></span><br><span class="line">			<span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, q+<span class="number">1</span>, r)</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们对3万个元素的有序序列分别进行<strong>传统的快速排序</strong> 和 <strong>随机化的快速排序</strong>，并比较它们的运行时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: QuickSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月21日 星期六 10时11分30秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;ctime&gt;  <span class="comment">// clock_t clock</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统划分操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=low+<span class="number">1</span>; j&lt;=high; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt;= pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			swap(A[i], A[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i], A[low]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机化划分操作，随机选择pivot</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_Random</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">int</span> i = rand() % (high+<span class="number">1</span>);</span><br><span class="line">	swap(A[low], A[i]);</span><br><span class="line">	<span class="keyword">return</span> Partition(A, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = Partition(A, low, high);</span><br><span class="line">		QuickSort(A, low, pos-<span class="number">1</span>);</span><br><span class="line">		QuickSort(A, pos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机化快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort_Random</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = Partition_Random(A, low, high);</span><br><span class="line">		QuickSort_Random(A, low, pos-<span class="number">1</span>);</span><br><span class="line">		QuickSort_Random(A, pos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	clock_t t1, t2;</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">30000</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; ++i)</span><br><span class="line">		A[i] = i+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">	t1 = clock();</span><br><span class="line">	QuickSort(A, <span class="number">0</span>, <span class="number">30000</span>-<span class="number">1</span>);</span><br><span class="line">	t1 = clock() - t1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Traditional quicksort took "</span>&lt;&lt; t1 &lt;&lt; <span class="string">" clicks(about "</span> &lt;&lt; ((<span class="keyword">float</span>)t1)/CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds)."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t2 = clock();</span><br><span class="line">	QuickSort_Random(A, <span class="number">0</span>, <span class="number">30000</span>-<span class="number">1</span>);</span><br><span class="line">	t2 = clock() - t2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Randomized quicksort took "</span>&lt;&lt; t2 &lt;&lt; <span class="string">" clicks(about "</span> &lt;&lt; ((<span class="keyword">float</span>)t2)/CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds)."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost ~]$ ./QuickSort </span><br><span class="line">Traditional quicksort took <span class="number">1210309</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">1.21031</span> seconds)</span></span>.</span><br><span class="line">Randomized quicksort took <span class="number">457573</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">0.457573</span> seconds)</span></span>.</span><br><span class="line">[songlee@localhost ~]$ ./QuickSort </span><br><span class="line">Traditional quicksort took <span class="number">1208038</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">1.20804</span> seconds)</span></span>.</span><br><span class="line">Randomized quicksort took <span class="number">644950</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">0.64495</span> seconds)</span></span>.</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看出，对于有序的输入，随机化版本的快速排序的效率会高很多。</p>
<h4 id="问题记录：">问题记录：</h4><p>我们知道交换两个变量的值有以下三种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = a;  <span class="comment">// 方法一</span></span><br><span class="line">a = b;</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a+b;  <span class="comment">// 方法二</span></span><br><span class="line">b = a-b;</span><br><span class="line">a = a-b;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;  <span class="comment">// 方法三</span></span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure>
<p>但是你会发现在本程序中，如果swap函数使用后面两种方法会出错。由于方法二和方法三没有使用中间变量，它们交换值的原理是直接对变量的内存单元进行操作。<strong>如果两个变量对应的同一内存单元，则经过两次加减或异或操作，内存单元的值已经变为了0，因而不能实现变量值交换</strong>。所以当需要交换值的变量可能是同一变量时，必须使用第三变量实现交换，否则会对变量清零。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="快速排序的介绍">快速排序的介绍</h3><p>快速排序是一种排序算法，对包含n个数的输入数组，最坏的情况运行时间为<strong>Θ(n^2)</strong>[Θ读作theta]。虽然这个最坏情况的运行时间比较差，但快速排序通常是用于排序的最佳的实用选择。这是因为其平均情况下的性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，它还能够进行就地排序，在虚拟内存环境中也能很好的工作。</p>
<p>和归并排序一样，快速排序也是基于<strong>分治法</strong>（Divide and conquer）：]]>
    
    </summary>
    
      <category term="快排" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵原地转置]]></title>
    <link href="http://yoursite.com/2014/04/09/matrix-transpose-inplace/"/>
    <id>http://yoursite.com/2014/04/09/matrix-transpose-inplace/</id>
    <published>2014-04-09T02:06:00.000Z</published>
    <updated>2015-05-09T17:09:52.322Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>微软面试题</strong>：将一个MxN的矩阵存储在一个一维数组中，编程实现矩阵的转置。</p>
<p><strong>要求</strong>：空间复杂度为O(1)<a id="more"></a></p>
<h3 id="思路分析">思路分析</h3><p>下面以一个4x2的矩阵A={1,2,3,4,5,6,7,8}进行分析，转置过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20140606173801500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>图中右下角的红色数字表示在一维数组中的下标。矩阵的转置其实就是数组中元素的移动，具体的移动过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20140606173842187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们发现，这些移动的元素的下标是一个个环，下标1的元素移动到4，下标4的元素移动到2，下标2的元素移动到1。在编写程序的时候，我们需要解决两个问题：第一个是如何判定环是否重复（已处理过）；第二个是如何计算当前元素下标的前驱与后继。</p>
<p><strong>第一个问题</strong>：如何判断环是重复已处理过的？因为我们遍历整个数组时下标是从小到大的，所以如果是第一次遍历该环，则第一个下标肯定是这个环中最小的。如果一个环被处理过，那么总能找到一个它的后继是小于它的。从上图可以明显看出来。</p>
<p><strong>第二个问题</strong>：如何计算当前元素下标的前驱与后继？假设转置前某个元素的数组下标为i，则它所在行列为（i/N, i%N），转置后所在行列则为（i%N, i/N），可计算转置后数组下标为<strong>(i%N)*M+i/N</strong>，此为i的<strong>后继</strong>。假设转置后某个元素的数组下标为i，则它所在行列为（i/M, i%M），则转置前所在行列为（i%M, i/M），可计算此时下标为<strong>(i%M)*N+i/M</strong>，此为i的<strong>前驱</strong>。</p>
<h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: matrix_transpose.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月06日 星期五 14时26分15秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后继 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%n)*m + i/n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前驱 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%m)*n + i/m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理以下标i为起点的环 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movedata</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = mtx[i];  <span class="comment">// 暂存</span></span><br><span class="line">    <span class="keyword">int</span> cur = i;       <span class="comment">// 当前下标</span></span><br><span class="line">    <span class="keyword">int</span> pre = getPre(cur, m, n);</span><br><span class="line">    <span class="keyword">while</span>(pre != i)</span><br><span class="line">    &#123;</span><br><span class="line">        mtx[cur] = mtx[pre];</span><br><span class="line">        cur = pre;</span><br><span class="line">        pre = getPre(cur, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    mtx[cur] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转置，即循环处理所有环 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> next = getNext(i, m, n);</span><br><span class="line">        <span class="keyword">while</span>(next &gt; i) <span class="comment">// 若存在后继小于i说明重复</span></span><br><span class="line">            next = getNext(next, m, n);</span><br><span class="line">        <span class="keyword">if</span>(next == i)   <span class="comment">// 处理当前环 </span></span><br><span class="line">            movedata(mtx, i, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出矩阵 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)%n == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mtx[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mtx[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[<span class="number">4</span>*<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before matrix transposition:"</span> &lt;&lt; endl;</span><br><span class="line">    print(matrix, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    transpose(matrix, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After matrix transposition:"</span> &lt;&lt; endl;</span><br><span class="line">    print(matrix, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://img.blog.csdn.net/20140606173940156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>微软面试题</strong>：将一个MxN的矩阵存储在一个一维数组中，编程实现矩阵的转置。</p>
<p><strong>要求</strong>：空间复杂度为O(1)]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[变位词问题]]></title>
    <link href="http://yoursite.com/2014/04/08/brother-word/"/>
    <id>http://yoursite.com/2014/04/08/brother-word/</id>
    <published>2014-04-08T13:10:46.000Z</published>
    <updated>2015-05-09T17:04:38.085Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》第二章提到了一个变位词问题，变位词指的是一个单词可以通过改变其他单词中字母的顺序来得到，也叫做兄弟单词，如army-&gt;mary。由变位词可以引申出几个算法问题，包括字符串包含问题，比较两个字符串是否是变位词，以及找出字典中变位词集合的问题。</p>
<h3 id="字符串包含问题">字符串包含问题</h3><p>(1) 问题描述：存在字符串1和字符串2，假设字符串2相对较短，如何快速地判定字符串2中的字符都存在于字符串1里（假定字符串只包含字母）？<a id="more"></a></p>
<p>(2) 举例：字符串1为ABCDEFGHIJK，字符串2为ABCDE，则字符串1包含字符串2，因为字符串2中包含的字母在字符串1中也都有。</p>
<p>(3) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>最直接的思路就是针对字符串2中的每个字符，轮询字符串1进行比较，看是否在字符串1里面。很明显这种的时间效率为<strong>O(n*m)</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;long_str.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(long_str[j] == short_str[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == long_str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEF"</span>;</span><br><span class="line">    Compare(l, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>这里由于假定了字符串只包含字母，所以我们可以用一个额外的数组flag[26]作为26个字符标识位，先遍历长字符串将对应的标识位置1，再遍历短字符串，如果对应的标示位都是1，则包含；否则不包含。<strong>这种方法的时间复杂度为O(n+m)，为了提高空间效率，这里不使用数组而使用26个bit位来作为标示位（bitset容器）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;26&gt; flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;long_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag.set(n)置第n位为1</span></span><br><span class="line">        flag.<span class="built_in">set</span>(long_str[i]-<span class="string">'A'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag.test(n)判断第n位是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(!flag.test(short_str[i]-<span class="string">'A'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEZ"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(l, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法还可以进行优化，例如如果长字串的前缀就为短字串，那么我们可以不需要n+m次，而只需要2m次。具体实现请自己思考。</p>
<ul>
<li><strong>思路三</strong></li>
</ul>
<p>给每个字母分配一个素数，从2开始到3，5，7…遍历长字串，求得每个字符对应素数的乘积。然后遍历短字串，判断该乘积能否被短字符串中的字符对应的素数整除，如果除的结果存在余数，则说明有不匹配的字母；如果整个过程都没有余数，则说明短字串中的字母在长字串里都有。<strong>这种方法的时间复杂度也是O(n+m)，需要26个额外空间存素数，但是这种方法有一个缺点就是需要跟大整数打交道，因为乘积可能非常大</strong>。（这里我们使用<cstdint>头文件中定义的int64_t和uint64_t）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;cstdint&gt;  // C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> primeNum[<span class="number">26</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,</span><br><span class="line">                        <span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="comment">/* int64_t和uint64_t分别表示64位的有符号和无符号整形数 */</span></span><br><span class="line">    <span class="comment">/* 在不同位数机器的平台下通用，都是64位 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> ch = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;long_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch*primeNum[long_str[i]-<span class="string">'A'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch%primeNum[short_str[i]-<span class="string">'A'</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEK"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(l, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cstdint></p>
<h3 id="比较两个字符串是否为变位词">比较两个字符串是否为变位词</h3><p>(1) 问题描述：如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，问如何在迅速匹配兄弟字符串（如，bad和adb就是兄弟字符串）。</p>
<p>(2) 注意：第一点中讨论了字符串包含问题，但是不要以为两个字符串互相包含就是（变位词）兄弟字符串了，例如aabcde和edcba互相包含，但它们不是变位词。</p>
<p>(3) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>给每个字母分配一个素数，可以通过判断两个字符串的素数乘积是否相等。跟上述素数法一样，时间复杂度也是O(n+m)，需要跟大整数打交道。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;cstdint&gt; // C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> primeNum[<span class="number">26</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,</span><br><span class="line">                        <span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="keyword">uint64_t</span> ch = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch*primeNum[s1[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s2.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch/primeNum[s2[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abandon"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"banadon"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(s1, s2))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They are brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They aren't brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>将两个字符串按照字母表顺序排序，看排序后的字符串是否相等，如果相等则是兄弟字符串（变位词）。这种方法的时间效率根据你使用的排序算法不同而不同。当然，你可以自己写排序算法，这里我们使用C++的STL中的sort()函数对字符串进行排序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义序函数（二元谓词）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 采用泛型算法对s1,s2排序，sort()采用的是快速排序算法</span></span><br><span class="line">    sort(s1.begin(), s1.end(), myfunction);</span><br><span class="line">    sort(s2.begin(), s2.end(), myfunction);</span><br><span class="line">    <span class="keyword">if</span>(!s1.compare(s2))  <span class="comment">// 相等返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abandon"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"banadon"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(s1, s2))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They are brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They aren't brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="字典找出所有变位词集合（重点）">字典找出所有变位词集合（重点）</h3><p>(1) 问题描述：给定一个英语字典，找出其中的所有变位词集合。</p>
<p>(2) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>对于这个问题，最快想到的最直接的方法就是针对每一个单词跟字典中的其他单词进行比较。然而，假设一次比较至少花费1微秒的时间，则拥有二十万单词的字典将花费：<strong>200000单词 x 200000比较/单词 x 1微秒/比较 = 40000x10^6秒 = 40000秒 ≈ 11.1小时</strong>。比较的次数太多了，导致效率低下，我们需要找出效率更高的方法。</p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>标识字典中的每一个单词，使得在相同变位词类中的单词具有相同的的标识，然后集中具有相同标识的单词。将每个单词按照字母表排序，排序后得到的字符串作为该单词的标识。那么对于该问题的解题过程可以分为三步：<strong>第一步，读入字典文件，对单词进行排序得到标识；第二步，将所有的单词按照其标识的顺序排序；第三步，将同一个变位词类中的各个单词放到同一行中</strong>。</p>
<p>这里出现了标识-单词（key-value）对，我们很容易想到C++中的关联容器<strong>map</strong>，使用<strong>map</strong>的好处就是：</p>
<ol>
<li><strong>动态管理内存，容器大小动态改变；</strong></li>
<li><strong>单词与它的标识一一对应，对于相同标识(key)的单词直接加在值(value)后面；</strong></li>
<li><strong>无需根据标识排序，因为map会自动按关键字有序（默认升序）</strong>。 </li>
</ol>
<p>所以，在将每个单词及其标识存入map以后，就可以直接遍历输出了，每一个map元素就是一个变位词集合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fstream&gt;    <span class="comment">// file I/O</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;map&gt;        <span class="comment">// map</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;     <span class="comment">// string</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;  <span class="comment">// sort</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *map是C++中的关联容器</span><br><span class="line"> *     按关键字有序</span><br><span class="line"> *     关键字不可重复</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义比较函数（用于排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span><br><span class="line"> *对每个单词排序</span><br><span class="line"> *排序后字符串作为关键字，原单词作为值</span><br><span class="line"> *存入map中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sign_sort</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dic)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 文件流</span></span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(dic)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't open file: "</span> + <span class="built_in">string</span>(dic) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> aword;</span><br><span class="line">    <span class="built_in">string</span> asign;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; aword)</span><br><span class="line">    &#123;</span><br><span class="line">        asign = aword;</span><br><span class="line">        sort(asign.begin(), asign.end(), myfunction);</span><br><span class="line">        <span class="comment">// 若标识不存在，创建一个新map元素，若存在，加在值后面</span></span><br><span class="line">        word[asign] += aword + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *写入输出文件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!out)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't create file: "</span> + <span class="built_in">string</span>(file) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator begin = word.begin();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator end = word.end();</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; begin-&gt;second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dic;  </span><br><span class="line">    <span class="built_in">string</span> outfile;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input dictionary name: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; dic;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input output filename: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; outfile;</span><br><span class="line"></span><br><span class="line">    sign_sort(dic.c_str());</span><br><span class="line">    write_file(outfile.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>附</strong>：（2012.5.6百度实习笔试题）一个单词交换字母位置，可得另一个单词，如army-&gt;mary，成为兄弟单词。提供一个单词，在字典中找到它的兄弟。描述数据结构和查询过程。</p>
<p><strong>解题思路</strong>：如果不允许进行预处理，那么我们只能顺序遍历整个字典，计算每个单词的标识与给定单词的标识比较。如果允许进行预处理，我们可以如上述思路二将所有单词加入一个map，然后输出关键字（给定单词的标识）对应的值，值中就包含了该单词的所有兄弟单词。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》第二章提到了一个变位词问题，变位词指的是一个单词可以通过改变其他单词中字母的顺序来得到，也叫做兄弟单词，如army-&gt;mary。由变位词可以引申出几个算法问题，包括字符串包含问题，比较两个字符串是否是变位词，以及找出字典中变位词集合的问题。</p>
<h3 id="字符串包含问题">字符串包含问题</h3><p>(1) 问题描述：存在字符串1和字符串2，假设字符串2相对较短，如何快速地判定字符串2中的字符都存在于字符串1里（假定字符串只包含字母）？]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一维向量旋转算法]]></title>
    <link href="http://yoursite.com/2014/04/07/vector-rotation/"/>
    <id>http://yoursite.com/2014/04/07/vector-rotation/</id>
    <published>2014-04-07T12:43:09.000Z</published>
    <updated>2015-05-09T16:52:45.288Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》第二章提到了n元一维向量旋转算法（又称数组循环移位算法）的五种思路，并且比较了它们在时间和空间性能上的区别和优劣。</p>
<h3 id="问题描述">问题描述</h3><p>将一个n元一维向量向左旋转i个位置。例如，假设n=8，i=3，向量abcdefgh旋转为向量defghabc。简单的代码使用一个n元的中间向量在n步内可完成该工作。你能否仅使用几十个额外字节的内存空间，在正比于n的时间内完成向量的旋转？<a id="more"></a></p>
<h3 id="解决方案">解决方案</h3><p><strong>思路一</strong>：将向量x中的前i个元素复制到一个临时数组中，接着将余下的n-i个元素左移i个位置，然后再将前i个元素从临时数组中复制到x中余下的位置。<strong>性能：这种方法使用了i个额外的位置，如果i很大则产生了过大的存储空间的消耗。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 17时07分06秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将前i个元素临时保存</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(s, 0, i)</span></span>;</span><br><span class="line">    <span class="comment">// 将剩余的左移i个位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>    j=i; j&lt;s.size(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        s[j-i] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.substr(<span class="number">0</span>, s.size()-i) + tmp;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路二</strong>：定义一个函数将x向左旋转一个位置（其时间正比于n），然后调用该函数i次。<strong>性能：这种方法虽然空间复杂度为O(1)，但产生了过多的运行时间消耗。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate_1.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 19时49分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateOnce</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;s.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i-<span class="number">1</span>] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[i-<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数i次</span></span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rotateOnce(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路三</strong>：移动x[0]到临时变量t中，然后移动x[i]到x[0]中，x[2i]到x[i]，依次类推，直到我们又回到x[0]的位置提取元素，此时改为从临时变量t中提取元素，然后结束该过程（当下标大于n时对n取模或者减去n）。如果该过程没有移动全部的元素，就从x[1]开始再次进行移动，总共移动i和n的最大公约数次。<strong>性能：这种方法非常精巧，像书中所说的一样堪称巧妙的杂技表演。空间复杂度为O(1)，时间复杂度为线性时间，满足问题的性能要求，但还不是最佳。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate_2.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 20时21分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧几里德（辗转相除）算法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            i = i%j;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            j = j%i;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> times = gcd(s.size(), i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;times; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s[j];</span><br><span class="line">        <span class="keyword">int</span> pre = j; <span class="comment">// 记录上一次的位置</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = pre+i;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= s.size())</span><br><span class="line">                t = t-s.size();</span><br><span class="line">            <span class="keyword">if</span>(t == j) <span class="comment">// 直到tmp原来的位置j为止</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s[pre] = s[t];</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        s[pre] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路四</strong>：旋转向量x实际上就是交换向量ab的两段，得到向量ba，这里a代表x的前i个元素。假设a比b短。将b分割成$b_l$和$b_r$，使$b_r$的长度和a的长度一样。交换a和$b_r$，将$ab_lb_r$转换成$b_rb_la$。因为序列a已在它的最终位置了，所以我们可以集中精力交换b的两个部分了。由于这个新问题和原先的问题是一样的，所以我们以递归的方式进行解决。这种方法可以得到优雅的程序，但是需要巧妙的代码，并且要进行一些思考才能看出它的效率足够高。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></p>
<p><strong>思路五</strong>：（<strong>最佳</strong>）将这个问题看做是把数组ab转换成ba，同时假定我们拥有一个函数可以将数组中特定部分的元素逆序。从ab开始，首先对a求逆，得到$a^r b$，然后对b求逆，得到$a^r b^r$。最后整体求逆，得到$(a^r b^r)^r$，也就是ba。<br>reverse(0, i-1)   /<em>cbadefgh</em>/<br>reverse(i, n-1)  /<em>cbahgfed</em>/<br>reverse(0, n-1) /<em>defghabc</em>/<br><strong>性能：求逆序的方法在时间和空间上都很高效，而且代码非常简短，很难出错。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 23时37分54秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = s[begin];</span><br><span class="line">        s[begin] = s[end];</span><br><span class="line">        s[end] = tmp;</span><br><span class="line">        ++begin;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(s, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">    reverse(s, i, s.size()-<span class="number">1</span>);</span><br><span class="line">    reverse(s, <span class="number">0</span>, s.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展延伸">扩展延伸</h3><p><strong>如何将向量abc旋转变成cba？</strong><br>和前面的问题类似，此向量旋转对应着非相邻内存块的交换模型。解法很相似，即利用恒等式：</p>
<p>$$cba = （a^r b^r c^r）^r$$</p>
<p><strong>注</strong>：在面试或笔试时，如若出现向量旋转（内存块交换）问题，最好使用思路五答题，不仅高效而且简洁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》第二章提到了n元一维向量旋转算法（又称数组循环移位算法）的五种思路，并且比较了它们在时间和空间性能上的区别和优劣。</p>
<h3 id="问题描述">问题描述</h3><p>将一个n元一维向量向左旋转i个位置。例如，假设n=8，i=3，向量abcdefgh旋转为向量defghabc。简单的代码使用一个n元的中间向量在n步内可完成该工作。你能否仅使用几十个额外字节的内存空间，在正比于n的时间内完成向量的旋转？]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[位图排序]]></title>
    <link href="http://yoursite.com/2014/04/06/bitmap-sorting/"/>
    <id>http://yoursite.com/2014/04/06/bitmap-sorting/</id>
    <published>2014-04-06T12:22:42.000Z</published>
    <updated>2015-05-09T16:40:43.567Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》里面讲到了一种算法导论里没有提到过的位图排序方法，这种排序方法是<strong>通过牺牲空间效率来追求时间效率（线性时间）以达到时间-空间折中与双赢</strong>的目的。下面简单讲一下我对位图排序思想的理解。</p>
<h3 id="问题描述">问题描述</h3><p>1 . 输入：一个至多包含1千万个非负整数的文件<a id="more"></a></p>
<p>2 . 特征：①每个数都是小于10000000的非负整数；②没有重复的数字；③数据之间不存在关联关系。</p>
<p>3 . 约束：①最多1MB的内存空间可用；②磁盘空间充足；③运行时间最多几分钟，最好是线性时间。</p>
<p>4 .  输出：按升序排列的整数序列。</p>
<h3 id="位图排序思想">位图排序思想</h3><p>由于待排序的数据记录较多，我们单纯地使用常见的排序方法时间效率较低，运行时间会很长。而且内存空间有限（限制为1MB左右），所以我们不能同时把所有整数读入内存（如果每个整数使用7个字节来存储，那么1MB内存空间只能存大约143000个数字）。当然我们可以多次读取输入文件，多次排序，但是更好的方案是使用位图排序，可以使用有限的1MB内存空间并只进行一趟排序。</p>
<p>1 . 根据待排序集合中最大的数，开辟一个位数组，用来表示待排序集合中的整数；</p>
<p>2 . 待排序集合中的数字在位数组中的对应位置置1，其他的置0；</p>
<p><strong>例如，待排序集合{1,2,3,5,8,13}可以表示为：0-1-1-1-0-1-0-0-1-0-0-0-0-1</strong></p>
<p>这样排序过程自然可以分为三步：</p>
<pre><code>第一步：将所有的位都置为0；

第二步：通过读入文件中的每个整数，将每个对应的位都置为1；

第三步：检验每一位，如果该位为1，输出对应的整数。
</code></pre><p><strong>注意</strong>：位图排序是使用一个<strong>二进制位</strong>而不是一个整数来表示0或1，这样可以大大地减少所需要的内存空间。使用位图排序的前提是要知道待排序序列中的最大数。<strong>位图排序的缺点</strong>是有些数没有出现过，仍要为其保留一个位。故位图排序比较适合关键字密集的序列，例如一个城市的电话号码。</p>
<p>伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Phase 1: initialize set to empty*/</span></span><br><span class="line">	<span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line">		bit[i] = <span class="number">0</span></span><br><span class="line"><span class="comment">/*Phase 2: insert present elements into the set*/</span></span><br><span class="line">	<span class="keyword">for</span> each i in the input file</span><br><span class="line">		bit[i] = <span class="number">1</span></span><br><span class="line"><span class="comment">/*Phase 3: write sorted output*/</span></span><br><span class="line">	<span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line">		<span class="keyword">if</span> bit[i] == <span class="number">1</span></span><br><span class="line">			write i on the output file</span><br></pre></td></tr></table></figure></p>
<p><strong>性能</strong>：时间复杂度可达O(n)，1MB包含8<em>1024</em>1024个位，所需内存10000000/(8<em>1024</em>1024)=1.20MB，如果不是严格限制的话可以看做基本符合要求。</p>
<h3 id="位图排序实现">位图排序实现</h3><p>位图排序时，我们需要考虑：给出一个数，如何找到其对应位图的位置，方法就是首先找到该数对应的字节，然后在找到该数对应的位。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bitmap[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/* 可以表示16个数，即0～15 */</span></span><br></pre></td></tr></table></figure></p>
<p>一个字节有八位，5表示第0个字节的第5位上；14表示第1个字节的第6个位上。</p>
<p>在这里<strong>为了简化位处理，我们使用C++标准库的bitset容器。bitset是C++提供的一种位集合的数据结构，它让我们可以像使用数组一样使用位，可以访问指定下标的bit位。和其他容器一样，bitset也是一个模板类。</strong>具体的bitset方法可以查看<a href="http://zh.cppreference.com/w/cpp/utility/bitset" target="_blank" rel="external">std::bitset reference</a>。</p>
<p>下面我们使用bitset容器进行位图排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BitSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月01日 星期日 23时46分32秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bitset</span>&lt;MAX+1&gt; bit;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 将对应位置置1 */</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bit.<span class="built_in">set</span>(arr[i]);</span><br><span class="line">		<span class="comment">/* bit.set(n)表示将第n位置1 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 输出排序结果 */</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* bit.test(n)判断第n位是否为1 */</span></span><br><span class="line">		<span class="keyword">if</span>(bit.test(i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：0 1 2 5 7 9 10 13 16 20</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》里面讲到了一种算法导论里没有提到过的位图排序方法，这种排序方法是<strong>通过牺牲空间效率来追求时间效率（线性时间）以达到时间-空间折中与双赢</strong>的目的。下面简单讲一下我对位图排序思想的理解。</p>
<h3 id="问题描述">问题描述</h3><p>1 . 输入：一个至多包含1千万个非负整数的文件]]>
    
    </summary>
    
      <category term="Bitmap" scheme="http://yoursite.com/tags/Bitmap/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[各种内部排序算法的实现]]></title>
    <link href="http://yoursite.com/2014/04/03/implementation-of-internal-sortings/"/>
    <id>http://yoursite.com/2014/04/03/implementation-of-internal-sortings/</id>
    <published>2014-04-03T02:05:19.000Z</published>
    <updated>2015-05-09T16:33:48.363Z</updated>
    <content type="html"><![CDATA[<p>排序算法相信对大家来说都不陌生，或许很多人已经把它们记得滚瓜烂熟，随时可以写出来。是的，这些都是最基本的算法。很惭愧我没有达到那种熟练程度，甚至都快忘了。最近把各种内部排序算法复习了一下，包括插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序。（另：堆排序原理说起来比较长，请看我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/02/dui-pai-xu-de-suan-fa-shi-xian/" target="_blank" rel="external">堆排序的算法实现</a>）<a id="more"></a></p>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: sort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年04月27日 星期日 22时28分39秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;直接插入排序&gt;&gt;</span><br><span class="line"> *    为了实现N个数的排序，将后面N-1个数依次插入到前面已排好的子序列中，</span><br><span class="line"> *假定刚开始第1个数是一个已排好序的子序列。经过N-1趟就能得到一个有序序列。</span><br><span class="line"> *****时间复杂度：最好情况O(n)，最坏情况O(n^2)，平均情况O(n^2).</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	ElementType temp;  <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = A[i]; </span><br><span class="line">		<span class="keyword">for</span>(j = i; j&gt;<span class="number">0</span> &amp;&amp; A[j-<span class="number">1</span>]&gt;temp; --j)</span><br><span class="line">			A[j] = A[j-<span class="number">1</span>];</span><br><span class="line">		A[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;折半插入排序&gt;&gt;</span><br><span class="line"> *    与直接插入排序不同的是，折半插入排序不是边比较边移动，而是将比较和移</span><br><span class="line"> *动操作分离出来，即先折半查找出元素的待插入位置，然后再统一地移动待插入位</span><br><span class="line"> *置之后的所有元素。不难看出折半插入排序仅仅是减少了比较的次数。</span><br><span class="line"> *****时间复杂度：O(n^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">	ElementType temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = A[i];</span><br><span class="line">		low = <span class="number">0</span>; high = i-<span class="number">1</span>;  <span class="comment">// 设置折半查找的范围</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">		&#123;</span><br><span class="line">			mid = (low+high)/<span class="number">2</span>;  <span class="comment">// 取中间点</span></span><br><span class="line">			<span class="keyword">if</span>(A[mid] &gt; temp)</span><br><span class="line">				high = mid-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				low = mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(j=i-<span class="number">1</span>; j&gt;=high+<span class="number">1</span>; --j) <span class="comment">// 统一后移</span></span><br><span class="line">			A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">		A[high+<span class="number">1</span>] = temp;    <span class="comment">// 插入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;希尔排序&gt;&gt;</span><br><span class="line"> *    希尔排序通过比较相距一定间隔的元素，即形如L[i,i+d,i+2d,...i+kd]的序列</span><br><span class="line"> *然后缩小间距，再对各分组序列进行排序。直到只比较相邻元素的最后一趟排序为</span><br><span class="line"> *止，即最后的间距为1。希尔排序有时也叫做*缩小增量排序*</span><br><span class="line"> *****时间复杂度：依赖于增量序列的选择，但最坏情况才为O(N^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, dk;   <span class="comment">// dk是增量</span></span><br><span class="line">    ElementType temp;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(dk=n/<span class="number">2</span>; dk&gt;<span class="number">0</span>; dk/=<span class="number">2</span>)  <span class="comment">// 增量变化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=dk; i&lt;n; ++i)  <span class="comment">// 每个分组序列进行直接插入排序</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp = A[i];</span><br><span class="line">			<span class="keyword">for</span>(j=i-dk; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; j-=dk)</span><br><span class="line">				A[j+dk] = A[j];  <span class="comment">// 后移</span></span><br><span class="line">			A[j+dk] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;冒泡排序&gt;&gt;</span><br><span class="line"> *    冒泡排序的基本思想是从后往前（或从前往后）两两比较相邻元素的值，若为</span><br><span class="line"> *逆序，则交换它们，直到序列比较完。我们称它为一趟冒泡。每一趟冒泡都会将一</span><br><span class="line"> *个元素放置到其最终位置上。</span><br><span class="line"> *****时间复杂度：最好情况O(n)，最坏情况O(n^2)，平均情况O(n^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="keyword">false</span>;   <span class="comment">// 表示本次冒泡是否发生交换的标志</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j) <span class="comment">// 从后往前</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j-<span class="number">1</span>] &gt; A[j]) </span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 交换</span></span><br><span class="line">				A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>]^A[j];</span><br><span class="line">				A[j] = A[j-<span class="number">1</span>]^A[j];</span><br><span class="line">				A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>]^A[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="keyword">false</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;快速排序&gt;&gt;</span><br><span class="line"> *    快速排序是对冒泡排序的一种改进。其基本思想是基于分治法：在待排序表L[n]</span><br><span class="line"> *中任取一个元素pivot作为基准，通过一趟排序将序列划分为两部分L[1...K-1]和</span><br><span class="line"> *L[k+1...n]，是的L[1...k-1]中的所有元素都小于pivot，而L[k+1...n]中所有元素</span><br><span class="line"> *都大于或等于pivot。则pivot放在了其最终位置L(k)上。然后，分别递归地对两个子</span><br><span class="line"> *序列重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终</span><br><span class="line"> *位置上。</span><br><span class="line"> *****时间复杂度：快排的运行时间与划分是否对称有关，最坏情况O(n^2),最好情况</span><br><span class="line"> *O(nlogn),平均情况为O(nlogn)</span><br><span class="line"> *****空间复杂度：由于需要递归工作栈，最坏情况为O(n)，平均情况为O(logn)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 划分操作有很多版本，这里就总以当前表中第一个元素作为枢纽/基准</span></span><br><span class="line">	ElementType pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot)</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];  <span class="comment">// 将比枢纽值小的元素移到左端</span></span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];  <span class="comment">// 将比枢纽值大的元素移到右端</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A[low] = pivot;  <span class="comment">// 枢纽元素放到最终位置</span></span><br><span class="line">	<span class="keyword">return</span> low;      <span class="comment">// 返回枢纽元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)  <span class="comment">// 递归跳出的条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pivotPos = Partition(A, low, high); <span class="comment">// 划分操作，返回基准元素的最终位置</span></span><br><span class="line">		QuickSort(A, low, pivotPos-<span class="number">1</span>);  <span class="comment">// 递归</span></span><br><span class="line">		QuickSort(A, pivotPos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;简单选择排序&gt;&gt;</span><br><span class="line"> *    选择排序的算法思想很简单，假设序列为L[n]，第i趟排序即从L[i...n]中选择</span><br><span class="line"> *关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置。经过n-1</span><br><span class="line"> *趟排序就可以使得序列有序了。</span><br><span class="line"> *****时间复杂度：始终是O(n^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectedSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; ++i)  <span class="comment">// 一共进行n-1趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> minPos = i;  <span class="comment">// 记录最小元素的位置</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[minPos])</span><br><span class="line">				minPos = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(minPos != i)  <span class="comment">// 与第i个位置交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[i]^A[minPos];</span><br><span class="line">			A[minPos] = A[i]^A[minPos];</span><br><span class="line">			A[i] = A[i]^A[minPos];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;堆排序&gt;&gt;</span><br><span class="line"> *    堆排序是一种树形选择排序方法，在排序过程中，将L[n]看成是一棵完全二叉</span><br><span class="line"> *树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当</span><br><span class="line"> *前无序区中选择关键字最大（或最小）的元素。堆排序的思路是：首先将序列L[n]</span><br><span class="line"> *的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大</span><br><span class="line"> *值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大根堆的性</span><br><span class="line"> *质，堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。</span><br><span class="line"> *如此重复，直到堆中仅剩下一个元素为止。</span><br><span class="line"> *****时间复杂度：O(nlogn)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElementType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType temp = A[i];  <span class="comment">// 暂存A[i]</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])</span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大</span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])</span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[largest];</span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElementType A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, n);       <span class="comment">// 初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// n-1趟的交换和建堆过程 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输出最大的堆顶元素（和堆底元素交换）</span></span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[i] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		<span class="comment">// 调整，把剩余的n-1个元素整理成堆</span></span><br><span class="line">		AdjustDown(A, <span class="number">0</span>, i);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;2-路归并排序&gt;&gt;</span><br><span class="line"> *    顾名思义，2-路归并就是将2个有序表组合成一个新的有序表。假定待排序表</span><br><span class="line"> *有n个元素，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并...不</span><br><span class="line"> *停重复，直到合成一个长度为n的有序序列为止。Merge()函数是将前后相邻的两个</span><br><span class="line"> *有序表归并为一个有序表，设A[low...mid]和A[mid+1...high]存放在同一顺序表的</span><br><span class="line"> *相邻位置上，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个元素</span><br><span class="line"> *进行比较，将较小者放入A中。</span><br><span class="line"> *****时间复杂度：每一趟归并为O(n),共log2n趟，所以时间为O(nlog2n)</span><br><span class="line"> *****空间复杂度：O(n)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line">ElementType *B = <span class="keyword">new</span> ElementType[<span class="number">13</span>];  <span class="comment">// 和数组A一样大</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span>(k=low; k&lt;=high; ++k)</span><br><span class="line">		B[k] = A[k];             <span class="comment">// 将A中所有元素复制到B</span></span><br><span class="line">	<span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i; i&lt;=mid&amp;&amp;j&lt;=high; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(B[i] &lt;= B[j])      <span class="comment">// 比较B的左右两段序列中的元素</span></span><br><span class="line">			A[k] = B[i++];    <span class="comment">// 将较小值复制到A中</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A[k] = B[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)  A[k++] = B[i++];   <span class="comment">// 若第一个表未检测完，复制</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high) A[k++] = B[j++];   <span class="comment">// 若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">		MergeSort(A, low, mid);       <span class="comment">// 对左侧子序列进行递归排序</span></span><br><span class="line">		MergeSort(A, mid+<span class="number">1</span>, high);    <span class="comment">// 对右侧子序列进行递归排序</span></span><br><span class="line">		Merge(A, low, mid, high);     <span class="comment">// 归并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 输出函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 主函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType Arr[<span class="number">13</span>] = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">	<span class="comment">//InsertSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//BinaryInsertSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//ShellSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//BubbleSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//QuickSort(Arr, 0, 12);</span></span><br><span class="line">	<span class="comment">//SelectedSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//HeapSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//MergeSort(Arr, 0, 12);</span></span><br><span class="line">	print(Arr, <span class="number">13</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序算法相信对大家来说都不陌生，或许很多人已经把它们记得滚瓜烂熟，随时可以写出来。是的，这些都是最基本的算法。很惭愧我没有达到那种熟练程度，甚至都快忘了。最近把各种内部排序算法复习了一下，包括插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序。（另：堆排序原理说起来比较长，请看我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/02/dui-pai-xu-de-suan-fa-shi-xian/">堆排序的算法实现</a>）]]>
    
    </summary>
    
      <category term="内部排序" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆排序的算法实现]]></title>
    <link href="http://yoursite.com/2014/04/02/heap-sort-implementation/"/>
    <id>http://yoursite.com/2014/04/02/heap-sort-implementation/</id>
    <published>2014-04-02T01:41:35.000Z</published>
    <updated>2015-05-09T16:28:59.939Z</updated>
    <content type="html"><![CDATA[<p>由于堆排序算法说起来比较长，所以在这里单独讲一下。堆排序是一种树形选择排序方法，它的特点是：在排序过程中，将L[n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 </p>
<h3 id="堆的定义">堆的定义</h3><p><strong>堆的定义</strong>如下：n个关键字序列L[n]成为堆，当且仅当该序列满足：①L(i) &lt;= L(2i)且L(i) &lt;= L(2i+1)  或者  ②L(i) &gt;= L(2i)且L(i) &gt;= L(2i+1)   其中i属于[1, n/2]。<a id="more"></a></p>
<p>满足第①种情况的堆称为<strong>小根堆</strong>（小顶堆），满足第②种情况的堆称为<strong>大根堆</strong>（大顶堆）。在大根堆中，最大元素存放在根结点中，且对任一非根结点，它的值小于或等于其双亲结点值。小根堆则恰恰相反，小根堆的根结点存放的是最小元素。例如{16, 14, 10, 8, 7, 9, 3, 2}表示的大根堆： </p>
<p><img src="http://img.blog.csdn.net/20140501182414140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="构造初始堆">构造初始堆</h3><p>堆排序的关键就是构造初始堆。n个结点的完全二叉树中，最后一个结点是第n/2（向下取整）个结点的孩子。所以构造初始堆的流程是：对第n/2（向下取整）个结点为根的子树进行筛选（以大根堆为例，若根结点的关键字小于左右子女中关键字的较大者，则交换），使该子树成为堆。之后向前依次对从n/2-1到1的各结点为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不是，将左右子结点中较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。 </p>
<p><strong>由于在数组中下标从0开始，所以在堆中i的左子结点为2<em>i+1，右子结点为2</em>i+2。</strong>下面是将某个结点i向下调整建堆的算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElementType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType temp = A[i];  <span class="comment">// 暂存A[i]</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])</span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大</span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])</span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[largest];</span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建堆，从n/2（向下取整）到1依次对各结点向下调整，当然由于数组下标从0开始，所以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElementType A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆排序">堆排序</h3><p>构造初始堆成功以后，堆排序的思路就很简单了：首先将存放在L[n]中的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大根堆的性质，堆被破坏。这时将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩下一个元素为止。算法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, n);       <span class="comment">// 初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// n-1趟的交换和建堆过程 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输出最大的堆顶元素（和堆底元素交换）</span></span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[i] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		<span class="comment">// 调整，把剩余的n-1个元素整理成堆</span></span><br><span class="line">		AdjustDown(A, <span class="number">0</span>, i);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能">性能</h3><ul>
<li><p><strong>时间复杂度</strong>：向下调整的时间与树高有关，为O(h)。可以证明在元素个数为n的序列上建堆，其时间复杂度为O(n)。之后还有n-1次向下调整操作，每次调整的时间为O(h)，故在最好，最坏和平均情况下，堆排序的时间复杂度为O(nlogn)。</p>
</li>
<li><p><strong>空间复杂度</strong>：仅使用了常数个辅助单元，空间复杂度为O(1)。</p>
</li>
<li><p><strong>稳定性</strong>：不稳定。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于堆排序算法说起来比较长，所以在这里单独讲一下。堆排序是一种树形选择排序方法，它的特点是：在排序过程中，将L[n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 </p>
<h3 id="堆的定义">堆的定义</h3><p><strong>堆的定义</strong>如下：n个关键字序列L[n]成为堆，当且仅当该序列满足：①L(i) &lt;= L(2i)且L(i) &lt;= L(2i+1)  或者  ②L(i) &gt;= L(2i)且L(i) &gt;= L(2i+1)   其中i属于[1, n/2]。]]>
    
    </summary>
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树遍历序列的求解]]></title>
    <link href="http://yoursite.com/2014/04/01/binary-tree-sequence/"/>
    <id>http://yoursite.com/2014/04/01/binary-tree-sequence/</id>
    <published>2014-04-01T15:45:35.000Z</published>
    <updated>2015-05-09T16:23:32.636Z</updated>
    <content type="html"><![CDATA[<h2 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h2><p><img src="http://img.blog.csdn.net/20140320230233703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><a id="more"></a></p>
<p>上面为一个二叉树，可知它的遍历序列分别为：</p>
<ul>
<li>先序遍历：ABDECFG</li>
<li>中序遍历：DBEAFCG</li>
<li>后序遍历：DEBFGCA</li>
</ul>
<p><strong>我们需要知道的是</strong>，由二叉树的<strong>先序序列</strong> 和 <strong>中序序列</strong>可以唯一地确定一棵二叉树；由二叉树的<strong>后序序列</strong> 和 <strong>中序序列</strong>也可以唯一地确定一棵二叉树；但是如果只知道先序序列和后序序列，则无法唯一确定一棵二叉树。</p>
<h2 id="已知二叉树的先序序列和中序序列，求后序序列。">已知二叉树的先序序列和中序序列，求后序序列。</h2><p>因为由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树，所以进而可以唯一地确定它的后序遍历。在先序遍历序列中，第一个结点一定是二叉树的根结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列就是左子树的中序序列，后一个子序列就是右子树的中序序列。根据这两个子序列的长度，可以在先序序列中找到对应的左子树先序序列和右子树先序序列。而左子树先序序列的第一个结点是左子树的根结点，右子树先序序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p>
<p><strong>C++代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">	&gt; File Name: Test.cpp</span><br><span class="line">	&gt; Author: SongLee</span><br><span class="line">	&gt; E-mail: lisong.shine@qq.com </span><br><span class="line">	&gt; Created Time: 2014年03月20日 星期四 17时11分31秒</span><br><span class="line">	&gt; Personal Blog: http://songlee24.github.com/</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right;</span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* PostOrderFromOrderings(<span class="keyword">char</span>* inorder, <span class="keyword">char</span>* preorder, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    node-&gt;elem = *preorder;</span><br><span class="line">    <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; rootIndex &lt; length; rootIndex++)  <span class="comment">// 求左子树的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[rootIndex] == *preorder)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = PostOrderFromOrderings(inorder, preorder + <span class="number">1</span>, rootIndex);</span><br><span class="line">    node-&gt;right = PostOrderFromOrderings(inorder + rootIndex + <span class="number">1</span>, preorder + rootIndex + <span class="number">1</span>, length - (rootIndex + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;elem &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 求后序序列，所以最后输出根结点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pre = <span class="string">"ABDECFG"</span>;</span><br><span class="line">    <span class="keyword">char</span>* in = <span class="string">"DBEAFCG"</span>;</span><br><span class="line">    PostOrderFromOrderings(in, pre, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="已知二叉树的后序序列和中序序列，求先序序列。">已知二叉树的后序序列和中序序列，求先序序列。</h2><p>同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树，所以进而可以唯一地确定先序遍历序列。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分。 </p>
<p><strong>C++代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">	&gt; File Name: Test1.cpp</span><br><span class="line">	&gt; Author: SongLee</span><br><span class="line">	&gt; E-mail: lisong.shine@qq.com </span><br><span class="line">	&gt; Created Time: 2014年03月20日 星期四 21时56分57秒</span><br><span class="line">	&gt; Personal Blog: http://songlee24.github.com/</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right;</span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* PreOrderFromOrderings(<span class="keyword">char</span>* inorder, <span class="keyword">char</span>* postorder, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    node-&gt;elem = postorder[length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; rootIndex &lt; length; rootIndex++)   <span class="comment">// 求左子树的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[rootIndex] == postorder[length-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;elem &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 求先序序列，所以先输出根结点</span></span><br><span class="line">    node-&gt;left = PreOrderFromOrderings(inorder, postorder, rootIndex);</span><br><span class="line">    node-&gt;right = PreOrderFromOrderings(inorder + rootIndex + <span class="number">1</span>, postorder + rootIndex, length - (rootIndex + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* post = <span class="string">"DEBFGCA"</span>;</span><br><span class="line">    <span class="keyword">char</span>* in = <span class="string">"DBEAFCG"</span>;</span><br><span class="line">    PreOrderFromOrderings(in, post, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h2><p><img src="http://img.blog.csdn.net/20140320230233703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">]]>
    
    </summary>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <link href="http://yoursite.com/2014/03/12/observer-pattern/"/>
    <id>http://yoursite.com/2014/03/12/observer-pattern/</id>
    <published>2014-03-12T10:25:10.000Z</published>
    <updated>2015-05-09T16:17:01.989Z</updated>
    <content type="html"><![CDATA[<p>观察者模式（Observer）：定义了对象之间的一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>实现观察者模式的方法有多种，但是以包含Subject与Observer接口的类设计的做法最常见，下面看看观察者模式的类图： <a id="more"></a></p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/QQ622A56FE20140312104632_zpsf43cb29b.png" alt=""></p>
<p>主题（Subject）是真正拥有数据的人，观察者则是主题的依赖者，在主题数据变化时接收通知并更新。这样比起让许多对象控制同一份数据来，可以得到更干净的OO设计。 </p>
<p>主题与观察者之间是松耦合的，它们可以交互，但不知道彼此的细节。比如对于观察者，主题只知道观察者实现了某个接口，主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现Observer接口的对象列表；同样的，我们也可以在任何时候删除某些观察者。因为松耦合的关系，改变主题或观察者其中一方，并不会影响另一方。<strong>松耦合的设计能让我们建立有弹性的OO系统以应对变化，因为对象之间的互相依赖降到了最低。</strong></p>
<p>下面就以经典的气象监测问题为例，说说观察者模式的应用： </p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/111_zpsdf5328e6.png" alt=""></p>
<p>此气象站系统只包括三个部分：气象站、WeatherData对象、布告板。</p>
<p>工作的流程：WeatherData对象从气象站获取最新的测量数据（温度、湿度、气压），并及时更新到三个布告板（显示装置）上。 </p>
<p>假设从气象站获取数据的方法已经实现好了，那么我们只需要考虑如何将新的数据更新到三个布告板上，而且要尽量实现系统可拓展，让其他开发人员可以定制布告板，用户可以任意的添加或删除布告板，那么我们如何建立这个系统呢？</p>
<p>当然是使用观察者模式，这里的WeatherData类正是观察者模式中的“一”，即主题；而布告板就是“多”，即观察者；这样就建立起了一对多的依赖关系。WeatherData对象是真正拥有数据的一方，包括温度、湿度、气压，当这些值改变时，必须通知所有的布告板，好让它们各自做出处理。在这里，布告板作为Observer为了获取数据，必须先向WeatherData对象注册，一旦WeatherData知道有某个布告板的存在，就会适时地调用布告板的某个公共的接口（例如. update）来告诉布告板观测值是多少。由于update()方法是所有布告板公共的接口，所以需要在布告板的基类（Java中说接口）中定义。下面是设计图：</p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/112_zps9079588e.png" alt=""></p>
<ul>
<li>WeatherData实现主题（Subject）接口</li>
<li>布告板实现观察者（Observer）接口，这样主题在需要通知观察者时，就有了一个共同的接口</li>
<li>同时还为布告板建立一个共同的接口DisplayElement，用于实现display()方法</li>
<li>每个布告板中应该声明一个Subject接口类对象</li>
</ul>
<h2 id="C++实现：">C++实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subject接口类</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Subject   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observer接口类</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> Observer  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类 用于display</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeatherData实现Subject接口</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Subject.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WeatherData : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WeatherData(<span class="keyword">void</span>);</span><br><span class="line">    ~WeatherData(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="comment">// 以下方法用于从气象台获取数据，这里不予考虑</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeatherData.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::registerObserver( Observer* o )</span><br><span class="line">&#123;</span><br><span class="line">    observers.push_back(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::removeObserver( Observer* o )</span><br><span class="line">&#123;</span><br><span class="line">    observers.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::notifyObserver()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Observer*&gt;::iterator iterator=observers.begin(); observers.end()!=iterator; ++iterator)</span><br><span class="line">    &#123;</span><br><span class="line">        Observer* observer = *iterator;</span><br><span class="line">        observer-&gt;update(temperature, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::measurementsChanged()</span><br><span class="line">&#123;</span><br><span class="line">    notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::setMeasurements( <span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">    <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pressure = pressure;</span><br><span class="line">    measurementsChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getTemperature()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> temperature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getHumidity()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> humidity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getPressure()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pressure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “目前状况”布告板 实现观察者接口</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CurrentConditionsDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CurrentConditionsDisplay(Subject* weatherData);</span><br><span class="line">    ~CurrentConditionsDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CurrentConditionsDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CurrentConditionsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay::CurrentConditionsDisplay( Subject* weatherData )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay::~CurrentConditionsDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentConditionsDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;temperature = temp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentConditionsDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf( ios::showpoint );</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Current conditions: "</span>  &lt;&lt; temperature;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" F degrees and "</span> &lt;&lt; humidity;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"% humidity"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据统计布告板</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StatisticsDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Subject* weatherData;</span><br><span class="line">    <span class="keyword">float</span> maxTemp;</span><br><span class="line">    <span class="keyword">float</span> minTemp;</span><br><span class="line">    <span class="keyword">float</span> tempSum;</span><br><span class="line">    <span class="keyword">int</span> numReadings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StatisticsDisplay(Subject* weatherData);</span><br><span class="line">    ~StatisticsDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// StatisticsDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "StatisticsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">StatisticsDisplay::StatisticsDisplay(Subject* weatherData)</span><br><span class="line">&#123;</span><br><span class="line">    maxTemp = <span class="number">0.0</span>;      <span class="comment">// 记录最高温</span></span><br><span class="line">    minTemp = <span class="number">200.0F</span>;   <span class="comment">// 记录最低温</span></span><br><span class="line">    tempSum = <span class="number">0.0</span>;      <span class="comment">// 温度和，用于计算平均温度</span></span><br><span class="line">    numReadings = <span class="number">0</span>;    <span class="comment">// 次数，用于计算平均温度</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatisticsDisplay::~StatisticsDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StatisticsDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    tempSum += temp;</span><br><span class="line">    numReadings++;</span><br><span class="line">    <span class="keyword">if</span>( temp &gt; maxTemp ) &#123;</span><br><span class="line">        maxTemp = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( temp &lt; minTemp ) &#123;</span><br><span class="line">        minTemp = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StatisticsDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf( ios::showpoint );</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Avg/Max/Min temperature = "</span> &lt;&lt; ( tempSum / numReadings );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"/"</span> &lt;&lt; maxTemp &lt;&lt; <span class="string">"/"</span> &lt;&lt; minTemp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 天气预报布告板</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ForecastDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> currentPressure;</span><br><span class="line">    <span class="keyword">float</span> lastPressure;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ForecastDisplay(Subject* weatherData);</span><br><span class="line">    ~ForecastDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForecastDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ForecastDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ForecastDisplay::ForecastDisplay(Subject* weatherData)</span><br><span class="line">&#123;</span><br><span class="line">    currentPressure = <span class="number">29.92F</span>;  <span class="comment">// 假设现在的</span></span><br><span class="line">    lastPressure = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForecastDisplay::~ForecastDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ForecastDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    lastPressure = currentPressure;</span><br><span class="line">    currentPressure = pressure;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ForecastDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Forecast: "</span>;</span><br><span class="line">    <span class="keyword">if</span>( currentPressure &gt; lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Improving weather on the way!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( currentPressure == lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"More of the same"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( currentPressure &lt; lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Watch out for cooler, rainy weather"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序入口WeatherStation.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CurrentConditionsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ForecastDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "StatisticsDisplay.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WeatherData* weatherData = <span class="keyword">new</span> WeatherData;</span><br><span class="line"></span><br><span class="line">    CurrentConditionsDisplay* cu = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">    StatisticsDisplay* st = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">    ForecastDisplay* fo = <span class="keyword">new</span> ForecastDisplay(weatherData);</span><br><span class="line">    <span class="comment">// 更新数据，这里手动模拟</span></span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span> );</span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span> );</span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span> );</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：">运行结果：</h3><p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/20140312_zpsacbd0ec3.jpeg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>观察者模式（Observer）：定义了对象之间的一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>实现观察者模式的方法有多种，但是以包含Subject与Observer接口的类设计的做法最常见，下面看看观察者模式的类图：]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Basic-设计模式" scheme="http://yoursite.com/categories/Basic-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单例模式]]></title>
    <link href="http://yoursite.com/2014/03/11/singleton-pattern/"/>
    <id>http://yoursite.com/2014/03/11/singleton-pattern/</id>
    <published>2014-03-11T14:36:58.000Z</published>
    <updated>2015-05-09T16:05:52.922Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2><p>单件模式（SingletonPattern）：确保一个类只有一个实例，并提供一个全局访问点。和全局变量一样方便，又没有全局变量的缺点，即不需要从一开始就创建对象，而是在需要时才创建它。</p>
<p><strong><em>那么要如何保证一个类只能被实例化一次呢？</em></strong>一般情况下，如果存在一个类，我们都是可以多次地实例化它的。那么如果这样呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>咦？构造函数私有？含有私有的构造器的类应该是不能被其他类实例化的，因为只有MyClass内部的代码才能调用这个私有的构造函数。虽然只有MyClass类的实例才能调用MyClass构造器，但在这之前，必须有一个MyClass实例。然而这个类又不能被实例化，这样就产生了矛盾！</p>
<p>看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示MyClass有一个静态方法，我们可以这样调用这个方法：MyClass.getInstance(); 因为getInstance()是一个静态方法，换句话说，是一个“类”方法。引用一个静态方法，你需要使用类名，而不是对象名。</p>
<p>那么把上面两段代码合在一起，是否就可以使MyClass只产生一个实例了呢？</p>
<p><strong>看下面的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">       <span class="comment">//利用一个静态变量来记录MyClass类的唯一实例</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> MyClass uniqueInstance;</span><br><span class="line">       <span class="comment">//私有构造函数，只有自MyClass类内才可以调用</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       <span class="comment">//用getInstance静态方法实例化对象，并返回</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                      uniqueInstance = <span class="keyword">new</span> MyClass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当然，单件类也是一个正常的类，具有其他的变量和方法</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个经典的单件模式的实现！之所以实例唯一，是因为单件类没有公开的构造器，其他类不能自行将其实例化得到一个实例，而必须通过它的静态方法getInstance()去创建一个实例。</p>
<p><img src="http://img.blog.csdn.net/20140312224101968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="C++代码实现：">C++代码实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Singleton&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="keyword">static</span> Singleton* uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* getInstance();</span><br><span class="line">    <span class="comment">// other methods...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"Singleton.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Singleton::Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~Singleton()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == NULL)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">    uniqueInstance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == NULL)&#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"Singleton.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::uniqueInstance = NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::getInstance();</span><br><span class="line">    Singleton* singleton2 = Singleton::getInstance();</span><br><span class="line">    <span class="keyword">if</span>(singleton1 == singleton2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got same singleton!!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Oh,no!got a different singleton!!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2><p>单件模式（SingletonPattern）：确保一个类只有一个实例，并提供一个全局访问点。和全局变量一样方便，又没有全局变量的缺点，即不需要从一开始就创建对象，而是在需要时才创建它。</p>
<p><strong><em>那么要如何保证一个类只能被实例化一次呢？</em></strong>一般情况下，如果存在一个类，我们都是可以多次地实例化它的。那么如果这样呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Basic-设计模式" scheme="http://yoursite.com/categories/Basic-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>