<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SongLee's Blog]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-10T00:10:59.702Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python3基础（五） 函数]]></title>
    <link href="http://yoursite.com/2014/08/09/python-basic-05/"/>
    <id>http://yoursite.com/2014/08/09/python-basic-05/</id>
    <published>2014-08-09T15:58:33.000Z</published>
    <updated>2015-05-10T00:10:59.702Z</updated>
    <content type="html"><![CDATA[<p><strong>函数（function）</strong>是组织好的、可重复使用的、具有一定功能的代码段。函数能提高应用的模块性和代码的重复利用率，Python中已经提供了很多内建函数，比如print()，同时Python还允许用户自定义函数。</p>
<h3 id="定义">定义</h3><p>定义函数使用关键字<code>def</code>，后接函数名和放在圆括号( )中的可选参数列表，函数内容以<strong>冒号</strong>起始并且<strong>缩进</strong>。一般格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">	<span class="string">"""文档字符串"""</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>注意：参数列表可选，文档字符串可选，return语句可选。</p>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="string">"""Print a Fibonacci series"""</span></span><br><span class="line">	a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> b &lt; n:</span><br><span class="line">		print(b, end=<span class="string">' '</span>)</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fib(<span class="number">2000</span>)  <span class="comment"># call</span></span><br><span class="line">f = fib    <span class="comment"># assignment</span></span><br><span class="line">f(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></p>
<p>函数名的值是一种用户自定义的函数类型。函数名的值可以被赋予另一个名字，使其也能作为函数使用。</p>
<p><br></p>
<h3 id="函数变量作用域">函数变量作用域</h3><p>在函数内部定义的变量拥有一个局部作用域，在函数外定义的拥有全局作用域。注意：在函数内部可以引用全局变量，但无法对其赋值（除非用<code>global</code>进行声明）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>         <span class="comment"># 全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'func1() print a ='</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">21</span>    <span class="comment"># 局部变量a</span></span><br><span class="line">	print(<span class="string">'func2() print a ='</span>, a) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> a</span><br><span class="line">	a = <span class="number">10</span>    <span class="comment"># 修改全局变量a</span></span><br><span class="line">	print(<span class="string">'func3() print a ='</span>, a)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br><span class="line">func3()</span><br><span class="line">print(<span class="string">'the global a ='</span>, a)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="函数调用">函数调用</h3><p><strong>1、普通调用</strong></p>
<p>与其他语言中函数调用一样，Python中在调用函数时，需要给定和形参相同个数的实参并按顺序一一对应。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">	print(<span class="string">'Name:'</span>,name,<span class="string">'Age:'</span>,age,<span class="string">'Gender:'</span>,gender,end=<span class="string">' '</span>)</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fun(<span class="string">'Jack'</span>, <span class="number">20</span>, <span class="string">'man'</span>) <span class="comment"># call</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、使用关键字参数调用函数</strong></p>
<p>函数也可以通过<code>keyword=value</code> 形式的关键字参数来调用，因为我们明确指出了对应关系，所以参数的顺序也就无关紧要了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">	print(<span class="string">'Name:'</span>,name,<span class="string">'Age:'</span>,age,<span class="string">'Gender:'</span>,gender,end=<span class="string">' '</span>)</span><br><span class="line">	print()</span><br><span class="line"></span><br><span class="line">fun(gender=<span class="string">'man'</span>, name=<span class="string">'Jack'</span>, age=<span class="number">20</span>) <span class="comment"># using keyword arguments</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3、调用具有默认实参的函数</strong></p>
<p>Python中的函数也可以给一个或多个参数指定默认值，这样在调用时可以选择性地省略该参数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">fun</span><span class="params">(a, b, c=5)</span>:</span></span><br><span class="line">	print(a+b+c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2)</span></span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1,2,3)</span></span></span><br></pre></td></tr></table></figure></p>
<p><em>注意</em>：通常情况下默认值只被计算一次，但如果默认值是一个<strong>可变对象</strong>时会有所不同, 如列表, 字典, 或大多类的对象时。例如，下面的函数在随后的调用中会累积参数值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">fun</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">	L.append(a)</span><br><span class="line">	print(L)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(1)</span>  # 输出[1]</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(2)</span>  # 输出[1, 2]</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(3)</span>  # 输出[1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4、调用可变参数函数</strong></p>
<p>通过在形参前加一个星号（*）或两个星号（**）来指定函数可以接收任意数量的实参。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(*args)</span>:</span></span><br><span class="line">	print(type(args))</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt;</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(**args)</span>:</span></span><br><span class="line">	print(type(args))</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">fun(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>,e=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br><span class="line"><span class="comment"># &#123;'d': 4, 'e': 5, 'b': 2, 'c': 3, 'a': 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>从两个示例的输出可以看出：当参数形如<code>*args</code>时，传递给函数的任意个实参会按位置被包装进一个元组（tuple）；当参数形如<code>**args</code>时，传递给函数的任意个<code>key=value</code>实参会被包装进一个字典（dict）。</p>
<p><strong>5、通过解包参数调用函数</strong></p>
<p>上一点说到传递任意数量的实参时会将它们打包进一个元组或字典，当然有打包也就有<strong>解包（unpacking）</strong>。通过 单星号和双星号对List、Tuple和Dictionary进行解包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span>:</span></span><br><span class="line">	print(a+b+c)</span><br><span class="line"></span><br><span class="line">fun()   <span class="comment"># 正常调用</span></span><br><span class="line">list1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">dict1 = &#123;<span class="string">'a'</span>:<span class="number">40</span>, <span class="string">'b'</span>:<span class="number">50</span>, <span class="string">'c'</span>:<span class="number">60</span>&#125;</span><br><span class="line">fun(*list1)   <span class="comment"># 解包列表</span></span><br><span class="line">fun(**dict1)  <span class="comment"># 解包字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 66</span></span><br><span class="line"><span class="comment"># 150</span></span><br></pre></td></tr></table></figure></p>
<p>注：*用于解包Sequence，**用于解包字典。解包字典会得到一系列的<code>key=value</code>，故本质上就是使用<strong>关键字参数</strong>调用函数。</p>
<p><br></p>
<h3 id="lambda表达式">lambda表达式</h3><p>lambda关键词能创建小型匿名函数。lambda函数能接收任何数量的参数但只能返回一个表达式的值，它的一般形式如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">lambda</span> [<span class="atom">arg1</span> [,<span class="atom">arg2</span>,.....<span class="atom">argn</span>]] : <span class="atom">expression</span></span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以在任何需要函数对象的地方使用，它们在语法上被限制为单一的表达式：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda x, y: x+<span class="literal">y</span></span><br><span class="line"><span class="keyword">print</span>(<span class="literal">f</span>(10, 20))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_fun</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> x: x+n</span><br><span class="line"></span><br><span class="line">f = make_fun(<span class="number">15</span>)</span><br><span class="line">print(f(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="文档字符串">文档字符串</h3><p>函式体的第一个语句可以是三引号括起来的字符串， 这个字符串就是函数的<strong>文档字符串</strong>，或称为docstring 。我们可以使用<code>print(function.__doc__)</code>输出文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""Some information of this function.</span><br><span class="line">	This is documentation string."""</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">print(fun.__doc__)</span><br></pre></td></tr></table></figure></p>
<p>文档字符串主要用于描述一些关于函数的信息，让用户交互地浏览和输出。建议养成在代码中添加文档字符串的好习惯。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>函数（function）</strong>是组织好的、可重复使用的、具有一定功能的代码段。函数能提高应用的模块性和代码的重复利用率，Python中已经提供了很多内建函数，比如print()，同时Python还允许用户自定义函数。</p>
<h3 id="定义">定义</h3><p>定义函数使用关键字<code>def</code>，后接函数名和放在圆括号( )中的可选参数列表，函数内容以<strong>冒号</strong>起始并且<strong>缩进</strong>。一般格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">	<span class="string">"""文档字符串"""</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（四） 条件与循环控制]]></title>
    <link href="http://yoursite.com/2014/08/09/python-basic-04/"/>
    <id>http://yoursite.com/2014/08/09/python-basic-04/</id>
    <published>2014-08-09T00:28:43.000Z</published>
    <updated>2015-05-09T23:59:59.883Z</updated>
    <content type="html"><![CDATA[<p>Python的流程控制语句包括：if条件语句、while循环语句、for循环语句、range函数以及break、continue、pass控制语句。这些语句在Python中的语义和在其他语言中是一样的，所以这里就只说它们的写法。</p>
<h3 id="if语句">if语句</h3><p>if语句是最常用的条件控制语句，Python中的一般形式为：<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件一:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">elif</span> 条件二:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure></p>
<p>Python中用<code>elif</code>代替了<code>else if</code>，所以if语句的关键字为：if - elif - else。</p>
<p><strong>注意</strong>：<br>1、每个条件后面要使用<strong>冒号（:）</strong>，表示接下来是满足条件后要执行的语句块。<br>2、使用<strong>缩进</strong>来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>3、在Python中没有switch - case语句。</p>
<p>示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="function"><span class="title">int</span><span class="params">(input(<span class="string">"Please enter an integer: "</span>)</span></span>)</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Negative.'</span>)</span></span></span><br><span class="line">elif x == <span class="number">0</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Zero.'</span>)</span></span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Positive.'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="while语句">while语句</h3><p>Python中while语句的一般形式：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure></p>
<p>同样需要注意冒号和缩进。另外，在Python中<strong>没有do..while循环</strong>。</p>
<p>示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">10</span>:  <span class="comment"># 循环输出斐波纳契数列</span></span><br><span class="line">	print(b)</span><br><span class="line">	<span class="operator">a</span>, b = b, <span class="operator">a</span>+b</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="for语句">for语句</h3><p>Python中的for语句与C语言中的for语句有点不同：<strong>C语言中的for语句允许用户自定义迭代步骤和终止条件；而Python的for语句可以遍历任何序列（sequence），按照元素在序列中的出现顺序依次迭代。</strong>一般形式为：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">variable</span> <span class="keyword">in</span> <span class="keyword">sequence</span>:</span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statements</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'cat'</span>,<span class="string">'love'</span>,<span class="string">'apple'</span>,<span class="string">'python'</span>,<span class="string">'friends'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">words</span>:</span><br><span class="line">	print(<span class="keyword">item</span>, <span class="built_in">len</span>(<span class="keyword">item</span>))</span><br></pre></td></tr></table></figure></p>
<p>如果你需要在循环体内修改你正迭代的序列，你最好是制作一个副本，这时<a href="http://blog.csdn.net/lisonglisonglisong/article/details/38440761" target="_blank" rel="external">切片标记</a>就非常有用了：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">words</span> = [<span class="string">'cat'</span>,<span class="string">'love'</span>,<span class="string">'apple'</span>,<span class="string">'python'</span>,<span class="string">'friends'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">words</span>[:]:    <span class="comment"># 制作整个列表的切片副本</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(<span class="keyword">item</span>) &gt;= <span class="number">6</span>:</span><br><span class="line">		<span class="keyword">words</span>.insert(<span class="number">0</span>, <span class="keyword">item</span>)</span><br><span class="line">print(<span class="keyword">words</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们注意到循环语句中还可以使用<code>else子句</code>，下面第五点有讲到。</p>
<p><br></p>
<h3 id="range函数">range函数</h3><p>如果你要遍历一个数字序列，那么内置的<strong>range()</strong>函数就可以派上用场了。函数range()常用于for循环中，用于产生一个算术数列：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">10</span>))   <span class="comment"># 默认从0开始</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">1</span>, <span class="number">11</span>))  <span class="comment"># 从1到11，前闭后开</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>))  <span class="comment"># 5表示步长，每隔5取一个数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">2</span>, <span class="number">11</span>)</span></span>:</span><br><span class="line">	<span class="function"><span class="title">print</span><span class="params">(i)</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="break、continue、pass及else子句">break、continue、pass及else子句</h3><p><strong>break</strong></p>
<p>break语句与C语言中的一样，跳出最近的for或while循环。</p>
<p><strong>continue</strong></p>
<p>continue语句同样是从 C 语言借用的, 它终止当前迭代而进行循环的<br>下一次迭代。</p>
<p><strong>pass</strong></p>
<p>pass语句什么都不做，它只在语法上需要一条语句但程序不需要任何操作时使用。pass语句是为了保持程序结构的完整性。</p>
<p><strong>else子句</strong></p>
<p>在循环语句中还可以使用<code>else子句</code>，else子句在<strong>序列遍历结束</strong>（for语句）或<strong>循环条件为假</strong>（while语句）时执行，但循环被break终止时不执行：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 循环结束执行<span class="keyword">else</span>子句</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(2, 11):</span><br><span class="line">	<span class="keyword">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span>('<span class="keyword">for</span> statement is over.')</span><br><span class="line"></span><br><span class="line"># 被<span class="keyword">break</span>终止时不会执行<span class="keyword">else</span>子句</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(5):</span><br><span class="line">	<span class="keyword">if</span>(i == 4):</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span>('<span class="keyword">for</span> statement is over')  # 不会输出</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python的流程控制语句包括：if条件语句、while循环语句、for循环语句、range函数以及break、continue、pass控制语句。这些语句在Python中的语义和在其他语言中是一样的，所以这里就只说它们的写法。</p>
<h3 id="if语句">if语句</h3><p>if语句是最常用的条件控制语句，Python中的一般形式为：]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（三） 运算符]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-03/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-03/</id>
    <published>2014-08-08T12:13:46.000Z</published>
    <updated>2015-05-10T00:48:27.720Z</updated>
    <content type="html"><![CDATA[<p>Python中的运算符大部分与C语言的类似，但也有很多不同的地方。这里就大概地罗列一下Python 3中的运算符。</p>
<h3 id="算术运算符">算术运算符</h3><a id="more"></a>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>x + y</td>
<td>加</td>
<td>10+20=30</td>
</tr>
<tr>
<td>x - y</td>
<td>减</td>
<td>10-5=5</td>
</tr>
<tr>
<td>x * y</td>
<td>乘</td>
<td>3*6=18</td>
</tr>
<tr>
<td>x / y</td>
<td>除-返回浮点数</td>
<td>2/4 = 0.5</td>
</tr>
<tr>
<td>x // y</td>
<td>取整除 - 返回商的整数部分</td>
<td>2//4 = 0</td>
</tr>
<tr>
<td>x % y</td>
<td>取余</td>
<td>15 % 4 = 3</td>
</tr>
<tr>
<td>-x</td>
<td>异号</td>
<td>-(-5) = 5</td>
</tr>
<tr>
<td>+x</td>
<td>不变号</td>
<td>+5 = 5</td>
</tr>
<tr>
<td>abs(x)</td>
<td>取绝对值</td>
<td>abs(-0.4) = 0.4</td>
</tr>
<tr>
<td>int(x)</td>
<td>x转换为整数</td>
<td>int(5.9) = 5</td>
</tr>
<tr>
<td>float(x)</td>
<td>x转换为浮点数</td>
<td>float(5) = 5.0</td>
</tr>
<tr>
<td>complex(re, im)</td>
<td>返回复数 - re为实数部分 im为虚数部分</td>
<td>complex(4,3) = 4+3j</td>
</tr>
<tr>
<td>c.conjugate()</td>
<td>返回c的共轭复数</td>
<td>c=4+3j; c.conjugate() = 4-3j</td>
</tr>
<tr>
<td>divmod(x, y)</td>
<td>返回一个数值对(x//y, x%y)</td>
<td>divmod(8, 3) = (2, 2)</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>x的y次幂</td>
<td>pow(2, 5) = 32</td>
</tr>
<tr>
<td>x**y</td>
<td>x的y次幂</td>
<td>2 ** 5 = 32</td>
</tr>
</tbody>
</table>
<p>Note：</p>
<ol>
<li>双斜杠 // 除法总是向下取整。 </li>
<li>从符点数到整数的转换可能会舍入也可能截断，建议使用math.floor()和math.ceil()明确定义的转换。</li>
<li>Python定义<code>pow(0, 0)</code>和<code>0 ** 0</code>等于1。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中的运算符大部分与C语言的类似，但也有很多不同的地方。这里就大概地罗列一下Python 3中的运算符。</p>
<h3 id="算术运算符">算术运算符</h3>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（二） 基本数据类型]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-02/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-02/</id>
    <published>2014-08-08T08:00:56.000Z</published>
    <updated>2015-05-09T23:57:04.233Z</updated>
    <content type="html"><![CDATA[<p>Python中的变量<strong>不需要声明</strong>。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在Python中，变量就是变量，它没有类型，<strong>我们所说的“类型”是变量所指的内存中对象的类型</strong>。Python 3中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<p>本文主要先介绍这几种数据类型的定义和它们之间的联系与区别。<br><a id="more"></a></p>
<h3 id="Numbers">Numbers</h3><p>Python 3支持<strong>int、float、bool、complex</strong>（复数）。数值类型的赋值和计算都是很直观的，就像大多数语言一样。内置的<code>type()</code>函数可以用来查询变量所指的对象类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="keyword">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; &lt;<span class="title">class</span> '<span class="title">float</span>'&gt; &lt;<span class="title">class</span> '<span class="title">bool</span>'&gt; &lt;<span class="title">class</span> '<span class="title">complex</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>数值运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余 </span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p><strong>要点</strong>：<br>1、Python可以同时为多个变量赋值，如<code>a, b = 1, 2</code>。<br>2、一个变量可以通过赋值指向不同类型的对象。<br>3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。<br>4、在混合计算时，Pyhton会把整型转换成为浮点数。</p>
<h3 id="Strings">Strings</h3><p>Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来，同时使用反斜杠(\)转义特殊字符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = <span class="string">'Yes,he doesn\'t'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(s, type(s), len(s))</span><br><span class="line">Yes,he doesn<span class="string">'t &lt;class '</span>st<span class="string">r'&gt; 14</span></span><br></pre></td></tr></table></figure></p>
<p>如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)</span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)</span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure></p>
<p>另外，反斜杠可以作为续行符，表示下一行是上一行的延续。还可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>跨越多行。</p>
<p>字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(<span class="string">'str'</span>+<span class="string">'ing'</span>, <span class="string">'my'</span>*<span class="number">3</span>)</span><br><span class="line">string mymymy</span><br></pre></td></tr></table></figure></p>
<p>Python中的字符串有<strong>两种索引方式</strong>，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。注意，没有单独的字符类型，一个字符就是长度为1的字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></p>
<p>还可以对字符串进行<strong>切片</strong>，获取一段子串。用冒号分隔两个索引，形式为<code>变量[头下标:尾下标]</code>。截取的范围是前闭后开的，并且两个索引都可以省略：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word = <span class="string">'ilovepython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">1</span><span class="symbol">:</span><span class="number">5</span>]</span><br><span class="line"><span class="string">'love'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="symbol">:</span>]</span><br><span class="line"><span class="string">'ilovepython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[<span class="number">5</span><span class="symbol">:</span>]</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; word[-<span class="number">10</span><span class="symbol">:-</span><span class="number">6</span>]</span><br><span class="line"><span class="string">'love'</span></span><br></pre></td></tr></table></figure></p>
<p>与C字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如<code>word[0] = &#39;m&#39;</code>会导致错误。</p>
<p><strong>要点</strong>：<br>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。<br>2、字符串可以用+运算符连接在一起，用*运算符重复。<br>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。<br>4、Python中的字符串不能改变。</p>
<h3 id="List">List</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。列表是写在<strong>方括号</strong>之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = [<span class="string">'him'</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="string">'her'</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line">[<span class="string">'him'</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="string">'her'</span>]</span><br></pre></td></tr></table></figure></p>
<p>和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。详细的在这里就不赘述了。</p>
<p>列表还支持串联操作，使用+操作符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a + [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p>与Python字符串不一样的是，列表中的元素是可以改变的：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>] = []   <span class="comment"># 删除</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。</p>
<p><strong>要点</strong>：<br>1、List写在方括号之间，元素用逗号隔开。<br>2、和字符串一样，list可以被索引和切片。<br>3、List可以使用+操作符进行拼接。<br>4、List中的元素是可以改变的。</p>
<h3 id="Tuple">Tuple</h3><p>元组（tuple）与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。元组写在<strong>小括号</strong>里，元素之间用逗号隔开。元组中的元素类型也可以不相同：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = <span class="list">(<span class="number">1991</span>, <span class="number">2014</span>, <span class="quoted">'physics</span>', <span class="quoted">'math</span>')</span></span><br><span class="line">&gt;&gt;&gt; print<span class="list">(<span class="keyword">a</span>, type<span class="list">(<span class="keyword">a</span>)</span>, len<span class="list">(<span class="keyword">a</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="number">1991</span>, <span class="number">2014</span>, <span class="quoted">'physics</span>', <span class="quoted">'math</span>')</span> &lt;class <span class="quoted">'tuple</span><span class="quoted">'&gt;</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。其实，可以把字符串看作一种特殊的元组。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(tup[<span class="number">0</span>], tup[<span class="number">1</span><span class="symbol">:</span><span class="number">5</span>])</span><br><span class="line"><span class="number">1</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup[<span class="number">0</span>] = <span class="number">11</span>  <span class="comment"># 修改元组元素的操作是非法的</span></span><br></pre></td></tr></table></figure></p>
<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">tup1 =</span> () <span class="comment"># 空元组</span></span><br><span class="line"><span class="variable">tup2 =</span> (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></p>
<p>另外，元组也支持用+操作符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tup1, tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(tup1+tup2)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<p>string、list和tuple都属于<strong>sequence（序列）</strong>。</p>
<p>要点：<br>1、与字符串一样，元组的元素不能修改。<br>2、元组也可以被索引和切片，方法一样。<br>3、注意构造包含0或1个元素的元组的特殊语法规则。<br>4、元组也可以使用+操作符进行拼接。</p>
<h3 id="Sets">Sets</h3><p>集合（set）是一个<strong>无序不重复</strong>元素的集。基本功能是进行成员关系测试和消除重复元素。可以使用<strong>大括号</strong> 或者 <strong>set()函数</strong>创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; student = &#123;<span class="string">'Tom'</span>, <span class="string">'Jim'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print(student)   <span class="comment"># 重复的元素被自动去掉</span></span><br><span class="line">&#123;<span class="string">'Jim'</span>, <span class="string">'Jack'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Rose'</span> in student  <span class="comment"># membership testing（成员测试）</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="comment"># set可以进行集合运算</span></span><br><span class="line">... </span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a</span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a - b     <span class="comment"># a和b的差集</span></span><br><span class="line">&#123;<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a | b     <span class="comment"># a和b的并集</span></span><br><span class="line">&#123;<span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a &amp; b     <span class="comment"># a和b的交集</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a ^ b     <span class="comment"># a和b中不同时存在的元素</span></span><br><span class="line">&#123;<span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>要点：<br>1、set集合中的元素不重复，重复了它会自动去掉。<br>2、set集合可以用大括号或者set()函数创建，但空集合必须使用set()函数创建。<br>3、set集合可以用来进行成员测试、消除重复元素。 </p>
<h3 id="Dictionary">Dictionary</h3><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。字典是一种映射类型（mapping type），它是一个无序的<strong>键 : 值</strong>对集合。关键字必须使用不可变类型，也就是说list和包含可变类型的tuple不能做关键字。在同一个字典中，关键字还必须互不相同。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dic = &#123;&#125;  <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel = &#123;<span class="string">'Jack'</span><span class="symbol">:</span><span class="number">1557</span>, <span class="string">'Tom'</span><span class="symbol">:</span><span class="number">1320</span>, <span class="string">'Rose'</span><span class="symbol">:</span><span class="number">1886</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel</span><br><span class="line">&#123;<span class="string">'Tom'</span><span class="symbol">:</span> <span class="number">1320</span>, <span class="string">'Jack'</span><span class="symbol">:</span> <span class="number">1557</span>, <span class="string">'Rose'</span><span class="symbol">:</span> <span class="number">1886</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel[<span class="string">'Jack'</span>]   <span class="comment"># 主要的操作：通过key查询</span></span><br><span class="line"><span class="number">1557</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; del tel[<span class="string">'Rose'</span>]  <span class="comment"># 删除一个键值对</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel[<span class="string">'Mary'</span>] = <span class="number">4127</span>  <span class="comment"># 添加一个键值对</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; tel</span><br><span class="line">&#123;<span class="string">'Tom'</span><span class="symbol">:</span> <span class="number">1320</span>, <span class="string">'Jack'</span><span class="symbol">:</span> <span class="number">1557</span>, <span class="string">'Mary'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; list(tel.keys())  <span class="comment"># 返回所有key组成的list</span></span><br><span class="line">[<span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Mary'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sorted(tel.keys()) <span class="comment"># 按key排序</span></span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Tom'</span> in tel       <span class="comment"># 成员测试</span></span><br><span class="line"><span class="constant">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="string">'Mary'</span> not in tel  <span class="comment"># 成员测试</span></span><br><span class="line"><span class="constant">False</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数 <strong>dict()</strong> 直接从键值对sequence中构建字典，当然也可以进行推导，如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dict([(<span class="string">'sape'</span>, <span class="number">4139</span>), (<span class="string">'guido'</span>, <span class="number">4127</span>), (<span class="string">'jack'</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">'jack'</span><span class="symbol">:</span> <span class="number">4098</span>, <span class="string">'sape'</span><span class="symbol">:</span> <span class="number">4139</span>, <span class="string">'guido'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; &#123;<span class="symbol">x:</span> x**<span class="number">2</span> for x in (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span><span class="symbol">:</span> <span class="number">4</span>, <span class="number">4</span><span class="symbol">:</span> <span class="number">16</span>, <span class="number">6</span><span class="symbol">:</span> <span class="number">36</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dict(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">'jack'</span><span class="symbol">:</span> <span class="number">4098</span>, <span class="string">'sape'</span><span class="symbol">:</span> <span class="number">4139</span>, <span class="string">'guido'</span><span class="symbol">:</span> <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p>要点：<br>1、字典是一种映射类型，它的元素是键值对。<br>2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用{ }。 </p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中的变量<strong>不需要声明</strong>。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在Python中，变量就是变量，它没有类型，<strong>我们所说的“类型”是变量所指的内存中对象的类型</strong>。Python 3中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<p>本文主要先介绍这几种数据类型的定义和它们之间的联系与区别。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3基础（一） Hello World]]></title>
    <link href="http://yoursite.com/2014/08/08/python-basic-01/"/>
    <id>http://yoursite.com/2014/08/08/python-basic-01/</id>
    <published>2014-08-08T02:35:14.000Z</published>
    <updated>2015-05-09T23:55:19.007Z</updated>
    <content type="html"><![CDATA[<p>对于新手一般会遇到一个问题：<strong>学习Python 2还是Python 3呢？</strong>  对于我个人而言，我是个完全的新手，没有历史包袱，所以我直接学习Python 3。我相信在未来几年，Python 3会逐步取代Python 2成为主流。</p>
<p>Python是一门解释型、面向对象、动态数据类型的高级程序设计语言，更多的介绍看<a href="https://docs.python.org/3.4/tutorial/appetite.html" target="_blank" rel="external">官方文档</a>。Python让程序更加的紧凑、可读性更强，用 Python 写的程序通常比同样的C、C++或Java程序要短得多，这是因为以下几个原因：<br><a id="more"></a></p>
<ul>
<li>高级数据结构使你能够在单条的语句中表达复杂的操作。</li>
<li>代码块的组织依赖于缩进而不是开始/结束符，例如{ }。</li>
<li>参数或变量不需要声明。</li>
</ul>
<p>OK！下面开始让我们进入Python的世界吧！</p>
<h3 id="第一个HelloWorld程序">第一个HelloWorld程序</h3><p><strong>1、交互模式</strong></p>
<p>交互模式即命令行模式，在Linux终端输入<code>$python</code>即可进入Python交互模式，主提示符&gt;&gt;&gt;提示你输入命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="constant">Python</span> <span class="number">3.3</span>.<span class="number">2</span> (default, <span class="constant">Jun</span> <span class="number">30</span> <span class="number">2014</span>, <span class="number">17</span><span class="symbol">:</span><span class="number">20</span><span class="symbol">:</span><span class="number">03</span>) </span><br><span class="line">[<span class="constant">GCC</span> <span class="number">4.8</span>.<span class="number">3</span> <span class="number">20140624</span> (<span class="constant">Red</span> <span class="constant">Hat</span> <span class="number">4.8</span>.<span class="number">3</span>-<span class="number">1</span>)] on linux</span><br><span class="line"><span class="constant">Type</span> <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>输入多行结构时就需要从属提示符了，例如下面这个if语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>flag=<span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">if</span> flag:</span><br><span class="line"><span class="prompt">... </span>    print(<span class="string">"Hello World!"</span>)</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line">Hello World!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>注：在Python 3.x中，print是一个函数，所以必须使用括号输出。</p>
<p><strong>2、脚本文件</strong></p>
<p>我们也可以将代码写到一个.py文件中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后用python命令执行该脚本文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python hello<span class="class">.py</span> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p><strong>3、可执行脚本</strong></p>
<p>在类Unix系统中，Python脚本可以像Shell脚本那样直接执行，通过在脚本文件开头添加一行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br></pre></td></tr></table></figure></p>
<p>然后通过chmod命令修改权限为可执行：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>chmod +x hello.py</span><br></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello<span class="class">.py</span> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="基础语法">基础语法</h3><p><strong>1、编码</strong></p>
<p>默认情况下，Python 3源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。当然你也可以为源码文件指定不同的编码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、标识符</strong></p>
<p>在Python 3中，非-ASCII 标识符也是允许的了。但最好还是只使用英文、数字、下划线作为标识符，并且不能以数字开头。（区分大小写）</p>
<p><strong>3、python保留字</strong></p>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个<a href="https://docs.python.org/2/library/keyword.html" target="_blank" rel="external">keyword</a> module，可以输出当前版本的所有关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>4、注释</strong></p>
<p>Python中单行注释以#开头，多行注释用三个单引号（’’’）或者三个双引号（”””）将注释括起来。</p>
<p><strong>5、行与缩进</strong></p>
<p>python最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<p><br><br><br><br><br></p>
<h3 id="附：">附：</h3><p>在现在的Unix/Linux系统中都会内置Python解释器，在我的Fedora20系统中就同时装了python2和python3。在终端输入<code>$python</code>会使用python 2.x的解释器，输入<code>$python3</code>会使用python 3.x的解释器。现在我想修改一下<strong>软链接</strong>，让<code>$python</code>命令默认使用python 3.x解释器，<code>$python2</code>命令使用python 2.x解释器。怎么做？</p>
<p><strong>软链接：</strong> 一种特殊的文件，该文件的内容是指向另一个文件的位置或路径。它不占用磁盘空间，类似于Windows操作系统中的快捷方式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">硬链接：<span class="tag">ln</span> <span class="attr_selector">[参数]</span> 源文件 目标文件</span><br><span class="line">软链接：<span class="tag">ln</span> <span class="tag">-s</span> <span class="attr_selector">[源文件或目录]</span> <span class="attr_selector">[目标文件或目录]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>ln命令</strong>的功能是为某一个文件在另外一个位置建立一个同步的链接（软链接或者硬链接），现在我要修改python的软链接：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/python2.7 /</span>usr<span class="regexp">/bin/</span>python2  <span class="comment">// 创建python2软链接</span></span><br><span class="line">$ sudo rm <span class="regexp">/usr/</span>bin<span class="regexp">/python  /</span>/ 删除原来的python软链接</span><br><span class="line">$ sudo ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/python3.3 /</span>usr<span class="regexp">/bin/</span>python  <span class="comment">// 创建新的python软链接</span></span><br></pre></td></tr></table></figure></p>
<p>修改了软链接以后的一个伴随的问题是：有些用python写的命令不能执行了，因为python2和python3的语法不兼容。比如<strong>yum命令</strong>，它是python写的，从yum文件开头的<code>#!/usr/bin/python</code>可以看出来。因为python软链接被修改为指向python 3.x解释器，所以执行yum命令时会报语法错误。</p>
<p>我们可以通过修改yum文件来修复这个问题，既然之前我们已经创建了python2软链接指向python 2.x解释器，所以我们修改yum文件开头为<code>#!/usr/bin/python2</code>就可以了，这样在执行yum命令时就会使用python 2.x解释器而不是python 3.x的解释器了。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于新手一般会遇到一个问题：<strong>学习Python 2还是Python 3呢？</strong>  对于我个人而言，我是个完全的新手，没有历史包袱，所以我直接学习Python 3。我相信在未来几年，Python 3会逐步取代Python 2成为主流。</p>
<p>Python是一门解释型、面向对象、动态数据类型的高级程序设计语言，更多的介绍看<a href="https://docs.python.org/3.4/tutorial/appetite.html">官方文档</a>。Python让程序更加的紧凑、可读性更强，用 Python 写的程序通常比同样的C、C++或Java程序要短得多，这是因为以下几个原因：<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Lang.-Python" scheme="http://yoursite.com/categories/Lang-Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1987年国际C语言混乱代码大赛获奖的一行代码]]></title>
    <link href="http://yoursite.com/2014/08/06/Obfuscated-C-Code-Contest/"/>
    <id>http://yoursite.com/2014/08/06/Obfuscated-C-Code-Contest/</id>
    <published>2014-08-06T09:15:43.000Z</published>
    <updated>2015-05-09T18:31:06.371Z</updated>
    <content type="html"><![CDATA[<p>最近<a href="http://coolshell.cn" target="_blank" rel="external">CoolShell博主</a>做了一个很有意思的在线puzzle，这些谜题很有趣同时也有一定的难度。由于水平有限，我并没有通关，我觉得这些题还是很值得一做的，从中可以学到很多东西。</p>
<p>例如其中的第二题：<br><img src="http://img.blog.csdn.net/20140806160507493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><a id="more"></a></p>
<p>题目中给出了一个键盘和一行看不懂的字符串。这个键盘的<strong>键盘布局</strong>和现在通用的键盘（<strong>QWERTY键盘</strong>）不一样，它叫做<strong><a href="http://baike.baidu.com/view/1410112.htm" target="_blank" rel="external">Dvorak键盘</a></strong>。这里就不多作解释了，详细的可以去Google。根据提示：<strong>我们需要通过两种键盘的布局映射，将给出的字符串转换成QWERTY键盘下的输出。</strong>当然，你可以自己一对一写出来，不过<a href="http://wbic16.xedoloh.com/dvorak.html" target="_blank" rel="external">在线转换工具</a>更方便。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">macb</span><span class="params">()</span> ? <span class="title">lpcbyu</span><span class="params">(&amp;gbcq/<span class="variable">_</span>\<span class="number">021</span><span class="comment">%ocq\012\0_=w(gbcq)/_dak._=&#125;_ugb_[0q60)s+</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>转换之后得到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() &#123; <span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是1987年<strong>国际C语言混乱代码大赛（The International Obfuscated C Code Contest, IOCCC）</strong>一等奖的获奖代码，由贝尔实验室的David Korn提交。当然平时我们不会写出这么复杂难懂的代码，但是分析这样的代码却可以扩展我们的知识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* unix被编译器内定为一个宏 </span><br><span class="line">	 * 相当于#define unix 1     */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"unix=%d\n"</span>, unix); <span class="comment">/* =1 */</span>	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印字符串"un"，因为"fun"是个字符数组</span><br><span class="line">	 * "fun"+1相当于字符指针右移，指向"un" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="string">"fun"</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* "have"是个字符数组，"have"[1]即字符a</span><br><span class="line">	 * 输出97，即第二个字符'a'的ASCII值。*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="string">"have"</span>[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在C语言中，x[1] = 1[x] */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span>)[<span class="string">"have"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 97 - 96 = 0x61 - 0x60 = 1 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span>)[<span class="string">"have"</span>] - <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所以 "fun"+((1)["have"]-0x60) 相当于"fun"+1，输出"un" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"fun"</span> + ((<span class="number">1</span>)[<span class="string">"have"</span>] - <span class="number">0x60</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将其中的1用unix代替 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 以上为后半部分 = "un" */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面两个都输出"bcde", 因为指针都是从'b'开始 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"abcde"</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;<span class="string">"abcde"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &amp;"abcde"[1] == &amp;(1)["abcde"]  输出一样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;(<span class="number">1</span>)[<span class="string">"abcde"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1用unix代替 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, &amp;unix[<span class="string">"abcde"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面输出"%six" 并换行 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;<span class="string">"?%six\n"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注意：</span><br><span class="line">	   \012 = 0x0a = \n, </span><br><span class="line">	   第一个字符 \021 被跳过</span><br><span class="line">	   \0 是空字符  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 同样输出"%six" 并换行 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;<span class="string">"\021%six\012\0"</span>[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相当于这样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;unix[<span class="string">"\021%six\012\0"</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 把字符串"%six\n"当作格式，输出"ABix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>], <span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相当于这样 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%six\n"</span>, <span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所以下面的可以输出"unix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%six\n"</span>, (unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 至此，问题解决！！！输出"unix" */</span></span><br><span class="line">	<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span>-<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要用到了x[a]和指针运算的一些知识，相信上面的步骤和注释已经很清楚了，最终结果就是输出<code>unix</code>。<br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近<a href="http://coolshell.cn">CoolShell博主</a>做了一个很有意思的在线puzzle，这些谜题很有趣同时也有一定的难度。由于水平有限，我并没有通关，我觉得这些题还是很值得一做的，从中可以学到很多东西。</p>
<p>例如其中的第二题：<br><img src="http://img.blog.csdn.net/20140806160507493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">]]>
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之普通函数指针与成员函数指针]]></title>
    <link href="http://yoursite.com/2014/08/01/cpp-function-pointer/"/>
    <id>http://yoursite.com/2014/08/01/cpp-function-pointer/</id>
    <published>2014-08-01T11:43:55.000Z</published>
    <updated>2015-05-09T18:27:27.205Z</updated>
    <content type="html"><![CDATA[<p><strong>函数指针（function pointer）</strong>是通过指向函数的指针间接调用函数。相信很多人对指向一般函数的函数指针使用的比较多，而对指向类成员函数的函数指针则比较陌生。我最近也被问到了这方面的问题，心中却也没有清晰的答案。故决定去查阅资料，并按照自己的思路写下这篇学习总结。<br><br></p>
<h3 id="普通函数指针">普通函数指针</h3><p>通常我们所说的<strong>函数指针</strong>指的是指向一般普通函数的指针。和其他指针一样，函数指针指向某种特定类型，<strong>所有被同一指针运用的函数必须具有相同的形参类型和返回类型。</strong><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">// 声明函数指针</span></span><br></pre></td></tr></table></figure></p>
<p>这里，pf指向的函数类型是<code>int (int, int)</code>，即函数的参数是两个int型，返回值也是int型。注：<strong>*pf两端的括号必不可少，如果不写这对括号，则pf是一个返回值为int指针的函数。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// typedef一个类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1+s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pFun pf1 = add;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf1)(<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 调用add函数</span></span><br><span class="line">	pf1 = mns;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf1)(<span class="number">8</span>,<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// 调用mns函数</span></span><br><span class="line">	<span class="built_in">string</span> (*pf2)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;) = merge;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*pf2)(<span class="string">"hello "</span>, <span class="string">"world"</span>) &lt;&lt; endl;  <span class="comment">// 调用merge函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如示例代码，直接声明函数指针变量显得冗长而烦琐，所以我们可以使用<code>typedef</code>定义自己的函数指针类型。另外，函数指针还可以作为函数的形参类型，实参则可以直接使用函数名。<br><br></p>
<h3 id="成员函数指针">成员函数指针</h3><p><strong>成员函数指针（member function pointer）</strong>是指可以指向类的非静态成员函数的指针。类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。<strong>与普通函数指针不同的是，</strong><br>成员函数指针不仅要指定目标函数的形参列表和返回类型，还必须指出成员函数所属的类。因此，我们必须在*之前添加<code>classname::</code>以表示当前定义的指针指向classname的成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (A::*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">// 声明一个成员函数指针</span></span><br></pre></td></tr></table></figure></p>
<p>同理，这里<code>A::*pf</code>两端的括号也是必不可少的，如果没有这对括号，则pf是一个返回A类数据成员（int型）指针的函数。注意：和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = &amp;A::add;   <span class="comment">// 正确：必须显式地使用取址运算符（&amp;）</span></span><br><span class="line">pf = A::add;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<p><strong>当我们初始化一个成员函数指针时，其指向了类的某个成员函数，但并没有指定该成员所属的对象——直到使用成员函数指针时，才提供成员所属的对象。</strong>下面是一个成员函数指针的使用示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(A::*pClassFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 成员函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" + "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m+n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m+n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" - "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m-n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" * "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m*n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m*n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dev</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" / "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m/n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(pClassFun fun, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">// 类内部接口</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*fun)(m, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(A obj, pClassFun fun, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">// 类外部接口</span></span><br><span class="line">	<span class="keyword">return</span> (obj.*fun)(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"member function 'call':"</span> &lt;&lt; endl;</span><br><span class="line">	a.call(&amp;A::add, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::mns, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::mul, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	a.call(&amp;A::dev, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"external function 'call':"</span> &lt;&lt; endl;</span><br><span class="line">	call(a, &amp;A::add, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::mns, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::mul, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	call(a, &amp;A::dev, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如示例所示，我们一样可以使用<code>typedef</code>定义成员函数指针的类型别名。另外，<strong>我们需要留意函数指针的使用方法</strong>：对于普通函数指针，是这样使用<code>(*pf)(arguments)</code>，因为要调用函数，必须先解引用函数指针，而函数调用运算符()的优先级较高，所以<code>(*pf)</code>的括号必不可少；对于成员函数指针，唯一的不同是需要在某一对象上调用函数，所以只需要加上成员访问符即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(obj.*pf)(arguments)         <span class="comment">// obj 是对象</span></span><br><span class="line">(objptr-&gt;*pf)(arguments)     <span class="comment">// objptr是对象指针</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="函数表驱动">函数表驱动</h3><p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法就是将其存入一个<strong>函数表（function table）</strong>当中。当程序需要执行某个特定的函数时，就从表中查找对应的函数指针，用该指针来调用相应的程序代码，这个就是函数指针在<strong>表驱动法</strong>中的应用。</p>
<p><strong>表驱动法（Table-Driven Approach）</strong>就是用查表的方法获取信息。通常，在数据不多时可用逻辑判断语句（if…else或switch…case）来获取信息；但随着数据的增多，逻辑语句会越来越长，此时表驱动法的优势就体现出来了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(A::*pClassFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;    <span class="comment">// 构造函数，初始化表</span></span><br><span class="line">		table[<span class="string">"+"</span>] = &amp;A::add;</span><br><span class="line">		table[<span class="string">"-"</span>] = &amp;A::mns;</span><br><span class="line">		table[<span class="string">"*"</span>] = &amp;A::mul;</span><br><span class="line">		table[<span class="string">"/"</span>] = &amp;A::dev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" + "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m+n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m+n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" - "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m-n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" * "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m*n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m*n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dev</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" / "</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m/n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找表，调用相应函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*table[s])(m, n);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, pClassFun&gt; table;  <span class="comment">// 函数表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.call(<span class="string">"+"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"-"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"*"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	a.call(<span class="string">"/"</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个示例，示例中的“表”通过map来实现（当然也可以使用数组）。表驱动法使用时需要注意：一是如何查表，从表中读取正确的数据；二是表里存放什么，如数值或函数指针。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>函数指针（function pointer）</strong>是通过指向函数的指针间接调用函数。相信很多人对指向一般函数的函数指针使用的比较多，而对指向类成员函数的函数指针则比较陌生。我最近也被问到了这方面的问题，心中却也没有清晰的答案。故决定去查阅资料，并按照自己的思路写下这篇学习总结。<br><br></p>
<h3 id="普通函数指针">普通函数指针</h3><p>通常我们所说的<strong>函数指针</strong>指的是指向一般普通函数的指针。和其他指针一样，函数指针指向某种特定类型，<strong>所有被同一指针运用的函数必须具有相同的形参类型和返回类型。</strong>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之动态数组类的封装]]></title>
    <link href="http://yoursite.com/2014/07/28/cpp-dynamic-array/"/>
    <id>http://yoursite.com/2014/07/28/cpp-dynamic-array/</id>
    <published>2014-07-27T17:52:34.000Z</published>
    <updated>2015-05-09T18:24:03.618Z</updated>
    <content type="html"><![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/" target="_blank" rel="external">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3><a id="more"></a>
<p>当用new为一个动态数组申请一块内存时，数组中的元素是<strong>连续存储</strong>的，例如 vector和string。当向一个动态数组添加元素时，如果没有空间容纳新元素，不可能简单地将新元素添加到内存中的其他位置——因为元素必须连续存储。所以<strong>必须重新分配一块更大的内存空间，将原来的元素从旧位置移动到新空间中，然后添加新元素，释放旧的内存空间</strong>。如果我们每添加一个新元素，就执行一次这样的内存分配和释放操作，效率将会慢到不行。</p>
<p>为了避免上述的代价，必须减少内存重新分配的次数。所以我们采取的策略是：<strong>在不得不分配新的内存空间时，分配比新的空间需求更大的内存空间（通常为2倍）</strong>。这样，在相当一段时间内，添加元素时就不用重新申请内存空间。注意，只有当迫不得已时才可以分配新的内存空间。</p>
<h3 id="类的四大函数">类的四大函数</h3><p>一个C++类一般至少有四大函数，即构造函数、拷贝构造函数、拷贝赋值运算符、析构函数。如果类未自己定义上述函数，C++编译器将为其合成4个默认的版本。但是往往编译器合成的并不是我们所期望的，为此我们有必要自己定义它们。</p>
<p><strong>构造函数</strong></p>
<p>类的<strong>构造函数（constructor）</strong>用来初始化类对象的非static数据成员，无论何时只要类的对象被创建，就会执行构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();  <span class="comment">// 构造函数</span></span><br><span class="line">	Foo(<span class="built_in">string</span> &amp;s);  <span class="comment">// 接受一个参数的构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数的名字和类名相同，没有返回类型。类可以包含多个构造函数（重载），它们之间在参数数量或类型上需要有所区别。<strong>构造函数有一个初始化部分和一个函数体</strong>，成员的初始化是在函数体执行之前完成的。</p>
<p><strong>拷贝构造函数</strong></p>
<p>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数（copy constructor）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝构造函数定义了如何用一个对象<strong>初始化</strong>另一个同类型的对象。拷贝初始化通常使用拷贝构造函数来完成。<strong>拷贝初始化</strong>发生在下列情况中：</p>
<ul>
<li>使用等号（=）初始化一个变量</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素</li>
</ul>
<p><strong>拷贝赋值运算符</strong></p>
<p>类的<strong>拷贝赋值运算符（copy-assignment operator）</strong>是一个名为<code>operator=</code>的函数。类似于其他任何函数，它也有一个返回类型和一个参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>拷贝赋值运算符定义了如何将一个对象<strong>赋值</strong>给另一个同类型的对象。赋值运算符是一个成员函数也是一个二元运算符，其左侧运算对象就绑定到隐式的this指针，右侧运算对象作为显式参数传递。<strong>注意</strong>：为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>
<p><strong>析构函数</strong></p>
<p>类的<strong>析构函数（destructor）</strong>用来释放类对象使用的资源并销毁类对象的非static数据成员，无论何时只要一个对象被销毁，就会自动执行析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~Foo();  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>析构函数的名字由波浪号（~）加类名构成，也没有返回类型。由于析构函数不接受参数，因此它不能被重载。<strong>析构函数有一个函数体和一个析构部分</strong>，销毁一个对象时，首先执行析构函数体，然后按初始化顺序的逆序销毁成员。</p>
<h3 id="运算符的重载">运算符的重载</h3><p>重载的运算符是具有特殊名字的函数：<strong>它们的名字由关键字<code>operator</code>和其后要定义的运算符号共同组成</strong>。和其他函数一样，重载的运算符也包含返回类型、参数列表、函数体，比如拷贝赋值运算符。</p>
<p>当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。有些运算符必须作为成员，而另一些运算符作为普通函数比作为成员更好：</p>
<ul>
<li>赋值（=）、下标（[ ]）、调用（( )）和成员访问箭头（-&gt;）运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常应该是成员。</li>
<li>具有<strong>对称性</strong>的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
<p>当然，除了赋值运算符之外，我们还需要为动态数组定义<strong>下标运算符operator []</strong>。下标运算符必须是成员函数。为了让下标可以出现在赋值运算符的任意一端，下标运算符函数通常返回所访问元素的引用。</p>
<h3 id="动态数组类的封装">动态数组类的封装</h3><p>下面给出了动态数组DArray类的接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DArray</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> *m_Data;  <span class="comment">// 存放数组的动态内存指针</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;      <span class="comment">// 数组的元素个数</span></span><br><span class="line">	<span class="keyword">int</span> m_Max;       <span class="comment">// 预留给动态数组的内存大小</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;     <span class="comment">// 初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">()</span></span>;     <span class="comment">// 释放动态内存</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">InvalidateIndex</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 判断下标的合法性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DArray();        <span class="comment">// 默认构造函数</span></span><br><span class="line">	DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue = <span class="number">0</span>);  <span class="comment">// 构造函数，设置数组大小，默认值为dValue</span></span><br><span class="line">	DArray(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	DArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr);  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	~DArray();       <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;    <span class="comment">// 输出显式所有数组元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;   <span class="comment">// 获取数组的大小（元素个数）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetSize</span><span class="params">(<span class="keyword">int</span> nSize)</span></span>;  <span class="comment">// 重新设置数组的大小</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;  <span class="comment">// 获取指定位置元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetAt</span><span class="params">(<span class="keyword">int</span> nIndex,<span class="keyword">double</span> dValue)</span></span>; <span class="comment">// 重置指定元素的值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteAt</span><span class="params">(<span class="keyword">int</span> nIndex)</span></span>;     <span class="comment">// 删除指定位置地元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertAt</span><span class="params">(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span></span>;  <span class="comment">// 插入一个新的元素到数组中</span></span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span>;      <span class="comment">// 重载下标运算符[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是我的实现：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DArray::Init()</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = <span class="number">0</span>;   <span class="comment">// 默认情况下数组不包含元素</span></span><br><span class="line">	m_Max = <span class="number">1</span>;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DArray::Free()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DArray::InvalidateIndex(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&gt;=<span class="number">0</span> &amp;&amp; nIndex&lt;m_Size)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">DArray::DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">int</span> nSize, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize == <span class="number">0</span>)</span><br><span class="line">		Init();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Size = nSize;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i]=dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">DArray::DArray(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	m_Size = arr.m_Size;  <span class="comment">/*复制常规成员*/</span></span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	m_Data = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];   <span class="comment">/*复制指针指向的内容*/</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_Data, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">DArray&amp; DArray::<span class="keyword">operator</span>=(<span class="keyword">const</span> DArray&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;arr)  <span class="comment">/*自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	m_Size = arr.m_Size;</span><br><span class="line">	m_Max = arr.m_Max;</span><br><span class="line">	<span class="comment">/* 先将右侧对象拷贝到临时对象中，然后再销毁左侧对象*/</span> </span><br><span class="line">	<span class="keyword">double</span> *m_Temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">	<span class="built_in">memcpy</span>(m_Temp, arr.m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">	<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">	m_Data = m_Temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">DArray::~DArray()</span><br><span class="line">&#123;</span><br><span class="line">	Free();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> DArray::Print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: The empty array can't be Printed."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m_Size; ++i)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m_Data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组大小</span></span><br><span class="line"><span class="keyword">int</span> DArray::GetSize()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组大小</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetSize(<span class="keyword">int</span> nSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nSize &lt; m_Size)   <span class="comment">/*截断*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nSize; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m_Size&lt;=nSize &amp;&amp; nSize&lt;=m_Max)  <span class="comment">/*新增元素置0*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			m_Data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nSize &gt; m_Max)   <span class="comment">/*需要重新分配空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = nSize*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span> *temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size; i&lt;nSize; ++i)</span><br><span class="line">			temp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	m_Size = nSize; <span class="comment">/*设置数组大小*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素</span></span><br><span class="line"><span class="keyword">double</span> DArray::GetAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of GetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置指定位置元素的值</span></span><br><span class="line"><span class="keyword">void</span> DArray::SetAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of SetAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个新元素到数组末尾</span></span><br><span class="line"><span class="keyword">void</span> DArray::PushBack(<span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		m_Data[m_Size] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/*数组大小加1*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除一个元素</span></span><br><span class="line"><span class="keyword">void</span> DArray::DeleteAt(<span class="keyword">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(InvalidateIndex(nIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of DeleteAt is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=nIndex; i&lt;m_Size; ++i)</span><br><span class="line">			m_Data[i] = m_Data[i+<span class="number">1</span>];</span><br><span class="line">		m_Data[m_Size-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		--m_Size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个新元素到指定位置</span></span><br><span class="line"><span class="keyword">void</span> DArray::InsertAt(<span class="keyword">int</span> nIndex, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of InsertAt is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_Size &lt; m_Max)  <span class="comment">/* 未满，插入 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>               <span class="comment">/* 重新分配空间 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Max = m_Max*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span>* temp = <span class="keyword">new</span> <span class="keyword">double</span>[m_Max];</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, m_Data, m_Size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">		<span class="keyword">delete</span> [] m_Data;</span><br><span class="line">		m_Data = temp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m_Size-<span class="number">1</span>; i&gt;=nIndex; --i)</span><br><span class="line">			m_Data[i+<span class="number">1</span>] = m_Data[i];</span><br><span class="line">		m_Data[nIndex] = dValue;</span><br><span class="line">	&#125;</span><br><span class="line">	++m_Size;  <span class="comment">/* 数组大小加1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载下标运算符[]</span></span><br><span class="line"><span class="keyword">double</span> DArray::<span class="keyword">operator</span>[](<span class="keyword">int</span> nIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(nIndex&lt;<span class="number">0</span> || nIndex&gt;=m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index in [] is invalid!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_Data[nIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过简单的测试，暂时还没有发现Bug。可能测试并不全面，如果你发现了问题，希望你能在评论里告诉我，万分感谢！！！<br><br><br><br></p>
<h3 id="附：String类的实现">附：String类的实现</h3><p>C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能要求具备 std::string 的功能，但至少要求能正确管理资源。</p>
<p>如果你弄懂了上面DArray类的写法，那么实现String类应该就不难了。因为面试官一般只是想考查你能不能正确地写出构造函数、析构函数、拷贝构造函数、拷贝赋值运算符以及+、[ ]、&lt;&lt;、&gt;&gt;运算符重载等等。下面给出一个String类的接口，你可以自己试试手实现一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> String&#123;  </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp;,String&amp;); <span class="comment">//重载&lt;&lt;运算符  </span></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp;,String&amp;); <span class="comment">//重载&gt;&gt;运算符  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    String();   <span class="comment">// 默认构造函数</span></span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* str);       <span class="comment">// 带参构造函数  </span></span><br><span class="line">    String(<span class="keyword">const</span> String&amp; rhs);        <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs);   <span class="comment">// 拷贝赋值运算符  </span></span><br><span class="line">    String <span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span>;  <span class="comment">//operator+  </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp;);              <span class="comment">//operator!=   </span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span>);              <span class="comment">//operator[]  </span></span><br><span class="line">    <span class="function">size_t <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_str() <span class="keyword">const</span>;</span><br><span class="line">    ~String();    <span class="comment">// 析构函数 </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是String类的实现，注意一些得分点：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::String()</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	m_data[<span class="number">0</span>] = <span class="string">'\0'</span>;  <span class="comment">/*得分点：空字符串存放结束标志'\0'*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参的构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">	:m_data(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)  <span class="comment">/*得分点：自赋值*/</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">	<span class="keyword">delete</span> [] m_data; <span class="comment">/*得分点：释放左侧对象资源*/</span></span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator+</span></span><br><span class="line">String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	String newStr;</span><br><span class="line">	newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data)+<span class="built_in">strlen</span>(rhs.m_data)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(newStr.m_data, m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator==</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(m_data, rhs.m_data) == <span class="number">0</span>) <span class="comment">/*相等返回0*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator!=</span></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;<span class="built_in">strlen</span>(m_data))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_data[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: the index of [] is invalid."</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String大小</span></span><br><span class="line">size_t String::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取C风格字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* String::c_str() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str.m_data;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&gt;&gt;运算符</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">255</span>];</span><br><span class="line">	is &gt;&gt; temp;</span><br><span class="line">	str = temp;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>动态数组（Dynamic Array）</strong>是指动态分配的、可以根据需求动态增长占用内存的数组。为了实现一个动态数组类的封装，我们需要考虑几个问题：<strong><a href="http://songlee24.github.io/blog/2014/07/25/c-plus-plus-xue-xi-zhi-new-delete-malloc-free/">new/delete的使用</a>、内存分配策略、类的四大函数（构造函数、拷贝构造函数、拷贝赋值运算符、析构函数）、运算符的重载</strong>。涉及到的知识点很多，鉴于本人水平有限，在这里只做简单的介绍。</p>
<h3 id="内存分配策略">内存分配策略</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之new与delete、malloc与free]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-new-malloc/"/>
    <id>http://yoursite.com/2014/07/25/cpp-new-malloc/</id>
    <published>2014-07-25T14:06:45.000Z</published>
    <updated>2015-05-09T18:20:44.204Z</updated>
    <content type="html"><![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br><a id="more"></a><br>标准库定义了operator new函数的几个重载版本，没有使用<code>noexcept</code>说明的版本在内存分配失败时可能会抛出bad_alloc异常，而使用了的不会抛出异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t )</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t );	</span><br><span class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( size_t , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[]( size_t , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用new表达式时，实际执行了三步操作：</p>
<ul>
<li>new表达式调用上面的<strong>operator new</strong>（或者<strong>operator new[]</strong>）的标准库函数，函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</li>
<li>编译器运行相应的<strong>构造函数</strong>以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ul>
<p>对于operator new函数或者operator new[]函数来说，它的返回类型必须是void*，第一个形参的类型必须是size_t且该形参不能含有默认实参。当编译器调用operator new或者operator new[]函数时，会把存储指定对象或者指定对象的数组所需的字节数传给size_t形参。</p>
<p><strong>delete表达式</strong></p>
<p>标准库也定义了operator delete函数的几个重载版本，<code>noexcept</code>说明符表示在内存分配失败时返回空指针而不是抛出bad_alloc异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span>* , <span class="keyword">const</span> nothrow_t&amp; ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用delete表达式时，实际执行了两步操作：</p>
<ul>
<li>对指针所指的对象或者所指的数组中的元素执行对应的<strong>析构函数</strong>。</li>
<li>编译器调用<strong>operator delete</strong>（或者<strong>operator delete[]</strong>）的标准库函数释放内存空间。</li>
</ul>
<p>对于operator delete函数或者operator delete[]函数来说，它们的返回类型必须是void，第一个形参的类型必须是void*。执行一条delete表达式将调用相应的operator函数，并用指向待释放内存的指针来初始化void*形参。<br><br></p>
<h3 id="malloc和free">malloc和free</h3><p>malloc和free是C/C++中的<strong>标准库函数</strong>，也是用于申请动态内存和释放内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* <span class="built_in">malloc</span>( size_t size );</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">free</span><span class="params">( <span class="keyword">void</span>* ptr )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>malloc函数</strong>接受一个表示待分配字节数的size_t，返回指向分配空间的指针；如果分配失败，则返回空指针。<strong>free函数</strong>接受一个void<em>，它是malloc返回的指针的副本，free将相关内存返还给系统。<em>*注意</em></em>：malloc函数并不会调用构造函数来初始化内存，free函数也不会自动调用析构函数。<br><br></p>
<h3 id="new和malloc、delete和free的区别">new和malloc、delete和free的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;     <span class="comment">// 没有初始化列表， 所以没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();   <span class="comment">// 空初始化列表， 执行zero初始化,  所以初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);  <span class="comment">// 非空初始化列表， 执行值初始化， 所以初始化为3</span></span><br><span class="line"><span class="comment">// 注：对于没有构造函数的内置类型，new会不会初始化在于有没有初始列表（空列表“()”也算）</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];     <span class="comment">// 分配大小为sizeof(int)*100;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p5 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"><span class="keyword">double</span> *p6 = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p><strong>new和malloc的区别：</strong></p>
<ol>
<li><p>new是一个运算符，malloc()是一个库函数。</p>
</li>
<li><p>new会调用构造函数，而malloc()不会。</p>
</li>
<li><p>new返回指定类型的指针，而malloc()返回void*。</p>
</li>
<li><p>new会自动计算需要分配的空间，而malloc()需要手工计算字节数。</p>
</li>
<li><p>new可以被重载，而malloc()不能。<br><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> [] p2;</span><br><span class="line"><span class="built_in">free</span>(p3);</span><br><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>delete和free的区别：</strong></p>
<ol>
<li><p>delete是一个运算符，free()是一个库函数。</p>
</li>
<li><p>delete会调用析构函数，而free()不会。</p>
</li>
<li><p>delete可以被重载，而free()不能。</p>
</li>
</ol>
<p><br><br><br><br></p>
<h3 id="总结：">总结：</h3><p>malloc和free是C/C++中的标准库函数，new和delete是C++的运算符。对于非内置数据类型的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++的面试时，对于new/delete和malloc/free这两对的使用和区别经常被考查到，如果这种基础的问题都答不上来，估计很难过面试了。这篇文章仅仅是浅显的讲一下，仅供参考。</p>
<h3 id="new和delete">new和delete</h3><p>new和delete是C++的<strong>运算符</strong>，用于动态分配内存和释放内存。</p>
<p><strong>new表达式</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之命名空间]]></title>
    <link href="http://yoursite.com/2014/07/25/cpp-namespace/"/>
    <id>http://yoursite.com/2014/07/25/cpp-namespace/</id>
    <published>2014-07-25T10:34:52.000Z</published>
    <updated>2015-05-09T18:17:13.366Z</updated>
    <content type="html"><![CDATA[<p>在C++中，<strong>命名空间（namespace）</strong>的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个<strong>全局命名空间（global namespace）</strong>，全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用<code>::member</code>的形式表示）。</p>
<h3 id="定义命名空间">定义命名空间</h3><p><strong>1、每个命名空间都是一个作用域</strong><br><a id="more"></a><br>和其他作用域类似，在命名空间中的每个名字必须表示唯一实体，而在不同命名空间中，可以有相同名字的成员。</p>
<p><strong>2、命名空间可以是不连续的</strong></p>
<p>命名空间可以定义在几个不同的部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;</span><br><span class="line">    <span class="comment">/* …… */</span></span><br><span class="line">&#125;   <span class="comment">// 命名空间作用域后面无须分号</span></span><br></pre></td></tr></table></figure></p>
<p>如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间添加一些新的成员。</p>
<p><strong>3、命名空间是可以嵌套的</strong></p>
<p>嵌套的命名空间是指定义在其他命名空间中的命名空间。嵌套的命名空间是一个嵌套的作用域，内层命名空间声明的名字将隐藏外层命名空间声明的同名成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">namespace</span> outer &#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> inner &#123;</span><br><span class="line">		<span class="keyword">int</span> z = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; outer::inner::z;  <span class="comment">// 输出10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，通常我们不把#include头文件放在命名空间内部。</p>
<p><strong>4、未命名的命名空间</strong></p>
<p><strong>未命名的命名空间（unnamed namespace）</strong>是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。在标准C++引入命名空间的概念之前，程序需要将名字声明成<code>static</code>以使其对于整个文件有效，但是，现在在文件中进行静态声明的做法已经被C++标准取消了，取而代之的是使用<strong>未命名的命名空间</strong>。</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。也就是说，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。<em>另外，由于未命名的命名空间它没有名字，所以其中定义的名字的作用域与该命名空间所在的作用域相同</em>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;   <span class="comment">// i的全局声明</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">10</span>;  <span class="comment">// 错误，二义性</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> local &#123;</span><br><span class="line">    <span class="keyword">namespace</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">local::i = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="使用命名空间">使用命名空间</h3><p>对命名空间中成员的引用，需要使用命名空间的作用域运算符<strong>(::)</strong>。但是，像<code>namespace_name::member_name</code>这样使用命名空间的成员非常烦琐，我们需要使用一些其他的更简便的方法。</p>
<p><strong>1、命名空间的别名</strong></p>
<p>有些命名空间的名字很长或者命名空间嵌套了很多层，我们可以为其设定一个较短的同义词，也就是别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cln = cpluslus_learning_namespace;</span><br><span class="line"><span class="keyword">namespace</span> Qlib = outer::inner::QueryLib;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、using声明</strong></p>
<p>一条<strong>using声明（using declaration）</strong>语句一次只引入命名空间的一个成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::[命名空间名::……]成员名;   <span class="comment">// 例如 using OLib::List;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3、using指示</strong></p>
<p><strong>using指示（using directive）</strong>和using声明不同的地方是，我们无法控制哪些名字是可见的，因为using指示会使得某个特定的命名空间中所有的名字都可见：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   <span class="comment">// 引入命名空间std</span></span><br></pre></td></tr></table></figure></p>
<p>使用命名空间主要是为了防止名字冲突，如果随意使用using指示注入命名空间的所有名字，将重新引入名字冲突的问题。另外，<strong>using声明和using指示在作用域上有区别</strong>：using声明是将一个成员引入当前命名空间作用域内；using指示是将所有成员引入当前和上一层命名空间作用域内：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;    <span class="comment">// 命名空间</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">16</span>, j=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;   <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> nsp;   <span class="comment">// 如果使用j，将在::j和nsp::j之间产生冲突</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; j;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将using指示<code>using namespace nsp;</code>改成using声明<code>using nsp::j;</code>则会正确输出15。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C++中，<strong>命名空间（namespace）</strong>的目的是为了防止名字冲突。每个命名空间是一个作用域，在所有命名空间之外，还存在一个<strong>全局命名空间（global namespace）</strong>，全局命名空间以隐式的方式声明，它并没有名字。在命名空间机制中，原来的全局变量，就是位于全局命名空间中（可以用<code>::member</code>的形式表示）。</p>
<h3 id="定义命名空间">定义命名空间</h3><p><strong>1、每个命名空间都是一个作用域</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之模板特例化]]></title>
    <link href="http://yoursite.com/2014/07/23/cpp-template-specialization/"/>
    <id>http://yoursite.com/2014/07/23/cpp-template-specialization/</id>
    <published>2014-07-22T16:19:13.000Z</published>
    <updated>2015-05-09T18:14:35.042Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/blog/2014/07/18/c-plus-plus-xue-xi-zhi-han-shu-mo-ban-yu-lei-mo-ban/" target="_blank" rel="external">模板</a>是C++中一个很重要的特性，写一份代码能用于多种数据类型（包括用户自定义类型）。例如，STL的sort()函数可以用于多种数据类型的排序，类stack可以用作多种数据类型的栈。但是，<strong>如果我们想对特定的数据类型执行不同的代码（而不是通用模板）呢？</strong>这种情况下就可以使用<strong>模板特例化（template specialization）</strong>。</p>
<h3 id="函数模板特例化">函数模板特例化</h3><a id="more"></a>
<p>当特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。使用关键字template后跟一个空尖括号&lt;&gt;，即<code>template &lt;&gt;</code>，以指出我们正在特例化一个模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The main template fun(): "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;   <span class="comment">// 对int型特例化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Specialized template for int type: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	fun&lt;<span class="keyword">char</span>&gt;(<span class="string">'a'</span>);</span><br><span class="line">	fun&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">	fun&lt;<span class="keyword">float</span>&gt;(<span class="number">9.15</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">The</span> main <span class="keyword">template</span> fun(): a</span><br><span class="line"><span class="type">Specialized</span> <span class="keyword">template</span> <span class="keyword">for</span> <span class="type">int</span> <span class="keyword">type</span>: <span class="number">10</span></span><br><span class="line"><span class="type">The</span> main <span class="keyword">template</span> fun(): <span class="number">9</span>.<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<p>对于除int型外的其他数据类型，都会调用通用版本的函数模板<code>fun(T a)</code>；对于int型，则会调用特例化版本的<code>fun(int a)</code>。注意，<strong>一个特例化版本的本质是一个实例</strong>，而非函数的重载。因此，特例化不影响函数匹配。</p>
<h3 id="类模板特例化">类模板特例化</h3><p>除了特例化函数模板，我们还可以<strong>特例化类模板</strong>。下面是一个简单的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"General template object"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">// 对int型特例化</span></span><br><span class="line"><span class="keyword">class</span> Test&lt;<span class="keyword">int</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Specialized template object"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Test&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	Test&lt;<span class="keyword">char</span>&gt; b;</span><br><span class="line">	Test&lt;<span class="keyword">float</span>&gt; c;</span><br><span class="line">	a.print();</span><br><span class="line">	b.print();</span><br><span class="line">	c.print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Specialized</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br><span class="line"><span class="type">General</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br><span class="line"><span class="type">General</span> <span class="keyword">template</span> <span class="keyword">object</span></span><br></pre></td></tr></table></figure></p>
<p>另外，与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，这种叫做类模板的<strong>偏特化</strong> 或 <strong>部分特例化（partial specialization）</strong>。例如，C++标准库中的类vector的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Allocator&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在vector这个例子中，一个参数被绑定到bool类型，而另一个参数仍未绑定需要由用户指定。注意，一个类模板的部分特例化版本仍然是一个模板，因为使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<p><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/blog/2014/07/18/c-plus-plus-xue-xi-zhi-han-shu-mo-ban-yu-lei-mo-ban/">模板</a>是C++中一个很重要的特性，写一份代码能用于多种数据类型（包括用户自定义类型）。例如，STL的sort()函数可以用于多种数据类型的排序，类stack可以用作多种数据类型的栈。但是，<strong>如果我们想对特定的数据类型执行不同的代码（而不是通用模板）呢？</strong>这种情况下就可以使用<strong>模板特例化（template specialization）</strong>。</p>
<h3 id="函数模板特例化">函数模板特例化</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之可变参数的函数与模板]]></title>
    <link href="http://yoursite.com/2014/07/22/cpp-changeable-parameter/"/>
    <id>http://yoursite.com/2014/07/22/cpp-changeable-parameter/</id>
    <published>2014-07-22T08:12:24.000Z</published>
    <updated>2015-05-09T18:10:49.174Z</updated>
    <content type="html"><![CDATA[<p>所谓<strong>可变参数</strong>指的是函数的参数个数可变，参数类型不定的函数。为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，我们可以编写<strong>可变参数模板</strong>。另外，C++还有一种特殊的<strong>省略符形参</strong>，可以用它传递可变数量的实参，不过这种一般只用于与C函数交互的接口程序。</p>
<h3 id="可变参数函数">可变参数函数</h3><a id="more"></a>
<p> <strong>1、initializer_list形参</strong></p>
<p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参（C++11新标准）。和vector一样，initializer_list也是一种模板类型。下面看看initializer_list提供的一些操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;initializer_list&gt;  <span class="comment">// 头文件</span></span></span><br><span class="line">initializer_list&lt;T&gt; lst;    <span class="comment">// 默认初始化，T类型元素的空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;; <span class="comment">// 初始化为初始值列表的副本</span></span><br><span class="line">lst2(lst)     <span class="comment">// 拷贝或赋值不会拷贝列表中的元素；拷贝后，</span></span><br><span class="line">lst2 = lst    <span class="comment">// 原始列表和副本共享元素</span></span><br><span class="line">lst.size()    <span class="comment">// 列表中的元素数量</span></span><br><span class="line">lst.begin()   <span class="comment">// 返回指向lst中首元素的指针</span></span><br><span class="line">lst.end()     <span class="comment">// 返回指向lst中尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure></p>
<p>下面给出一个例子，需要注意的是，含有initializer_list形参的函数也可以同时拥有其他形参。另外，如果想给initializer_list形参传递一个实参的序列，必须把序列<strong>放在一对花括号内</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="built_in">string</span>&gt; li)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">("")</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> beg=li.begin(); beg!=li.end(); ++beg)</span><br><span class="line">		str += *beg;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; func(&#123;<span class="string">"This"</span>,<span class="string">" "</span>,<span class="string">"is"</span>,<span class="string">" "</span>,<span class="string">"C++"</span>&#125;) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>2、省略符形参</strong></p>
<p>函数可以用省略符形参”…”表示不定参数部分，省略符形参只能出现在形参列表的最后一个位置，它的形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="comment">// 典型例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>省略符形参应该仅仅用于C和C++通用的类型</strong>，因为大多数类类型的对象在传递给省略符形参时都无法正确拷贝。下面是<strong>&lt; cstdarg &gt;</strong>头文件中的几个宏定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdarg&gt;  <span class="comment">// C中是&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// va_list是一种数据类型，args用于持有可变参数。</span></span><br><span class="line"><span class="comment">// 定义typedef char* va_list;</span></span><br><span class="line">va_list args;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用va_start并传入两个参数：第一个参数为va_list类型的变量</span></span><br><span class="line"><span class="comment">// 第二个参数为"..."前最后一个参数名</span></span><br><span class="line"><span class="comment">// 将args初始化为指向第一个参数（可变参数列表）</span></span><br><span class="line">va_start(args, paramN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索参数，va_arg的第一个参数是va_list变量，第二个参数指定返回值的类型</span></span><br><span class="line"><span class="comment">// 每一次调用va_arg会获取当前的参数，并自动更新指向下一个可变参数。</span></span><br><span class="line">va_arg(args,type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放va_list变量</span></span><br><span class="line">va_end(args);</span><br></pre></td></tr></table></figure></p>
<p>下面给出一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_nums</span><span class="params">(<span class="keyword">int</span> count,...)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	va_list args;</span><br><span class="line">	va_start(args, count);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; ++i)</span><br><span class="line">		result += va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; add_nums(<span class="number">4</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器是将参数压入栈中进行传递的。传递实参的时候，编译器会从实参列表中，按从右到左的顺序将参数入栈，对于add_nums(4, 25, 25, 50, 50)的调用，则入栈的顺序是 50, 50, 25, 25, 4 (注意没有可变参数与不可变参数之分)。由于栈的地址是从高到低的，所以在知道了第一个参数地址和参数的类型之后，就可以获取各个参数的地址。<br><br></p>
<h3 id="可变参数模板">可变参数模板</h3><p>一个<strong>可变参数模板（variadic template）</strong>就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包（parameter packet）</strong>。存在两种参数包：<strong>模板参数包</strong>（表示零个或多个模板参数）和<strong>函数参数包</strong>（表示零个或多个函数参数）。</p>
<p>上述说到我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数，但是所有实参必须具有相同的类型。当我们既不知道要处理的实参数目也不知道它们的类型时，我们就需要使用可变参数的函数模板了。我们用一个<strong>省略号</strong>来指出一个模板参数或函数参数表示一个包：<em>在一个模板参数列表中，<code>class...</code>或<code>typename...</code>指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;...rest)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可变参数函数模板通常是递归的。第一步调用处理包中的第一个实参，然后用剩余的实参调用自身。<strong>为了终止递归，我们还需要定义一个非可变参数的函数模板</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并处理包中最后一个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;...rest)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;     <span class="comment">// 打印第一个实参</span></span><br><span class="line">	print(rest...);       <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	print(<span class="string">"string1"</span>, <span class="number">2</span>, <span class="number">3.14f</span>, <span class="string">"string2"</span>, <span class="number">42</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非可变参数版本的<code>print</code>负责终止递归并打印初始调用中的最后一个实参。对于最后一次递归调用<code>print(42)</code>，两个<code>print</code>版本都是可行的。但是，非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。<br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓<strong>可变参数</strong>指的是函数的参数个数可变，参数类型不定的函数。为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型；如果实参的类型不同，我们可以编写<strong>可变参数模板</strong>。另外，C++还有一种特殊的<strong>省略符形参</strong>，可以用它传递可变数量的实参，不过这种一般只用于与C函数交互的接口程序。</p>
<h3 id="可变参数函数">可变参数函数</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之函数模板与类模板]]></title>
    <link href="http://yoursite.com/2014/07/18/cpp-template/"/>
    <id>http://yoursite.com/2014/07/18/cpp-template/</id>
    <published>2014-07-18T10:58:57.000Z</published>
    <updated>2015-05-09T18:06:44.265Z</updated>
    <content type="html"><![CDATA[<p><strong>泛型编程（Generic Programming）</strong>是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。</p>
<p><strong>模板（template）</strong>是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。<br><a id="more"></a></p>
<h3 id="函数模板">函数模板</h3><p>一个通用的<strong>函数模板（function template）</strong>就是一个公式，可用来生成针对特定类型或特定值的函数版本。模板定义以<strong>关键字template</strong>开始，后面跟一个<strong>模板参数列表</strong>，列表中的多个<strong>模板参数（template parameter）</strong>以逗号分隔。模板参数表示在类或函数定义中用到的类型或值。</p>
<p><strong>1、类型参数</strong></p>
<p>一个模板<strong>类型参数（type parameter）</strong>表示的是一种类型。我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数前必须使用关键字<strong>class</strong> 或 <strong>typename</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// typename和class一样的</span></span><br><span class="line"><span class="function">T <span class="title">function</span><span class="params">(T* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T tmp = *p;   <span class="comment">// 临时变量类型为T</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;   <span class="comment">// 返回值类型为T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键字typename和class是一样的作用，但显然typename比class更为直观，它更清楚地指出随后的名字是一个类型名。</p>
<p>编译器用模板类型实参为我们<strong>实例化（instantiate）</strong>特定版本的函数，一个版本称做模板的一个<strong>实例（instantiation）</strong>。当我们调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参。当然如果函数没有模板类型的参数，则我们需要特别指出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; function(&amp;a) &lt;&lt; endl;     <span class="comment">// 编译器根据函数实参推断模板实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; function&lt;<span class="keyword">int</span>&gt;(&amp;a) &lt;&lt; endl;   <span class="comment">// &lt;int&gt;指出模板参数为int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、非类型参数</strong></p>
<p>在模板中还可以定义<strong>非类型参数（nontype parameter）</strong>，一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> M, <span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; M+N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>* C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; C &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">char</span> (&amp;R)[<span class="number">9</span>]&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; R &lt;&lt; <span class="string">" "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">void</span> (*f)(<span class="keyword">const</span> <span class="keyword">char</span>*)&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	f(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">9</span>] = <span class="string">"template"</span>;   <span class="comment">// 全局变量，具有静态生存期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	add&lt;<span class="number">10</span>, <span class="number">20</span>&gt;();</span><br><span class="line">	func1&lt;arr&gt;(<span class="string">"pointer"</span>);</span><br><span class="line">	func2&lt;arr&gt;(<span class="string">"reference"</span>);</span><br><span class="line">	func3&lt;print&gt;(<span class="string">"template function pointer"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代。一个非类型参数可以是一个整型，或者是一个指向对象或函数的指针或引用：绑定到整形（非类型参数）的实参必须是一个<strong>常量表达式</strong>，绑定到指针或引用（非类型参数）的实参必须具有<strong>静态的生存期</strong>（比如全局变量），不能把<strong>普通局部变量</strong> 或 <strong>动态对象</strong>绑定到指针或引用的非类型形参。<br><br></p>
<h3 id="类模板">类模板</h3><p>相应的，<strong>类模板（class template）</strong>是用来生成类的蓝图。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，所以我们必须<strong>显式</strong>的提供模板实参。与函数模板一样，类模板参数可以是<strong>类型参数</strong>，也可以是<strong>非类型参数</strong>，这里就不再赘述了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Array(T arr[], <span class="keyword">int</span> s);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *ptr;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板外部定义成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::Array(T arr[], <span class="keyword">int</span> s)</span><br><span class="line">&#123;</span><br><span class="line">	ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">	size = s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">		ptr[i]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; *(ptr+i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">5</span>] = &#123;<span class="string">'J'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>&#125;;</span><br><span class="line">	Array&lt;<span class="keyword">char</span>&gt; charArr(a, <span class="number">5</span>);</span><br><span class="line">	charArr.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArr(b, <span class="number">5</span>);</span><br><span class="line">	intArr.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板的成员函数</strong></p>
<p>与其他类一样，我们既可以在类模板内部，也可以在类模板外部定义其成员函数。定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">return_type class_name&lt;T&gt;::member_name(parm-<span class="built_in">list</span>) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，对于一个实例化了的类模板，其成员函数只有在使用时才被实例化。如果一个成员函数没有被使用，则它不会被实例化。</p>
<p><strong>类模板和友元</strong></p>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板的友元，则友元被授权可以访问所有模板的实例。如果友元自身是模板，类可以授权给所有友元模板的实例，也可以只授权给特定实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Pal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;C&gt;;  <span class="comment">// 用类C实例化的Pal是C的一个友元</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; <span class="comment">//Pal2所有实例都是C的友元;无须前置声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> C2 &#123;</span><br><span class="line">	<span class="comment">// C2的每个实例将用相同类型实例化的Pal声明为友元,一对一关系</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;T&gt;;</span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; </span><br><span class="line">	<span class="comment">// Pal3是普通非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>类模板的static成员</strong></p>
<p>类模板可以声明static成员。<strong>类模板的每一个实例都有其自己独有的static成员对象</strong>，对于给定的类型X，所有class_name&lt; X &gt;类型的对象共享相同的一份static成员实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//...其他操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i;  <span class="comment">// 静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Foo&lt;T&gt;::i = <span class="number">10</span>;  <span class="comment">// 初始化为10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Foo&lt;<span class="keyword">int</span>&gt; f1;</span><br><span class="line">	Foo&lt;<span class="keyword">int</span>&gt; f2;</span><br><span class="line">	Foo&lt;<span class="keyword">float</span>&gt; f3;</span><br><span class="line">	f1.print();   <span class="comment">// 输出11</span></span><br><span class="line">	f2.print();   <span class="comment">// 输出12</span></span><br><span class="line">	f3.print();   <span class="comment">// 输出11</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过类类型对象来访问一个类模板的static对象，也可以使用作用域运算符（::）直接访问静态成员。类似模板类的其他成员函数，一个static成员函数也只有在使用时才会实例化。</p>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>泛型编程（Generic Programming）</strong>是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。</p>
<p><strong>模板（template）</strong>是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之多重继承与虚继承]]></title>
    <link href="http://yoursite.com/2014/07/17/cpp-inheritance/"/>
    <id>http://yoursite.com/2014/07/17/cpp-inheritance/</id>
    <published>2014-07-17T12:22:31.000Z</published>
    <updated>2015-05-09T18:03:42.863Z</updated>
    <content type="html"><![CDATA[<h3 id="多重继承">多重继承</h3><p>我们知道，在单继承中，派生类的对象中包含了<strong>基类部分</strong> 和 <strong>派生类自定义部分</strong>。同样的，在<strong>多重继承（multiple inheritance）</strong>关系中，派生类的对象包含了每个基类的子对象和自定义成员的子对象。下面是一个多重继承关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> B&#123; <span class="comment">/*  */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C继承了A，派生类D又继承了B和C，如图所示，一个D对象中含有一个B部分、一个C部分（其中又含有一个A部分）以及在D中声明的非静态数据成员：<a id="more"></a><br><img src="http://img.blog.csdn.net/20140717181313546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>构造与析构：</strong></p>
<p>构造一个派生类对象将首先构造它的所有基类子对象，其中基类的构造顺序与派生列表中基类的出现顺序保持一致，即B -&gt; A -&gt; C -&gt; D。<br>销毁一个派生类对象的顺序正好与其创建的顺序相反，即析构函数的调用顺序正好与构造函数相反，即D -&gt; C -&gt; A -&gt; B。注意派生类的析构函数只负责清除派生类本身分配的资源（析构函数体），派生类的成员及基类都是<strong>自动销毁</strong>的（隐式析构阶段）。</p>
<p><strong>类型转换：</strong></p>
<p>在多重继承的情况下，可以令某个可访问基类的指针或引用直接指向一个派生类对象。编译器不会在派生类向基类的几种转换中进行比较和选择，在它看来转换到任意一种基类都一样好。<br><br></p>
<h3 id="虚继承">虚继承</h3><p>尽管在派生列表中不允许同一个基类出现两次，但实际上派生类可以多次继承同一个类。<br><img src="http://img.blog.csdn.net/20140717200257421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>派生类通常会含有继承链上每个类对应的子部分。<strong>在上面的两种情况中，class D都间接地继承了class A两次，那么意味着class D中包含了class A的两份拷贝。所以在一个class D的对象中将含有2组class A的成员，此时若不加前缀限定符直接使用某个成员将引发“二义性”错误</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():str(<span class="string">"name"</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	d.str = <span class="string">"songlee"</span>;  <span class="comment">// 错误：对成员‘str’的请求有歧义</span></span><br><span class="line">	d.print();  <span class="comment">// 错误：对成员‘print’的请求有歧义</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然你可以使用作用域<code>d.B::str = &quot;songlee&quot;;</code>和<code>d.B::print();</code>来规避“二义性”错误，但这并没有从根本上解决问题。</p>
<p>为了解决上述问题，C++提供了<strong>虚继承（virtual inheritance）</strong>的机制。虚继承的目的是令某个类作出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>。在这种机制下，不论虚基类在继承体系中出现多少次，在派生类中都只包含唯一一个共享的虚基类子对象。<strong>我们指定虚基类的方式是在派生列表中添加关键字virtual：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():str(<span class="string">"name"</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;   <span class="comment">// 虚继承，A为虚基类</span></span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;   <span class="comment">// 关键字public和virtual的顺序随意</span></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	d.str = <span class="string">"songlee"</span>;   <span class="comment">// 正确</span></span><br><span class="line">	d.print();           <span class="comment">// 正确</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在派生列表中添加virtual（关键字public和virtual的顺序随意）指定A为虚基类，B和C将共享A的同一份实例，这样在D的对象中也将只有A的唯一一份实例，所以A的成员可以被直接访问，并且不会产生二义性。</p>
<p>虚继承最典型的应用是iostream继承于istream和ostream，而istream和ostream虚继承于ios：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> istream : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> ostream : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> iostream : <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><strong>注意：</strong></p>
<ol>
<li>支持向基类的常规类型转换。也就是说即使基类是虚基类，也能通过基类的指针或引用操作派生类的对象。</li>
<li>虚继承只是解决了一个派生类对象中存在同一个基类的多份拷贝的问题，并没有解决多个基类存在同名成员的二义性问题。</li>
<li>在虚继承中，虚基类是由最低层的派生类负责初始化的。如上例中，当创建一个D对象时，D位于派生的最低层并由它负责初始化共享的A基类部分。</li>
<li>含有虚基类的对象的构造顺序与一般的多重继承的构造顺序稍有区别：先初始化虚基类子对象（最低层派生类负责），然后按派生列表中的顺序依次对直接基类（非虚）进行初始化。</li>
<li>析构的顺序与构造的顺序正好相反。</li>
</ol>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多重继承">多重继承</h3><p>我们知道，在单继承中，派生类的对象中包含了<strong>基类部分</strong> 和 <strong>派生类自定义部分</strong>。同样的，在<strong>多重继承（multiple inheritance）</strong>关系中，派生类的对象包含了每个基类的子对象和自定义成员的子对象。下面是一个多重继承关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A&#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> B&#123; <span class="comment">/*  */</span> &#125;; </span><br><span class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123; <span class="comment">/*  */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; <span class="comment">/*  */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C继承了A，派生类D又继承了B和C，如图所示，一个D对象中含有一个B部分、一个C部分（其中又含有一个A部分）以及在D中声明的非静态数据成员：]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之虚函数与纯虚函数]]></title>
    <link href="http://yoursite.com/2014/07/17/cpp-virtual-function/"/>
    <id>http://yoursite.com/2014/07/17/cpp-virtual-function/</id>
    <published>2014-07-16T16:15:07.000Z</published>
    <updated>2015-05-09T17:58:56.994Z</updated>
    <content type="html"><![CDATA[<p>面向对象程序设计（object-oriented programming）的核心思想是<strong><em>数据抽象、继承、动态绑定。</em></strong>通过数据抽象，可以使类的接口与实现分离，使用继承，可以更容易地定义与其他类相似但不完全相同的新类，使用动态绑定，可以在一定程度上忽略相似类的区别，而以统一的方式使用它们的对象。</p>
<p><strong>虚函数</strong>的作用是实现<strong>多态性（Polymorphism）</strong>，多态性是将接口与实现进行分离，采用共同的方法，但因个体差异而采用不同的策略。<strong>纯虚函数</strong>则是一种特殊的虚函数。<em>虚函数联系到多态，多态联系到继承。所以本文中都是在继承层次上做文章。没了继承，什么都没得谈。</em><br><a id="more"></a></p>
<h3 id="虚函数">虚函数</h3><p>1 . <strong>定义</strong></p>
<p>在C++中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通过在函数之前加上virtual关键字将其定义为<strong>虚函数（virtual）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base&#123;  <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive_Class : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;  <span class="comment">// 默认也为虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当我们在派生类中覆盖某个函数时，可以在函数前加virtual关键字。然而这不是必须的，<strong>因为一旦某个函数被声明成虚函数，则所有派生类中它都是虚函数</strong>。任何构造函数之外的非静态函数都可以是虚函数。派生类经常（但不总是）覆盖它继承的虚函数，如果派生类没有覆盖其基类中某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>2 . <strong>动态绑定</strong></p>
<p> 当我们使用基类的引用（或指针）调用一个虚函数时将发生<strong>动态绑定（dynamic binding）</strong>。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，可能是基类中的版本也可能是派生类中的版本，判断的依据是引用（或指针）所绑定的对象的真实类型。与非虚函数在编译时绑定不同，虚函数是在运行时选择函数的版本，所以动态绑定也叫<strong>运行时绑定（run-time binding）</strong>。</p>
<p>3 . <strong>静态类型与动态类型</strong></p>
<p> <strong>静态类型</strong>指的是变量声明时的类型或表达式生成的类型，它在编译时总是已知的；<strong>动态类型</strong>指的是变量或表达式表示的内存中的对象的类型，它直到运行时才可知。当且仅当通过基类的指针或引用调用虚函数时，才会在运行时解析该调用，<strong>也只有在这种情况下对象的动态类型才有可能与静态类型不同</strong>。如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>4 . <strong>final和override</strong></p>
<p> 派生类中如果定义了一个函数与基类中虚函数同名但形参列表不同，编译器会认为这是派生类新定义的函数。如果我们的意图本是覆盖虚函数，则这种错误很难发现。通过在派生类中的虚函数最后加<strong>override关键字</strong>使得意图更加清晰。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报错。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base&#123;  <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derive_Class : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> override</span>;  <span class="comment">// 报错，没有覆盖虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果我们定义一个类，并不希望它被继承。或者希望某个函数不被覆盖，则可以把类或者函数指定为<strong>final</strong>，则之后任何尝试继承该类或覆盖该函数的操作将引发错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base final &#123; <span class="comment">/*   */</span> &#125;;     <span class="comment">// 基类不能被继承</span></span><br><span class="line"><span class="keyword">class</span> Derive_Class : <span class="keyword">public</span> Base &#123; <span class="comment">/*  */</span> &#125;;     <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;   <span class="comment">// 不允许后续的其他类覆盖func(int)</span></span><br></pre></td></tr></table></figure></p>
<p>5 . <strong>回避虚函数的机制</strong></p>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。可以使用<strong>作用域运算符</strong>实现这一目的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强行调用基类中定义的函数版本而不管baseP的动态类型是什么</span></span><br><span class="line"><span class="keyword">int</span> a = baseP-&gt;Base::func(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<p> 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。</p>
<h3 id="纯虚函数">纯虚函数</h3><p>1 . <strong>定义</strong></p>
<p>为了方便使用多态特性，我们常常需要在基类中定义虚函数。在许多情况下，在基类中不能对虚函数给出有意义的实现。为了让虚函数在基类什么也不做，引进了“纯虚函数”的概念，使函数无须定义。<em>我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为<strong>纯虚函数（pure virtual）</strong>。</em>其中，=0只能出现在类内部的虚函数声明语句处：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base&#123;  <span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。</p>
<p>2 . <strong>抽象基类</strong></p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类叫<strong>抽象基类（abstract base class）</strong>。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象基类。因为抽象基类含有纯虚函数（没有定义），所以<strong>我们不能创建一个抽象基类的对象</strong>，但可以声明指向抽象基类的指针或引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base base;   <span class="comment">// 错误，不能实例化抽象基类</span></span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h3 id="总结：">总结：</h3><ol>
<li>虚函数必须实现，不实现编译器会报错。</li>
<li>父类和子类都有各自的虚函数版本。由多态方式在运行时动态绑定。</li>
<li>通过作用域运算符可以强行调用指定的虚函数版本。</li>
<li>纯虚函数声明如下：<code>virtual void funtion()=0;</code> 纯虚函数无需定义。包含纯虚函数的类是抽象基类，抽象基类不能创建对象，但可以声明指向抽象基类的指针或引用。</li>
<li>派生类实现了纯虚函数以后，该纯虚函数在派生类中就变成了虚函数，其子类可以再对该函数进行覆盖。</li>
<li>析构函数通常应该是虚函数，这样就能确保在析构时调用正确的析构函数版本。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象程序设计（object-oriented programming）的核心思想是<strong><em>数据抽象、继承、动态绑定。</em></strong>通过数据抽象，可以使类的接口与实现分离，使用继承，可以更容易地定义与其他类相似但不完全相同的新类，使用动态绑定，可以在一定程度上忽略相似类的区别，而以统一的方式使用它们的对象。</p>
<p><strong>虚函数</strong>的作用是实现<strong>多态性（Polymorphism）</strong>，多态性是将接口与实现进行分离，采用共同的方法，但因个体差异而采用不同的策略。<strong>纯虚函数</strong>则是一种特殊的虚函数。<em>虚函数联系到多态，多态联系到继承。所以本文中都是在继承层次上做文章。没了继承，什么都没得谈。</em><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之继承中的访问控制]]></title>
    <link href="http://yoursite.com/2014/07/16/cpp-access-control/"/>
    <id>http://yoursite.com/2014/07/16/cpp-access-control/</id>
    <published>2014-07-16T05:16:59.000Z</published>
    <updated>2015-05-09T17:57:02.013Z</updated>
    <content type="html"><![CDATA[<p>我们通常认为一个类有两种不同的用户：<strong>普通用户</strong> 和 <strong>类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。如果进一步考虑继承的话就会出现第三种用户，即<strong>派生类</strong>。派生类可以访问基类的公有（public）成员和受保护（protected）成员，但不能访问基类的私有（private）成员。<br><a id="more"></a><br>继承相关点：</p>
<ul>
<li>大多数类都只继承自一个类，这种形式的继承叫做<strong>“单继承”</strong>。本文主要讲的是单继承。</li>
<li>一个派生类的对象中，包含继承自基类的部分和派生类自定义的部分。正因为派生类含有基类部分，所以可以进行<strong>派生类到基类的类型转换</strong>，这种转换是隐式的。</li>
<li>不存在从基类向派生类的隐式类型转换。</li>
<li>派生类向基类的自动类型转换只对指针或引用有效，对象之间不存在类型转换。</li>
<li>如果基类定义了静态成员，则不论派生出多少个派生类，每个静态成员都只存在唯一实例。</li>
<li>防止一个类被继承可以使用关键字final，这时C++11新标准中提供的。</li>
<li>继承中的<a href="http://songlee24.github.io/blog/2014/07/16/c-plus-plus-xue-xi-zhi-xu-han-shu-yu-chun-xu-han-shu/" target="_blank" rel="external">虚函数与纯虚函数</a>（见文章）。<br><br><br></li>
</ul>
<h3 id="公有、私有和受保护成员">公有、私有和受保护成员</h3><p><strong>1 . 访问说明符</strong></p>
<p>在C++中通过使用访问说明符<strong>public、protected、private</strong>来对类的成员进行访问控制，控制成员对于普通用户或派生类来说是否可访问：</p>
<ul>
<li><p><strong>public</strong>：定义为public的成员对普通用户、类的实现者、派生类都是可访问的。public通常用于定义类的外部接口。</p>
</li>
<li><p><strong>protected</strong>：定义protected成员的目的是让派生类可以访问而禁止其他用户访问。所以类的实现者和派生类可以访问，而普通用户不能访问。</p>
</li>
<li><p><strong>private</strong>：定义为private的成员只能被类的实现者（成员和友元）访问。private部分通常用于封装（即隐藏）类的实现细节。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> People&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(Student &amp;s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(People &amp;p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，可以通过派生类对象访问基类的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Student &amp;s)</span></span>&#123; s.name=<span class="string">"Songlee"</span>; <span class="built_in">cout</span>&lt;&lt; s.name &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// 错误，不能通过基类对象访问基类的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(People &amp;p)</span></span>&#123; p.name=<span class="string">"Songlee"</span>; <span class="built_in">cout</span>&lt;&lt; p.name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，派生类的成员或友元只能通过<strong>派生类对象</strong>来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p><strong>2 . 改变成员的可访问性</strong></p>
<p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using</strong>声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> People&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> People::name;  <span class="comment">// 将继承来的name成员的访问权限改为public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Student me;</span><br><span class="line">	me.name = <span class="string">"SongLee"</span>;     <span class="comment">// 可以访问name了</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; me.name &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何<strong>可访问成员</strong>（非私有成员）标记出来，改变其访问权限。</p>
<h3 id="公有、私有和受保护继承">公有、私有和受保护继承</h3><p>我们注意到，在类的<strong>派生列表</strong>中用到了访问说明符public、protected和private，它们分别表示不同的继承方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> B &#123; <span class="comment">/*  */</span> &#125;;     <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">private</span> B &#123; <span class="comment">/*  */</span> &#125;;    <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">protected</span> B &#123; <span class="comment">/*  */</span> &#125;;  <span class="comment">// 受保护继承</span></span><br></pre></td></tr></table></figure></p>
<p>派生类的派生列表中的访问说明符<strong>对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响</strong>。派生类的成员（及友元）对基类成员的访问权限只与基类中的访问说明符有关。</p>
<p>那么派生列表中的访问说明符有什么作用呢？<br><strong>派生列表中访问说明符的作用</strong>是<em>控制派生类<strong>用户</strong>对于基类成员的访问权限</em>，注意是派生类的用户。下面给出不同的继承方式导致的访问权限的变化：</p>
<ul>
<li><p><strong>public继承</strong>：如果继承是公有的，则成员将遵循其原有的访问说明符。父类中的public、protected和private属性在子类中不发生改变。</p>
</li>
<li><p><strong>protected继承</strong>：比protected级别高的访问权限会变成protected。即父类中的public属性在子类中变为protected，父类中的protected和private属性在子类中不变。</p>
</li>
<li><p><strong>private继承</strong>：比private级别高的访问权限会变成private。即父类中的三种访问属性在子类中都会变成private。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;   <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> A_public;      <span class="comment">// 公有成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">string</span> A_protected;   <span class="comment">// 受保护成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">private</span> A &#123;    <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123; A_public=<span class="string">"public"</span>; A_protected=<span class="string">"protected"</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	B b;   <span class="comment">// 通过B的对象访问</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.A_public &lt;&lt;<span class="string">" "</span>&lt;&lt; b.A_protected &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在派生列表中不使用访问说明符，则struct关键字默认的是公有继承，class关键字默认的是私有继承。不过建议在继承时最好显式地将访问说明符写出来。<br><br><br><br>另外，不同的继承方式也会影响派生类向基类的转换，假定Derive继承自Base：</p>
<ul>
<li><p>只有当Derive公有地继承自Base时，用户代码才能使用派生类向基类的转换；如果Derive继承Base的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>
</li>
<li><p>不论Derive以什么方式继承Base，Derive的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</p>
</li>
<li><p>如果Derive继承Base的方式是公有的或者受保护的，则Derive的派生类的成员和友元可以使用Derive向Base的类型转换；反之，如果Derive继承Base的方式是私有的，则不能使用。<br><br><br></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们通常认为一个类有两种不同的用户：<strong>普通用户</strong> 和 <strong>类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有部分。如果进一步考虑继承的话就会出现第三种用户，即<strong>派生类</strong>。派生类可以访问基类的公有（public）成员和受保护（protected）成员，但不能访问基类的私有（private）成员。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++与C的那些差异]]></title>
    <link href="http://yoursite.com/2014/07/06/difference-between-c-and-cpp/"/>
    <id>http://yoursite.com/2014/07/06/difference-between-c-and-cpp/</id>
    <published>2014-07-06T10:27:21.000Z</published>
    <updated>2015-05-09T17:52:03.555Z</updated>
    <content type="html"><![CDATA[<p>虽说C++是向后兼容C的，但C++与C还是存在许多差异。这里举了几个例子，也是我们很容易忽略的地方。如果你还知道其他的更多的Differences，或者发现什么错误，可以评论告诉我，大家一起学习进步。另外，随着学习的进行，本文会持续更新……</p>
<p><strong>C编译通过但C++编译不通过</strong><br><a id="more"></a><br><strong>1、C++中编译器不允许在一个函数声明之前调用它，但C中编译器是允许的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   foo();     <span class="comment">// foo()在它的声明/定义之前被调用</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、C++中不能用一个普通指针指向一个常量，但C中可以。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> j = <span class="number">20</span>;  </span><br><span class="line">    <span class="comment">/* C++编译会报错，C中编译会有warning，但可以通过 */</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;j; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*ptr: %d\n"</span>, *ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、在C语言中，void指针可以直接赋给其他类型的指针，如int*, char*等。但在C++中，void指针必须要明确地进行类型转换。（malloc函数返回值为void *类型）</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vptr;</span><br><span class="line">    <span class="keyword">int</span> *iptr = vptr; <span class="comment">// C++中必须用int *iptr = (int *)vptr;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>C和C++输出结果不相同</strong></p>
<p><strong>4、字符常量在C和C++被当作不同地类型看待：在C中，字符常量如’a’,’b’被当作int型，而在C++中被当作char型。所以，在C中sizeof(‘A’)相当于sizeof(int)，输出为4；在C++中sizeof(‘A’)仍相当于sizeof(char)，输出为1。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(<span class="string">'a'</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5、在C中定义结构体必须使用<code>struct</code>关键字，但在C++中可以省略。在C++中局部变量会覆盖同名的全局变量，但在C中却不会。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> T &#123; <span class="keyword">double</span> x; &#125;; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(T));  <span class="comment">// C输出4，C++输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>6、布尔结果在C++和C中的表示是不同的。因为C语言不直接支持布尔型，所以其实返回的是int型，而C++则返回的是bool类型。所以</strong>sizeof(1==1)<strong>在C中是sizeof(int)，在C++中是sizeof(bool)。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  <span class="comment">// 请用gcc和g++分别进行编译</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="number">1</span>==<span class="number">1</span>));  <span class="comment">// C输出4，C++输出1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽说C++是向后兼容C的，但C++与C还是存在许多差异。这里举了几个例子，也是我们很容易忽略的地方。如果你还知道其他的更多的Differences，或者发现什么错误，可以评论告诉我，大家一起学习进步。另外，随着学习的进行，本文会持续更新……</p>
<p><strong>C编译通过但C++编译不通过</strong><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之extern关键字]]></title>
    <link href="http://yoursite.com/2014/07/05/C-extern-C/"/>
    <id>http://yoursite.com/2014/07/05/C-extern-C/</id>
    <published>2014-07-05T14:08:05.000Z</published>
    <updated>2015-05-09T17:45:24.885Z</updated>
    <content type="html"><![CDATA[<p>我们知道，extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。另外，extern还可以与”C”连用，作为链接指示。</p>
<h3 id="C++名字修饰（Name_Mangling）">C++名字修饰（Name Mangling）</h3><a id="more"></a>
<p>这就要从C++的重载说起了，在C++中<strong>函数重载</strong>指的是几个函数的函数名相同，参数列表不同。那么当生成obj中间文件/目标文件的时候，C++编译器如何区分这几个重载函数呢？——<strong>通过把原函数名与参数信息结合，产生一个独特的内部名字</strong>，这种技术叫做<a href="http://zh.wikipedia.org/zh/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">名字修饰</a>（Name Mangling）。名字修饰规则没有一个标准，所以不同的编译器的名字修饰规则也不一样。</p>
<p>下面是一组函数，其中f()函数重载了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">f</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">f</span> <span class="params">(<span class="keyword">int</span>)</span>  </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">int</span> i = f(), j = f(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>f(void)和f(int)是不同的函数，除了函数名相同以外没有任何关系。当生成obj目标文件时，为了区分它们，C++编译器根据参数信息进行了名字修饰：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  __f_v (<span class="keyword">void</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">int</span>  __f_i (<span class="keyword">int</span>)  &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> __g_v (<span class="keyword">void</span>) &#123; <span class="keyword">int</span> i = __f_v(), j = __f_i(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意g()也被名字修饰了，虽然没有任何名字冲突。名字修饰应用于C++的任何符号。</p>
<h3 id="为什么要使用extern_“C”？">为什么要使用extern “C”？</h3><p>C语言中没有名字修饰，因为C语言不支持函数重载。但是如果C++中含有C代码，在编译时C++编译器对C代码的函数也会进行名字修饰，函数名变了以后，将导致在C运行库中找不到对应函数，发生链接错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下面的代码保存为.cpp文件，并用C++编译器编译</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GeeksforGeeks"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccQBO9Im.o：在函数‘main’中：</span><br><span class="line">test<span class="class">.cpp</span>:(.text+<span class="number">0</span>xf)：对‘<span class="function"><span class="title">printf</span><span class="params">(char const*, ...)</span></span>’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>为了防止C++编译器对C代码进行名字修饰，我们将C代码用<strong>extern “C”</strong>进行链接指定，<strong>告诉编译器，在生成中间文件时，不要对这部分代码进行名字修饰，而是生成符合C规则的中间符号名。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello!"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加了extern “C”链接指示后，上面的代码就能够正常运行了。<br><br><br><br><br><strong>附</strong>：所有的C风格的头文件（stdio.h, string.h, … 等等）都有在extern “C”下声明，形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Declarations of this file */</span></span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们知道，extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。另外，extern还可以与”C”连用，作为链接指示。</p>
<h3 id="C++名字修饰（Name_Mangling）">C++名字修饰（Name Mangling）</h3>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Lang.-C++" scheme="http://yoursite.com/categories/Lang-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深度优先搜索的实现]]></title>
    <link href="http://yoursite.com/2014/07/04/depth-first-search/"/>
    <id>http://yoursite.com/2014/07/04/depth-first-search/</id>
    <published>2014-07-04T03:53:09.000Z</published>
    <updated>2015-05-09T17:41:24.830Z</updated>
    <content type="html"><![CDATA[<p>图的遍历是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：广度优先搜索（Breadth-First-Search）和深度优先搜索（Depth-First-Search）。</p>
<h3 id="深度优先搜索（DFS）的算法思想">深度优先搜索（DFS）的算法思想</h3><a id="more"></a>
<p>深度优先搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。它的基本思想就是：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<p><img src="http://img.blog.csdn.net/20140704111631015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，从顶点2开始深度优先遍历图，结果为：2，0，1，3。</p>
<h3 id="DFS算法实现">DFS算法实现</h3><p>和<a href="http://songlee24.github.io/2014/07/03/breadth-first-search/" target="_blank" rel="external">广度优先搜索</a>一样，为了防止顶点被多次访问，需要使用一个访问标记数组visited[]来标记顶点是否已经被访问过。</p>
<p>这里使用邻接表表示图。对于一个<strong>有向图</strong>，<strong>假设从给定顶点可以访问到图的所有其他顶点</strong>，则DFS递归算法的C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: DFS.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年07月04日 星期五 10时38分26秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图 */</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;                               <span class="comment">// 顶点数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                      <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>; <span class="comment">// 从顶点v深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                        <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;          <span class="comment">// 向图中添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;                     <span class="comment">// 从v开始深度优先遍历图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);                 <span class="comment">// 将w添加到v的链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从v开始深度优先遍历 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::DFSUtil(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 访问顶点v并输出</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=adj[v].begin(); i!=adj[v].end(); ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[*i])              <span class="comment">// 若邻接点尚未访问</span></span><br><span class="line">			DFSUtil(*i, visited);     <span class="comment">// 递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对图进行深度优先遍历，调用递归函数DFSUtil() */</span></span><br><span class="line"><span class="keyword">void</span> Graph::DFS(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设从给定顶点v可以到达图的所有顶点</span></span><br><span class="line">	DFSUtil(v, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(4)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Depth First Traversal (starting from vertex 2) \n"</span>;</span><br><span class="line">	g.DFS(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是假设从给定顶点可以访问到图的所有其他顶点。<strong>如果没有这个假设，为了对图作一个完整的深度优先遍历，我们需要对每个顶点调用DFSUtil()</strong>。当然那之前需要先检查顶点是否已经访问过。所以我们只需要修改<strong>DFS()</strong>函数部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::DFS()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对每个顶点调用DFSUtil()，从0开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			DFSUtil(i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<strong>无向图</strong>的深度优先搜索，只是邻接表不一样，其他的都是一样的。我们只需要修改addEdge(v, w)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">  adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">  adj[w].push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：图的邻接矩阵表示是唯一的，但对于邻接表来说，如果边的输入次序不同，生成的邻接表也不同。因此，对于同一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。</p>
<h3 id="DFS算法性能分析">DFS算法性能分析</h3><p>1 . <strong>空间复杂度</strong></p>
<p>DFS算法是一个递归算法，需要借助一个递归工作栈，故它的空间复杂度为O(|V|)。</p>
<p>2 . <strong>时间复杂度</strong></p>
<ul>
<li><p>当以<strong>邻接表</strong>存储时，时间复杂度为<strong>O(|V|+|E|)</strong>。</p>
</li>
<li><p>当以<strong>邻接矩阵</strong>存储时，时间复杂度为<strong>O(|V|^2)</strong>。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>图的遍历是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：广度优先搜索（Breadth-First-Search）和深度优先搜索（Depth-First-Search）。</p>
<h3 id="深度优先搜索（DFS）的算法思想">深度优先搜索（DFS）的算法思想</h3>]]>
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广度优先搜索的实现]]></title>
    <link href="http://yoursite.com/2014/07/03/breadth-first-search/"/>
    <id>http://yoursite.com/2014/07/03/breadth-first-search/</id>
    <published>2014-07-03T13:20:36.000Z</published>
    <updated>2015-05-09T17:36:47.414Z</updated>
    <content type="html"><![CDATA[<p><strong>图的遍历</strong>是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：<strong>广度优先搜索</strong>（Breadth-First-Search）和<strong>深度优先搜索</strong>（Depth-First-Search）。</p>
<h3 id="广度优先搜索（BFS）的算法思想">广度优先搜索（BFS）的算法思想</h3><a id="more"></a>
<p>广度优先搜索类似于二叉树的<strong>层序遍历</strong>，它的基本思想就是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，…，wi，然后再依次访问w1，w2，…，wi的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点……依次类推，直到图中所有顶点都被访问过为止。</p>
<p>广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此<strong>它不是一个递归的算法</strong>。为了实现逐层的访问，算法必须借助一个辅助队列，以记录正在访问的顶点的下一层顶点。</p>
<p><img src="http://img.blog.csdn.net/20140703195044578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，为一个有向图，从顶点2开始广度优先遍历整个图，可知结果为2，0，3，1。</p>
<h3 id="BFS算法实现">BFS算法实现</h3><p>与树相比，图的不同之处在于<strong>它存在回路/环</strong>，因此在遍历时一个顶点可能被访问多次。为了防止这种情况出现，我们使用一个访问标记数组visited[]来标记顶点是否已经被访问过。</p>
<p>在广度优先搜索一个图之前，我们首先要构造一个图，<strong>图的存储方式</strong>主要有两种：<strong>邻接矩阵、邻接表</strong>。这里我们使用邻接表来存储图：</p>
<p><img src="http://img.blog.csdn.net/20140703201818812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>简单起见，我们先假设从起始顶点可以达到其他所有顶点。</strong>以有向图为例，C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BFS.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年07月03日 星期四 18时37分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表存储有向图 */</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;                       <span class="comment">// 顶点的数量</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;              <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;  <span class="comment">// 向图中添加一条边</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;             <span class="comment">// BFS遍历</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 构造函数 *****/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];      <span class="comment">// 初始化V条链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从顶点v出发广度优先搜索 */</span></span><br><span class="line"><span class="keyword">void</span> Graph::BFSUtil(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// BFS辅助队列</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">queue</span>.push_back(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 出队</span></span><br><span class="line">		v = <span class="built_in">queue</span>.front();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测已出队的顶点s的所有邻接顶点</span></span><br><span class="line">		<span class="comment">// 若存在尚未访问的邻接点，访问它并压入队列</span></span><br><span class="line">		<span class="keyword">for</span>(i = adj[v].begin(); i!=adj[v].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 广度优先搜索 **/</span></span><br><span class="line"><span class="keyword">void</span> Graph::BFS(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化访问标记数组</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 假设从给定顶点可以到达图的所有顶点</span></span><br><span class="line">	BFSUtil(v, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建图</span></span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(4)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Following is BFS Traversal (starting from vertex 2) \n"</span>;</span><br><span class="line">	g.BFS(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是假设从起始顶点开始能够到达图的所有顶点。如果不能到达所有顶点，即存在多个连通分量呢？那么<strong>我们就要对每个连通分量都进行一次广度优先搜索</strong>。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEXT_NUM];   <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G)</span>        <span class="comment">// 设访问函数为visit()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;      <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)    <span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[i])          <span class="comment">// 对每个连通分量调用一次BFS</span></span><br><span class="line">			BFS(G,i);            <span class="comment">// Vi未访问过，从Vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSUtil</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	visit(v);                    <span class="comment">// 访问初始顶点</span></span><br><span class="line">	visited[v] = <span class="keyword">true</span>;           <span class="comment">// v已访问</span></span><br><span class="line">	Enqueue(Q, v);               <span class="comment">// 顶点v入队列</span></span><br><span class="line">	<span class="keyword">while</span>(!isEmpty(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		Dequeue(Q, v);           <span class="comment">// 顶点v出队列</span></span><br><span class="line">		<span class="keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,v))</span><br><span class="line">			<span class="keyword">if</span>(!visited[w])      <span class="comment">// 检测v的所有邻接点</span></span><br><span class="line">			&#123;</span><br><span class="line">				visit(w);        <span class="comment">// 若w未访问，访问之</span></span><br><span class="line">				visited[w]=<span class="keyword">true</span>; <span class="comment">// 标记</span></span><br><span class="line">				Enqueue(Q, w);   <span class="comment">// 顶点w入队列</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据伪代码，相信不难写出对于多个连通分量的图的广度优先搜索，我们只需要修改<strong>BFS()</strong>函数部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::BFS()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化访问标记数组</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对每个连通分量调用一次BFSUtil()，从0号顶点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			BFSUtil(i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<strong>无向图</strong>的广度优先搜索，只是邻接表不一样，其他的都是一样的。我们只需要修改addEdge(v, w)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);         <span class="comment">// 将w加到v的list</span></span><br><span class="line">	adj[w].push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BFS算法性能分析">BFS算法性能分析</h3><p>1 . <strong>空间复杂度</strong></p>
<p>无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点都需要入队一次，在最坏的情况下，空间复杂度为<strong>O(|V|)</strong>。</p>
<p>2 . <strong>时间复杂度</strong></p>
<ul>
<li><p>当采用<strong>邻接表</strong>存储时，每个顶点均需搜索一次，故时间复杂度为O(|V|)，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(|E|)，算法总的时间复杂度为<strong>O(|V|+|E|)</strong>。</p>
</li>
<li><p>当采用<strong>邻接矩阵</strong>存储时，查找每个顶点的邻接点所需的时间为O(|V|)，故算法总的时间复杂度为<strong>O(|V|^2)</strong>。</p>
</li>
</ul>
<p> <br><br><br><br><br><strong>注</strong>：广度优先搜索（BFS）算法思想有很多应用，比如Dijkstra单源最短路径算法和Prim最小生成树算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>图的遍历</strong>是指从图中的某一个顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可以看作是一种特殊的图的遍历。图的遍历主要有两种算法：<strong>广度优先搜索</strong>（Breadth-First-Search）和<strong>深度优先搜索</strong>（Depth-First-Search）。</p>
<h3 id="广度优先搜索（BFS）的算法思想">广度优先搜索（BFS）的算法思想</h3>]]>
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>