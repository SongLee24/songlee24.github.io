<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Man]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-09T17:13:57.590Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[快速排序的分析与优化]]></title>
    <link href="http://yoursite.com/2014/06/21/quick-sort-analysis/"/>
    <id>http://yoursite.com/2014/06/21/quick-sort-analysis/</id>
    <published>2014-06-21T06:53:39.000Z</published>
    <updated>2015-05-09T17:13:57.590Z</updated>
    <content type="html"><![CDATA[<h3 id="快速排序的介绍">快速排序的介绍</h3><p>快速排序是一种排序算法，对包含n个数的输入数组，最坏的情况运行时间为<strong>Θ(n^2)</strong>[Θ读作theta]。虽然这个最坏情况的运行时间比较差，但快速排序通常是用于排序的最佳的实用选择。这是因为其平均情况下的性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，它还能够进行就地排序，在虚拟内存环境中也能很好的工作。</p>
<p>和归并排序一样，快速排序也是基于<strong>分治法</strong>（Divide and conquer）：<a id="more"></a></p>
<ul>
<li><strong>分解</strong>：数组A[p..r]被划分成两个(可能为空)的子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A[q]，A[q+1..r]中的每个元素都大于等于A[q]。这样元素A[q]就位于其最终位置上了。</li>
<li><strong>解决</strong>：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]排序。</li>
<li><strong>合并</strong>：因为两个子数组是就地排序，不需要合并，整个数组已有序。</li>
</ul>
<p><strong>伪代码</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	x = A[p]</span><br><span class="line">	<span class="tag">i</span> = <span class="tag">p</span></span><br><span class="line">	<span class="keyword">for</span> j=p+<span class="number">1</span> to r</span><br><span class="line">		do <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">			then <span class="tag">i</span> = i+<span class="number">1</span></span><br><span class="line">				 <span class="function"><span class="title">exchange</span><span class="params">(A[i],A[j])</span></span></span><br><span class="line">	<span class="function"><span class="title">exchange</span><span class="params">(A[p], A[i])</span></span></span><br><span class="line">	return i</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">QUICKSORT</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="tag">p</span> &lt; r</span><br><span class="line">		then <span class="tag">q</span> = <span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">			 <span class="function"><span class="title">QUICKSORT</span><span class="params">(A, p, q-<span class="number">1</span>)</span></span></span><br><span class="line">			 <span class="function"><span class="title">QUICKSORT</span><span class="params">(A, q+<span class="number">1</span>, r)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3><p><strong>1、最坏情况</strong></p>
<p>快速排序的最坏情况发生在当<strong>数组已经有序或者逆序排好</strong>的情况下。这样的话划分过程产生的两个区域中有一个没有元素，另一个包含n-1个元素。此时算法的运行时间可以递归地表示为：<code>T(n) = T(n-1)+T(0)+Θ(n)</code>，递归式的解为<code>T(n)=Θ(n^2)</code>。可以看出，快速排序算法最坏情况运行时间并不比插入排序的更好。</p>
<p><strong>2、最好情况</strong></p>
<p>如果我们足够幸运，在每次划分操作中做到最平衡的划分，即将数组划分为n/2:n/2。此时得到的递归式为<code>T(n) = 2T(n/2)+Θ(n)</code>，根据主定理的情况二可得<code>T(n)=Θ(nlgn)</code>。</p>
<p><strong>3、平均情况</strong></p>
<p>假设一：快排中的划分点非常偏斜，比如每次都将数组划分为1/10 : 9/10的两个子区域，这种情况下运行时间是多少呢？运行时间递归式为<code>T(n) = T(n/10)+T(9n/10)+Θ(n)</code>，使用递归树解得<code>T(n)=Θ(nlgn)</code>。可以看出，当划分点非常偏斜的时候，运行时间仍然是Θ(nlgn)。</p>
<p>假设二：Partition所产生的划分既有“好的”，也有“差的”，它们交替出现。这种平均情况下运行时间又是多少呢？这时的递归式为（G表示Good，B表示Bad）：</p>
<blockquote>
<p>G(n) = 2B(n/2) + Θ(n)</p>
<p>B(n) = G(n-1) + Θ(n)</p>
<p>解：G(n) = 2(G(n/2-1) + Θ(n/2)) + Θ(n) = 2G(n/2-1) + Θ(n) = Θ(nlgn)  </p>
</blockquote>
<p>可以看出，当好、差划分交替出现时，快排的运行时间就如全是好的划分一样，仍然是Θ(nlgn) 。</p>
<h3 id="快排的优化">快排的优化</h3><p>经过上面的分析可以知道，在输入有序或逆序时快速排序很慢，在其余情况则表现良好。如果输入本身已被排序，那么就糟了。那么我们如何确保对于所有输入，它均能够获得较好的平均情况性能呢？前面的快速排序我们默认使用数组中第一个元素作为主元。假设随机选择数组中的元素作为主元，则快排的运行时间将不依赖于输入序列的顺序。我们把<strong>随机选择主元</strong>的快速排序叫做Randomized Quicksort。</p>
<p>在随机化的快速排序中，我们不是始终选择第一个元素作为主元，而是从数组A[p…r]中随机选择一个元素，然后将其与第一个元素交换。由于主元元素是随机选择的，我们期望在平均情况下，对输入数组的划分能够比较对称。</p>
<p><strong>伪代码</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">RANDOMIZED-PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="tag">i</span> = <span class="function"><span class="title">RANDOM</span><span class="params">(p, r)</span></span></span><br><span class="line">	<span class="function"><span class="title">exchange</span><span class="params">(A[p], A[i])</span></span></span><br><span class="line">	return <span class="function"><span class="title">PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, p, r)</span></span></span><br><span class="line">	<span class="keyword">if</span> <span class="tag">p</span> &lt; r</span><br><span class="line">		then <span class="tag">q</span> = <span class="function"><span class="title">RANDOMIZED-PARTITION</span><span class="params">(A, p, r)</span></span></span><br><span class="line">			<span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, p, q-<span class="number">1</span>)</span></span></span><br><span class="line">			<span class="function"><span class="title">RANDOMIZED-QUICKSORT</span><span class="params">(A, q+<span class="number">1</span>, r)</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们对3万个元素的有序序列分别进行<strong>传统的快速排序</strong> 和 <strong>随机化的快速排序</strong>，并比较它们的运行时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: QuickSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月21日 星期六 10时11分30秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;ctime&gt;  <span class="comment">// clock_t clock</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统划分操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=low+<span class="number">1</span>; j&lt;=high; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt;= pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			swap(A[i], A[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[i], A[low]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机化划分操作，随机选择pivot</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_Random</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">int</span> i = rand() % (high+<span class="number">1</span>);</span><br><span class="line">	swap(A[low], A[i]);</span><br><span class="line">	<span class="keyword">return</span> Partition(A, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = Partition(A, low, high);</span><br><span class="line">		QuickSort(A, low, pos-<span class="number">1</span>);</span><br><span class="line">		QuickSort(A, pos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机化快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort_Random</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = Partition_Random(A, low, high);</span><br><span class="line">		QuickSort_Random(A, low, pos-<span class="number">1</span>);</span><br><span class="line">		QuickSort_Random(A, pos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	clock_t t1, t2;</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">30000</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; ++i)</span><br><span class="line">		A[i] = i+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">	t1 = clock();</span><br><span class="line">	QuickSort(A, <span class="number">0</span>, <span class="number">30000</span>-<span class="number">1</span>);</span><br><span class="line">	t1 = clock() - t1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Traditional quicksort took "</span>&lt;&lt; t1 &lt;&lt; <span class="string">" clicks(about "</span> &lt;&lt; ((<span class="keyword">float</span>)t1)/CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds)."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t2 = clock();</span><br><span class="line">	QuickSort_Random(A, <span class="number">0</span>, <span class="number">30000</span>-<span class="number">1</span>);</span><br><span class="line">	t2 = clock() - t2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Randomized quicksort took "</span>&lt;&lt; t2 &lt;&lt; <span class="string">" clicks(about "</span> &lt;&lt; ((<span class="keyword">float</span>)t2)/CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds)."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost ~]$ ./QuickSort </span><br><span class="line">Traditional quicksort took <span class="number">1210309</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">1.21031</span> seconds)</span></span>.</span><br><span class="line">Randomized quicksort took <span class="number">457573</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">0.457573</span> seconds)</span></span>.</span><br><span class="line">[songlee@localhost ~]$ ./QuickSort </span><br><span class="line">Traditional quicksort took <span class="number">1208038</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">1.20804</span> seconds)</span></span>.</span><br><span class="line">Randomized quicksort took <span class="number">644950</span> <span class="function"><span class="title">clicks</span><span class="params">(about <span class="number">0.64495</span> seconds)</span></span>.</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看出，对于有序的输入，随机化版本的快速排序的效率会高很多。</p>
<h4 id="问题记录：">问题记录：</h4><p>我们知道交换两个变量的值有以下三种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = a;  <span class="comment">// 方法一</span></span><br><span class="line">a = b;</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a+b;  <span class="comment">// 方法二</span></span><br><span class="line">b = a-b;</span><br><span class="line">a = a-b;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;  <span class="comment">// 方法三</span></span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure>
<p>但是你会发现在本程序中，如果swap函数使用后面两种方法会出错。由于方法二和方法三没有使用中间变量，它们交换值的原理是直接对变量的内存单元进行操作。<strong>如果两个变量对应的同一内存单元，则经过两次加减或异或操作，内存单元的值已经变为了0，因而不能实现变量值交换</strong>。所以当需要交换值的变量可能是同一变量时，必须使用第三变量实现交换，否则会对变量清零。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="快速排序的介绍">快速排序的介绍</h3><p>快速排序是一种排序算法，对包含n个数的输入数组，最坏的情况运行时间为<strong>Θ(n^2)</strong>[Θ读作theta]。虽然这个最坏情况的运行时间比较差，但快速排序通常是用于排序的最佳的实用选择。这是因为其平均情况下的性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，它还能够进行就地排序，在虚拟内存环境中也能很好的工作。</p>
<p>和归并排序一样，快速排序也是基于<strong>分治法</strong>（Divide and conquer）：]]>
    
    </summary>
    
      <category term="快排" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵原地转置]]></title>
    <link href="http://yoursite.com/2014/04/09/matrix-transpose-inplace/"/>
    <id>http://yoursite.com/2014/04/09/matrix-transpose-inplace/</id>
    <published>2014-04-09T02:06:00.000Z</published>
    <updated>2015-05-09T17:09:52.322Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>微软面试题</strong>：将一个MxN的矩阵存储在一个一维数组中，编程实现矩阵的转置。</p>
<p><strong>要求</strong>：空间复杂度为O(1)<a id="more"></a></p>
<h3 id="思路分析">思路分析</h3><p>下面以一个4x2的矩阵A={1,2,3,4,5,6,7,8}进行分析，转置过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20140606173801500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>图中右下角的红色数字表示在一维数组中的下标。矩阵的转置其实就是数组中元素的移动，具体的移动过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20140606173842187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们发现，这些移动的元素的下标是一个个环，下标1的元素移动到4，下标4的元素移动到2，下标2的元素移动到1。在编写程序的时候，我们需要解决两个问题：第一个是如何判定环是否重复（已处理过）；第二个是如何计算当前元素下标的前驱与后继。</p>
<p><strong>第一个问题</strong>：如何判断环是重复已处理过的？因为我们遍历整个数组时下标是从小到大的，所以如果是第一次遍历该环，则第一个下标肯定是这个环中最小的。如果一个环被处理过，那么总能找到一个它的后继是小于它的。从上图可以明显看出来。</p>
<p><strong>第二个问题</strong>：如何计算当前元素下标的前驱与后继？假设转置前某个元素的数组下标为i，则它所在行列为（i/N, i%N），转置后所在行列则为（i%N, i/N），可计算转置后数组下标为<strong>(i%N)*M+i/N</strong>，此为i的<strong>后继</strong>。假设转置后某个元素的数组下标为i，则它所在行列为（i/M, i%M），则转置前所在行列为（i%M, i/M），可计算此时下标为<strong>(i%M)*N+i/M</strong>，此为i的<strong>前驱</strong>。</p>
<h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: matrix_transpose.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月06日 星期五 14时26分15秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后继 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%n)*m + i/n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前驱 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPre</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%m)*n + i/m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理以下标i为起点的环 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movedata</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = mtx[i];  <span class="comment">// 暂存</span></span><br><span class="line">    <span class="keyword">int</span> cur = i;       <span class="comment">// 当前下标</span></span><br><span class="line">    <span class="keyword">int</span> pre = getPre(cur, m, n);</span><br><span class="line">    <span class="keyword">while</span>(pre != i)</span><br><span class="line">    &#123;</span><br><span class="line">        mtx[cur] = mtx[pre];</span><br><span class="line">        cur = pre;</span><br><span class="line">        pre = getPre(cur, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    mtx[cur] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转置，即循环处理所有环 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> next = getNext(i, m, n);</span><br><span class="line">        <span class="keyword">while</span>(next &gt; i) <span class="comment">// 若存在后继小于i说明重复</span></span><br><span class="line">            next = getNext(next, m, n);</span><br><span class="line">        <span class="keyword">if</span>(next == i)   <span class="comment">// 处理当前环 </span></span><br><span class="line">            movedata(mtx, i, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出矩阵 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)%n == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mtx[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mtx[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[<span class="number">4</span>*<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before matrix transposition:"</span> &lt;&lt; endl;</span><br><span class="line">    print(matrix, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    transpose(matrix, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After matrix transposition:"</span> &lt;&lt; endl;</span><br><span class="line">    print(matrix, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://img.blog.csdn.net/20140606173940156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>微软面试题</strong>：将一个MxN的矩阵存储在一个一维数组中，编程实现矩阵的转置。</p>
<p><strong>要求</strong>：空间复杂度为O(1)]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[变位词问题]]></title>
    <link href="http://yoursite.com/2014/04/08/brother-word/"/>
    <id>http://yoursite.com/2014/04/08/brother-word/</id>
    <published>2014-04-08T13:10:46.000Z</published>
    <updated>2015-05-09T17:04:38.085Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》第二章提到了一个变位词问题，变位词指的是一个单词可以通过改变其他单词中字母的顺序来得到，也叫做兄弟单词，如army-&gt;mary。由变位词可以引申出几个算法问题，包括字符串包含问题，比较两个字符串是否是变位词，以及找出字典中变位词集合的问题。</p>
<h3 id="字符串包含问题">字符串包含问题</h3><p>(1) 问题描述：存在字符串1和字符串2，假设字符串2相对较短，如何快速地判定字符串2中的字符都存在于字符串1里（假定字符串只包含字母）？<a id="more"></a></p>
<p>(2) 举例：字符串1为ABCDEFGHIJK，字符串2为ABCDE，则字符串1包含字符串2，因为字符串2中包含的字母在字符串1中也都有。</p>
<p>(3) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>最直接的思路就是针对字符串2中的每个字符，轮询字符串1进行比较，看是否在字符串1里面。很明显这种的时间效率为<strong>O(n*m)</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;long_str.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(long_str[j] == short_str[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == long_str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEF"</span>;</span><br><span class="line">    Compare(l, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>这里由于假定了字符串只包含字母，所以我们可以用一个额外的数组flag[26]作为26个字符标识位，先遍历长字符串将对应的标识位置1，再遍历短字符串，如果对应的标示位都是1，则包含；否则不包含。<strong>这种方法的时间复杂度为O(n+m)，为了提高空间效率，这里不使用数组而使用26个bit位来作为标示位（bitset容器）</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;26&gt; flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;long_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag.set(n)置第n位为1</span></span><br><span class="line">        flag.<span class="built_in">set</span>(long_str[i]-<span class="string">'A'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag.test(n)判断第n位是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(!flag.test(short_str[i]-<span class="string">'A'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEZ"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(l, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法还可以进行优化，例如如果长字串的前缀就为短字串，那么我们可以不需要n+m次，而只需要2m次。具体实现请自己思考。</p>
<ul>
<li><strong>思路三</strong></li>
</ul>
<p>给每个字母分配一个素数，从2开始到3，5，7…遍历长字串，求得每个字符对应素数的乘积。然后遍历短字串，判断该乘积能否被短字符串中的字符对应的素数整除，如果除的结果存在余数，则说明有不匹配的字母；如果整个过程都没有余数，则说明短字串中的字母在长字串里都有。<strong>这种方法的时间复杂度也是O(n+m)，需要26个额外空间存素数，但是这种方法有一个缺点就是需要跟大整数打交道，因为乘积可能非常大</strong>。（这里我们使用<cstdint>头文件中定义的int64_t和uint64_t）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;cstdint&gt;  // C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> long_str, <span class="built_in">string</span> short_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> primeNum[<span class="number">26</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,</span><br><span class="line">                        <span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="comment">/* int64_t和uint64_t分别表示64位的有符号和无符号整形数 */</span></span><br><span class="line">    <span class="comment">/* 在不同位数机器的平台下通用，都是64位 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> ch = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;long_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch*primeNum[long_str[i]-<span class="string">'A'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;short_str.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch%primeNum[short_str[i]-<span class="string">'A'</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> l = <span class="string">"ABCDEFGHIJK"</span>;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"ABCDEK"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(l, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cstdint></p>
<h3 id="比较两个字符串是否为变位词">比较两个字符串是否为变位词</h3><p>(1) 问题描述：如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，问如何在迅速匹配兄弟字符串（如，bad和adb就是兄弟字符串）。</p>
<p>(2) 注意：第一点中讨论了字符串包含问题，但是不要以为两个字符串互相包含就是（变位词）兄弟字符串了，例如aabcde和edcba互相包含，但它们不是变位词。</p>
<p>(3) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>给每个字母分配一个素数，可以通过判断两个字符串的素数乘积是否相等。跟上述素数法一样，时间复杂度也是O(n+m)，需要跟大整数打交道。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;cstdint&gt; // C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> primeNum[<span class="number">26</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,</span><br><span class="line">                        <span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    <span class="keyword">uint64_t</span> ch = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch*primeNum[s1[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s2.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = ch/primeNum[s2[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abandon"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"banadon"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(s1, s2))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They are brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They aren't brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>将两个字符串按照字母表顺序排序，看排序后的字符串是否相等，如果相等则是兄弟字符串（变位词）。这种方法的时间效率根据你使用的排序算法不同而不同。当然，你可以自己写排序算法，这里我们使用C++的STL中的sort()函数对字符串进行排序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义序函数（二元谓词）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 采用泛型算法对s1,s2排序，sort()采用的是快速排序算法</span></span><br><span class="line">    sort(s1.begin(), s1.end(), myfunction);</span><br><span class="line">    sort(s2.begin(), s2.end(), myfunction);</span><br><span class="line">    <span class="keyword">if</span>(!s1.compare(s2))  <span class="comment">// 相等返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abandon"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"banadon"</span>;</span><br><span class="line">    <span class="keyword">if</span>(Compare(s1, s2))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They are brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"They aren't brother words!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="字典找出所有变位词集合（重点）">字典找出所有变位词集合（重点）</h3><p>(1) 问题描述：给定一个英语字典，找出其中的所有变位词集合。</p>
<p>(2) 解决方案：</p>
<ul>
<li><strong>思路一</strong></li>
</ul>
<p>对于这个问题，最快想到的最直接的方法就是针对每一个单词跟字典中的其他单词进行比较。然而，假设一次比较至少花费1微秒的时间，则拥有二十万单词的字典将花费：<strong>200000单词 x 200000比较/单词 x 1微秒/比较 = 40000x10^6秒 = 40000秒 ≈ 11.1小时</strong>。比较的次数太多了，导致效率低下，我们需要找出效率更高的方法。</p>
<ul>
<li><strong>思路二</strong></li>
</ul>
<p>标识字典中的每一个单词，使得在相同变位词类中的单词具有相同的的标识，然后集中具有相同标识的单词。将每个单词按照字母表排序，排序后得到的字符串作为该单词的标识。那么对于该问题的解题过程可以分为三步：<strong>第一步，读入字典文件，对单词进行排序得到标识；第二步，将所有的单词按照其标识的顺序排序；第三步，将同一个变位词类中的各个单词放到同一行中</strong>。</p>
<p>这里出现了标识-单词（key-value）对，我们很容易想到C++中的关联容器<strong>map</strong>，使用<strong>map</strong>的好处就是：</p>
<ol>
<li><strong>动态管理内存，容器大小动态改变；</strong></li>
<li><strong>单词与它的标识一一对应，对于相同标识(key)的单词直接加在值(value)后面；</strong></li>
<li><strong>无需根据标识排序，因为map会自动按关键字有序（默认升序）</strong>。 </li>
</ol>
<p>所以，在将每个单词及其标识存入map以后，就可以直接遍历输出了，每一个map元素就是一个变位词集合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fstream&gt;    <span class="comment">// file I/O</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;map&gt;        <span class="comment">// map</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;     <span class="comment">// string</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;  <span class="comment">// sort</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *map是C++中的关联容器</span><br><span class="line"> *     按关键字有序</span><br><span class="line"> *     关键字不可重复</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义比较函数（用于排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span><br><span class="line"> *对每个单词排序</span><br><span class="line"> *排序后字符串作为关键字，原单词作为值</span><br><span class="line"> *存入map中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sign_sort</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dic)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 文件流</span></span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(dic)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't open file: "</span> + <span class="built_in">string</span>(dic) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> aword;</span><br><span class="line">    <span class="built_in">string</span> asign;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; aword)</span><br><span class="line">    &#123;</span><br><span class="line">        asign = aword;</span><br><span class="line">        sort(asign.begin(), asign.end(), myfunction);</span><br><span class="line">        <span class="comment">// 若标识不存在，创建一个新map元素，若存在，加在值后面</span></span><br><span class="line">        word[asign] += aword + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *写入输出文件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!out)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't create file: "</span> + <span class="built_in">string</span>(file) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator begin = word.begin();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator end = word.end();</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; begin-&gt;second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dic;  </span><br><span class="line">    <span class="built_in">string</span> outfile;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input dictionary name: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; dic;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input output filename: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; outfile;</span><br><span class="line"></span><br><span class="line">    sign_sort(dic.c_str());</span><br><span class="line">    write_file(outfile.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>附</strong>：（2012.5.6百度实习笔试题）一个单词交换字母位置，可得另一个单词，如army-&gt;mary，成为兄弟单词。提供一个单词，在字典中找到它的兄弟。描述数据结构和查询过程。</p>
<p><strong>解题思路</strong>：如果不允许进行预处理，那么我们只能顺序遍历整个字典，计算每个单词的标识与给定单词的标识比较。如果允许进行预处理，我们可以如上述思路二将所有单词加入一个map，然后输出关键字（给定单词的标识）对应的值，值中就包含了该单词的所有兄弟单词。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》第二章提到了一个变位词问题，变位词指的是一个单词可以通过改变其他单词中字母的顺序来得到，也叫做兄弟单词，如army-&gt;mary。由变位词可以引申出几个算法问题，包括字符串包含问题，比较两个字符串是否是变位词，以及找出字典中变位词集合的问题。</p>
<h3 id="字符串包含问题">字符串包含问题</h3><p>(1) 问题描述：存在字符串1和字符串2，假设字符串2相对较短，如何快速地判定字符串2中的字符都存在于字符串1里（假定字符串只包含字母）？]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一维向量旋转算法]]></title>
    <link href="http://yoursite.com/2014/04/07/vector-rotation/"/>
    <id>http://yoursite.com/2014/04/07/vector-rotation/</id>
    <published>2014-04-07T12:43:09.000Z</published>
    <updated>2015-05-09T16:52:45.288Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》第二章提到了n元一维向量旋转算法（又称数组循环移位算法）的五种思路，并且比较了它们在时间和空间性能上的区别和优劣。</p>
<h3 id="问题描述">问题描述</h3><p>将一个n元一维向量向左旋转i个位置。例如，假设n=8，i=3，向量abcdefgh旋转为向量defghabc。简单的代码使用一个n元的中间向量在n步内可完成该工作。你能否仅使用几十个额外字节的内存空间，在正比于n的时间内完成向量的旋转？<a id="more"></a></p>
<h3 id="解决方案">解决方案</h3><p><strong>思路一</strong>：将向量x中的前i个元素复制到一个临时数组中，接着将余下的n-i个元素左移i个位置，然后再将前i个元素从临时数组中复制到x中余下的位置。<strong>性能：这种方法使用了i个额外的位置，如果i很大则产生了过大的存储空间的消耗。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 17时07分06秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将前i个元素临时保存</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(s, 0, i)</span></span>;</span><br><span class="line">    <span class="comment">// 将剩余的左移i个位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>    j=i; j&lt;s.size(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        s[j-i] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.substr(<span class="number">0</span>, s.size()-i) + tmp;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路二</strong>：定义一个函数将x向左旋转一个位置（其时间正比于n），然后调用该函数i次。<strong>性能：这种方法虽然空间复杂度为O(1)，但产生了过多的运行时间消耗。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate_1.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 19时49分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateOnce</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;s.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i-<span class="number">1</span>] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[i-<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数i次</span></span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rotateOnce(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路三</strong>：移动x[0]到临时变量t中，然后移动x[i]到x[0]中，x[2i]到x[i]，依次类推，直到我们又回到x[0]的位置提取元素，此时改为从临时变量t中提取元素，然后结束该过程（当下标大于n时对n取模或者减去n）。如果该过程没有移动全部的元素，就从x[1]开始再次进行移动，总共移动i和n的最大公约数次。<strong>性能：这种方法非常精巧，像书中所说的一样堪称巧妙的杂技表演。空间复杂度为O(1)，时间复杂度为线性时间，满足问题的性能要求，但还不是最佳。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate_2.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 20时21分59秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧几里德（辗转相除）算法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            i = i%j;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            j = j%i;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 左移个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> times = gcd(s.size(), i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;times; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s[j];</span><br><span class="line">        <span class="keyword">int</span> pre = j; <span class="comment">// 记录上一次的位置</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = pre+i;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= s.size())</span><br><span class="line">                t = t-s.size();</span><br><span class="line">            <span class="keyword">if</span>(t == j) <span class="comment">// 直到tmp原来的位置j为止</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s[pre] = s[t];</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        s[pre] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路四</strong>：旋转向量x实际上就是交换向量ab的两段，得到向量ba，这里a代表x的前i个元素。假设a比b短。将b分割成$b_l$和$b_r$，使$b_r$的长度和a的长度一样。交换a和$b_r$，将$ab_lb_r$转换成$b_rb_la$。因为序列a已在它的最终位置了，所以我们可以集中精力交换b的两个部分了。由于这个新问题和原先的问题是一样的，所以我们以递归的方式进行解决。这种方法可以得到优雅的程序，但是需要巧妙的代码，并且要进行一些思考才能看出它的效率足够高。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></p>
<p><strong>思路五</strong>：（<strong>最佳</strong>）将这个问题看做是把数组ab转换成ba，同时假定我们拥有一个函数可以将数组中特定部分的元素逆序。从ab开始，首先对a求逆，得到$a^r b$，然后对b求逆，得到$a^r b^r$。最后整体求逆，得到$(a^r b^r)^r$，也就是ba。<br>reverse(0, i-1)   /<em>cbadefgh</em>/<br>reverse(i, n-1)  /<em>cbahgfed</em>/<br>reverse(0, n-1) /<em>defghabc</em>/<br><strong>性能：求逆序的方法在时间和空间上都很高效，而且代码非常简短，很难出错。</strong></p>
<p>C++代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: vector_rotate.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月04日 星期三 23时37分54秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = s[begin];</span><br><span class="line">        s[begin] = s[end];</span><br><span class="line">        s[end] = tmp;</span><br><span class="line">        ++begin;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        i = i%s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(s, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">    reverse(s, i, s.size()-<span class="number">1</span>);</span><br><span class="line">    reverse(s, <span class="number">0</span>, s.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span>&lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展延伸">扩展延伸</h3><p><strong>如何将向量abc旋转变成cba？</strong><br>和前面的问题类似，此向量旋转对应着非相邻内存块的交换模型。解法很相似，即利用恒等式：</p>
<p>$$cba = （a^r b^r c^r）^r$$</p>
<p><strong>注</strong>：在面试或笔试时，如若出现向量旋转（内存块交换）问题，最好使用思路五答题，不仅高效而且简洁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》第二章提到了n元一维向量旋转算法（又称数组循环移位算法）的五种思路，并且比较了它们在时间和空间性能上的区别和优劣。</p>
<h3 id="问题描述">问题描述</h3><p>将一个n元一维向量向左旋转i个位置。例如，假设n=8，i=3，向量abcdefgh旋转为向量defghabc。简单的代码使用一个n元的中间向量在n步内可完成该工作。你能否仅使用几十个额外字节的内存空间，在正比于n的时间内完成向量的旋转？]]>
    
    </summary>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[位图排序]]></title>
    <link href="http://yoursite.com/2014/04/06/bitmap-sorting/"/>
    <id>http://yoursite.com/2014/04/06/bitmap-sorting/</id>
    <published>2014-04-06T12:22:42.000Z</published>
    <updated>2015-05-09T16:40:43.567Z</updated>
    <content type="html"><![CDATA[<p>《编程珠玑》里面讲到了一种算法导论里没有提到过的位图排序方法，这种排序方法是<strong>通过牺牲空间效率来追求时间效率（线性时间）以达到时间-空间折中与双赢</strong>的目的。下面简单讲一下我对位图排序思想的理解。</p>
<h3 id="问题描述">问题描述</h3><p>1 . 输入：一个至多包含1千万个非负整数的文件<a id="more"></a></p>
<p>2 . 特征：①每个数都是小于10000000的非负整数；②没有重复的数字；③数据之间不存在关联关系。</p>
<p>3 . 约束：①最多1MB的内存空间可用；②磁盘空间充足；③运行时间最多几分钟，最好是线性时间。</p>
<p>4 .  输出：按升序排列的整数序列。</p>
<h3 id="位图排序思想">位图排序思想</h3><p>由于待排序的数据记录较多，我们单纯地使用常见的排序方法时间效率较低，运行时间会很长。而且内存空间有限（限制为1MB左右），所以我们不能同时把所有整数读入内存（如果每个整数使用7个字节来存储，那么1MB内存空间只能存大约143000个数字）。当然我们可以多次读取输入文件，多次排序，但是更好的方案是使用位图排序，可以使用有限的1MB内存空间并只进行一趟排序。</p>
<p>1 . 根据待排序集合中最大的数，开辟一个位数组，用来表示待排序集合中的整数；</p>
<p>2 . 待排序集合中的数字在位数组中的对应位置置1，其他的置0；</p>
<p><strong>例如，待排序集合{1,2,3,5,8,13}可以表示为：0-1-1-1-0-1-0-0-1-0-0-0-0-1</strong></p>
<p>这样排序过程自然可以分为三步：</p>
<pre><code>第一步：将所有的位都置为0；

第二步：通过读入文件中的每个整数，将每个对应的位都置为1；

第三步：检验每一位，如果该位为1，输出对应的整数。
</code></pre><p><strong>注意</strong>：位图排序是使用一个<strong>二进制位</strong>而不是一个整数来表示0或1，这样可以大大地减少所需要的内存空间。使用位图排序的前提是要知道待排序序列中的最大数。<strong>位图排序的缺点</strong>是有些数没有出现过，仍要为其保留一个位。故位图排序比较适合关键字密集的序列，例如一个城市的电话号码。</p>
<p>伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Phase 1: initialize set to empty*/</span></span><br><span class="line">	<span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line">		bit[i] = <span class="number">0</span></span><br><span class="line"><span class="comment">/*Phase 2: insert present elements into the set*/</span></span><br><span class="line">	<span class="keyword">for</span> each i in the input file</span><br><span class="line">		bit[i] = <span class="number">1</span></span><br><span class="line"><span class="comment">/*Phase 3: write sorted output*/</span></span><br><span class="line">	<span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line">		<span class="keyword">if</span> bit[i] == <span class="number">1</span></span><br><span class="line">			write i on the output file</span><br></pre></td></tr></table></figure></p>
<p><strong>性能</strong>：时间复杂度可达O(n)，1MB包含8<em>1024</em>1024个位，所需内存10000000/(8<em>1024</em>1024)=1.20MB，如果不是严格限制的话可以看做基本符合要求。</p>
<h3 id="位图排序实现">位图排序实现</h3><p>位图排序时，我们需要考虑：给出一个数，如何找到其对应位图的位置，方法就是首先找到该数对应的字节，然后在找到该数对应的位。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bitmap[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/* 可以表示16个数，即0～15 */</span></span><br></pre></td></tr></table></figure></p>
<p>一个字节有八位，5表示第0个字节的第5位上；14表示第1个字节的第6个位上。</p>
<p>在这里<strong>为了简化位处理，我们使用C++标准库的bitset容器。bitset是C++提供的一种位集合的数据结构，它让我们可以像使用数组一样使用位，可以访问指定下标的bit位。和其他容器一样，bitset也是一个模板类。</strong>具体的bitset方法可以查看<a href="http://zh.cppreference.com/w/cpp/utility/bitset" target="_blank" rel="external">std::bitset reference</a>。</p>
<p>下面我们使用bitset容器进行位图排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: BitSort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年06月01日 星期日 23时46分32秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bitset</span>&lt;MAX+1&gt; bit;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 将对应位置置1 */</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bit.<span class="built_in">set</span>(arr[i]);</span><br><span class="line">		<span class="comment">/* bit.set(n)表示将第n位置1 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 输出排序结果 */</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* bit.test(n)判断第n位是否为1 */</span></span><br><span class="line">		<span class="keyword">if</span>(bit.test(i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：0 1 2 5 7 9 10 13 16 20</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《编程珠玑》里面讲到了一种算法导论里没有提到过的位图排序方法，这种排序方法是<strong>通过牺牲空间效率来追求时间效率（线性时间）以达到时间-空间折中与双赢</strong>的目的。下面简单讲一下我对位图排序思想的理解。</p>
<h3 id="问题描述">问题描述</h3><p>1 . 输入：一个至多包含1千万个非负整数的文件]]>
    
    </summary>
    
      <category term="Bitmap" scheme="http://yoursite.com/tags/Bitmap/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[各种内部排序算法的实现]]></title>
    <link href="http://yoursite.com/2014/04/03/implementation-of-internal-sortings/"/>
    <id>http://yoursite.com/2014/04/03/implementation-of-internal-sortings/</id>
    <published>2014-04-03T02:05:19.000Z</published>
    <updated>2015-05-09T16:33:48.363Z</updated>
    <content type="html"><![CDATA[<p>排序算法相信对大家来说都不陌生，或许很多人已经把它们记得滚瓜烂熟，随时可以写出来。是的，这些都是最基本的算法。很惭愧我没有达到那种熟练程度，甚至都快忘了。最近把各种内部排序算法复习了一下，包括插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序。（另：堆排序原理说起来比较长，请看我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/02/dui-pai-xu-de-suan-fa-shi-xian/" target="_blank" rel="external">堆排序的算法实现</a>）<a id="more"></a></p>
<p><strong>C++代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">    &gt; File Name: sort.cpp</span><br><span class="line">    &gt; Author: SongLee</span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com</span><br><span class="line">    &gt; Created Time: 2014年04月27日 星期日 22时28分39秒</span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.io</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;直接插入排序&gt;&gt;</span><br><span class="line"> *    为了实现N个数的排序，将后面N-1个数依次插入到前面已排好的子序列中，</span><br><span class="line"> *假定刚开始第1个数是一个已排好序的子序列。经过N-1趟就能得到一个有序序列。</span><br><span class="line"> *****时间复杂度：最好情况O(n)，最坏情况O(n^2)，平均情况O(n^2).</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	ElementType temp;  <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = A[i]; </span><br><span class="line">		<span class="keyword">for</span>(j = i; j&gt;<span class="number">0</span> &amp;&amp; A[j-<span class="number">1</span>]&gt;temp; --j)</span><br><span class="line">			A[j] = A[j-<span class="number">1</span>];</span><br><span class="line">		A[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;折半插入排序&gt;&gt;</span><br><span class="line"> *    与直接插入排序不同的是，折半插入排序不是边比较边移动，而是将比较和移</span><br><span class="line"> *动操作分离出来，即先折半查找出元素的待插入位置，然后再统一地移动待插入位</span><br><span class="line"> *置之后的所有元素。不难看出折半插入排序仅仅是减少了比较的次数。</span><br><span class="line"> *****时间复杂度：O(n^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">	ElementType temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = A[i];</span><br><span class="line">		low = <span class="number">0</span>; high = i-<span class="number">1</span>;  <span class="comment">// 设置折半查找的范围</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">		&#123;</span><br><span class="line">			mid = (low+high)/<span class="number">2</span>;  <span class="comment">// 取中间点</span></span><br><span class="line">			<span class="keyword">if</span>(A[mid] &gt; temp)</span><br><span class="line">				high = mid-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				low = mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(j=i-<span class="number">1</span>; j&gt;=high+<span class="number">1</span>; --j) <span class="comment">// 统一后移</span></span><br><span class="line">			A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">		A[high+<span class="number">1</span>] = temp;    <span class="comment">// 插入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;希尔排序&gt;&gt;</span><br><span class="line"> *    希尔排序通过比较相距一定间隔的元素，即形如L[i,i+d,i+2d,...i+kd]的序列</span><br><span class="line"> *然后缩小间距，再对各分组序列进行排序。直到只比较相邻元素的最后一趟排序为</span><br><span class="line"> *止，即最后的间距为1。希尔排序有时也叫做*缩小增量排序*</span><br><span class="line"> *****时间复杂度：依赖于增量序列的选择，但最坏情况才为O(N^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, dk;   <span class="comment">// dk是增量</span></span><br><span class="line">    ElementType temp;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(dk=n/<span class="number">2</span>; dk&gt;<span class="number">0</span>; dk/=<span class="number">2</span>)  <span class="comment">// 增量变化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=dk; i&lt;n; ++i)  <span class="comment">// 每个分组序列进行直接插入排序</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp = A[i];</span><br><span class="line">			<span class="keyword">for</span>(j=i-dk; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; j-=dk)</span><br><span class="line">				A[j+dk] = A[j];  <span class="comment">// 后移</span></span><br><span class="line">			A[j+dk] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;冒泡排序&gt;&gt;</span><br><span class="line"> *    冒泡排序的基本思想是从后往前（或从前往后）两两比较相邻元素的值，若为</span><br><span class="line"> *逆序，则交换它们，直到序列比较完。我们称它为一趟冒泡。每一趟冒泡都会将一</span><br><span class="line"> *个元素放置到其最终位置上。</span><br><span class="line"> *****时间复杂度：最好情况O(n)，最坏情况O(n^2)，平均情况O(n^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="keyword">false</span>;   <span class="comment">// 表示本次冒泡是否发生交换的标志</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j) <span class="comment">// 从后往前</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j-<span class="number">1</span>] &gt; A[j]) </span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 交换</span></span><br><span class="line">				A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>]^A[j];</span><br><span class="line">				A[j] = A[j-<span class="number">1</span>]^A[j];</span><br><span class="line">				A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>]^A[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="keyword">false</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;快速排序&gt;&gt;</span><br><span class="line"> *    快速排序是对冒泡排序的一种改进。其基本思想是基于分治法：在待排序表L[n]</span><br><span class="line"> *中任取一个元素pivot作为基准，通过一趟排序将序列划分为两部分L[1...K-1]和</span><br><span class="line"> *L[k+1...n]，是的L[1...k-1]中的所有元素都小于pivot，而L[k+1...n]中所有元素</span><br><span class="line"> *都大于或等于pivot。则pivot放在了其最终位置L(k)上。然后，分别递归地对两个子</span><br><span class="line"> *序列重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终</span><br><span class="line"> *位置上。</span><br><span class="line"> *****时间复杂度：快排的运行时间与划分是否对称有关，最坏情况O(n^2),最好情况</span><br><span class="line"> *O(nlogn),平均情况为O(nlogn)</span><br><span class="line"> *****空间复杂度：由于需要递归工作栈，最坏情况为O(n)，平均情况为O(logn)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 划分操作有很多版本，这里就总以当前表中第一个元素作为枢纽/基准</span></span><br><span class="line">	ElementType pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot)</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];  <span class="comment">// 将比枢纽值小的元素移到左端</span></span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];  <span class="comment">// 将比枢纽值大的元素移到右端</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A[low] = pivot;  <span class="comment">// 枢纽元素放到最终位置</span></span><br><span class="line">	<span class="keyword">return</span> low;      <span class="comment">// 返回枢纽元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)  <span class="comment">// 递归跳出的条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pivotPos = Partition(A, low, high); <span class="comment">// 划分操作，返回基准元素的最终位置</span></span><br><span class="line">		QuickSort(A, low, pivotPos-<span class="number">1</span>);  <span class="comment">// 递归</span></span><br><span class="line">		QuickSort(A, pivotPos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;简单选择排序&gt;&gt;</span><br><span class="line"> *    选择排序的算法思想很简单，假设序列为L[n]，第i趟排序即从L[i...n]中选择</span><br><span class="line"> *关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置。经过n-1</span><br><span class="line"> *趟排序就可以使得序列有序了。</span><br><span class="line"> *****时间复杂度：始终是O(n^2)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectedSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; ++i)  <span class="comment">// 一共进行n-1趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> minPos = i;  <span class="comment">// 记录最小元素的位置</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[minPos])</span><br><span class="line">				minPos = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(minPos != i)  <span class="comment">// 与第i个位置交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[i]^A[minPos];</span><br><span class="line">			A[minPos] = A[i]^A[minPos];</span><br><span class="line">			A[i] = A[i]^A[minPos];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;堆排序&gt;&gt;</span><br><span class="line"> *    堆排序是一种树形选择排序方法，在排序过程中，将L[n]看成是一棵完全二叉</span><br><span class="line"> *树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当</span><br><span class="line"> *前无序区中选择关键字最大（或最小）的元素。堆排序的思路是：首先将序列L[n]</span><br><span class="line"> *的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大</span><br><span class="line"> *值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大根堆的性</span><br><span class="line"> *质，堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。</span><br><span class="line"> *如此重复，直到堆中仅剩下一个元素为止。</span><br><span class="line"> *****时间复杂度：O(nlogn)</span><br><span class="line"> *****空间复杂度：O(1)</span><br><span class="line"> *****稳定性：不稳定</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElementType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType temp = A[i];  <span class="comment">// 暂存A[i]</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])</span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大</span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])</span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[largest];</span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElementType A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, n);       <span class="comment">// 初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// n-1趟的交换和建堆过程 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输出最大的堆顶元素（和堆底元素交换）</span></span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[i] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		<span class="comment">// 调整，把剩余的n-1个元素整理成堆</span></span><br><span class="line">		AdjustDown(A, <span class="number">0</span>, i);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *&lt;&lt;2-路归并排序&gt;&gt;</span><br><span class="line"> *    顾名思义，2-路归并就是将2个有序表组合成一个新的有序表。假定待排序表</span><br><span class="line"> *有n个元素，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并...不</span><br><span class="line"> *停重复，直到合成一个长度为n的有序序列为止。Merge()函数是将前后相邻的两个</span><br><span class="line"> *有序表归并为一个有序表，设A[low...mid]和A[mid+1...high]存放在同一顺序表的</span><br><span class="line"> *相邻位置上，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个元素</span><br><span class="line"> *进行比较，将较小者放入A中。</span><br><span class="line"> *****时间复杂度：每一趟归并为O(n),共log2n趟，所以时间为O(nlog2n)</span><br><span class="line"> *****空间复杂度：O(n)</span><br><span class="line"> *****稳定性：稳定</span><br><span class="line"> */</span></span><br><span class="line">ElementType *B = <span class="keyword">new</span> ElementType[<span class="number">13</span>];  <span class="comment">// 和数组A一样大</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span>(k=low; k&lt;=high; ++k)</span><br><span class="line">		B[k] = A[k];             <span class="comment">// 将A中所有元素复制到B</span></span><br><span class="line">	<span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i; i&lt;=mid&amp;&amp;j&lt;=high; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(B[i] &lt;= B[j])      <span class="comment">// 比较B的左右两段序列中的元素</span></span><br><span class="line">			A[k] = B[i++];    <span class="comment">// 将较小值复制到A中</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A[k] = B[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)  A[k++] = B[i++];   <span class="comment">// 若第一个表未检测完，复制</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high) A[k++] = B[j++];   <span class="comment">// 若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">		MergeSort(A, low, mid);       <span class="comment">// 对左侧子序列进行递归排序</span></span><br><span class="line">		MergeSort(A, mid+<span class="number">1</span>, high);    <span class="comment">// 对右侧子序列进行递归排序</span></span><br><span class="line">		Merge(A, low, mid, high);     <span class="comment">// 归并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 输出函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 主函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType Arr[<span class="number">13</span>] = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">	<span class="comment">//InsertSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//BinaryInsertSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//ShellSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//BubbleSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//QuickSort(Arr, 0, 12);</span></span><br><span class="line">	<span class="comment">//SelectedSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//HeapSort(Arr, 13);</span></span><br><span class="line">	<span class="comment">//MergeSort(Arr, 0, 12);</span></span><br><span class="line">	print(Arr, <span class="number">13</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序算法相信对大家来说都不陌生，或许很多人已经把它们记得滚瓜烂熟，随时可以写出来。是的，这些都是最基本的算法。很惭愧我没有达到那种熟练程度，甚至都快忘了。最近把各种内部排序算法复习了一下，包括插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序。（另：堆排序原理说起来比较长，请看我的另一篇文章：<a href="http://songlee24.github.io/blog/2014/04/02/dui-pai-xu-de-suan-fa-shi-xian/">堆排序的算法实现</a>）]]>
    
    </summary>
    
      <category term="内部排序" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆排序的算法实现]]></title>
    <link href="http://yoursite.com/2014/04/02/heap-sort-implementation/"/>
    <id>http://yoursite.com/2014/04/02/heap-sort-implementation/</id>
    <published>2014-04-02T01:41:35.000Z</published>
    <updated>2015-05-09T16:28:59.939Z</updated>
    <content type="html"><![CDATA[<p>由于堆排序算法说起来比较长，所以在这里单独讲一下。堆排序是一种树形选择排序方法，它的特点是：在排序过程中，将L[n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 </p>
<h3 id="堆的定义">堆的定义</h3><p><strong>堆的定义</strong>如下：n个关键字序列L[n]成为堆，当且仅当该序列满足：①L(i) &lt;= L(2i)且L(i) &lt;= L(2i+1)  或者  ②L(i) &gt;= L(2i)且L(i) &gt;= L(2i+1)   其中i属于[1, n/2]。<a id="more"></a></p>
<p>满足第①种情况的堆称为<strong>小根堆</strong>（小顶堆），满足第②种情况的堆称为<strong>大根堆</strong>（大顶堆）。在大根堆中，最大元素存放在根结点中，且对任一非根结点，它的值小于或等于其双亲结点值。小根堆则恰恰相反，小根堆的根结点存放的是最小元素。例如{16, 14, 10, 8, 7, 9, 3, 2}表示的大根堆： </p>
<p><img src="http://img.blog.csdn.net/20140501182414140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="构造初始堆">构造初始堆</h3><p>堆排序的关键就是构造初始堆。n个结点的完全二叉树中，最后一个结点是第n/2（向下取整）个结点的孩子。所以构造初始堆的流程是：对第n/2（向下取整）个结点为根的子树进行筛选（以大根堆为例，若根结点的关键字小于左右子女中关键字的较大者，则交换），使该子树成为堆。之后向前依次对从n/2-1到1的各结点为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不是，将左右子结点中较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。 </p>
<p><strong>由于在数组中下标从0开始，所以在堆中i的左子结点为2<em>i+1，右子结点为2</em>i+2。</strong>下面是将某个结点i向下调整建堆的算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElementType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType temp = A[i];  <span class="comment">// 暂存A[i]</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])</span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大</span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])</span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[largest];</span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建堆，从n/2（向下取整）到1依次对各结点向下调整，当然由于数组下标从0开始，所以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElementType A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆排序">堆排序</h3><p>构造初始堆成功以后，堆排序的思路就很简单了：首先将存放在L[n]中的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大根堆的性质，堆被破坏。这时将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩下一个元素为止。算法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, n);       <span class="comment">// 初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// n-1趟的交换和建堆过程 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输出最大的堆顶元素（和堆底元素交换）</span></span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[i] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		<span class="comment">// 调整，把剩余的n-1个元素整理成堆</span></span><br><span class="line">		AdjustDown(A, <span class="number">0</span>, i);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能">性能</h3><ul>
<li><p><strong>时间复杂度</strong>：向下调整的时间与树高有关，为O(h)。可以证明在元素个数为n的序列上建堆，其时间复杂度为O(n)。之后还有n-1次向下调整操作，每次调整的时间为O(h)，故在最好，最坏和平均情况下，堆排序的时间复杂度为O(nlogn)。</p>
</li>
<li><p><strong>空间复杂度</strong>：仅使用了常数个辅助单元，空间复杂度为O(1)。</p>
</li>
<li><p><strong>稳定性</strong>：不稳定。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于堆排序算法说起来比较长，所以在这里单独讲一下。堆排序是一种树形选择排序方法，它的特点是：在排序过程中，将L[n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 </p>
<h3 id="堆的定义">堆的定义</h3><p><strong>堆的定义</strong>如下：n个关键字序列L[n]成为堆，当且仅当该序列满足：①L(i) &lt;= L(2i)且L(i) &lt;= L(2i+1)  或者  ②L(i) &gt;= L(2i)且L(i) &gt;= L(2i+1)   其中i属于[1, n/2]。]]>
    
    </summary>
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树遍历序列的求解]]></title>
    <link href="http://yoursite.com/2014/04/01/binary-tree-sequence/"/>
    <id>http://yoursite.com/2014/04/01/binary-tree-sequence/</id>
    <published>2014-04-01T15:45:35.000Z</published>
    <updated>2015-05-09T16:23:32.636Z</updated>
    <content type="html"><![CDATA[<h2 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h2><p><img src="http://img.blog.csdn.net/20140320230233703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><a id="more"></a></p>
<p>上面为一个二叉树，可知它的遍历序列分别为：</p>
<ul>
<li>先序遍历：ABDECFG</li>
<li>中序遍历：DBEAFCG</li>
<li>后序遍历：DEBFGCA</li>
</ul>
<p><strong>我们需要知道的是</strong>，由二叉树的<strong>先序序列</strong> 和 <strong>中序序列</strong>可以唯一地确定一棵二叉树；由二叉树的<strong>后序序列</strong> 和 <strong>中序序列</strong>也可以唯一地确定一棵二叉树；但是如果只知道先序序列和后序序列，则无法唯一确定一棵二叉树。</p>
<h2 id="已知二叉树的先序序列和中序序列，求后序序列。">已知二叉树的先序序列和中序序列，求后序序列。</h2><p>因为由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树，所以进而可以唯一地确定它的后序遍历。在先序遍历序列中，第一个结点一定是二叉树的根结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列就是左子树的中序序列，后一个子序列就是右子树的中序序列。根据这两个子序列的长度，可以在先序序列中找到对应的左子树先序序列和右子树先序序列。而左子树先序序列的第一个结点是左子树的根结点，右子树先序序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p>
<p><strong>C++代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">	&gt; File Name: Test.cpp</span><br><span class="line">	&gt; Author: SongLee</span><br><span class="line">	&gt; E-mail: lisong.shine@qq.com </span><br><span class="line">	&gt; Created Time: 2014年03月20日 星期四 17时11分31秒</span><br><span class="line">	&gt; Personal Blog: http://songlee24.github.com/</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right;</span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* PostOrderFromOrderings(<span class="keyword">char</span>* inorder, <span class="keyword">char</span>* preorder, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    node-&gt;elem = *preorder;</span><br><span class="line">    <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; rootIndex &lt; length; rootIndex++)  <span class="comment">// 求左子树的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[rootIndex] == *preorder)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = PostOrderFromOrderings(inorder, preorder + <span class="number">1</span>, rootIndex);</span><br><span class="line">    node-&gt;right = PostOrderFromOrderings(inorder + rootIndex + <span class="number">1</span>, preorder + rootIndex + <span class="number">1</span>, length - (rootIndex + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;elem &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 求后序序列，所以最后输出根结点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pre = <span class="string">"ABDECFG"</span>;</span><br><span class="line">    <span class="keyword">char</span>* in = <span class="string">"DBEAFCG"</span>;</span><br><span class="line">    PostOrderFromOrderings(in, pre, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="已知二叉树的后序序列和中序序列，求先序序列。">已知二叉树的后序序列和中序序列，求先序序列。</h2><p>同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树，所以进而可以唯一地确定先序遍历序列。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分。 </p>
<p><strong>C++代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">	&gt; File Name: Test1.cpp</span><br><span class="line">	&gt; Author: SongLee</span><br><span class="line">	&gt; E-mail: lisong.shine@qq.com </span><br><span class="line">	&gt; Created Time: 2014年03月20日 星期四 21时56分57秒</span><br><span class="line">	&gt; Personal Blog: http://songlee24.github.com/</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right;</span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* PreOrderFromOrderings(<span class="keyword">char</span>* inorder, <span class="keyword">char</span>* postorder, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    node-&gt;elem = postorder[length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; rootIndex &lt; length; rootIndex++)   <span class="comment">// 求左子树的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[rootIndex] == postorder[length-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;elem &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 求先序序列，所以先输出根结点</span></span><br><span class="line">    node-&gt;left = PreOrderFromOrderings(inorder, postorder, rootIndex);</span><br><span class="line">    node-&gt;right = PreOrderFromOrderings(inorder + rootIndex + <span class="number">1</span>, postorder + rootIndex, length - (rootIndex + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* post = <span class="string">"DEBFGCA"</span>;</span><br><span class="line">    <span class="keyword">char</span>* in = <span class="string">"DBEAFCG"</span>;</span><br><span class="line">    PreOrderFromOrderings(in, post, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h2><p><img src="http://img.blog.csdn.net/20140320230233703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">]]>
    
    </summary>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <link href="http://yoursite.com/2014/03/12/observer-pattern/"/>
    <id>http://yoursite.com/2014/03/12/observer-pattern/</id>
    <published>2014-03-12T10:25:10.000Z</published>
    <updated>2015-05-09T16:17:01.989Z</updated>
    <content type="html"><![CDATA[<p>观察者模式（Observer）：定义了对象之间的一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>实现观察者模式的方法有多种，但是以包含Subject与Observer接口的类设计的做法最常见，下面看看观察者模式的类图： <a id="more"></a></p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/QQ622A56FE20140312104632_zpsf43cb29b.png" alt=""></p>
<p>主题（Subject）是真正拥有数据的人，观察者则是主题的依赖者，在主题数据变化时接收通知并更新。这样比起让许多对象控制同一份数据来，可以得到更干净的OO设计。 </p>
<p>主题与观察者之间是松耦合的，它们可以交互，但不知道彼此的细节。比如对于观察者，主题只知道观察者实现了某个接口，主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现Observer接口的对象列表；同样的，我们也可以在任何时候删除某些观察者。因为松耦合的关系，改变主题或观察者其中一方，并不会影响另一方。<strong>松耦合的设计能让我们建立有弹性的OO系统以应对变化，因为对象之间的互相依赖降到了最低。</strong></p>
<p>下面就以经典的气象监测问题为例，说说观察者模式的应用： </p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/111_zpsdf5328e6.png" alt=""></p>
<p>此气象站系统只包括三个部分：气象站、WeatherData对象、布告板。</p>
<p>工作的流程：WeatherData对象从气象站获取最新的测量数据（温度、湿度、气压），并及时更新到三个布告板（显示装置）上。 </p>
<p>假设从气象站获取数据的方法已经实现好了，那么我们只需要考虑如何将新的数据更新到三个布告板上，而且要尽量实现系统可拓展，让其他开发人员可以定制布告板，用户可以任意的添加或删除布告板，那么我们如何建立这个系统呢？</p>
<p>当然是使用观察者模式，这里的WeatherData类正是观察者模式中的“一”，即主题；而布告板就是“多”，即观察者；这样就建立起了一对多的依赖关系。WeatherData对象是真正拥有数据的一方，包括温度、湿度、气压，当这些值改变时，必须通知所有的布告板，好让它们各自做出处理。在这里，布告板作为Observer为了获取数据，必须先向WeatherData对象注册，一旦WeatherData知道有某个布告板的存在，就会适时地调用布告板的某个公共的接口（例如. update）来告诉布告板观测值是多少。由于update()方法是所有布告板公共的接口，所以需要在布告板的基类（Java中说接口）中定义。下面是设计图：</p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/112_zps9079588e.png" alt=""></p>
<ul>
<li>WeatherData实现主题（Subject）接口</li>
<li>布告板实现观察者（Observer）接口，这样主题在需要通知观察者时，就有了一个共同的接口</li>
<li>同时还为布告板建立一个共同的接口DisplayElement，用于实现display()方法</li>
<li>每个布告板中应该声明一个Subject接口类对象</li>
</ul>
<h2 id="C++实现：">C++实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subject接口类</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Subject   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observer接口类</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> Observer  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类 用于display</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeatherData实现Subject接口</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Subject.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WeatherData : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WeatherData(<span class="keyword">void</span>);</span><br><span class="line">    ~WeatherData(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="comment">// 以下方法用于从气象台获取数据，这里不予考虑</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeatherData.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::registerObserver( Observer* o )</span><br><span class="line">&#123;</span><br><span class="line">    observers.push_back(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::removeObserver( Observer* o )</span><br><span class="line">&#123;</span><br><span class="line">    observers.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::notifyObserver()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Observer*&gt;::iterator iterator=observers.begin(); observers.end()!=iterator; ++iterator)</span><br><span class="line">    &#123;</span><br><span class="line">        Observer* observer = *iterator;</span><br><span class="line">        observer-&gt;update(temperature, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::measurementsChanged()</span><br><span class="line">&#123;</span><br><span class="line">    notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::setMeasurements( <span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">    <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pressure = pressure;</span><br><span class="line">    measurementsChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getTemperature()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> temperature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getHumidity()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> humidity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getPressure()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pressure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “目前状况”布告板 实现观察者接口</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CurrentConditionsDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CurrentConditionsDisplay(Subject* weatherData);</span><br><span class="line">    ~CurrentConditionsDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CurrentConditionsDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CurrentConditionsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay::CurrentConditionsDisplay( Subject* weatherData )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay::~CurrentConditionsDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentConditionsDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;temperature = temp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentConditionsDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf( ios::showpoint );</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Current conditions: "</span>  &lt;&lt; temperature;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" F degrees and "</span> &lt;&lt; humidity;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"% humidity"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据统计布告板</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StatisticsDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Subject* weatherData;</span><br><span class="line">    <span class="keyword">float</span> maxTemp;</span><br><span class="line">    <span class="keyword">float</span> minTemp;</span><br><span class="line">    <span class="keyword">float</span> tempSum;</span><br><span class="line">    <span class="keyword">int</span> numReadings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StatisticsDisplay(Subject* weatherData);</span><br><span class="line">    ~StatisticsDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// StatisticsDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "StatisticsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">StatisticsDisplay::StatisticsDisplay(Subject* weatherData)</span><br><span class="line">&#123;</span><br><span class="line">    maxTemp = <span class="number">0.0</span>;      <span class="comment">// 记录最高温</span></span><br><span class="line">    minTemp = <span class="number">200.0F</span>;   <span class="comment">// 记录最低温</span></span><br><span class="line">    tempSum = <span class="number">0.0</span>;      <span class="comment">// 温度和，用于计算平均温度</span></span><br><span class="line">    numReadings = <span class="number">0</span>;    <span class="comment">// 次数，用于计算平均温度</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatisticsDisplay::~StatisticsDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StatisticsDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    tempSum += temp;</span><br><span class="line">    numReadings++;</span><br><span class="line">    <span class="keyword">if</span>( temp &gt; maxTemp ) &#123;</span><br><span class="line">        maxTemp = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( temp &lt; minTemp ) &#123;</span><br><span class="line">        minTemp = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StatisticsDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf( ios::showpoint );</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Avg/Max/Min temperature = "</span> &lt;&lt; ( tempSum / numReadings );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"/"</span> &lt;&lt; maxTemp &lt;&lt; <span class="string">"/"</span> &lt;&lt; minTemp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 天气预报布告板</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ForecastDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> currentPressure;</span><br><span class="line">    <span class="keyword">float</span> lastPressure;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ForecastDisplay(Subject* weatherData);</span><br><span class="line">    ~ForecastDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForecastDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ForecastDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ForecastDisplay::ForecastDisplay(Subject* weatherData)</span><br><span class="line">&#123;</span><br><span class="line">    currentPressure = <span class="number">29.92F</span>;  <span class="comment">// 假设现在的</span></span><br><span class="line">    lastPressure = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForecastDisplay::~ForecastDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ForecastDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    lastPressure = currentPressure;</span><br><span class="line">    currentPressure = pressure;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ForecastDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Forecast: "</span>;</span><br><span class="line">    <span class="keyword">if</span>( currentPressure &gt; lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Improving weather on the way!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( currentPressure == lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"More of the same"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( currentPressure &lt; lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Watch out for cooler, rainy weather"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序入口WeatherStation.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CurrentConditionsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ForecastDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "StatisticsDisplay.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WeatherData* weatherData = <span class="keyword">new</span> WeatherData;</span><br><span class="line"></span><br><span class="line">    CurrentConditionsDisplay* cu = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">    StatisticsDisplay* st = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">    ForecastDisplay* fo = <span class="keyword">new</span> ForecastDisplay(weatherData);</span><br><span class="line">    <span class="comment">// 更新数据，这里手动模拟</span></span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span> );</span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span> );</span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span> );</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：">运行结果：</h3><p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/20140312_zpsacbd0ec3.jpeg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>观察者模式（Observer）：定义了对象之间的一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>实现观察者模式的方法有多种，但是以包含Subject与Observer接口的类设计的做法最常见，下面看看观察者模式的类图：]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Basic-设计模式" scheme="http://yoursite.com/categories/Basic-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单例模式]]></title>
    <link href="http://yoursite.com/2014/03/11/singleton-pattern/"/>
    <id>http://yoursite.com/2014/03/11/singleton-pattern/</id>
    <published>2014-03-11T14:36:58.000Z</published>
    <updated>2015-05-09T16:05:52.922Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2><p>单件模式（SingletonPattern）：确保一个类只有一个实例，并提供一个全局访问点。和全局变量一样方便，又没有全局变量的缺点，即不需要从一开始就创建对象，而是在需要时才创建它。</p>
<p><strong><em>那么要如何保证一个类只能被实例化一次呢？</em></strong>一般情况下，如果存在一个类，我们都是可以多次地实例化它的。那么如果这样呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>咦？构造函数私有？含有私有的构造器的类应该是不能被其他类实例化的，因为只有MyClass内部的代码才能调用这个私有的构造函数。虽然只有MyClass类的实例才能调用MyClass构造器，但在这之前，必须有一个MyClass实例。然而这个类又不能被实例化，这样就产生了矛盾！</p>
<p>看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示MyClass有一个静态方法，我们可以这样调用这个方法：MyClass.getInstance(); 因为getInstance()是一个静态方法，换句话说，是一个“类”方法。引用一个静态方法，你需要使用类名，而不是对象名。</p>
<p>那么把上面两段代码合在一起，是否就可以使MyClass只产生一个实例了呢？</p>
<p><strong>看下面的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">       <span class="comment">//利用一个静态变量来记录MyClass类的唯一实例</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> MyClass uniqueInstance;</span><br><span class="line">       <span class="comment">//私有构造函数，只有自MyClass类内才可以调用</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       <span class="comment">//用getInstance静态方法实例化对象，并返回</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                      uniqueInstance = <span class="keyword">new</span> MyClass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当然，单件类也是一个正常的类，具有其他的变量和方法</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个经典的单件模式的实现！之所以实例唯一，是因为单件类没有公开的构造器，其他类不能自行将其实例化得到一个实例，而必须通过它的静态方法getInstance()去创建一个实例。</p>
<p><img src="http://img.blog.csdn.net/20140312224101968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="C++代码实现：">C++代码实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Singleton&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="keyword">static</span> Singleton* uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* getInstance();</span><br><span class="line">    <span class="comment">// other methods...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"Singleton.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Singleton::Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~Singleton()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == NULL)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">    uniqueInstance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == NULL)&#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"Singleton.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::uniqueInstance = NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::getInstance();</span><br><span class="line">    Singleton* singleton2 = Singleton::getInstance();</span><br><span class="line">    <span class="keyword">if</span>(singleton1 == singleton2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got same singleton!!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Oh,no!got a different singleton!!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2><p>单件模式（SingletonPattern）：确保一个类只有一个实例，并提供一个全局访问点。和全局变量一样方便，又没有全局变量的缺点，即不需要从一开始就创建对象，而是在需要时才创建它。</p>
<p><strong><em>那么要如何保证一个类只能被实例化一次呢？</em></strong>一般情况下，如果存在一个类，我们都是可以多次地实例化它的。那么如果这样呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Basic-设计模式" scheme="http://yoursite.com/categories/Basic-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>