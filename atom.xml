<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Man]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-09T16:28:59.939Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[堆排序的算法实现]]></title>
    <link href="http://yoursite.com/2014/04/02/heap-sort-implementation/"/>
    <id>http://yoursite.com/2014/04/02/heap-sort-implementation/</id>
    <published>2014-04-02T01:41:35.000Z</published>
    <updated>2015-05-09T16:28:59.939Z</updated>
    <content type="html"><![CDATA[<p>由于堆排序算法说起来比较长，所以在这里单独讲一下。堆排序是一种树形选择排序方法，它的特点是：在排序过程中，将L[n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 </p>
<h3 id="堆的定义">堆的定义</h3><p><strong>堆的定义</strong>如下：n个关键字序列L[n]成为堆，当且仅当该序列满足：①L(i) &lt;= L(2i)且L(i) &lt;= L(2i+1)  或者  ②L(i) &gt;= L(2i)且L(i) &gt;= L(2i+1)   其中i属于[1, n/2]。<a id="more"></a></p>
<p>满足第①种情况的堆称为<strong>小根堆</strong>（小顶堆），满足第②种情况的堆称为<strong>大根堆</strong>（大顶堆）。在大根堆中，最大元素存放在根结点中，且对任一非根结点，它的值小于或等于其双亲结点值。小根堆则恰恰相反，小根堆的根结点存放的是最小元素。例如{16, 14, 10, 8, 7, 9, 3, 2}表示的大根堆： </p>
<p><img src="http://img.blog.csdn.net/20140501182414140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="构造初始堆">构造初始堆</h3><p>堆排序的关键就是构造初始堆。n个结点的完全二叉树中，最后一个结点是第n/2（向下取整）个结点的孩子。所以构造初始堆的流程是：对第n/2（向下取整）个结点为根的子树进行筛选（以大根堆为例，若根结点的关键字小于左右子女中关键字的较大者，则交换），使该子树成为堆。之后向前依次对从n/2-1到1的各结点为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不是，将左右子结点中较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。 </p>
<p><strong>由于在数组中下标从0开始，所以在堆中i的左子结点为2<em>i+1，右子结点为2</em>i+2。</strong>下面是将某个结点i向下调整建堆的算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElementType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ElementType temp = A[i];  <span class="comment">// 暂存A[i]</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])</span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大</span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])</span><br><span class="line">		&#123;</span><br><span class="line">			A[i] = A[largest];</span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建堆，从n/2（向下取整）到1依次对各结点向下调整，当然由于数组下标从0开始，所以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElementType A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆排序">堆排序</h3><p>构造初始堆成功以后，堆排序的思路就很简单了：首先将存放在L[n]中的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大根堆的性质，堆被破坏。这时将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩下一个元素为止。算法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, n);       <span class="comment">// 初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// n-1趟的交换和建堆过程 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输出最大的堆顶元素（和堆底元素交换）</span></span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[i] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		A[<span class="number">0</span>] = A[<span class="number">0</span>]^A[i];</span><br><span class="line">		<span class="comment">// 调整，把剩余的n-1个元素整理成堆</span></span><br><span class="line">		AdjustDown(A, <span class="number">0</span>, i);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能">性能</h3><ul>
<li><p><strong>时间复杂度</strong>：向下调整的时间与树高有关，为O(h)。可以证明在元素个数为n的序列上建堆，其时间复杂度为O(n)。之后还有n-1次向下调整操作，每次调整的时间为O(h)，故在最好，最坏和平均情况下，堆排序的时间复杂度为O(nlogn)。</p>
</li>
<li><p><strong>空间复杂度</strong>：仅使用了常数个辅助单元，空间复杂度为O(1)。</p>
</li>
<li><p><strong>稳定性</strong>：不稳定。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于堆排序算法说起来比较长，所以在这里单独讲一下。堆排序是一种树形选择排序方法，它的特点是：在排序过程中，将L[n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 </p>
<h3 id="堆的定义">堆的定义</h3><p><strong>堆的定义</strong>如下：n个关键字序列L[n]成为堆，当且仅当该序列满足：①L(i) &lt;= L(2i)且L(i) &lt;= L(2i+1)  或者  ②L(i) &gt;= L(2i)且L(i) &gt;= L(2i+1)   其中i属于[1, n/2]。]]>
    
    </summary>
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树遍历序列的求解]]></title>
    <link href="http://yoursite.com/2014/04/01/binary-tree-sequence/"/>
    <id>http://yoursite.com/2014/04/01/binary-tree-sequence/</id>
    <published>2014-04-01T15:45:35.000Z</published>
    <updated>2015-05-09T16:23:32.636Z</updated>
    <content type="html"><![CDATA[<h2 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h2><p><img src="http://img.blog.csdn.net/20140320230233703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><a id="more"></a></p>
<p>上面为一个二叉树，可知它的遍历序列分别为：</p>
<ul>
<li>先序遍历：ABDECFG</li>
<li>中序遍历：DBEAFCG</li>
<li>后序遍历：DEBFGCA</li>
</ul>
<p><strong>我们需要知道的是</strong>，由二叉树的<strong>先序序列</strong> 和 <strong>中序序列</strong>可以唯一地确定一棵二叉树；由二叉树的<strong>后序序列</strong> 和 <strong>中序序列</strong>也可以唯一地确定一棵二叉树；但是如果只知道先序序列和后序序列，则无法唯一确定一棵二叉树。</p>
<h2 id="已知二叉树的先序序列和中序序列，求后序序列。">已知二叉树的先序序列和中序序列，求后序序列。</h2><p>因为由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树，所以进而可以唯一地确定它的后序遍历。在先序遍历序列中，第一个结点一定是二叉树的根结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列就是左子树的中序序列，后一个子序列就是右子树的中序序列。根据这两个子序列的长度，可以在先序序列中找到对应的左子树先序序列和右子树先序序列。而左子树先序序列的第一个结点是左子树的根结点，右子树先序序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p>
<p><strong>C++代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">	&gt; File Name: Test.cpp</span><br><span class="line">	&gt; Author: SongLee</span><br><span class="line">	&gt; E-mail: lisong.shine@qq.com </span><br><span class="line">	&gt; Created Time: 2014年03月20日 星期四 17时11分31秒</span><br><span class="line">	&gt; Personal Blog: http://songlee24.github.com/</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right;</span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* PostOrderFromOrderings(<span class="keyword">char</span>* inorder, <span class="keyword">char</span>* preorder, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    node-&gt;elem = *preorder;</span><br><span class="line">    <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; rootIndex &lt; length; rootIndex++)  <span class="comment">// 求左子树的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[rootIndex] == *preorder)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = PostOrderFromOrderings(inorder, preorder + <span class="number">1</span>, rootIndex);</span><br><span class="line">    node-&gt;right = PostOrderFromOrderings(inorder + rootIndex + <span class="number">1</span>, preorder + rootIndex + <span class="number">1</span>, length - (rootIndex + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;elem &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 求后序序列，所以最后输出根结点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pre = <span class="string">"ABDECFG"</span>;</span><br><span class="line">    <span class="keyword">char</span>* in = <span class="string">"DBEAFCG"</span>;</span><br><span class="line">    PostOrderFromOrderings(in, pre, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="已知二叉树的后序序列和中序序列，求先序序列。">已知二叉树的后序序列和中序序列，求先序序列。</h2><p>同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树，所以进而可以唯一地确定先序遍历序列。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分。 </p>
<p><strong>C++代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span><br><span class="line">	&gt; File Name: Test1.cpp</span><br><span class="line">	&gt; Author: SongLee</span><br><span class="line">	&gt; E-mail: lisong.shine@qq.com </span><br><span class="line">	&gt; Created Time: 2014年03月20日 星期四 21时56分57秒</span><br><span class="line">	&gt; Personal Blog: http://songlee24.github.com/</span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* left;</span><br><span class="line">    <span class="keyword">struct</span> TreeNode* right;</span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* PreOrderFromOrderings(<span class="keyword">char</span>* inorder, <span class="keyword">char</span>* postorder, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    node-&gt;elem = postorder[length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; rootIndex &lt; length; rootIndex++)   <span class="comment">// 求左子树的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[rootIndex] == postorder[length-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;elem &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 求先序序列，所以先输出根结点</span></span><br><span class="line">    node-&gt;left = PreOrderFromOrderings(inorder, postorder, rootIndex);</span><br><span class="line">    node-&gt;right = PreOrderFromOrderings(inorder + rootIndex + <span class="number">1</span>, postorder + rootIndex, length - (rootIndex + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* post = <span class="string">"DEBFGCA"</span>;</span><br><span class="line">    <span class="keyword">char</span>* in = <span class="string">"DBEAFCG"</span>;</span><br><span class="line">    PreOrderFromOrderings(in, post, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h2><p><img src="http://img.blog.csdn.net/20140320230233703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">]]>
    
    </summary>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <link href="http://yoursite.com/2014/03/12/observer-pattern/"/>
    <id>http://yoursite.com/2014/03/12/observer-pattern/</id>
    <published>2014-03-12T10:25:10.000Z</published>
    <updated>2015-05-09T16:17:01.989Z</updated>
    <content type="html"><![CDATA[<p>观察者模式（Observer）：定义了对象之间的一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>实现观察者模式的方法有多种，但是以包含Subject与Observer接口的类设计的做法最常见，下面看看观察者模式的类图： <a id="more"></a></p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/QQ622A56FE20140312104632_zpsf43cb29b.png" alt=""></p>
<p>主题（Subject）是真正拥有数据的人，观察者则是主题的依赖者，在主题数据变化时接收通知并更新。这样比起让许多对象控制同一份数据来，可以得到更干净的OO设计。 </p>
<p>主题与观察者之间是松耦合的，它们可以交互，但不知道彼此的细节。比如对于观察者，主题只知道观察者实现了某个接口，主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现Observer接口的对象列表；同样的，我们也可以在任何时候删除某些观察者。因为松耦合的关系，改变主题或观察者其中一方，并不会影响另一方。<strong>松耦合的设计能让我们建立有弹性的OO系统以应对变化，因为对象之间的互相依赖降到了最低。</strong></p>
<p>下面就以经典的气象监测问题为例，说说观察者模式的应用： </p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/111_zpsdf5328e6.png" alt=""></p>
<p>此气象站系统只包括三个部分：气象站、WeatherData对象、布告板。</p>
<p>工作的流程：WeatherData对象从气象站获取最新的测量数据（温度、湿度、气压），并及时更新到三个布告板（显示装置）上。 </p>
<p>假设从气象站获取数据的方法已经实现好了，那么我们只需要考虑如何将新的数据更新到三个布告板上，而且要尽量实现系统可拓展，让其他开发人员可以定制布告板，用户可以任意的添加或删除布告板，那么我们如何建立这个系统呢？</p>
<p>当然是使用观察者模式，这里的WeatherData类正是观察者模式中的“一”，即主题；而布告板就是“多”，即观察者；这样就建立起了一对多的依赖关系。WeatherData对象是真正拥有数据的一方，包括温度、湿度、气压，当这些值改变时，必须通知所有的布告板，好让它们各自做出处理。在这里，布告板作为Observer为了获取数据，必须先向WeatherData对象注册，一旦WeatherData知道有某个布告板的存在，就会适时地调用布告板的某个公共的接口（例如. update）来告诉布告板观测值是多少。由于update()方法是所有布告板公共的接口，所以需要在布告板的基类（Java中说接口）中定义。下面是设计图：</p>
<p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/112_zps9079588e.png" alt=""></p>
<ul>
<li>WeatherData实现主题（Subject）接口</li>
<li>布告板实现观察者（Observer）接口，这样主题在需要通知观察者时，就有了一个共同的接口</li>
<li>同时还为布告板建立一个共同的接口DisplayElement，用于实现display()方法</li>
<li>每个布告板中应该声明一个Subject接口类对象</li>
</ul>
<h2 id="C++实现：">C++实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subject接口类</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Subject   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observer接口类</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> Observer  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类 用于display</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeatherData实现Subject接口</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Subject.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WeatherData : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WeatherData(<span class="keyword">void</span>);</span><br><span class="line">    ~WeatherData(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="comment">// 以下方法用于从气象台获取数据，这里不予考虑</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeatherData.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::registerObserver( Observer* o )</span><br><span class="line">&#123;</span><br><span class="line">    observers.push_back(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::removeObserver( Observer* o )</span><br><span class="line">&#123;</span><br><span class="line">    observers.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::notifyObserver()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Observer*&gt;::iterator iterator=observers.begin(); observers.end()!=iterator; ++iterator)</span><br><span class="line">    &#123;</span><br><span class="line">        Observer* observer = *iterator;</span><br><span class="line">        observer-&gt;update(temperature, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::measurementsChanged()</span><br><span class="line">&#123;</span><br><span class="line">    notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::setMeasurements( <span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">    <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pressure = pressure;</span><br><span class="line">    measurementsChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getTemperature()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> temperature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getHumidity()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> humidity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> WeatherData::getPressure()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pressure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “目前状况”布告板 实现观察者接口</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CurrentConditionsDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CurrentConditionsDisplay(Subject* weatherData);</span><br><span class="line">    ~CurrentConditionsDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CurrentConditionsDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CurrentConditionsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay::CurrentConditionsDisplay( Subject* weatherData )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay::~CurrentConditionsDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentConditionsDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;temperature = temp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentConditionsDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf( ios::showpoint );</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Current conditions: "</span>  &lt;&lt; temperature;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" F degrees and "</span> &lt;&lt; humidity;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"% humidity"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据统计布告板</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StatisticsDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Subject* weatherData;</span><br><span class="line">    <span class="keyword">float</span> maxTemp;</span><br><span class="line">    <span class="keyword">float</span> minTemp;</span><br><span class="line">    <span class="keyword">float</span> tempSum;</span><br><span class="line">    <span class="keyword">int</span> numReadings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StatisticsDisplay(Subject* weatherData);</span><br><span class="line">    ~StatisticsDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// StatisticsDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "StatisticsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">StatisticsDisplay::StatisticsDisplay(Subject* weatherData)</span><br><span class="line">&#123;</span><br><span class="line">    maxTemp = <span class="number">0.0</span>;      <span class="comment">// 记录最高温</span></span><br><span class="line">    minTemp = <span class="number">200.0F</span>;   <span class="comment">// 记录最低温</span></span><br><span class="line">    tempSum = <span class="number">0.0</span>;      <span class="comment">// 温度和，用于计算平均温度</span></span><br><span class="line">    numReadings = <span class="number">0</span>;    <span class="comment">// 次数，用于计算平均温度</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatisticsDisplay::~StatisticsDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StatisticsDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    tempSum += temp;</span><br><span class="line">    numReadings++;</span><br><span class="line">    <span class="keyword">if</span>( temp &gt; maxTemp ) &#123;</span><br><span class="line">        maxTemp = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( temp &lt; minTemp ) &#123;</span><br><span class="line">        minTemp = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> StatisticsDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf( ios::showpoint );</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Avg/Max/Min temperature = "</span> &lt;&lt; ( tempSum / numReadings );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"/"</span> &lt;&lt; maxTemp &lt;&lt; <span class="string">"/"</span> &lt;&lt; minTemp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 天气预报布告板</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Observer.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DisplayElement.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ForecastDisplay : <span class="keyword">public</span> Observer, <span class="keyword">public</span> DisplayElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> currentPressure;</span><br><span class="line">    <span class="keyword">float</span> lastPressure;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ForecastDisplay(Subject* weatherData);</span><br><span class="line">    ~ForecastDisplay(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForecastDisplay.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ForecastDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ForecastDisplay::ForecastDisplay(Subject* weatherData)</span><br><span class="line">&#123;</span><br><span class="line">    currentPressure = <span class="number">29.92F</span>;  <span class="comment">// 假设现在的</span></span><br><span class="line">    lastPressure = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weatherData = weatherData;    <span class="comment">// 构造器中注册为观察者</span></span><br><span class="line">    weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ForecastDisplay::~ForecastDisplay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    weatherData-&gt;removeObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ForecastDisplay::update( <span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure )</span><br><span class="line">&#123;</span><br><span class="line">    lastPressure = currentPressure;</span><br><span class="line">    currentPressure = pressure;</span><br><span class="line">    display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ForecastDisplay::display()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Forecast: "</span>;</span><br><span class="line">    <span class="keyword">if</span>( currentPressure &gt; lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Improving weather on the way!"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( currentPressure == lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"More of the same"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( currentPressure &lt; lastPressure ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Watch out for cooler, rainy weather"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序入口WeatherStation.cpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WeatherData.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CurrentConditionsDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ForecastDisplay.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "StatisticsDisplay.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WeatherData* weatherData = <span class="keyword">new</span> WeatherData;</span><br><span class="line"></span><br><span class="line">    CurrentConditionsDisplay* cu = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">    StatisticsDisplay* st = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">    ForecastDisplay* fo = <span class="keyword">new</span> ForecastDisplay(weatherData);</span><br><span class="line">    <span class="comment">// 更新数据，这里手动模拟</span></span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span> );</span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span> );</span><br><span class="line">    weatherData-&gt;setMeasurements( <span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span> );</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：">运行结果：</h3><p><img src="http://i1329.photobucket.com/albums/w545/SongLee24/20140312_zpsacbd0ec3.jpeg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>观察者模式（Observer）：定义了对象之间的一对多关系，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>实现观察者模式的方法有多种，但是以包含Subject与Observer接口的类设计的做法最常见，下面看看观察者模式的类图：]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Basic-设计模式" scheme="http://yoursite.com/categories/Basic-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单例模式]]></title>
    <link href="http://yoursite.com/2014/03/11/singleton-pattern/"/>
    <id>http://yoursite.com/2014/03/11/singleton-pattern/</id>
    <published>2014-03-11T14:36:58.000Z</published>
    <updated>2015-05-09T16:05:52.922Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2><p>单件模式（SingletonPattern）：确保一个类只有一个实例，并提供一个全局访问点。和全局变量一样方便，又没有全局变量的缺点，即不需要从一开始就创建对象，而是在需要时才创建它。</p>
<p><strong><em>那么要如何保证一个类只能被实例化一次呢？</em></strong>一般情况下，如果存在一个类，我们都是可以多次地实例化它的。那么如果这样呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>咦？构造函数私有？含有私有的构造器的类应该是不能被其他类实例化的，因为只有MyClass内部的代码才能调用这个私有的构造函数。虽然只有MyClass类的实例才能调用MyClass构造器，但在这之前，必须有一个MyClass实例。然而这个类又不能被实例化，这样就产生了矛盾！</p>
<p>看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示MyClass有一个静态方法，我们可以这样调用这个方法：MyClass.getInstance(); 因为getInstance()是一个静态方法，换句话说，是一个“类”方法。引用一个静态方法，你需要使用类名，而不是对象名。</p>
<p>那么把上面两段代码合在一起，是否就可以使MyClass只产生一个实例了呢？</p>
<p><strong>看下面的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">       <span class="comment">//利用一个静态变量来记录MyClass类的唯一实例</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> MyClass uniqueInstance;</span><br><span class="line">       <span class="comment">//私有构造函数，只有自MyClass类内才可以调用</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       <span class="comment">//用getInstance静态方法实例化对象，并返回</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                      uniqueInstance = <span class="keyword">new</span> MyClass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当然，单件类也是一个正常的类，具有其他的变量和方法</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个经典的单件模式的实现！之所以实例唯一，是因为单件类没有公开的构造器，其他类不能自行将其实例化得到一个实例，而必须通过它的静态方法getInstance()去创建一个实例。</p>
<p><img src="http://img.blog.csdn.net/20140312224101968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="C++代码实现：">C++代码实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Singleton&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="keyword">static</span> Singleton* uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* getInstance();</span><br><span class="line">    <span class="comment">// other methods...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"Singleton.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Singleton::Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~Singleton()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == NULL)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">    uniqueInstance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == NULL)&#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"Singleton.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::uniqueInstance = NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::getInstance();</span><br><span class="line">    Singleton* singleton2 = Singleton::getInstance();</span><br><span class="line">    <span class="keyword">if</span>(singleton1 == singleton2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got same singleton!!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Oh,no!got a different singleton!!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2><p>单件模式（SingletonPattern）：确保一个类只有一个实例，并提供一个全局访问点。和全局变量一样方便，又没有全局变量的缺点，即不需要从一开始就创建对象，而是在需要时才创建它。</p>
<p><strong><em>那么要如何保证一个类只能被实例化一次呢？</em></strong>一般情况下，如果存在一个类，我们都是可以多次地实例化它的。那么如果这样呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Basic-设计模式" scheme="http://yoursite.com/categories/Basic-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>