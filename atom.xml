<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SongLee's Blog]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-10T11:50:29.559Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【Linux编程】进程间通信（IPC）]]></title>
    <link href="http://yoursite.com/2015/04/21/linux-IPC/"/>
    <id>http://yoursite.com/2015/04/21/linux-IPC/</id>
    <published>2015-04-21T12:51:21.000Z</published>
    <updated>2015-05-10T11:50:29.559Z</updated>
    <content type="html"><![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。<a id="more"></a></p>
<h3 id="1、特点：">1、特点：</h3><ol>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ol>
<h3 id="2、原型：">2、原型：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[2])</span></span>;    <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150419222058628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>要关闭管道只需将这两个文件描述符关闭即可。</p>
<h3 id="3、例子">3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150419223853807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">		read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="二、FIFO">二、FIFO</h2><p><strong>FIFO</strong>，也称为命名管道，它是一种文件类型。</p>
<h3 id="1、特点">1、特点</h3><ol>
<li><p>FIFO可以在无关的进程之间交换数据，与无名管道不同。</p>
</li>
<li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
</li>
</ol>
<h3 id="2、原型">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p>
<p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p>
<ul>
<li><p>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p>
</li>
<li><p>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p>
</li>
</ul>
<h3 id="3、例子-1">3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</p>
<ul>
<li><p><strong>write_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;   <span class="comment">// exit</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;    <span class="comment">// O_WRONLY</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;time.h&gt;     <span class="comment">// time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	time_t tp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO </span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">		n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">		<span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">		perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./write_fifo </span><br><span class="line">I am <span class="number">5954</span> <span class="keyword">process</span>.</span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./read_fifo </span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p><br><br><br>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p>
<p><img src="http://img.blog.csdn.net/20150420131002360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><br></p>
<h2 id="三、消息队列">三、消息队列</h2><p><strong>消息队列</strong>，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<h3 id="1、特点-1">1、特点</h3><ol>
<li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ol>
<h3 id="2、原型-1">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(key_t key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p>
<ul>
<li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li>
<li>key参数为<code>IPC_PRIVATE</code>。</li>
</ul>
<p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p>
<ul>
<li><code>type == 0</code>，返回队列中的第一个消息；</li>
<li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li>
<li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li>
</ul>
<p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p>
<h3 id="3、例子-2">3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p>
<ul>
<li><p><strong>msg_server.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环读取消息</span></span><br><span class="line">	<span class="keyword">for</span>(;;) </span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">		msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">		<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">		msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msg_client.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加消息，类型为888</span></span><br><span class="line">	msg.mtype = <span class="number">888</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">	msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取类型为777的消息</span></span><br><span class="line">	msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="四、信号量">四、信号量</h2><p><strong>信号量（semaphore）</strong>与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<h3 id="1、特点-2">1、特点</h3><ol>
<li><p>信号量用于进程间同步，若要在进程间传递数据需要结合<em>共享内存</em>。</p>
</li>
<li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p>
</li>
<li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
</li>
<li><p>支持信号量组。</p>
</li>
</ol>
<h3 id="2、原型-2">2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做<strong>二值信号量（Binary Semaphore）</strong>。而可以取多个正整数的信号量被称为通用信号量。</p>
<p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(key_t key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], size_t numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 。</p>
<p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sembuf </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 sem_op 是一次操作中的信号量的改变量：</p>
<ul>
<li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们。</p>
</li>
<li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p>
<ul>
<li>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</li>
<li>当相应的资源数不能满足请求时，这个操作与<code>sem_flg</code>有关。<ul>
<li>sem_flg 指定<code>IPC_NOWAIT</code>，则semop函数出错返回<code>EAGAIN</code>。</li>
<li>sem_flg 没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p>
<ul>
<li>当信号量已经为0，函数立即返回。</li>
<li>如果信号量的值不为0，则依据<code>sem_flg</code>决定函数动作：<ul>
<li>sem_flg指定<code>IPC_NOWAIT</code>，则出错返回<code>EAGAIN</code>。</li>
<li>sem_flg没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR  </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p>
<ul>
<li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li>
<li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li>
</ul>
<h3 id="3、例子-3">3、例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">	<span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	tmp.val = value;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//	若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//	若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//	释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//	如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">	key_t key;  </span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">	init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">		del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p>
<p><br></p>
<h2 id="五、共享内存">五、共享内存</h2><p><strong>共享内存（Shared Memory）</strong>，指两个或多个进程共享一个给定的存储区。</p>
<h3 id="1、特点-3">1、特点</h3><ol>
<li><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>
</li>
<li><p>因为多个进程可以同时操作，所以需要进行同步。</p>
</li>
<li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p>
</li>
</ol>
<h3 id="2、原型-3">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(key_t key, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="keyword">void</span> *shmat(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag);</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p>
<p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p>
<p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p>
<p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p>
<h3 id="3、例子-4">3、例子</h3><p>下面这个例子，使用了<strong>【共享内存+信号量+消息队列】</strong>的组合来实现服务器进程与客户进程间的通信。</p>
<ul>
<li>共享内存用来传递数据；</li>
<li>信号量用来同步；</li>
<li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li>
</ul>
<p><strong>Server.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(key_t key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">	<span class="keyword">struct</span> shmid_ds buf1;  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">	<span class="keyword">struct</span> msqid_ds buf2;  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量</span></span><br><span class="line">	semid = creat_sem(key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span> </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			sem_p(semid);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">			sem_v(semid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">	shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">	msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">	del_sem(semid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Client.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取信号量</span></span><br><span class="line">	<span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 写数据</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">		<span class="keyword">switch</span>(c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">				sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">				sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">				msg.mtype = <span class="number">888</span>;  </span><br><span class="line">				msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">				msg.mtype = <span class="number">888</span>;</span><br><span class="line">				msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br></pre></td></tr></table></figure></p>
<p>注释已经很详细了，所以代码的其他部分我就不解释了，下面是运行结果截图：</p>
<p><img src="http://img.blog.csdn.net/20150421203538923" alt=""></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可利用空间表（Free List）]]></title>
    <link href="http://yoursite.com/2015/04/08/free-list/"/>
    <id>http://yoursite.com/2015/04/08/free-list/</id>
    <published>2015-04-08T03:11:00.000Z</published>
    <updated>2015-05-10T11:47:00.859Z</updated>
    <content type="html"><![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br><a id="more"></a><br>为了避免频繁的new/delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从free list中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p>
<p>要求：</p>
<ol>
<li>实现一个对固定大小内存块进行管理的通用FreeList类，给出定义和实现。要求不能使用STL中的容器类。定义类的接口和实现时注意通用性、健壮性和可测试性。</li>
<li>如果该类的对象可能会被多个thread同时访问，请描述如何怎样保证线程安全。有没有办法在保证线程安全的同时尽可能增大并发度？如果有也请描述你的思路。</li>
</ol>
</blockquote>
<p><br></p>
<h3 id="一、介绍">一、介绍</h3><p>“可利用空间表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即<strong>可利用空间表（free list）</strong>。</p>
<p>当用户请求分配时，系统从可利用空间表中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到可利用空间表中，因此，可利用空间表亦称为“存储池”。</p>
<p>可利用空间表有三种结点结构：</p>
<ol>
<li><p><strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。</p>
</li>
<li><p><strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。</p>
</li>
<li><p><strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即可利用空间表中只有一个大小为整个存储区的结点。随着分配和回收的进行，可利用空间表的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是可利用空间表中的任一结点都能满足，而需要按照申请的长度在可利用空间表中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略：</p>
<ul>
<li><p><strong>首次适配法</strong>：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）</p>
</li>
<li><p><strong>最佳适配法</strong>：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）</p>
</li>
<li><p><strong>最差适配法</strong>：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）</p>
</li>
</ul>
</li>
</ol>
<p>三种分配策略适合于不同的情况，<code>首次适配法</code>的优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足 —— 这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。<code>最佳适配法</code>的优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统。<code>最差适配法</code>的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</p>
<p><br></p>
<h3 id="二、C++实现">二、C++实现</h3><p>根据题目要求，实现一个对固定大小内存块进行管理的通用FreeList类，即结点大小相同。其实这是最简单的一种实现，注意几个实现要点：</p>
<ul>
<li><p>一个静态成员指针static FreeList* freelist，用来指向可利用空间表。</p>
</li>
<li><p>重载 new 和 delete。</p>
</li>
</ul>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">class</span> FreeList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> FreeList&lt;Elem&gt; *freelist;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Elem element;</span><br><span class="line">	FreeList *next;</span><br><span class="line">	FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next=NULL);</span><br><span class="line">	FreeList(FreeList* next=NULL);</span><br><span class="line">	<span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>;    <span class="comment">// 重载new</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;   <span class="comment">// 重载delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;* FreeList&lt;Elem&gt;::freelist = NULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;element = elem;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span>* FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*freelist没有可用空间，就从系统分配*/</span></span><br><span class="line">	<span class="keyword">if</span>(freelist == NULL)  </span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">new</span> FreeList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*否则，从freelist表头摘取结点*/</span></span><br><span class="line">	FreeList&lt;Elem&gt;* temp = freelist;</span><br><span class="line">	freelist = freelist-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span> FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*把要释放的结点空间加入到freelist中*/</span></span><br><span class="line">	((FreeList&lt;Elem&gt;*)ptr)-&gt;next = freelist;</span><br><span class="line">	freelist = (FreeList&lt;Elem&gt;*)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>至于线程安全的问题，在多线程的环境下，线程同步的方式有多种：临界区、事件、互斥量、信号量。比如，我们可以把访问该类对象的代码段设置为 Critical Section，这样同一时间就只有一个线程可以执行这段代码。为了尽可能增大并发度，更好的方式是将代码改造成对临界数据的保护而不是对临界代码的保护，这样就可以令不会同时访问相同临界数据的线程完全并行地执行。</p>
<p>这是我个人的观点，如果你有更好的想法，欢迎交流和指正！</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br>]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2051-最小的K个数（Top K问题）]]></title>
    <link href="http://yoursite.com/2015/03/21/hua-wei-OJ2051/"/>
    <id>http://yoursite.com/2015/03/21/hua-wei-OJ2051/</id>
    <published>2015-03-21T11:36:34.000Z</published>
    <updated>2015-05-10T11:39:10.276Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组<a id="more"></a></li>
</ol>
<p><strong>输出：</strong></p>
<p>输出一个整数数组</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 5 7 2</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、Top_K问题">二、Top K问题</h1><p>对于 Top K 问题有很多种解法。</p>
<h2 id="解法一：排序">解法一：排序</h2><p>相信很多人会首先想到这种方法，先把数组按升序/降序进行排序，然后输出 K 个最小/最大的数。</p>
<ul>
<li>常规的排序方法时间复杂度至少是$Θ(nlog_2n)$。（<a href="http://songlee24.github.io/2014/04/03/implementation-of-internal-sortings/" target="_blank" rel="external">快排或堆排序</a>）</li>
<li>可能你会说，我们可以使用<a href="http://songlee24.github.io/2014/06/22/linear-sorting-algorithms/" target="_blank" rel="external">线性时间的排序算法</a>。当然可以，但通常它们对输入的数组有一定的要求。比如计数排序要求 n 个数都是正整数，且它们的取值范围不太大。</li>
</ul>
<h2 id="解法二：部分排序_$O(n*k)$">解法二：部分排序 $O(n*k)$</h2><p>由于我们只需要找出最小/最大的 k 个数，所以我们可以进行部分排序，比如<strong>简单选择排序</strong> 和 <strong>冒泡排序</strong>，它们每一趟都能把一个最小/最大元素放在最终位置上，所以进行 k 趟就能把 n 个数中的前 k 个排序出来。</p>
<p>部分简单选择排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123; <span class="comment">// k趟</span></span><br><span class="line">		<span class="keyword">int</span> Min = i;         <span class="comment">// 记录最小元素的位置</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[Min])</span><br><span class="line">				Min = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Min != i)  <span class="comment">// 与A[i]交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[Min];</span><br><span class="line">			A[Min] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>部分冒泡排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)  <span class="comment">// k趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j)  <span class="comment">// 一趟冒泡过程</span></span><br><span class="line">			<span class="keyword">if</span>(A[j-<span class="number">1</span>] &gt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = A[j-<span class="number">1</span>];</span><br><span class="line">				A[j-<span class="number">1</span>] = A[j];</span><br><span class="line">				A[j] = tmp;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="keyword">false</span>)  <span class="comment">// 已经有序</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，$O(nlog_2n)$ 与 $O(n*k)$ 哪一个更好呢？这取决于 k 的大小。在 k 较小的情况下，即 $k &lt;= log_2n$，可以选择部分排序。</p>
<h2 id="解法三：快排划分_$O(n*log_2k)$">解法三：快排划分 $O(n*log_2k)$</h2><p>根据基于快排<code>partition</code>操作的《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/33419201" target="_blank" rel="external">第k顺序统计量的求解</a>》，我们知道，当我们求出第 k 顺序统计量时，位于它前面的元素都比它小，位于它后面的元素都比它大。这时，数组的前 k 个数就是最小的 k 个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[high]&gt;=pivot)</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[low]&lt;=pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(low == high)</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = partition(A, low, high);</span><br><span class="line">	<span class="keyword">int</span> i = pos - low + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">		<span class="keyword">return</span> pos;  <span class="comment">// 返回前k个数的</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; k)</span><br><span class="line">		<span class="keyword">return</span> topK(A, low, pos, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> topK(A, pos+<span class="number">1</span>, high, k-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们说这个算法的平均时间复杂度是线性的，更准确地说，是 $O(n∗log_2k)$。另外，为了避免特殊数据下的算法退化，最好使用随机化版本的划分操作。</p>
<h2 id="解法四：大根堆_$O(n∗log_2k)$">解法四：大根堆 $O(n∗log_2k)$</h2><p>参见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/24846247" target="_blank" rel="external">堆排序</a>》，可以用大小为 k 的大根堆来存储最小的 k 个数。大根堆的堆顶元素就是最小 k 个数中最大的一个。每次新考虑一个数 X：</p>
<ul>
<li><p>如果 X 比堆顶的元素 Y 大，则不需要改变原来的堆，因为这个元素比最小的 k 个数都大。</p>
</li>
<li><p>如果 X 比堆顶元素 Y 小，那么用 X 替换堆顶的元素 Y。在 X 替换堆顶元素 Y 之后，大根堆的结构可能被破坏，需要进行向下调整。调整过程的时间复杂度是 $O(log_2k)$ 。</p>
</li>
</ul>
<p>遍历完成以后，数组的前 k 个数就是最小的 k 个数，但是它们并非有序，而是以堆的形式存在。C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> temp = A[i];  <span class="comment">// 暂存A[i]  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])  </span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大  </span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])  </span><br><span class="line">		&#123;  </span><br><span class="line">			A[i] = A[largest];  </span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置  </span></span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 维护 A[0...k-1] 这个大根堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, k);  <span class="comment">// 先用前面的k个数建大根堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i] &lt; A[<span class="number">0</span>])  <span class="comment">// 如果小于堆顶元素，替换之</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[<span class="number">0</span>];</span><br><span class="line">			A[<span class="number">0</span>] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">			AdjustDown(A, <span class="number">0</span>, k);  <span class="comment">// 向下调整</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：找最小的 $k$ 个数，就维护一个大根堆；找最大的 $k$ 个数，就维护一个小根堆。</p>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>第二部分已经讲解地很清楚了，几种解法都可以，只要注意输入输出的格式就行了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ1964-求解立方根（牛顿迭代法）]]></title>
    <link href="http://yoursite.com/2015/03/20/hua-wei-OJ1964/"/>
    <id>http://yoursite.com/2015/03/20/hua-wei-OJ1964/</id>
    <published>2015-03-20T11:32:16.000Z</published>
    <updated>2015-05-10T11:35:27.608Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<ul>
<li>计算一个数字的立方根，不使用库函数。</li>
<li>函数原型<code>double getCubeRoot(double input)</code></li>
</ul>
<p><strong>输入：</strong><a id="more"></a></p>
<p>待求解参数 double类型</p>
<p><strong>输出：</strong></p>
<p>输出参数的立方根，保留一位小数</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">216</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.0</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、解题报告">二、解题报告</h1><p>本题要求一个数的立方根的近似值，精确到小数点后的一位。这里使用 <a href="http://baike.baidu.com/view/643093.htm" target="_blank" rel="external"><strong>牛顿迭代法</strong></a> 求近似值。</p>
<p>牛顿迭代法，又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），<strong>它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法</strong>。多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x) = 0$的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程$f(x) = 0$的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。另外该方法广泛用于计算机编程中。</p>
<p>设 $r$ 是的根，选取 $x_0$ 作为 $r$ 的初始近似值：</p>
<ul>
<li><p>过点$(x_0,f(x_0))$做曲线$y=f(x)$的切线L，L的方程为 $y=f(x_0)+f’(x_0)(x-x_0)$，求出L与x轴交点的横坐标 $x_1 = x_0-\frac{f(x_0)}{f’(x_0)}$，称 $x_1$为 $r$ 的一次近似值。</p>
</li>
<li><p>过点 $(x_1,f(x_1))$ 做曲线 $y=f(x)$ 的切线，并求该切线与x轴交点的横坐标 $x_2 = x_1-\frac{f(x_1)}{f’(x_1)}$，称 $x_2$ 为 $r$ 的二次近似值。</p>
</li>
<li><p>重复以上过程，得 $r$ 的近似值序列。其中， $x_{n+1} = x_n-\frac{f(x_n)}{f’(x_n)}$ 称为 $r$ 的 $n+1$ 次近似值，上式称为<strong>牛顿迭代公式</strong>。</p>
</li>
</ul>
<hr>
<p>首先确定我们的函数 $f(x)$：</p>
<p>$$f(x) = x^3 - m$$</p>
<p>其中 $m$ 是一个常数，程序的输入。求导函数：</p>
<p>$$f’(x) = 3x^2$$</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> E 0.01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> num)</span> <span class="comment">// 函数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x*x-num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> _f(<span class="keyword">double</span> x)  <span class="comment">// 导函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>*x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getCubeRoot</span><span class="params">(<span class="keyword">double</span> input)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x0;  </span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		x0 = r;</span><br><span class="line">		r = x0 - f(x0,input)/_f(x0);</span><br><span class="line">	&#125; <span class="keyword">while</span>(f(r,input) &gt; E || f(r,input) &lt; -E);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">double</span> result = getCubeRoot(x); </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<ul>
<li>计算一个数字的立方根，不使用库函数。</li>
<li>函数原型<code>double getCubeRoot(double input)</code></li>
</ul>
<p><strong>输入：</strong>]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2288-合唱队（最长递增子序列）]]></title>
    <link href="http://yoursite.com/2015/03/19/hua-wei-OJ2288/"/>
    <id>http://yoursite.com/2015/03/19/hua-wei-OJ2288/</id>
    <published>2015-03-19T11:26:41.000Z</published>
    <updated>2015-05-10T11:31:34.675Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K) 。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。<a id="more"></a></p>
<p><strong>输入：</strong></p>
<p>第一行整数 N，表示同学的总数<br>第二行整数数组，空格隔开，表示 N 位同学身高</p>
<p><strong>输出：</strong></p>
<p>最少需要几位同学出列</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">186 186 150 200 160 130 197 200</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、最长递增子序列">二、最长递增子序列</h1><p><strong>最长递增子序列（Longest Increasing Subsequence）</strong>是指找到一个给定序列的最长子序列的长度，使得子序列中的所有元素单调递增。</p>
<p>例如：{ 3，5，7，1，2，8 }  的 LIS 是 { 3，5，7，8 }，长度为 4。</p>
<h2 id="解法一：转化为求最长公共子序列">解法一：转化为求最长公共子序列</h2><p>其实可以把 求最长递增子序列问题 转化为 求最长公共子序列的问题。</p>
<ul>
<li>设数组 { 3， 5， 7， 1， 2， 8 } 为 A</li>
<li>对数组 A 排序，排序后的数组为 B = { 1， 2， 3， 5， 7， 8 }。</li>
<li>于是，求数组 A 的最长递增子序列，就是求数组 A 与数组 B 的最长公共子序列。</li>
</ul>
<p>最长公共子序列的求法见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/41548557" target="_blank" rel="external">动态规划DP</a>》。本方法的时间复杂度是 </p>
<p>$$Θ(nlgn)+ Θ(n^2) = Θ(n^2)$$</p>
<h2 id="解法二：动态规划法">解法二：动态规划法</h2><p>虽然解法一也是使用动态规划，但是与解法一不同的是，解法二不进行转化，而是直接在原问题上采用动态规划法。</p>
<p><strong>最优子结构：</strong></p>
<p>对于长度为 N 的数组 $A[N] = { a<em>0, a_1, a_2, …, a</em>{n-1}}$，假设我们想求以 $a_i$ 结尾的最大递增子序列长度，设为$L[i]$，那么</p>
<p>$$<br>L[i] =<br>\begin{cases}<br>max(L[j]) + 1,  &amp; \text{where $j &lt; i$ and $A[j] &lt; A[i]$} \[2ex]<br>1, &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
<p>也就是 $j$ 的范围是 0 到 $i–1$。这样，想求 $a_i$ 结尾的最大递增子序列的长度，我们就需要遍历 $i$ 之前的所有位置 $j$（0到 i-1），找出$A[j] &lt; A[i]$，计算这些 $j$ 中，能产生最大 $L[j]$ 的 $j$，之后就可以求出 $L[i]$。之后对每一个$A[N]$中的元素都计算以他们各自结尾的最大递增子序列的长度，这些长度的最大值，就是我们要求的问题——数组$A$的最大递增子序列的长度。</p>
<p><strong>重叠子问题：</strong></p>
<p>根据上述推导式采用递归实现的话，有些子问题会被计算很多次。</p>
<p><strong>动态规划法：</strong></p>
<p>综上所述，LIS 问题具有动态规划需要的两个性质，可以使用动态规划求解该问题。设数组 A = { 3，5，7，1，2，8 }，则：</p>
<center><br><img src="http://img.blog.csdn.net/20150424101652021" alt=""><br></center>

<p>具体的打表方式如下：</p>
<ul>
<li>初始化对角线为 1；</li>
<li>对每一个 i，遍历 j（0 到 i-1）：<ul>
<li>若<code>A[i] &lt;= A[j]</code>，置 1。</li>
<li>若<code>A[i] &gt; A[j]</code>，取第 j 行的<strong>最大值</strong>加 1。</li>
</ul>
</li>
</ul>
<p>打完表以后，最后一行的最大值就是最长递增子序列的长度。由于每次都进行遍历，故时间复杂度还是 $Θ(n^2)$ 。</p>
<p>通常在实现的时候我们不会创建一整个表，因为这样太浪费空间。由打表的过程可知，我们只需要一个一维数组来保存每一行的最大值即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LIS 的动态规划方式实现</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLISLength</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* 一维数组 */</span></span><br><span class="line">   <span class="keyword">int</span>* lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化为1 */</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">      lis[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 计算每个i对应的lis最大值，即打表的过程 */</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)     <span class="comment">// 0到i-1</span></span><br><span class="line">         <span class="keyword">if</span> ( A[i] &gt; A[j] &amp;&amp; lis[i] &lt; lis[j]+<span class="number">1</span>)</span><br><span class="line">            lis[i] = lis[j] + <span class="number">1</span>;  <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 数组中最大的那个，就是最长递增子序列的长度 */</span></span><br><span class="line">   <span class="keyword">int</span> maxlis = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> ( maxlis &lt; lis[i] )</span><br><span class="line">         maxlis = lis[i];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> [] lis;</span><br><span class="line">   <span class="keyword">return</span> maxlis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; getLISLength(arr, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三：Θ(nlgn)的方案">解法三：Θ(nlgn)的方案</h2><p>本解法的具体操作如下：</p>
<ul>
<li>开一个栈，依次读取数组元素 x 与栈顶元素 top：<ul>
<li>如果 x &gt; top，将 x 入栈；</li>
<li>如果 x &lt; top，则二分查找栈中第一个 大于等于x 的数，并用 x 替换它。</li>
</ul>
</li>
</ul>
<p>遍历结束之后，最长递增序列长度即为栈的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLISLength</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 模拟栈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.size()==<span class="number">0</span> || v.back()&lt;A[i])</span><br><span class="line">			v.push_back(A[i]);</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">// 二分查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> mid, low=<span class="number">0</span>, high=v.size()-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">			&#123;</span><br><span class="line">				mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(v[mid] &lt; A[i])</span><br><span class="line">					low = mid + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					high = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v[low] = A[i];  <span class="comment">// 替换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了二分搜索，故时间复杂度变成了 $Θ(nlgn)$。</p>
<p>特别注意的是：本方法<strong>只能</strong>用于求最长递增子序列的长度，千万不要以为栈中的序列就是最长递增子序列：</p>
<ul>
<li><p>例一：原序列为1，5，8，3，6，7<br>栈为1，5，8，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6；再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。</p>
</li>
<li><p>例二：原序列为1，5，8，3<br>则最终栈为1，3，8。明显这不是最长递增子序列！</p>
</li>
</ul>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>根据题意可知，我们需要求出一个“中间点”，使得其左边的【最长递增子序列】和其右边的【最长递减子序列】之和最大。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">	<span class="keyword">int</span> *A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lis[i]表示以A[i]为结尾的最长递增子序列的长度</span></span><br><span class="line">	<span class="keyword">int</span> *lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line">	<span class="comment">// lds[i]表示以A[i]为起点的最长递减子序列的长度</span></span><br><span class="line">	<span class="keyword">int</span> *lds = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		lis[i] = <span class="number">1</span>;</span><br><span class="line">		lds[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt; A[j] &amp;&amp; lis[i] &lt; lis[j]+<span class="number">1</span>)</span><br><span class="line">				lis[i] = lis[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>; j&gt;i; --j)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt; A[j] &amp;&amp; lds[i] &lt; lds[j]+<span class="number">1</span>)</span><br><span class="line">				lds[i] = lds[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxl = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="keyword">if</span>(maxl &lt; lis[i]+lds[i])</span><br><span class="line">			maxl = lis[i] + lds[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; len - maxl + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] lis;</span><br><span class="line">	<span class="keyword">delete</span> [] lds;</span><br><span class="line">	<span class="keyword">delete</span> [] A;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K) 。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2011-最长公共子串]]></title>
    <link href="http://yoursite.com/2015/03/18/hua-wei-OJ2011/"/>
    <id>http://yoursite.com/2015/03/18/hua-wei-OJ2011/</id>
    <published>2015-03-18T11:19:52.000Z</published>
    <updated>2015-05-10T11:24:31.089Z</updated>
    <content type="html"><![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串<a id="more"></a></p>
<p><strong>输出：</strong></p>
<p>输出一个整数</p>
<p><strong>样例输入：</strong><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">asdfas</span> werasdfaswer</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、解题报告">二、解题报告</h3><p>与最长公共子序列（参见《<a href="http://songlee24.github.io/2014/11/27/dynamic-programming/" target="_blank" rel="external">动态规划DP</a>》）一样，最长公共子串也可以使用动态规划解决，只不过思路不太一样。准确地说，是打表的方式不一样。</p>
<p>举个例子：s1 = <code>bab</code>，s2 = <code>caba</code>。表如下</p>
<center><br><img src="http://img.blog.csdn.net/20150423105150153" alt=""><br></center>

<p>具体打表的方法是：</p>
<ul>
<li>第一行、第一列初始化为 0；</li>
<li>对于其他的格子：<ul>
<li>若对应的两个字符相等，格子的值设为左上角的值加 1。</li>
<li>若对应的两个字符不相等，直接置 0 。</li>
</ul>
</li>
</ul>
<p><br><br>这样的话，表中的最大元素就是 最长公共子串 的<strong>长度</strong>。并且也可以很容易看出最长公共子串有 2 个，分别是<code>ba</code>和<code>ab</code>。</p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLCStringLength</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> input, s1, s2;</span><br><span class="line">	getline(<span class="built_in">cin</span>, input);</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">	ss &gt;&gt; s1;</span><br><span class="line">	ss &gt;&gt; s2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getLCStringLength(s1, s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、扩展">三、扩展</h3><p>如何输出所有的最长公共子串？</p>
<p>很简单，我们记录下 s1 和 s2 的公共子串分别在 s1 、s2 中起始位置（即表中值为 1 的坐标）。打表完成以后，我们已经知道了最长公共子串的长度<code>length</code>，通过<code>substr()</code>判断即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.substr(i-<span class="number">1</span>, length) == s2.substr(j-<span class="number">1</span>, length)</span><br></pre></td></tr></table></figure></p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCString</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; firstPos;  <span class="comment">// 记录子串开始的坐标 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">				<span class="keyword">if</span>(table[i][j] == <span class="number">1</span>) </span><br><span class="line">					firstPos.push_back(make_pair(i, j));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出所有的最长公共子串</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator beg = firstPos.begin();</span><br><span class="line">	<span class="keyword">for</span>( ; beg!=firstPos.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start1 = beg-&gt;first-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> start2 = beg-&gt;second-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s1.substr(start1, biggest) == s2.substr(start2, biggest))</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s1.substr(start1, biggest) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"hello,world,james"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"james is saying hello"</span>;</span><br><span class="line">	printLCString(s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（二）]]></title>
    <link href="http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/"/>
    <id>http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/</id>
    <published>2015-03-16T18:40:53.000Z</published>
    <updated>2015-05-10T11:17:34.068Z</updated>
    <content type="html"><![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）<a id="more"></a></p>
<ul>
<li>进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行 pop 操作。</li>
</ul>
<p><strong>3.4</strong> 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</p>
<ul>
<li>每次只能移动一个盘子</li>
<li>盘子只能从柱子顶端滑出移到下一根柱子</li>
<li>盘子只能叠在比它大的盘子上</li>
</ul>
<p>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><strong>3.5</strong> 实现一个<code>MyQueue</code>类，该类用两个栈来实现一个队列。</p>
<p><strong>3.6</strong> 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code>和<code>isEmpty</code>。</p>
<p><strong>3.7</strong> 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>等。</p>
<p><br><br></p>
<h3 id="4、树与图">4、树与图</h3><p><strong>4.1</strong> 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</p>
<p><strong>4.2</strong> 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</p>
<p><strong>4.3</strong> 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</p>
<p><strong>4.4</strong> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</p>
<p><strong>4.5</strong> 实现一个函数，检查一棵二叉树是否为二叉查找树。</p>
<p><strong>4.6</strong> 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</p>
<p><strong>4.7</strong> 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</p>
<p><strong>4.8</strong> 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</p>
<p><strong>4.9</strong> 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</p>
<p><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>3.1 描述如何只用一个数组来实现三个栈。</strong></p>
<p>这个问题的难易程度取决于每个栈是<em>固定分割</em> 还是 <em>动态分割</em>。</p>
<ul>
<li><strong>固定分割</strong>：也就是每个栈分配固定大小的空间。这是最简单的实现方法，但是效率不高，因为即使某个栈是空的，它的空间也不能被别的栈使用。下面是每个栈占数组1/3的实现代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100</span>;  <span class="comment">// 每个栈的大小</span></span><br><span class="line">	<span class="keyword">int</span> tops[<span class="number">3</span>];                  <span class="comment">// 3个栈的栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>*size];              <span class="comment">// 共享的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">absTopOfStack</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// 返回栈顶指针在数组中的绝对量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		tops[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::absTopOfStack(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> flag * size + tops[flag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tops[flag] == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(tops[flag]+<span class="number">1</span> &gt;= size) <span class="comment">/*检查有无空闲空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Out of space.\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		++tops[flag];</span><br><span class="line">		arr[absTopOfStack(flag)] = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = arr[absTopOfStack(flag)];</span><br><span class="line">	arr[absTopOfStack(flag)] = <span class="number">0</span>;   <span class="comment">/*清零*/</span></span><br><span class="line">	--tops[flag];  <span class="comment">/*指针自减*/</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> arr[absTopOfStack(flag)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>动态分割</strong>：允许栈的大小灵活可变，要实现起来难度有点大。</p>
<ul>
<li><p><strong>思路一</strong>：我们可以先考虑<em>用一个数组实现两个栈</em>，思路很简单：分别用数组的两端作为两个栈的起点，向中间扩展，若两个栈中的元素总和不超过n，两个栈不会重叠。基于同样的想法，我们可以把第三个栈实现在数组的中部，当前两个栈中有一个满了（即将重叠第三个栈时），平移第三个栈以扩展栈空间。这种方法由于需要搬移元素所以效率不高。</p>
</li>
<li><p><strong>思路二</strong>：链式栈。通过链表的方式来实现栈，如下图：</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150407021806320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>链式栈</strong>是在一个数组上实现多个栈（3个、4个、5个…）的通用解决方案。下面是示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;       <span class="comment">// 存储关键字</span></span><br><span class="line">	<span class="keyword">int</span> preIndex;  <span class="comment">// 记录上一个元素的位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> top1, top2, top3;</span><br><span class="line">	<span class="keyword">int</span> array_size;  <span class="comment">// 数组的大小，即栈的最大容量</span></span><br><span class="line">	<span class="keyword">int</span> current_ptr; <span class="comment">// 下一个元素入栈的位置</span></span><br><span class="line">	Node* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks(<span class="keyword">int</span> size);</span><br><span class="line">	~Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks(<span class="keyword">int</span> size):array_size(size),</span><br><span class="line">	top1(-<span class="number">1</span>),top2(-<span class="number">1</span>),top3(-<span class="number">1</span>),current_ptr(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arr = <span class="keyword">new</span> Node[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stacks::~Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> top1 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> top2 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> top3 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error flag of stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(current_ptr == array_size) <span class="comment">// 栈已满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is full.\n"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		arr[current_ptr].key = value;</span><br><span class="line">		<span class="keyword">switch</span> (flag)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top1;</span><br><span class="line">			top1 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top2;</span><br><span class="line">			top2 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top3;</span><br><span class="line">			top3 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++current_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		value = arr[top1].key;</span><br><span class="line">		top1 = arr[top1].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		value = arr[top2].key;</span><br><span class="line">		top2 = arr[top2].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		value = arr[top3].key;</span><br><span class="line">		top3 = arr[top3].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top1].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top2].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top3].key;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.2 请设计一个栈，除pop与push方法，还支持min方法，可返回栈元素中的最小值。pop、push和min三个方法的时间复杂度必须为O(1)。</strong></p>
<p>通常来说<code>pop</code>和<code>push</code>方法的时间复杂度就是O(1)，关键是<code>min</code>方法。</p>
<p>可能有人会想 在Stack类里添加一个int型的变量用来记录最小值。当新元素入栈时，比较新元素与最小值，若新元素更小则更新最小值，此时<code>push</code>的时间效率是O(1)；但是当 minValue 出栈时，我们需要遍历整个栈，找出新的最小值，此时<code>pop</code>操作的时间效率就不符合O(1)的要求了。</p>
<ul>
<li><strong>思路一</strong>：记录每种状态下的最小值。通过给栈元素增加一个 min 字段，每个元素在入栈时记录当前状态下的最小值。这么一来，要找到最小值，直接查看栈顶元素的 min 就行了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	node n;</span><br><span class="line">	n.value = v;</span><br><span class="line">	n.min = v &lt; min() ? v : min();</span><br><span class="line">	s.push(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> top = s.top().value;</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> s.top().min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：利用辅助栈保存最小值。这种方法比思路一更节省空间一些 ———— 因为思路一中每个栈元素都要记录 min，而使用辅助栈，当入栈元素大于当前最小值时，不需要记录。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_s;  <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(v &lt;= min())</span><br><span class="line">		min_s.push(v);</span><br><span class="line">	s.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> top = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">if</span>(top == min())</span><br><span class="line">		min_s.pop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(min_s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> min_s.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong> 3.3 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）</strong></p>
<p>根据题意，<code>SetOfStacks</code>中应该有一个栈数组，而<code>push</code>和<code>pop</code>都是操作栈数组中的最后一个栈。入栈时若最后一个栈被填满，就需新建一个栈；出栈后若最后一个栈为空，就必须从栈数组中移除这个栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SetOfStacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; stacks;</span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 一个栈的最大存储量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SetOfStacks(<span class="keyword">int</span> cap);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现**********/</span></span><br><span class="line">SetOfStacks::SetOfStacks(<span class="keyword">int</span> cap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SetOfStacks::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!stacks.empty() &amp;&amp; stacks.back().size() &lt; capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		stacks.back().push(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 必须新建一个栈</span></span><br><span class="line">		s.push(v);</span><br><span class="line">		stacks.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SetOfStacks::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(stacks.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = stacks.back().top();</span><br><span class="line">	stacks.back().pop();</span><br><span class="line">	<span class="keyword">if</span>(stacks.back().empty())</span><br><span class="line">		stacks.pop_back();  <span class="comment">// 移除</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶：实现一个popAt(int index)方法，根据指定的子栈，执行 pop 操作。</strong></p>
<p>设想当弹出 栈1 的栈顶元素时，我们需要移出 栈2 的栈底元素，并将其推到栈1中。随后，将栈3的栈底元素推入栈2，将栈4的栈底元素推入栈3，以此类推。</p>
<p>有人可能会说，没必要执行“推入”操作，有些栈不填满也可以啊！而且还降低了时间复杂度。但是若之后有人假定所有的栈（最后一个栈除外）都是填满的，就可能出现意想不到的 error！这个问题并没有“标准答案”，你应该跟面试官讨论各种做法的优劣。</p>
<p><br><br><strong>3.4 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</strong></p>
<ul>
<li><strong>每次只能移动一个盘子</strong></li>
<li><strong>盘子只能从柱子顶端滑出移到下一根柱子</strong></li>
<li><strong>盘子只能叠在比它大的盘子上</strong></li>
</ul>
<p><strong>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</strong></p>
<p><img src="http://img.blog.csdn.net/20150407021526401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>首先我们从最简单的开始整理自己的思路：</p>
<ul>
<li>当<code>n=1</code>时，因为只有一个盘子，所以可以直接将盘子1从柱1移至柱3.</li>
<li>当<code>n=2</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1从柱1移至柱2。</li>
<li>将盘子2从柱1移至柱3。</li>
<li>将盘子1从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=3</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将上面两个盘子从柱1移至柱2，同上。</li>
<li>将盘子3移至柱3。</li>
<li>将盘子1、2从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=4</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1、2、3移至柱2，具体做法参见前面。</li>
<li>将盘子4移至柱3。</li>
<li>将盘子1、2、3移至柱3。</li>
</ol>
</li>
</ul>
<p>把柱1上的盘子移至柱3，需要柱2作为缓冲。可以看出，上面的过程是递归的，很自然地就可以导出递归算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Tower</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; disks;  <span class="comment">// 用整数的大小表示盘子的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> d)</span></span>;             <span class="comment">// 向柱子上添加盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveButtomTo</span><span class="params">(Tower &amp;t)</span></span>; <span class="comment">// 移动最下面那块盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveDisks</span><span class="params">(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span></span>;  <span class="comment">// 利用buf将n块盘子移至dest</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************实现*********************/</span></span><br><span class="line"><span class="keyword">void</span> Tower::add(<span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!disks.empty() &amp;&amp; disks.top() &lt;= d) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error placing disk "</span> &lt;&lt; d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		disks.push(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Tower::moveButtomTo(Tower &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> top = disks.top();</span><br><span class="line">	disks.pop();</span><br><span class="line">	t.add(top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现 —— 注意使用引用</span></span><br><span class="line"><span class="keyword">void</span> Tower::moveDisks(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/*将上面的n-1块盘子移至缓冲区*/</span></span><br><span class="line">		moveDisks(n-<span class="number">1</span>, buf, dest);</span><br><span class="line">		<span class="comment">/*将最下面那块盘子移至目的地*/</span></span><br><span class="line">		moveButtomTo(dest);</span><br><span class="line">		<span class="comment">/*将缓冲区的n-1块盘子移至目的地*/</span></span><br><span class="line">		buf.moveDisks(n-<span class="number">1</span>, dest, *<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************测试*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tower tower[<span class="number">3</span>];  <span class="comment">// 3根柱子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		tower[<span class="number">0</span>].add(i);</span><br><span class="line">	<span class="comment">// 移动</span></span><br><span class="line">	tower[<span class="number">0</span>].moveDisks(<span class="number">5</span>, tower[<span class="number">2</span>], tower[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.5 实现一个MyQueue类，该类用两个栈来实现一个队列。</strong></p>
<p>队列和栈的主要区别就是元素进出顺序。假设两个栈分别是 Newest 和 Oldest，为了用这两个栈达到先进先出（FIFO）的效果，在入队时我们将元素压入 Newest 栈，然后将 Newest 的元素弹出，压入 Oldest 栈中（这样就达到了反转的效果），在出队时，我们从 Oldest 栈中弹出元素。</p>
<p>注意，为了避免频繁的执行从 Newest 到 Oldest 的反转操作，我们规定：只有在发现 Oldest 为空时，才执行反转操作 —— 将 Newest 中的所有元素弹出并压入 Oldest 中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Newest;  <span class="comment">// 新入队的元素</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Oldest;  <span class="comment">// 准备出队的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverseStacks</span><span class="params">()</span></span>;  <span class="comment">// 将Newest元素弹出，压入Oldest </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;           <span class="comment">// 队列大小</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span></span>;  <span class="comment">// 入队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span>;        <span class="comment">// 出队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>;            <span class="comment">// 队首元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Oldest为空才进行反转，避免频繁操作</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::reverseStacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Oldest.empty())  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!Newest.empty()) &#123;</span><br><span class="line">			Oldest.push(Newest.top());</span><br><span class="line">			Newest.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Oldest.size()+Newest.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入Newest，最新元素始终位于它的顶端</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::enqueue(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	Newest.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Oldest出队</span></span><br><span class="line"><span class="keyword">int</span> MyQueue::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">int</span> value = Oldest.top();</span><br><span class="line">	Oldest.pop();</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::top()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">return</span> Oldest.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.6 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek和isEmpty。</strong></p>
<p>可以想到的一种做法是，搜索整个栈，找出最小元素，将其压入另一个栈；然后，在剩余元素中找出最小的，并将其入栈。但这种做法实际上需要两个额外的栈，一个用来存放最终的有序序列，一个在搜索时用作缓冲区。</p>
<p>那么，只使用一个额外的栈怎么做呢？可以从S1逐一弹出元素，然后按顺序插入S2中，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150407021739968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>S1是未排序的，S2是排好序的：</p>
<ul>
<li><p>从S1中弹出5，我们需要在S2中找到合适的位置插入这个数，所以将 12 和 8 移至 S1 中，然后将 5 压入 S2。</p>
</li>
<li><p>那么 8 和 12 需不需要移回 S2 呢？其实不需要，对于这两个数，我们可以像处理 5 那样重复相关步骤就可以了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Sort(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = s.top();</span><br><span class="line">		s.pop();          <span class="comment">// 弹出元素存到临时变量</span></span><br><span class="line">		<span class="keyword">while</span>(!r.empty() &amp;&amp; r.top() &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(r.top());</span><br><span class="line">			r.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		r.push(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>3.7 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 enqueue、dequeueAny、dequeueDog 和 dequeueCat 等。</strong></p>
<p><strong>思路一</strong>：只维护一个队列。那么 dequeueAny 就容易实现，而 dequeueDog 和 dequeueCat 就需迭代访问整个队列，找到第一只被收养的狗或猫。这种解法明显效率不高。</p>
<p><strong>思路二</strong>：为猫和狗各维护一个队列。那么 dequeueDog 和 dequeueCat 很容易实现，而 dequeueAny 需要比较猫队列与狗队列的队首，看哪个“更老”。为了方便 dequeueAny 的实现，我们给每个动物加一个额外的变量，以标记进入队列的先后顺序。这种解法显然更简单更高效！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> order;    <span class="comment">// 标记先后顺序</span></span><br><span class="line">	Animal(<span class="built_in">string</span> s):name(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******* 狗 *******/</span></span><br><span class="line"><span class="keyword">class</span> Dog : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dog(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* 猫 *******/</span></span><br><span class="line"><span class="keyword">class</span> Cat : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cat(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******队列*******/</span></span><br><span class="line"><span class="keyword">class</span> Queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;Dog&gt; dogs;</span><br><span class="line">	<span class="built_in">list</span>&lt;Cat&gt; cats;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue():order(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Dog d)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		d.order = order++;</span><br><span class="line">		dogs.push_back(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Cat c)</span>  <span class="comment">// 重载</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		c.order = order++;</span><br><span class="line">		cats.push_back(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Dog <span class="title">dequeueDog</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Dog d = dogs.front();</span><br><span class="line">		dogs.pop_front();</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Cat <span class="title">dequeueCat</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Cat c = cats.front();</span><br><span class="line">		cats.pop_front();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Animal <span class="title">dequeueAny</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dogs.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">		<span class="keyword">if</span>(cats.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dogs.front().order &lt; cats.front().order)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
<hr>
<p><strong>下面的题是关于树或图，做下面的题之前，首先我们要能够创建一棵二叉树或一个图：</strong></p>
<ul>
<li><strong>创建二叉树</strong>：二叉树是什么相信就不用我多说了，可以递归地根据输入创建一棵二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">&#125; *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归地创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		T = NULL;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = x;</span><br><span class="line">	createBinaryTree(T-&gt;left);</span><br><span class="line">	createBinaryTree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	createBinaryTree(T); </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>创建二叉查找树</strong>： 可以由一个数组生成一棵二叉查找树，见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757" target="_blank" rel="external">二叉查找树（BST）</a>》。</p>
</li>
<li><p><strong>创建图</strong>：图有两种存储方式，邻接矩阵和邻接表，这里采用邻接表来创建图。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Graph  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">int</span> V;                         <span class="comment">// 顶点数  </span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                <span class="comment">// 邻接表  </span></span><br><span class="line"> </span><br><span class="line">	Graph(<span class="keyword">int</span> V);                  <span class="comment">// 构造函数  </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;    <span class="comment">// 向图中添加边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span>  </span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;  </span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span>  </span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)  </span><br><span class="line">&#123;  </span><br><span class="line">	adj[v].push_back(w);          <span class="comment">// 将w添加到v的链表  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><strong>4.1 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</strong></p>
<p>本题明确地给出了平衡树的定义，我们的解法就是根据定义直接递归检查每棵子树的高度。代码中的 checkHeight 方法以递归方式获取左右子树的高度。若子树是平衡的，返回该子树的实际高度；若子树不平衡，返回-1，这时所有递归都会立即返回：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line"> * 平衡返回高度，不平衡返回-1</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查左子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> leftHeight = checkHeight(T-&gt;left);</span><br><span class="line">	<span class="keyword">if</span>(leftHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查右子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> rightHeight = checkHeight(T-&gt;right);</span><br><span class="line">	<span class="keyword">if</span>(rightHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查当前结点是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> diff = leftHeight&gt;rightHeight ? </span><br><span class="line">		leftHeight-rightHeight : rightHeight-leftHeight;</span><br><span class="line">	<span class="keyword">if</span>(diff &gt; <span class="number">1</span>)  <span class="comment">// 不平衡，返回-1</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>          <span class="comment">// 平衡，返回高度</span></span><br><span class="line">		<span class="keyword">return</span> leftHeight&gt;rightHeight ? leftHeight+<span class="number">1</span> : rightHeight+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkHeight(T) == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.2 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</strong></p>
<p>只需通过图的遍历，比如深度优先搜索或广度优先搜索，就能解决这个问题。</p>
<p>我们从其中一个结点出发，在遍历过程中检查是否找到另一个结点。在这个算法中，访问过的结点都应标记为“已访问”，以免循环和重复访问结点。下面的示例代码使用了广度优先搜索：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPathExist</span><span class="params">(Graph g, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;  <span class="comment">// 当做队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> V = g.getVertexNum();  <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)  </span><br><span class="line">		visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">	visited[start] = <span class="keyword">true</span>; <span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	<span class="built_in">queue</span>.push_back(start);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node = <span class="built_in">queue</span>.front(); <span class="comment">// 出队</span></span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=g.adj[node].begin(); i!=g.adj[node].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(*i == end)  <span class="comment">// 是否等于另一个结点</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">					<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.3 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</strong></p>
<p>要让二叉查找树的高度最小，就必须让左右子树的结点数越接近越好。根据二叉查找树的性质（中序遍历的序列是一个递增的有序序列），可以让该数组中间的值成为根节点，前半区间成为左子树，后半区间成为右子树。然后，每一个区间中间的值又成为子树的根节点，以此类推。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* createMinBST(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &gt; high)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span> NULL; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">	TreeNode* T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = A[mid];</span><br><span class="line">	T-&gt;left = createMinBST(A, low, mid-<span class="number">1</span>);</span><br><span class="line">	T-&gt;right = createMinBST(A, mid+<span class="number">1</span>, high);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.4 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</strong></p>
<p>根据题意，你可能认为这个问题需要一层一层遍历，每一层构成一个链表。但其实可以用任意方式遍历树，只要记住结点位于哪一层即可。</p>
<p>下面是使用先序遍历实现的一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLevelLists</span><span class="params">(BiTree T, <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode*&gt;&gt; &amp;lists, <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lists.size() &lt;= level)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>&lt;TreeNode*&gt; lst;</span><br><span class="line">		lst.push_back(T);</span><br><span class="line">		lists.push_back(lst);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		lists.at(level).push_back(T);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	createLevelLists(T-&gt;left, lists, level+<span class="number">1</span>);  <span class="comment">// 左子树</span></span><br><span class="line">	createLevelLists(T-&gt;right, lists, level+<span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以使用其他遍历方式，比如层序遍历、广度优先搜索。</p>
<p><br><br><strong>4.5 实现一个函数，检查一棵二叉树是否为二叉查找树。</strong></p>
<ul>
<li><strong>思路一</strong>：检查中序序列是否是升序。这是二叉查找树的性质，但<strong>需要注意的是</strong>，这种方法无法正确处理树中的重复值。若假定这棵树不包含重复值，则这种方法是有效的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inOrder</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*检查左子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;left, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查当前结点*/</span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= last)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	last = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查右子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;right, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = INT_MIN;</span><br><span class="line">	<span class="keyword">return</span> inOrder(T, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：自上而下传递最小和最大值，判断每个结点是否在范围内。假定根结点的值是20，最开始的范围是（<code>INT_MIN</code>,<code>INT_MAX</code>），根结点明显在这个范围内。然后判断左孩子是否在（<code>INT_MIN</code>, 20）这个范围内，右孩子是否在（20 ,<code>INT_MAX</code>）这个范围内。以此类推，递归下去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= min || T-&gt;data &gt; max)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!checkBST(T-&gt;left,min,T-&gt;data) || !checkBST(T-&gt;right,T-&gt;data,max))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> checkBST(T, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.6 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</strong></p>
<p>见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757#t2" target="_blank" rel="external">BST的前驱与后继</a>》，本题要求的是中序遍历中的后继结点。求一个结点 x 的后继，有两种情况：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继是右子树中值最小的结点，即右子树最左边的结点。</p>
</li>
<li><p>若结点 x 的右子树为空，表示已遍访 x 的子树。我们必须回到 x 的父结点，记父结点为 p ：</p>
<ul>
<li><p>如果 x 是 p 的左儿子，那么下一个要访问的结点就是 p ；</p>
</li>
<li><p>如果 x 是 p 的右儿子，表示已遍访 p 的子树，这时需从 p 往上继续访问，直到遇到一个祖先结点 pp，它的左儿子也是结点 x 的祖先。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* successor_BST(TreeNode* n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* tmp = n-&gt;right;</span><br><span class="line">		<span class="keyword">while</span>(tmp-&gt;left!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* p = n-&gt;parent;</span><br><span class="line">		<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right==n)</span><br><span class="line">		&#123;</span><br><span class="line">			n = p;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.7 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</strong></p>
<p>我们在解题之前应该先要问问面试官，这棵树的结点是否包含指向父结点的指针。</p>
<ul>
<li><p><strong>情况一</strong>：如果每个结点中包含指向父结点的指针，那么就可以直接向上追踪 p 和 q 的路径，直到两者相交。当然，在向上追踪的过程中我们需要标记结点是否已经被访问过，比如可以给结点添加<code>isVisited</code>域、或者将已访问结点映射到散列表。</p>
</li>
<li><p><strong>情况二</strong>：如果结点不包含指向父结点的指针，又不得将额外的结点储存在另外的数据结构中。那么我们的做法就是：从上向下判断，若 p 和 q 都在某结点的左边，就到左子树中查找共同祖先；若都在该结点的右边，则在右子树中查找共同祖先。要是 p 和 q 不在同一边，那么就表示已经找到第一个共同祖先了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若p为root的子孙，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(root == p)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> cover(root-&gt;left, p) || cover(root-&gt;right, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* getCommonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	<span class="keyword">if</span>(T == p || T == q)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> pAtLeft = cover(T-&gt;left, p);</span><br><span class="line">	<span class="keyword">bool</span> qAtLeft = cover(T-&gt;left, q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*若p和q不在同一边，则表示已经找到第一个共同祖先*/</span></span><br><span class="line">	<span class="keyword">if</span>(pAtLeft != qAtLeft)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="comment">/*若在同一边，遍访那一边*/</span></span><br><span class="line">	TreeNode* child = pAtLeft ? T-&gt;left : T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(child, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* commonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cover(T, p) || !cover(T, q))  <span class="comment">// --错误检查--</span></span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(T, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.8 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</strong></p>
<p>首先考虑小数据量的情况，可以求出两棵树的前序和中序遍历序列，若 T2 前序遍历是 T1 前序遍历的子串，并且 T2 中序遍历是 T1 中序遍历的子串，则 T2 为 T1 的子树。假设T1的节点数为 N，T2的节点数为 M。遍历两棵树的时间复杂度是 O(N + M)， 判断字符串是否为另一个字符串的子串的复杂性也是 O(N + M)（比如使用KMP算法）。所以总的时间复杂度是<code>O(N+M)</code>，所需的空间也是<code>O(N+M)</code>。———— 这里需要注意一点：对于左结点或者右结点为 null 的情况，需要在字符串中插入特殊字符表示。</p>
<p>对于简单的情形，上面的解法还算不错。但是当数据量非常大时，暂存前序和中序序列可能要占用太多的内存，所以我们考虑另一种解法：遍历 T1，每当 T1 的某个节点与 T2 的根节点值相同时，就判断两棵子树是否相同。假设 T2 的根节点在 T1 中出现了 k 次，那么算法的时间复杂度就是<code>O(N + k*M)</code>，最坏情况下是<code>O(N*M)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配两棵子树，完全一样返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL &amp;&amp; t2 == NULL) <span class="comment">/*若两者都为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL || t2 == NULL) <span class="comment">/*若只有一个为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data != t2-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> matchTree(t1-&gt;left,t2-&gt;left) &amp;&amp; matchTree(t1-&gt;right,t2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历大树t1，当某个结点与t2根结点相同，matchTree判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">/*大的树已经空了，还未找到子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data == t2-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(matchTree(t1, t2))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subTree(t1-&gt;left, t2) || subTree(t1-&gt;right, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t2 == NULL)  <span class="comment">/*空树一定是子树*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">	<span class="keyword">return</span> subTree(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的两种解法，哪种解法比较好呢？</p>
<ul>
<li><p>方法一会占用 O(N + M) 的内存，而另外一种解法只会占用 O(logN + logM) 的内存（递归的栈内存）。当考虑扩展性时，内存使用的多寡是个很重要的因素。</p>
</li>
<li><p>方法一的时间复杂度为O(N + M)，方法二最差的时间复杂度是O(N*M)。但是最差情况的时间复杂度并没有代表性，我们需要进一步观察，因为更可能的情况是很早就发现两棵树的不同，早早的退出了 matchTree。</p>
</li>
</ul>
<p>总的来说，在空间效率上，第二种解法更好。在时间上，需要通过实际数据来验证。</p>
<p><br><br><strong>4.9 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</strong></p>
<p>下面我们采用简化推广法来解题。</p>
<p><strong>Step 1 </strong>： 简化——假设路径必须从根节点开始，但可以在任意结点结束，该怎么解决？</p>
<p>在这种情况下，问题就会变得容易很多。我们可以从根节点开始，向下访问子节点，计算每条路径上到当前节点为止的数值总和，若与给定值相同则打印当前路径。注意，就算找到总和，仍要继续访问这条路径（因为可能存在正负相抵消的情况）。</p>
<p><strong>Step 2 </strong>： 推广——路径可从任意结点开始</p>
<p>如果路径可以从任意结点开始，在任意结点结束。在这种情况下我们稍作调整，对于每个结点，都向“上”检查是否有总和为 sum 的路径。具体来讲就是：递归访问每个结点 p 时，我们将 root 到 p 的完整 path 传入函数；然后，函数会从 p 到 root 逆序将结点上的值加起来，当每条子路径的总和等于 sum 时，打印该条子路径。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印从start到end的路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> path[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求一棵子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> leftDepth = depth(n-&gt;left);</span><br><span class="line">		<span class="keyword">int</span> rightDepth = depth(n-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> leftDepth&gt;rightDepth ? leftDepth+<span class="number">1</span> : rightDepth+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum, <span class="keyword">int</span> path[], <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*将当前结点插入路径*/</span></span><br><span class="line">	path[level] = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从当前结点到root结点，看是否存在和为sum的路径*/</span></span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		t += path[i];</span><br><span class="line">		<span class="keyword">if</span>(t == sum)</span><br><span class="line">			print(path, i, level);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*递归*/</span></span><br><span class="line">	findSum(T-&gt;left, sum, path, level+<span class="number">1</span>);</span><br><span class="line">	findSum(T-&gt;right, sum, path, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = depth(T);</span><br><span class="line">	<span class="keyword">int</span> *path = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(dep*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	findSum(T, sum, path, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(path);<span class="comment">/*释放内存*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（一）]]></title>
    <link href="http://yoursite.com/2015/03/16/cracking-the-coding-interview-01/"/>
    <id>http://yoursite.com/2015/03/16/cracking-the-coding-interview-01/</id>
    <published>2015-03-16T15:50:18.000Z</published>
    <updated>2015-05-10T11:14:29.828Z</updated>
    <content type="html"><![CDATA[<h3 id="1、数组与字符串">1、数组与字符串</h3><p><strong>1.1</strong> 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p>
<p><strong>1.2</strong> 用C或C++实现<code>void reverse(char* str)</code>函数，即反转一个null结尾的字符串。</p>
<p><strong>1.3</strong> 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>1.4</strong> 编写一个方法，将字符串中的空格全部替换为“%20”。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。示例：输入<code>Mr John Smith</code>，输出<code>Mr%20John%20Smith</code>。<a id="more"></a></p>
<p><strong>1.5</strong> 利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。</p>
<p><strong>1.6</strong> 给定一幅由 N x N 矩阵表示的图像，其中每个像素的大小为 4 字节，编写一个方法，将图像旋转90度。不占用额外内存空间能否做到？</p>
<p><strong>1.7</strong> 编写一个算法，若 M x N 矩阵中某个元素为0，则将其所在的行与列清零。</p>
<p><strong>1.8</strong> 假定有一个方法<code>isSubstring</code>，可检查一个单词是否为其他字符串的子串。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成，要求只能调用一次<code>isSubstring</code>。（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串。）</p>
<p><br><br></p>
<h3 id="2、链表">2、链表</h3><p><strong>2.1</strong> 编写代码，移除未排序链表中的重复结点。如果不得使用临时缓冲区，又该怎么解决？</p>
<p><strong>2.2</strong> 实现一个算法，找出单向链表中倒数第 k 个结点。</p>
<p><strong>2.3</strong> 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。示例：</p>
<ul>
<li>输入：单向链表<code>a-&gt;b-&gt;c-&gt;d-&gt;e</code>中的结点c</li>
<li>结果：不返回任何数据，但该链表变为<code>a-&gt;b-&gt;d-&gt;e</code>。</li>
</ul>
<p><strong>2.4</strong> 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前。</p>
<p><strong>2.5</strong> 给定两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。示例：</p>
<ul>
<li>输入：（<code>7-&gt;1-&gt;6</code>）+（<code>5-&gt;9-&gt;2</code>），即 617+295</li>
<li>输出：<code>2-&gt;1-&gt;9</code>，即 912</li>
</ul>
<p>假设这些数位是正向存放的，请再做一遍。示例：</p>
<ul>
<li>输入：（<code>6-&gt;1-&gt;7</code>）+（<code>2-&gt;9-&gt;5</code>），即 617+295</li>
<li>输出：<code>9-&gt;1-&gt;2</code>，即 912</li>
</ul>
<p><strong>2.6</strong> 给定一个有环链表，实现一个算法返回环路的开头结点。有环链表的定义：在链表中某个结点的 next 元素指向在它前面出现过的结点，则表明该链表存在环路。示例：</p>
<ul>
<li>输入：<code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>（C结点出现了两次）</li>
<li>输出：C</li>
</ul>
<p><strong>2.7</strong> 编写一个函数，检查链表是否为回文。</p>
<p><br><br><br><br><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>1.1</strong> 如果允许使用数据结构，我首先想到的是<code>map</code>，下标操作<code>map[&#39;key&#39;]</code>在 key 存在时执行搜索操作，否则执行插入操作。示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; amap;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		amap[A[i]] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator beg = amap.begin();</span><br><span class="line">	<span class="keyword">for</span>(;beg!=amap.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(beg-&gt;second &gt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不允许使用额外的数据结构，该如何处理呢？假定字符集为 ASCII，那么我们可以创建一个标记数组，索引 i 对应的 bool 值指示该字符串是否含有字母表第 i 个字符。若这个字符第二次出现，则立即返回 false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">int</span> len)</span>   <span class="comment">// 假定字符集为 ASCII</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">256</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> char_set[<span class="number">256</span>] = &#123;<span class="keyword">false</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(char_set[A[i]]) <span class="comment">// 字符已经出现过</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		char_set[A[i]] = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.2</strong> 根据函数的原型<code>void reverse(char* str)</code>，我们并不知道字符串的长度，所以需要先求出长度再进行反转：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* tmp = str;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*tmp++ != <span class="string">'\0'</span>)  <span class="comment">// 求出字符串的长度</span></span><br><span class="line">		++len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> high = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)    <span class="comment">// 反转</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c = str[low];</span><br><span class="line">		str[low] = str[high];</span><br><span class="line">		str[high] = c;</span><br><span class="line">		++low;</span><br><span class="line">		--high;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.3</strong> 由题意可知，这是一个变位词的问题，可以看我的另一篇文章《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/28705787" target="_blank" rel="external">变位词问题</a>》。通常的做法是把两个字符串按字母表顺序排序，比较排序后的字符串是否相等：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.length() != s2.length())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 泛型算法 sort() 采用的是快速排序算法</span></span><br><span class="line">	sort(s1.begin(), s1.end(), myfunction);</span><br><span class="line">	sort(s2.begin(), s2.end(), myfunction);</span><br><span class="line">	<span class="keyword">if</span>(!s1.compare(s2))  <span class="comment">// 相等返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一种方法就是：检查两个字符串的各字符数是否相同。（假定字符集为ASCII）我们只需创建一个大小 256 的整型数组，遍历第一个字符串，给每个字符计数；遍历第二个字符串，递减对应字符的数量。最后判断数组元素是否全部为0。</p>
<p><br><br><strong>1.4</strong> 本题的思路就是进行两次扫描。第一次扫描记录字符串中有多少空格，从而计算最终字符串的长度；第二次扫描从后往前移动字符并插入20%。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">			++spaceNum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> newLen = len + spaceNum*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] != <span class="string">' '</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			str[newLen - <span class="number">1</span>] = str[i];</span><br><span class="line">			newLen = newLen - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[newLen - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">			str[newLen - <span class="number">2</span>] = <span class="string">'2'</span>;</span><br><span class="line">			str[newLen - <span class="number">3</span>] = <span class="string">'%'</span>;</span><br><span class="line">			newLen = newLen - <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.5</strong> 本题思路很简单：遍历字符串，将字符和对应的重复次数拷贝到新字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int转string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">stringstream</span> ss;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	ss &lt;&lt; n;</span><br><span class="line">	ss &gt;&gt; str;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">compress</span><span class="params">(<span class="built_in">string</span> str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> tmp;</span><br><span class="line">	<span class="keyword">char</span> c = str[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;str.length(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == c)</span><br><span class="line">			++count;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp + c + int2string(count);</span><br><span class="line">			c = str[i];</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp = tmp + c + int2string(count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> str.length()&gt;tmp.length() ? tmp:str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.6</strong> 归纳题意，简言之就是：对N阶方阵进行原地转置。（思路就是对每一层执行环状旋转，将上边移到右边、右边移到下边、下边移到左边、左边移到上边）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> **mtx, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> layer=<span class="number">0</span>; layer &lt; n/<span class="number">2</span>; ++layer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> first = layer;</span><br><span class="line">		<span class="keyword">int</span> last = n-<span class="number">1</span>-layer;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=first; i&lt;last; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> offset = i - first;</span><br><span class="line">			<span class="comment">// 暂存上边：top = mtx[first][i]</span></span><br><span class="line">			<span class="keyword">int</span> top = *((<span class="keyword">int</span>*)mtx+first*n+i);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 左到上：mtx[first][i] = mtx[last-offset][first]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+first*n+i) = *((<span class="keyword">int</span>*)mtx+(last-offset)*n+first);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 下到左：mtx[last-offset][first] = mtx[last][last-offset]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+(last-offset)*n+first) = *((<span class="keyword">int</span>*)mtx+last*n+(last-offset));</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 右到下：mtx[last][last-offset] = mtx[i][last]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+last*n+(last-offset)) = *((<span class="keyword">int</span>*)mtx+i*n+last);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 上到右：mtx[i][last] = top</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+i*n+last) = top;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意二维数组作参数传递的问题，另外调用的时候像这样<code>rotate((int**)A, 4)</code>。这个算法的时间复杂度为<code>O(n^2)</code>，已是最优的做法。</p>
<p><br><br><strong>1.7</strong> 这个问题貌似很简单，直接遍历嘛！只要发现为零的元素，就将其所在的行与列清零。不过这个方法有个陷阱：清零以后会导致连锁效应，最后整个矩阵都变成 0。我们的做法是：遍历两遍，第一遍记录要清零的行与列，第二遍再执行清零操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZero</span><span class="params">(<span class="keyword">int</span> **mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> *row = <span class="keyword">new</span> <span class="keyword">bool</span>[m](); <span class="comment">// 默认初始化为false</span></span><br><span class="line">	<span class="keyword">bool</span> *col = <span class="keyword">new</span> <span class="keyword">bool</span>[n]();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(*((<span class="keyword">int</span>*)mtx+i*n+j) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				row[i] = <span class="keyword">true</span>;</span><br><span class="line">				col[j] = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(row[i] || col[j])</span><br><span class="line">			&#123;</span><br><span class="line">				*((<span class="keyword">int</span>*)mtx+i*n+j) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] row;</span><br><span class="line">	<span class="keyword">delete</span> [] col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.8</strong> 如果<code>x = wat</code>，<code>y = erbottle</code>，则<code>s1 = xy</code>，<code>s2 = yx</code>。不论x和y之间的分割点在何处，我们会发现<code>yx</code>肯定是<code>xyxy</code>的子串。即，s2总是s1s1的子串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRotation</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.length() == s2.length() &amp;&amp; s1.length()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> isSubstring(s1+s1, s2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br><br>在解决链表问题时，首先我们得学会<strong>如何创建链表</strong>，下面是单链表创建和打印的示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node </span><br><span class="line">&#123;</span><br><span class="line">	node* next;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据数组创建单链表：尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	node *head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	node *s, *tail = head;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		s = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">		s-&gt;data = A[i++];</span><br><span class="line">		tail-&gt;next = s;</span><br><span class="line">		tail = s;</span><br><span class="line">	&#125;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">	<span class="keyword">return</span> head;  <span class="comment">/*头结点不保存数据*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(p!=NULL)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.1</strong> 要想移除链表中的重复结点，我们只需在遍历的过程中，将每个未重复结点加入一个缓冲区。若发现有结点在缓冲区已经存在（即重复），则将该结点从链表中移除。只需遍历一次即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; buffer;   <span class="comment">// 这里使用set容器</span></span><br><span class="line">	node *p = L-&gt;next;</span><br><span class="line">	node *pre = L;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> data = p-&gt;data;</span><br><span class="line">		<span class="keyword">if</span>(buffer.find(data) == buffer.end())</span><br><span class="line">		&#123;</span><br><span class="line">			buffer.insert(data);</span><br><span class="line">			pre = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">/* 重复 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;next = p-&gt;next;</span><br><span class="line">			node* q = p;  <span class="comment">// 记录删除的结点</span></span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(q);  <span class="comment">// 释放</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不借助额外的缓冲区，那么就只能两两比较以判断是否重复，时间复杂度为<code>O(n^2)</code>。需要使用两个指针来迭代：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == NULL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	node* current = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(current!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node* runner = current;</span><br><span class="line">		<span class="keyword">while</span>(runner-&gt;next!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(runner-&gt;next-&gt;data == current-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				node* p = runner-&gt;next;</span><br><span class="line">				runner-&gt;next = runner-&gt;next-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				runner = runner-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		current = current-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.2</strong> 本题有多种解法。</p>
<ul>
<li><p>解法一：有人可能首先会想到：这太简单了，先遍历一次链表获取长度 length，那么倒数第 k 个结点就是第 (length - k)个结点。但是，你觉得这会是面试官想要的答案吗？？</p>
</li>
<li><p>解法二：<strong>递归</strong>。先通过递归到达链表的末尾，然后从后往前进行计数，每次递归调用返回时，将计数器加1。当计数器等于 k 时，访问的就是链表倒数第 k 个元素。（注意计数器 i 需要<strong>传引用</strong>）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node* kthToLast(node* head, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	node* p = kthToLast(head-&gt;next, k, i);</span><br><span class="line">	i = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法三：<strong>迭代法</strong>。相比于递归，迭代法通常不太直观但效率更高。思路就是：用两个指针 p1 和 p2 指向链表中两个距离为k的结点，然后以相同速度移动这两个指针，当其中一个指针指向链表的尾结点时，另一个指针指向的就是倒数第k个结点。（<strong>“快行指针”技巧</strong>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">node* kthToLast(LinkList L, <span class="keyword">int</span> k)    <span class="comment">// 时间复杂度O(n)，空间复杂度O(1)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个指针</span></span><br><span class="line">	node* p1 = L-&gt;next;</span><br><span class="line">	node* p2 = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p2向前移动k个结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k-<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p2 == NULL)  <span class="comment">/*错误检查*/</span></span><br><span class="line">			<span class="keyword">return</span> NULL;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p2 == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动p1与p2</span></span><br><span class="line">	<span class="keyword">while</span>(p2-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>2.3</strong>  本题中，你访问不到链表的首结点，只能访问待删除结点及之后的结点。所以我们的做法是：直接将后继结点的数据复制到当前结点，然后删除这个后继结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNode</span><span class="params">(node* c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==NULL || c-&gt;next==NULL) <span class="comment">// 尾结点无法删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	node* next = c-&gt;next;</span><br><span class="line">	c-&gt;data = next-&gt;data;</span><br><span class="line">	c-&gt;next = next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.4</strong> 链表不同于数组，在用现有元素创建新的链表时，我们不必移动和交换元素，只是改变元素的 next 指针的指向。所以本题的思路也很简单：遍历链表，将小于 x 的元素连接成一个链表，将大于等于 x 的元素连接成一个链表，最后合并两个链表即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">partition</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node* biggerHead = NULL;</span><br><span class="line">	node* biggerTail = NULL;</span><br><span class="line">	node* smallerHead = NULL;</span><br><span class="line">	node* smallerTail = NULL;</span><br><span class="line"></span><br><span class="line">	node* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node* next = p-&gt;next;</span><br><span class="line">		p-&gt;next = NULL;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data &lt; x)</span><br><span class="line">		&#123;   <span class="comment">/*将比x小的结点插入smaller链表的尾部*/</span></span><br><span class="line">			<span class="keyword">if</span>(smallerHead == NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				smallerHead = p;</span><br><span class="line">				smallerTail = smallerHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				smallerTail-&gt;next = p;</span><br><span class="line">				smallerTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;   <span class="comment">/*将比x大的结点插入bigger链表的尾部*/</span></span><br><span class="line">			<span class="keyword">if</span>(biggerHead == NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				biggerHead = p;</span><br><span class="line">				biggerTail = biggerHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				biggerTail-&gt;next = p;</span><br><span class="line">				biggerTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*遍历结束，合并两个链表*/</span></span><br><span class="line">	<span class="keyword">if</span>(smallerHead == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;next = biggerHead;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	smallerTail-&gt;next = biggerHead;</span><br><span class="line">	L-&gt;next = smallerHead;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.5</strong>  本题的思路是逐个结点对应相加，然后判断是否进位。我们使用递归来模拟这个加法过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">add</span><span class="params">(LinkList L1, LinkList L2, <span class="keyword">int</span> carry)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*两个链表全部为空且进位为0，则函数返回*/</span></span><br><span class="line">	<span class="keyword">if</span>(L1==NULL &amp;&amp; L2==NULL &amp;&amp; carry==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	node* result = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> value = carry;</span><br><span class="line">	<span class="keyword">if</span>(L1!=NULL)</span><br><span class="line">		value+=L1-&gt;data;</span><br><span class="line">	<span class="keyword">if</span>(L2!=NULL)</span><br><span class="line">		value+=L2-&gt;data;</span><br><span class="line"></span><br><span class="line">	result-&gt;data = value%<span class="number">10</span>;  <span class="comment">/*取个位*/</span></span><br><span class="line"></span><br><span class="line">	node* more = add(L1==NULL?NULL:L1-&gt;next, </span><br><span class="line">    				L2==NULL?NULL:L2-&gt;next, </span><br><span class="line">                    value&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	result-&gt;next = more;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里<code>add</code>之后返回的链表没有“头指针”。</p>
<p><br><br><strong>2.6</strong> 这个问题是由经典面试题——<strong>检查链表是否存在回路</strong>——演变而来。</p>
<p><img src="http://img.blog.csdn.net/20150324231307367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，如果链表中存在回路，那么我们遍历时会陷入死循环。那么，我们如何检测链表是否存在环 以及 寻找环的入口点呢？答案是<strong>“快慢指针”</strong>。</p>
<p>① 设置两个指针（fast、slow），初始值都指向头，slow每次前进一步，fast每次前进二步。如果链表存在环，则fast必定先进入环，而slow后进入环，两个指针必定相遇。这是<strong>检测</strong>。</p>
<p>② 在fast和slow第一次相遇的时候，假定slow走了n步，环路的入口是在p步，<br>   c为fast和slow相交点距离环路入口的距离。那么，slow走的路径： p+c ＝ n；<br>   fast走的路径： p+c+k*L = 2*n（L为环路的周长，k是整数），即n = k*L<br>   显然，如果从p+c点开始，slow再走n步的话，还可以回到p+c这个点。<br>   同时，fast从头开始走，步长为1，经过n步，也会达到p+c这点。<br>   显然，在这个过程中fast和slow只有前p步骤走的路径不同。所以当p1和p2再次重合的时候，必然是在链表的环路入口点上。</p>
<p>③ 综上所述，可得出如下算法：</p>
<ul>
<li><p>创建两个指针：fast和slow</p>
</li>
<li><p>slow每走一步，fast就走两步</p>
</li>
<li><p>两者碰在一起时，将slow重新指向链表头，fast保持不变</p>
</li>
<li><p>以相同速度移动slow和fast，一次一步，然后返回新的碰撞处。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">node* findLoopEntrance(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	node* slow = L-&gt;next;</span><br><span class="line">	node* fast = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)  <span class="comment">/*碰撞*/</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fast==NULL || fast-&gt;next==NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;  <span class="comment">/*没有环路*/</span></span><br><span class="line"></span><br><span class="line">	slow = L-&gt;next;   <span class="comment">/*重新指向链表头*/</span></span><br><span class="line">	<span class="keyword">while</span>(slow!=fast)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>2.7</strong> 所谓“回文”指正向看和反向看是一样的。在链表中可以定义为 <code>0-&gt;1-&gt;2-&gt;1-&gt;0</code>。</p>
<ul>
<li><p>解法一：根据定义，先将整个链表反转，然后比较反转链表和原始链表。若两者相同，则该链表为回文。（只需比较链表的前半部分）</p>
</li>
<li><p>解法二：迭代法。先进行迭代，将链表的前半部分入栈，再继续进行迭代，与后半部分进行比较。每次迭代时，比较当前结点和栈顶元素，若完成迭代时比较结果完全相同，则该链表为回文。（在链表长度未知的情况下，可以使用<strong>“快慢指针</strong>”将前半部分入栈）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node* fast = L-&gt;next;</span><br><span class="line">	node* slow = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**将链表的前半部分入栈**/</span></span><br><span class="line">	<span class="keyword">while</span>(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		s.push(slow-&gt;data);</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**链表有奇数个元素，跳过中间元素**/</span></span><br><span class="line">	<span class="keyword">if</span>(fast!=NULL)</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**比较**/</span></span><br><span class="line">	<span class="keyword">while</span>(slow!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> top = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="keyword">if</span>(top!=slow-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1、数组与字符串">1、数组与字符串</h3><p><strong>1.1</strong> 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p>
<p><strong>1.2</strong> 用C或C++实现<code>void reverse(char* str)</code>函数，即反转一个null结尾的字符串。</p>
<p><strong>1.3</strong> 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>1.4</strong> 编写一个方法，将字符串中的空格全部替换为“%20”。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。示例：输入<code>Mr John Smith</code>，输出<code>Mr%20John%20Smith</code>。]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试题之strcpy/strlen/strcat/strcmp的实现]]></title>
    <link href="http://yoursite.com/2015/03/15/string-operating-function/"/>
    <id>http://yoursite.com/2015/03/15/string-operating-function/</id>
    <published>2015-03-15T09:15:22.000Z</published>
    <updated>2015-05-10T11:11:47.072Z</updated>
    <content type="html"><![CDATA[<p>阿里的电面要我用C/C++实现一个字符串拷贝的函数，虽然以前写过 strcpy 的函数实现，但时间过去很久了，再加上有点紧张，突然就措手不及了。最后写是写出来了，但没考虑异常的情况，面试官好像很不满意。(T_T)，写篇文章记录一下，以免日后重蹈覆辙。</p>
<h3 id="一、字符串拷贝strcpy">一、字符串拷贝strcpy</h3><p>函数<code>strcpy</code>的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">strcpy</span>(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span><br><span class="line">&#123;</span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL)); </span><br><span class="line">	<span class="keyword">char</span> *address = des;  </span><br><span class="line">	<span class="keyword">while</span>((*des++ = *src++) != <span class="string">'\0'</span>)  </span><br><span class="line">		;  </span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要知道 strcpy 会拷贝’\0’，还有要注意：</p>
<ul>
<li><p>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。</p>
</li>
<li><p>要判断源指针和目的指针为空的情况，思维要严谨，这里使用<code>assert</code>（见文末）。</p>
</li>
<li><p>要用一个临时变量保存目的串的首地址，最后返回这个首地址。</p>
</li>
<li><p>函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。</p>
</li>
</ul>
<p><br></p>
<h3 id="二、字符串长度strlen">二、字符串长度strlen</h3><p>函数<code>strlen</code>的原型是<code>size_t strlen(const char *s)</code>，其中 size_t 就是 unsigned int。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	assert(str != NULL);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((*str++) != <span class="string">'\0'</span>)</span><br><span class="line">		++len;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>strlen 与 sizeof 的区别：</p>
<ul>
<li><p>sizeof是运算符，strlen是库函数。</p>
</li>
<li><p>sizeof可以用类型、变量做参数，而strlen只能用 char* 变量做参数，且必须以<code>\0</code>结尾。</p>
</li>
<li><p>sizeof是在编译的时候计算类型或变量所占内存的大小，而strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度。</p>
</li>
<li><p>数组做sizeof的参数不退化，传递给strlen就退化为指针了。</p>
</li>
</ul>
<p><br></p>
<h3 id="三、字符串连接strcat">三、字符串连接strcat</h3><p>函数<code>strcat</code>的原型是<code>char* strcat(char* des, char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">strcat</span>(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)   <span class="comment">// const表明为输入参数 </span></span><br><span class="line">&#123;  </span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL));</span><br><span class="line">	<span class="keyword">char</span>* address = des;</span><br><span class="line">	<span class="keyword">while</span>(*des != <span class="string">'\0'</span>)  <span class="comment">// 移动到字符串末尾</span></span><br><span class="line">		++des;</span><br><span class="line">	<span class="keyword">while</span>(*des++ = *src++)</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、字符串比较strcmp">四、字符串比较strcmp</h3><p>函数<code>strcmp</code>的原型是<code>int strcmp(const char *s1,const char *s2)</code>。  </p>
<ul>
<li>若s1==s2，返回零；</li>
<li>若s1&gt;s2，返回正数；</li>
<li>若s1&lt;s2，返回负数。</li>
</ul>
<p>即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇<code>\0</code>为止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	assert((s1!=NULL) &amp;&amp; (s2!=NULL));</span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1 == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
<h3 id="附：assert()断言">附：assert()断言</h3><p><code>assert</code>是宏，而不是函数。它的原型定义在头文件 assert.h 中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>宏 assert 经常用于在函数开始处检验传入参数的合法性，可以将其看作是异常处理的一种高级形式。<strong>assert 的作用是</strong>先计算表达式expression，然后判断：</p>
<ul>
<li><p>如果表达式值为假，那么它先向stderr打印错误信息，然后通过调用 abort 来终止程序运行。</p>
</li>
<li><p>如果表达式值为真，继续运行后面的程序。</p>
</li>
</ul>
<p>注意：<code>assert</code>只在 DEBUG 下生效，在调试结束后，可以通过在<code>#include &lt;assert.h&gt;</code>语句之前插入<code>#define NDEBUG</code>来禁用assert调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阿里的电面要我用C/C++实现一个字符串拷贝的函数，虽然以前写过 strcpy 的函数实现，但时间过去很久了，再加上有点紧张，突然就措手不及了。最后写是写出来了，但没考虑异常的情况，面试官好像很不满意。(T_T)，写篇文章记录一下，以免日后重蹈覆辙。</p>
<h3 id="一、字符串拷贝strcpy">一、字符串拷贝strcpy</h3><p>函数<code>strcpy</code>的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树（BST）]]></title>
    <link href="http://yoursite.com/2015/01/13/binary-search-tree/"/>
    <id>http://yoursite.com/2015/01/13/binary-search-tree/</id>
    <published>2015-01-12T16:08:39.000Z</published>
    <updated>2015-05-10T11:02:28.213Z</updated>
    <content type="html"><![CDATA[<p><strong>二叉查找树（Binary Search Tree）</strong>又叫二叉排序树（Binary Sort Tree），它是一种数据结构，支持多种动态集合操作，如 Search、Insert、Delete、Minimum 和 Maximum 等。</p>
<p>二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。</p>
</li>
<li><p>左、右子树本身也分别是一棵二叉查找树（二叉排序树）。<a id="more"></a></p>
</li>
</ol>
<p>可以看出，二叉查找树是一个递归的数据结构，且对二叉查找树进行中序遍历，可以得到一个<strong>递增</strong>的有序序列。</p>
<p>首先，我们来定义一下 BST 的结点结构体，结点中除了 key 域，还包含域 left, right 和 parent，它们分别指向结点的左儿子、右儿子和父节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	Node* left;</span><br><span class="line">	Node* right;</span><br><span class="line">	Node* parent;</span><br><span class="line">&#125; *BSTree;</span><br></pre></td></tr></table></figure></p>
<h3 id="一、BST的插入与构造">一、BST的插入与构造</h3><p>二叉查找树作为一种动态结构，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在结点的关键字等于给定值时再进行插入。</p>
<p>由于二叉查找树是递归定义的，插入结点的过程是：若原二叉查找树为空，则直接插入；否则，若关键字 k 小于根结点关键字，则插入到左子树中，若关键字 k 大于根结点关键字，则插入到右子树中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入：将关键字k插入到二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k, Node* parent=NULL)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		T-&gt;key = k;</span><br><span class="line">		T-&gt;left = NULL;</span><br><span class="line">		T-&gt;right = NULL;</span><br><span class="line">		T-&gt;parent = parent;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 返回1表示成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 树中存在相同关键字</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;left, k, T);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;right, k, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造</strong>一棵二叉查找树就是依次输入数据元素，并将它们插入到二叉排序树中的适当位置。具体过程是：每读入一个元素，就建立一个新结点；若二叉查找树为空，则新结点作为根结点；若二叉查找树非空，则将新结点的值与根结点的值比较，如果小于根结点的值，则插入到左子树中，否则插入到右子树中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 构造：用数组arr[]创建二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T = NULL;  <span class="comment">// 初始时为空树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		BST_Insert(T, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，插入的新结点一定是某个叶结点。另外，插入操作既可以递归实现，也可以使用非递归（迭代）实现。通常来说非递归的效率会更高。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 非递归插入：将关键字k插入到二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert_NonRecur</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node* pre = NULL;  <span class="comment">// 记录上一个结点</span></span><br><span class="line">	Node* t = T;</span><br><span class="line">	<span class="keyword">while</span>(t != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		pre = t;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; t-&gt;key)</span><br><span class="line">			t = t-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; t-&gt;key)</span><br><span class="line">			t = t-&gt;right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	node-&gt;key = k;</span><br><span class="line">	node-&gt;left = NULL;</span><br><span class="line">	node-&gt;right = NULL;</span><br><span class="line">	node-&gt;parent = pre;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pre == NULL)</span><br><span class="line">		T = node;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; pre-&gt;key)</span><br><span class="line">			pre-&gt;left = node;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pre-&gt;right = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、BST的查找">二、BST的查找</h3><p>对于二叉查找树，最常见的操作就是查找树中的某个关键字。除了Search操作外，二叉查找树还能支持如 Minimum（最小值）、Maximum（最大值）、Predecessor（前驱）、Successor（后继）等查询。对于高度为 h 的树，这些操作都可以在 Θ(h) 时间内完成。</p>
<p><strong>1. 查找</strong></p>
<p>BST 的查找是从根结点开始，若二叉树非空，将给定值与根结点的关键字比较，若相等，则查找成功；若不等，则当给定值小于根结点关键字时，在根结点的左子树中查找，否则在根结点的右子树中查找。显然，这是一个递归的过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 递归查找：返回指向包含关键字k的结点的指针</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Search(BSTree T, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL || k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Search(T-&gt;left, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> BST_Search(T-&gt;right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用非递归的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 非递归查找：返回指向包含关键字k的结点的指针</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Search_NonRecur(BSTree T, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T != NULL &amp;&amp; k != T-&gt;key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">			T = T-&gt;left;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T = T-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 最大值与最小值</strong></p>
<p>由二叉查找树的性质可知，最左下结点即为关键字最小的结点，最右下结点即为关键字最大的结点。此过程无需比较，只需要沿着最左和最右的路径查找下去，直到遇到 NULL 为止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 最小值：查找二叉查找树中关键字最小的结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Minimum(BSTree T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T-&gt;left != NULL)</span><br><span class="line">		T = T-&gt;left;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 最大值：查找二叉查找树中关键字最大的结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Maximum(BSTree T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T-&gt;right != NULL)</span><br><span class="line">		T = T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 前驱与后继</strong></p>
<p>给定一个二叉查找树的结点，求出它在<strong>中序遍历</strong>中的前驱与后继。如果所有的关键字均不相同，则某结点 x 的后继是：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继就是它的右子树中关键字值最小的结点；</p>
</li>
<li><p>若结点 x 的右子树为空，为了找到其后继，从结点 x 开始向上查找，直到遇到一个祖先结点 y，它的左儿子也是结点 x 的祖先，则结点 y 就是结点 x 的后继。如下图</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150110234933625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 后继：查找给定结点在中序遍历中的后继结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Successor(Node* node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;right != NULL)</span><br><span class="line">		<span class="keyword">return</span> BST_Minimum(node-&gt;right);</span><br><span class="line">	Node* p = node-&gt;parent;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right == node)</span><br><span class="line">	&#123;</span><br><span class="line">		node = p;</span><br><span class="line">		p = p-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求前驱（predecessor）的过程对称，对于某个结点 x ，它的前驱是：</p>
<ul>
<li><p>若结点 x 的左子树不为空，则 x 的前驱是它的左子树中关键字值最大的结点；</p>
</li>
<li><p>若结点 x 的左子树为空，为了找到其前驱，从结点 x 开始向上查找，直到遇到一个祖先结点 y，它的右儿子也是结点 x 的祖先，则结点 y 就是结点 x 的前驱。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 前驱：查找给定结点在中序遍历中的前驱结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Predecessor(Node* node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;left != NULL)</span><br><span class="line">		<span class="keyword">return</span> BST_Maximum(node-&gt;left);</span><br><span class="line">	Node* p = node-&gt;parent;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;left == node)</span><br><span class="line">	&#123;</span><br><span class="line">		node = p;</span><br><span class="line">		p = p-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以在这里讨论如何求中序序列的后继，主要是为了后面讲删除操作做铺垫。</p>
<h3 id="三、BST的删除">三、BST的删除</h3><p>二叉查找树的删除操作是相对复杂一点，它要按 3 种情况来处理：</p>
<ul>
<li><p>若被删除结点 z 是叶子结点，则直接删除，不会破坏二叉排序树的性质；</p>
</li>
<li><p>若结点 z 只有左子树或只有右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置；</p>
</li>
<li><p>若结点 z 既有左子树，又有右子树，则用 z 的后继（Successor）代替 z，然后从二叉查找树中删除这个后继，这样就转换成了第一或第二种情况。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_Delete</span><span class="params">(BSTree &amp;T,Node* z)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(z-&gt;left == NULL &amp;&amp; z-&gt;right == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = NULL;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = NULL;  <span class="comment">// 只剩一个结点的情况</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;left != NULL &amp;&amp; z-&gt;right == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		z-&gt;left-&gt;parent = z-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = z-&gt;left;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = z-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = z-&gt;left;  <span class="comment">// 删除左斜单支树的根结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;left == NULL &amp;&amp; z-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		z-&gt;right-&gt;parent = z-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = z-&gt;right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = z-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = z-&gt;right;  <span class="comment">// 删除右斜单支树的根结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node* s = BST_Successor(z);</span><br><span class="line">		z-&gt;key = s-&gt;key;   <span class="comment">// s的关键字替换z的关键字</span></span><br><span class="line">		BST_Delete(T, s);  <span class="comment">// 转换为第一或第二种情况</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个高度为 h 的二叉查找树来说，删除操作和插入操作一样，都可以在 Θ(h) 时间内完成。</p>
<h3 id="四、随机构造的二叉查找树">四、随机构造的二叉查找树</h3><p>二叉查找树可以实现任何一种基本的动态集合操作，且各基本操作的运行时间都是 Θ(h)。当树的高度较低时，这些操作执行的较快；但是，当树的高度较高时，性能会变差。比如，<strong>如果各元素是按严格增长的顺序插入的，那么构造出来的树就是一个高度为 n-1 的链。</strong> 为了尽量减少这种最坏情况的出现，我们可以随机地构造二叉查找树，即随机地将各关键字插入一棵初始为空的树来构造 BST。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;ctime&gt;</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机构造二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T = NULL;  </span><br><span class="line">	<span class="comment">// 随机遍历数组，进行插入操作</span></span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">		BST_Insert(T, arr[j]);</span><br><span class="line">		swap(arr[j], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
<h3 id="附：随机遍历数组">附：随机遍历数组</h3><p>在随机构造二叉查找树时，需要解决 随机遍历数组 的问题，即随机遍历一个数组中的所有元素，既不重复也不遗漏。这里能想到的一种思路是：先随机生成<code>0...n-1</code>之间的一个数，然后与数组最后一个数交换，然后再随机生成<code>0...n-2</code>之间的一个数，与数组倒数第二个数交换，直到整个数组遍历结束。显然这个算法的时间复杂度是 O(n)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;ctime&gt;    <span class="comment">// time</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> tmp = a;  </span><br><span class="line">	a = b;  </span><br><span class="line">	b = tmp;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机遍历数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse_Random</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 输出</span></span><br><span class="line">		swap(arr[j], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	Traverse_Random(arr, <span class="number">9</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>（全文完）</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>二叉查找树（Binary Search Tree）</strong>又叫二叉排序树（Binary Sort Tree），它是一种数据结构，支持多种动态集合操作，如 Search、Insert、Delete、Minimum 和 Maximum 等。</p>
<p>二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。</p>
</li>
<li><p>左、右子树本身也分别是一棵二叉查找树（二叉排序树）。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之构造函数中的异常处理]]></title>
    <link href="http://yoursite.com/2015/01/12/cpp-exception-in-constructor/"/>
    <id>http://yoursite.com/2015/01/12/cpp-exception-in-constructor/</id>
    <published>2015-01-12T09:06:05.000Z</published>
    <updated>2015-05-10T10:59:43.206Z</updated>
    <content type="html"><![CDATA[<p>构造函数中可不可以抛出异常？当然可以。从语法上来说，是可以的；从实际情况来看，现在的软件系统日渐庞大和复杂，很难保证 Constructor 在执行过程中完全不发生一点异常。</p>
<p>那么，如果构造函数中抛出异常，会发生什么情况呢？</p>
<h3 id="一、构造函数中抛出异常将导致对象的析构函数不被执行。">一、构造函数中抛出异常将导致对象的析构函数不被执行。</h3><p>C++仅能 delete 被完全构造的对象（fully constructed objects），只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。所以如果在构造函数中抛出一个异常，这个异常将传递到创建对象的地方（程序控制权也会随之转移），这样对象就只是部分被构造，它的析构函数将不会被执行。<a id="more"></a></p>
<p>看下面的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************类定义**********************/</span></span><br><span class="line"><span class="keyword">class</span> person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str):name(str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//throw exception("测试：在构造函数中抛出一个异常");</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造一个对象！"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁一个对象！"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************测试类**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">person <span class="title">me</span><span class="params">("songlee")</span></span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(exception e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意上面的 me 是一个局部对象，所以离开<code>try{}</code>的作用域，会自动执行析构函数。运行上述代码，输出结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造一个对象！</span><br><span class="line">销毁一个对象！</span><br></pre></td></tr></table></figure></p>
<p>如果在构造函数中抛出一个异常（去掉注释），输出结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试：在构造函数中抛出一个异常</span><br></pre></td></tr></table></figure></p>
<p>可以看出，析构函数没有被自动执行。为什么<em>“构造一个对象！”</em>也没有输出呢？因为程序控制权转移了，所以在异常点以后的语句都不会被执行。</p>
<h3 id="二、构造函数抛出异常可能导致内存泄露">二、构造函数抛出异常可能导致内存泄露</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B() &#123; </span><br><span class="line">		<span class="comment">//throw exception("测试：在B的构造函数中抛出一个异常");</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造 B 对象!"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~B()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁 B 对象!"</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Tester &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address);</span><br><span class="line">	~Tester();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> theName;</span><br><span class="line">	<span class="built_in">string</span> theAddress;</span><br><span class="line">	A *a;</span><br><span class="line">	B *b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面声明了三个类（A、B、Tester）,其中Tester类的构造函数和析构函数定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tester::Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address):</span><br><span class="line">	theName(name),</span><br><span class="line">	theAddress(address)</span><br><span class="line">&#123;</span><br><span class="line">	a = <span class="keyword">new</span> A();</span><br><span class="line">	b = <span class="keyword">new</span> B();  <span class="comment">// &lt;——</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造 Tester 对象!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tester::~Tester()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁 Tester 对象!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造函数中，动态的分配了内存空间给a、b两个指针。析构函数负责删除这些指针，确保Tester对象不会发生内存泄露（C++中delete一个空指针也是安全的）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tester *tes = NULL;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		tes = <span class="keyword">new</span> Tester(<span class="string">"songlee"</span>,<span class="string">"201"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(exception e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">delete</span> tes; <span class="comment">// 删除NULL指针是安全的</span></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行输出结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造 B 对象!</span><br><span class="line">构造 Tester 对象!</span><br><span class="line">销毁 B 对象!</span><br><span class="line">销毁 Tester 对象!</span><br></pre></td></tr></table></figure></p>
<p>看上去好像一切良好，在正常情况下确实没有错。但是在有异常的情况下，恐怕就不会良好了。</p>
<p><strong>试想在 Tester 的构造函数执行时，</strong><code>b = new B()</code><strong>抛出了异常：</strong>可能是因为operator new不能给B对象分配足够的内存，也可能是因为 B 的构造函数自己抛出了一个异常。不论什么原因，在 Tester 构造函数内抛出异常，这个异常将传递到建立 Tester 对象的地方（程序控制权也会转移）。</p>
<p>在 B 的构造函数里抛出异常（去掉注释）时，程序运行结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试：在B的构造函数中抛出一个异常</span><br></pre></td></tr></table></figure></p>
<p>可以看出，C++拒绝为没有完成构造操作的对象调用析构函数，即使你使用了<code>delete</code>语句。由于 Tester 的析构函数不会执行，所以给A对象 a 动态分配（new）的空间无法释放，将造成内存泄露。</p>
<p><strong>注：</strong>不用为 Tester 对象中的非指针数据成员操心，因为它们不是new出来的，且在异常抛出之前已经构造完全，所以它们会自动逆序析构。</p>
<h3 id="三、解决上述内存泄露的方法">三、解决上述内存泄露的方法</h3><p>因为当对象在构造中抛出异常后C++不负责清除（动态分配）的对象，所以你必须重新设计构造函数以让它们自己清除。<strong>常用的方法</strong>是捕获所有的异常，然后执行一些清除代码，最后再重新抛出异常让它继续传递。</p>
<p>示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Tester::Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address):</span><br><span class="line">	theName(name),</span><br><span class="line">	theAddress(address),</span><br><span class="line">	a(NULL),   <span class="comment">// 初始化为空指针是必须的</span></span><br><span class="line">	b(NULL)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="keyword">new</span> A();</span><br><span class="line">		b = <span class="keyword">new</span> B();  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(...)   <span class="comment">// 捕获所有异常</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> a;</span><br><span class="line">		<span class="keyword">delete</span> b;</span><br><span class="line">		<span class="keyword">throw</span>;   <span class="comment">// 继续传递异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种更好的方法是使用<strong>智能指针（smart pointer）</strong>，不过关于智能指针的内容比较多，在这里就不说了。</p>
<p><br><br><br><br><br><br><strong>总结：</strong></p>
<ul>
<li><p>在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。</p>
</li>
<li><p>构造函数中抛出异常，对象的析构函数将不会被执行。</p>
</li>
<li><p>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露。</p>
</li>
<li><p>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>构造函数中可不可以抛出异常？当然可以。从语法上来说，是可以的；从实际情况来看，现在的软件系统日渐庞大和复杂，很难保证 Constructor 在执行过程中完全不发生一点异常。</p>
<p>那么，如果构造函数中抛出异常，会发生什么情况呢？</p>
<h3 id="一、构造函数中抛出异常将导致对象的析构函数不被执行。">一、构造函数中抛出异常将导致对象的析构函数不被执行。</h3><p>C++仅能 delete 被完全构造的对象（fully constructed objects），只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。所以如果在构造函数中抛出一个异常，这个异常将传递到创建对象的地方（程序控制权也会随之转移），这样对象就只是部分被构造，它的析构函数将不会被执行。]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android网络爬虫程序（基于Jsoup）]]></title>
    <link href="http://yoursite.com/2015/01/11/android-crawler/"/>
    <id>http://yoursite.com/2015/01/11/android-crawler/</id>
    <published>2015-01-11T15:53:11.000Z</published>
    <updated>2015-05-10T10:52:59.184Z</updated>
    <content type="html"><![CDATA[<p>摘要：基于 Jsoup 实现一个 Android 的网络爬虫程序，抓取网页的内容并显示出来。写这个程序的主要目的是抓取<a href="http://xjh.haitou.cc/" target="_blank" rel="external">海投网</a>的宣讲会信息（公司、时间、地点）并在移动端显示，这样就可以随时随地的浏览在学校举办的宣讲会信息了。</p>
<h3 id="一、Jsoup简介">一、Jsoup简介</h3><p><a href="http://jsoup.org/" target="_blank" rel="external">Jsoup</a> 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常方便的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>Jsoup主要有以下功能：<a id="more"></a></p>
<ul>
<li><p>从一个URL，文件或字符串中解析HTML；</p>
</li>
<li><p>使用DOM或CSS选择器来查找、取出数据；</p>
</li>
<li><p>对HTML元素、属性、文本进行操作；</p>
</li>
<li><p>清除不受信任的HTML (来防止XSS攻击)</p>
</li>
</ul>
<p>好了，下面写几段代码来说明 Jsoup 是如何优雅的进行 HTML 文档处理的。首先，我们需要去 <a href="http://jsoup.org/download" target="_blank" rel="external">Jsoup官网</a> 下载Jsoup的<code>jar</code>包，然后加入项目的依赖库中。</p>
<p><strong>1） HTML解析</strong></p>
<p>Jsoup 可以从一个字符串、文件或者一个 URL 中解析HTML，解析的目的主要是为了得到一个干净完整的解析结果，并生成 Document 对象实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a document from a String</span></span><br><span class="line">String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;神奕的博客&lt;/title&gt;&lt;/head&gt;"</span></span><br><span class="line">        +<span class="string">"&lt;body&gt;&lt;p&gt;搭个博客写学习笔记！！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">Document doc = Jsoup.parse(html);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load a Document from a File</span></span><br><span class="line">File input = <span class="keyword">new</span> File(<span class="string">"D://a.html"</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load a Document from a URL</span></span><br><span class="line">Document doc = Jsoup.connect(<span class="string">"http://example.com/"</span>).get();</span><br></pre></td></tr></table></figure></p>
<p>当加载和解析一个本地的HTML文件时，如果在加载文件的时候发生错误，将抛出 IOException，应作适当处理。</p>
<p><strong>2） 数据提取</strong></p>
<p>将HTML解析成一个<code>Document</code>之后，就可以使用传统的 DOM 方法进行数据抽取。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 海投网</span></span><br><span class="line">String url = <span class="string">"http://xjh.haitou.cc/wh/uni-1/after/hold/page-1/"</span>;</span><br><span class="line">Document doc = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line">Elements elements = doc.getElementsByTag(<span class="string">"company"</span>);</span><br><span class="line"><span class="keyword">for</span>(Element e : elements) &#123;</span><br><span class="line">    System.out.println(e.text());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Document 对象和 Elements 对象提供了一系列类似于DOM的方法来查找元素，比如 getElementById(String id)、getElementsByTag(String tag) 等等。更多方法请看《<a href="http://www.open-open.com/jsoup/dom-navigation.htm" target="_blank" rel="external">Jsoup Cookbook</a>》。</p>
<p>另外，还可以使用 Selector 选择器（类似于CSS或jQuery语法）来查找元素。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 海投网</span></span><br><span class="line">String url = <span class="string">"http://xjh.haitou.cc/wh/uni-1/after/hold/page-1/"</span>;</span><br><span class="line">Document doc = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过标签company查找元素</span></span><br><span class="line">Elements company = doc.select(<span class="string">"company"</span>);</span><br><span class="line"><span class="comment">// 带有href属性的a元素</span></span><br><span class="line">Elements links = doc.select(<span class="string">"a[href]"</span>);</span><br><span class="line"><span class="comment">// 扩展名为.png的图片</span></span><br><span class="line">Elements pngs = doc.select(<span class="string">"img[src$=.png]"</span>);</span><br><span class="line"><span class="comment">// class等于content的div标签</span></span><br><span class="line">Element content = doc.select(<span class="string">"div.content"</span>).first();</span><br></pre></td></tr></table></figure></p>
<p>选择器实现了非常强大和灵活的查找功能。<code>select</code>方法在Document、Element 或 Elements 对象中都可以使用，且是上下文相关的，因此可实现指定元素的过滤或者链式选择访问。<code>select</code>方法将返回一个Elements集合，并提供一组方法来抽取和处理结果。</p>
<p>通过 DOM 方法或者 Selector 方法查找到一些 Elements 元素之后，我们需要从这些元素中取得数据，下面是几个常用的方法：</p>
<ul>
<li><p>取得一个属性的值，可以使用<code>Node.attr(String key)</code>方法；</p>
</li>
<li><p>取得一个元素中的文本，可以使用<code>Element.text()</code>方法；</p>
</li>
<li><p>取得元素或属性中的HTML内容，可用<code>Element.html()</code>或<code>Node.outerHtml()</code>方法</p>
</li>
<li><p>取得一个元素的 id ：<code>Element.id()</code></p>
</li>
<li><p>取得一个元素的标签名：<code>Element.tagName()</code></p>
</li>
<li><p>取得一个元素的类名：<code>Element.className()</code></p>
</li>
</ul>
<p><strong>3） 数据修改</strong></p>
<p>在解析一个 Document 之后可能想修改其中的某些属性值、HTML或文本内容，然后再保存到磁盘或都输出到前台页面。例如：我们可以为文档中的所有图片增加可点击链接、修改链接地址或者是修改文本等。Jsoup 提供了很多方法用来进行修改，这里就不列举了，请移步 <a href="http://www.open-open.com/jsoup/set-attributes.htm" target="_blank" rel="external">Jsoup Cookbook</a> 。</p>
<h3 id="二、海投网的页面抓取">二、海投网的页面抓取</h3><p><a href="http://www.haitou.cc/" target="_blank" rel="external">海投网</a>是一个为高校毕业生服务的招聘信息网，创始人是华中科技大学的毕业生。现在我要抓取在华中科技大学举办的宣讲会的信息，网页如下图：</p>
<p><img src="http://img.blog.csdn.net/20150124222530359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>查看网页源代码，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150124222646938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>可以看出，公司名是在一个 company 标签内，宣讲会时间是在一个类名为 text-center 的 td 标签内，学校的具体地点则是在一个类名为 preach-tbody-addre 的 td 标签内。这么一分析，要提取华中科技大学的宣讲会信息就变得挺简单了。</p>
<p>Java代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jsoup.Connection;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String url = <span class="string">"http://xjh.haitou.cc/wh/uni-1/after/hold/page-1/"</span>;</span><br><span class="line">        Connection conn = Jsoup.connect(url);</span><br><span class="line">        <span class="comment">// 修改http包中的header,伪装成浏览器进行抓取</span></span><br><span class="line">        conn.header(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:32.0) Gecko/    20100101 Firefox/32.0"</span>);</span><br><span class="line">        Document doc = conn.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取tbody元素下的所有tr元素</span></span><br><span class="line">        Elements elements = doc.select(<span class="string">"tbody tr"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Element element : elements) &#123;</span><br><span class="line">        	String companyName = element.getElementsByTag(<span class="string">"company"</span>).text();</span><br><span class="line">        	String time = element.select(<span class="string">"td.text-center"</span>).first().text();</span><br><span class="line">        	String address = element.getElementsByClass(<span class="string">"preach-tbody-addre"</span>).text();</span><br><span class="line">        	</span><br><span class="line">        	System.out.println(<span class="string">"公司："</span>+companyName);</span><br><span class="line">        	System.out.println(<span class="string">"宣讲时间："</span>+time);</span><br><span class="line">        	System.out.println(<span class="string">"宣讲学校：华中科技大学"</span>);</span><br><span class="line">        	System.out.println(<span class="string">"具体地点："</span>+address);</span><br><span class="line">        	System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>某些网站禁止爬虫，不能抓取或者抓取一定数量后封IP。这时候我们需要<strong>伪装成浏览器</strong>进行抓取，这可以通过修改http包中的header来实现（<a href="http://www.966266.com/jishu/user-agent-chaxun.html" target="_blank" rel="external">设置User-Agent</a>）。运行上面的程序得到输出结果：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">公司：瑞声科技(常州)有限公司</span><br><span class="line">宣讲时间：2015-03-07 19:00(周六)</span><br><span class="line">宣讲学校：华中科技大学</span><br><span class="line"><span class="header">具体地点：大学生活动中心305阶梯教室</span><br><span class="line">---------------------------------</span></span><br><span class="line">公司：普联技术有限公司</span><br><span class="line">宣讲时间：2015-03-08 19:00(周日)</span><br><span class="line">宣讲学校：华中科技大学</span><br><span class="line"><span class="header">具体地点：大学生活动中心305阶梯教室</span><br><span class="line">---------------------------------</span></span><br><span class="line">公司：大联大投资控股股份有限公司</span><br><span class="line">宣讲时间：2015-03-09 09:30(周一)</span><br><span class="line">宣讲学校：华中科技大学</span><br><span class="line"><span class="header">具体地点：大学生活动中心305阶梯教室</span><br><span class="line">---------------------------------</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h3 id="三、应用到Android程序中">三、应用到Android程序中</h3><p>开发 Android 程序，你需要搭建开发环境，很简单：先安装Java的JDK（最好不低于1.6），然后去<a href="http://developer.android.com" target="_blank" rel="external">Android官网</a>下载并安装 <strong>Android Studio</strong> 就行了。</p>
<p>在Android程序中使用 Jsoup 需要注意两点：</p>
<ul>
<li><p>在AndroidManifest.xml文件中添加网络访问权限<code>android.permission.INTERNET</code></p>
</li>
<li><p>Android在4.0之后，不允许在主线程里执行网络（http）请求，也就是说 Jsoup 的代码需要写在子线程里。</p>
</li>
</ul>
<p><strong>1） 多线程</strong></p>
<p>4.0 版本以后，如果你在主线程里尝试进行网络操作，会报android.os.NetworkOnMainThreadException 的异常。所以我们需要开辟子线程进行异步加载，用到<code>Thread</code>、<code>Runnable</code>、<code>Handler</code>这三个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">this</span>.setContentView(R.layout.share_mblog_view);</span><br><span class="line">    <span class="comment">// 开辟一个线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="javadoc">/**</span><br><span class="line">         * 要执行的操作</span><br><span class="line">         */</span></span><br><span class="line">    	<span class="comment">// 执行完毕后给handler发送一个空消息</span></span><br><span class="line">        handler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="javadoc">/**</span><br><span class="line">         * 处理UI</span><br><span class="line">         */</span></span><br><span class="line">    	<span class="comment">// 当收到消息时就会执行这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2） 判断网络连接是否可用</strong></p>
<p>如果在没有可用网络的情况下执行网络爬虫程序，App将会报错。所以在每次执行之前都应该先判断网络是否可用。大致步骤如下：</p>
<p>① 获取ConnectivityManager对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Context context = activity.getApplicationContext();</span><br><span class="line"><span class="comment">// 获取手机所有连接管理对象（包括对wi-fi,net等连接的管理）</span></span><br><span class="line">ConnectivityManager cm = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br></pre></td></tr></table></figure></p>
<p>② 获取NetworkInfo对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkInfo info = cm.getActiveNetworkInfo();</span><br></pre></td></tr></table></figure></p>
<p>③ 判断网络类型，Android的网络分为两大类：WIFI 和 手机网络<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WIFI 判定条件</span></span><br><span class="line">info != <span class="keyword">null</span> &amp;&amp; info.getType() == ConnectivityManager.TYPE_WIFI</span><br><span class="line"><span class="comment">// 手机网络 判定条件</span></span><br><span class="line">info !=<span class="keyword">null</span> &amp;&amp; info.getType() ==  ConnectivityManager.TYPE_MOBILE</span><br></pre></td></tr></table></figure></p>
<p>而手机网络具体又分为很多类，比如移动3G、移动2G、联通2G等等。这里就不说了，自行Google。</p>
<p>④ 判断网络连接是否可用（包括所有网络类型）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNetworkAvailable</span><span class="params">(Activity activity)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Context context = activity.getApplicationContext();</span><br><span class="line">    ConnectivityManager cm = (ConnectivityManager) </span><br><span class="line">    		context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cm == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 获取所有NetworkInfo对象</span></span><br><span class="line">        NetworkInfo[] networkInfo = cm.getAllNetworkInfo();</span><br><span class="line">        <span class="keyword">if</span> (networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; networkInfo.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (networkInfo[i].getState() == NetworkInfo.State.CONNECTED)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 存在可用的网络连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，要在 AndroidManifest.xml 文件中添加访问网络状态的权限：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p><br><br>另外，本程序在 UI 界面开发上涉及到 Android 中的 ListView（显示）、PopupWindow（菜单）、ProgressDialog（加载）、AlertDialog（提示）等控件的使用。因为本文并不是讨论 Android 控件的使用，在这里就不赘述了。</p>
<p><img src="http://img.blog.csdn.net/20150124232559703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>源码下载：</strong><a href="https://github.com/SongLee24/android-crawler" target="_blank" rel="external">https://github.com/SongLee24/android-crawler</a></p>
<p><br><br><br><br><br><br>（全文完）<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘要：基于 Jsoup 实现一个 Android 的网络爬虫程序，抓取网页的内容并显示出来。写这个程序的主要目的是抓取<a href="http://xjh.haitou.cc/">海投网</a>的宣讲会信息（公司、时间、地点）并在移动端显示，这样就可以随时随地的浏览在学校举办的宣讲会信息了。</p>
<h3 id="一、Jsoup简介">一、Jsoup简介</h3><p><a href="http://jsoup.org/">Jsoup</a> 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常方便的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>Jsoup主要有以下功能：]]>
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="System-Android" scheme="http://yoursite.com/categories/System-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AES加密算法的C++实现]]></title>
    <link href="http://yoursite.com/2014/12/13/aes-encrypt/"/>
    <id>http://yoursite.com/2014/12/13/aes-encrypt/</id>
    <published>2014-12-13T06:47:48.000Z</published>
    <updated>2015-05-10T10:47:59.945Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要：</strong>作为新一代的加密标准，AES 旨在取代 DES（请看《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external">DES加密算法的C++实现</a>》），以适应当今分布式开放网络对数据加密安全性的要求。本文在分析了 AES 加密原理的基础上着重说明了算法实现的具体步骤，并用 C++ 实现了对文件的加密和解密。</p>
<h1 id="一、AES_介绍">一、AES 介绍</h1><p><strong>AES（高级加密标准，Advanced Encryption Standard）</strong>，在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种分组加密标准。这个标准用来替代原先的 DES，目前已经广为全世界所使用，成为对称密钥算法中最流行的算法之一。<a id="more"></a></p>
<p>在 AES 出现之前，最常用的对称密钥算法是 <a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external"><strong>DES 加密算法</strong></a>，它在 1977 年被公布成为美国政府的商用加密标准。DES 的主要问题是密钥长度较短，渐渐不适合于分布式开放网络对数据加密安全性的要求。因此，1998年美国政府决定不再继续延用 DES 作为联邦加密标准，并发起了征集 AES 候选算法的活动。征集活动对 AES 的基本要求是： 比三重DES快、至少与三重DES一样安全、数据分组长度为128比特、密钥长度为128/192/256比特。</p>
<p>经过三年多的甄选，比利时的密码学家所设计的 Rijndael 算法最终脱颖而出，成为新一代的高级加密标准，并于 2001 年由美国国家标准与技术研究院（NIST）发布于 <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf" target="_blank" rel="external">FIPS PUB 197</a>。</p>
<h1 id="二、AES_算法原理">二、AES 算法原理</h1><p>AES算法（即 Rijndael 算法）是一个对称分组密码算法。数据分组长度必须是 <strong>128 bits</strong>，使用的密钥长度为 <strong>128，192</strong> 或 <strong>256 bits</strong>。对于三种不同密钥长度的 AES 算法，分别称为<strong>“AES-128”、“AES-192”、“AES-256”</strong>。（Rijndael 的设计还可以处理其它的分组长度和密钥长度，但 AES 标准中没有采用）</p>
<p>下图是 AES 加密解密的整体流程图：</p>
<p><img src="http://img.blog.csdn.net/20141213142652421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>这里我们需要知道3个符号：<code>Nb</code>—— 状态 State 包含的列（32-bit 字）的个数，也就是说 Nb=4；<code>Nk</code>—— 密钥包含的 32-bit 字的个数，也就是说 Nk=4，6 或 8；<code>Nr</code>—— 加密的轮数，对于不同密钥长度，轮数不一样，具体如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20141213142619522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>下面分为密钥扩展、分组加密、分组解密三个部分来讲 AES 算法，我会尽可能地简明扼要，若还有不懂的，请自行 Google。</p>
<h2 id="1）密钥扩展">1）密钥扩展</h2><p>AES 算法通过密钥扩展程序（Key Expansion）将用户输入的密钥 K 扩展生成 <code>Nb(Nr+1)</code>个字，存放在一个线性数组<code>w[Nb*(Nr+1)]</code>中。具体如下：</p>
<ol>
<li><p>位置变换函数<code>RotWord()</code>，接受一个字 [a0, a1, a2, a3] 作为输入，循环左移一个字节后输出 [a1, a2, a3, a0]。</p>
</li>
<li><p>S盒变换函数<code>SubWord()</code>，接受一个字 [a0, a1, a2, a3] 作为输入。S盒是一个16x16的表，其中每一个元素是一个字节。对于输入的每一个字节，前四位组成十六进制数 x 作为行号，后四位组成的十六进制数 y 作为列号，查找表中对应的值。最后函数输出 4 个新字节组成的 32-bit 字。</p>
</li>
<li><p>轮常数<code>Rcon[]</code>，如何计算的就不说了，直接把它当做常量数组。</p>
</li>
<li><p>扩展密钥数组<code>w[]</code>的前 Nk 个元素就是外部密钥 K，以后的元素<code>w[i]</code>等于它前一个元素<code>w[i-1]</code>与前第 Nk 个元素<code>w[i-Nk]</code>的异或，即<code>w[i] = w[i-1] XOR w[i-Nk]</code>；但若 i 为 Nk 的倍数，则<code>w[i] = w[i-Nk] XOR SubWord(RotWord(w[i-1])) XOR Rcon[i/Nk-1]</code>。</p>
</li>
</ol>
<p>注意，上面的第四步说明适合于 AES-128 和 AES-192，详细的伪代码如下：</p>
<p><img src="http://img.blog.csdn.net/20141213142747609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>密钥扩展程序的 C++ 代码（AES-128）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bitset&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;8&gt; byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;32&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nr = <span class="number">10</span>;  <span class="comment">// AES-128需要 10 轮加密</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nk = <span class="number">4</span>;   <span class="comment">// Nk 表示输入密钥的 word 个数</span></span><br><span class="line"></span><br><span class="line">byte S_Box[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>,</span><br><span class="line">	 <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>, <span class="number">0x76</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, </span><br><span class="line">	 <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>, <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, </span><br><span class="line">	 <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>, <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>, </span><br><span class="line">	 <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, </span><br><span class="line">	 <span class="number">0x52</span>, <span class="number">0x3B</span>, <span class="number">0xD6</span>, <span class="number">0xB3</span>, <span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, </span><br><span class="line">	 <span class="number">0x6A</span>, <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>, <span class="number">0xCF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, </span><br><span class="line">	 <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x51</span>, <span class="number">0xA3</span>, <span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>, <span class="number">0x38</span>, <span class="number">0xF5</span>, </span><br><span class="line">	 <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, </span><br><span class="line">	 <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, </span><br><span class="line">	 <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, </span><br><span class="line">	 <span class="number">0xC2</span>, <span class="number">0xD3</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>, <span class="number">0x79</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, </span><br><span class="line">	 <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>, <span class="number">0x65</span>, <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, </span><br><span class="line">	 <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, </span><br><span class="line">	 <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE1</span>, <span class="number">0xF8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>, </span><br><span class="line">	 <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>, <span class="number">0xE6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, </span><br><span class="line">	 <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮常数，密钥扩展中用到。（AES-128只需要10轮）</span></span><br><span class="line">word Rcon[<span class="number">10</span>] = &#123;<span class="number">0x01000000</span>, <span class="number">0x02000000</span>, <span class="number">0x04000000</span>, <span class="number">0x08000000</span>, <span class="number">0x10000000</span>, </span><br><span class="line">				 <span class="number">0x20000000</span>, <span class="number">0x40000000</span>, <span class="number">0x80000000</span>, <span class="number">0x1b000000</span>, <span class="number">0x36000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将4个 byte 转换为一个 word.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">Word</span><span class="params">(byte&amp; k1, byte&amp; k2, byte&amp; k3, byte&amp; k4)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">word <span class="title">result</span><span class="params">(0x00000000)</span></span>;</span><br><span class="line">	word temp;</span><br><span class="line">	temp = k1.to_ulong();  <span class="comment">// K1</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">24</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k2.to_ulong();  <span class="comment">// K2</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k3.to_ulong();  <span class="comment">// K3</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k4.to_ulong();  <span class="comment">// K4</span></span><br><span class="line">	result |= temp;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  按字节 循环左移一位</span><br><span class="line"> *  即把[a0, a1, a2, a3]变成[a1, a2, a3, a0]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">RotWord</span><span class="params">(word&amp; rw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word high = rw &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	word low = rw &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	<span class="keyword">return</span> high | low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  对输入word中的每一个字节进行S-盒变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">SubWord</span><span class="params">(word&amp; sw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i+=<span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = sw[i+<span class="number">7</span>]*<span class="number">8</span> + sw[i+<span class="number">6</span>]*<span class="number">4</span> + sw[i+<span class="number">5</span>]*<span class="number">2</span> + sw[i+<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = sw[i+<span class="number">3</span>]*<span class="number">8</span> + sw[i+<span class="number">2</span>]*<span class="number">4</span> + sw[i+<span class="number">1</span>]*<span class="number">2</span> + sw[i];</span><br><span class="line">		byte val = S_Box[row][col];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)</span><br><span class="line">			temp[i+j] = val[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1)]</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyExpansion</span><span class="params">(byte key[4*Nk], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// w[]的前4个就是输入的key</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; Nk) </span><br><span class="line">	&#123;</span><br><span class="line">		w[i] = Word(key[<span class="number">4</span>*i], key[<span class="number">4</span>*i+<span class="number">1</span>], key[<span class="number">4</span>*i+<span class="number">2</span>], key[<span class="number">4</span>*i+<span class="number">3</span>]);</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = Nk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">4</span>*(Nr+<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		temp = w[i-<span class="number">1</span>]; <span class="comment">// 记录前一个word</span></span><br><span class="line">		<span class="keyword">if</span>(i % Nk == <span class="number">0</span>)</span><br><span class="line">			w[i] = w[i-Nk] ^ SubWord(RotWord(temp)) ^ Rcon[i/Nk-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			w[i] = w[i-Nk] ^ temp;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte key[<span class="number">16</span>] = &#123;<span class="number">0x2b</span>, <span class="number">0x7e</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, </span><br><span class="line">				    <span class="number">0x28</span>, <span class="number">0xae</span>, <span class="number">0xd2</span>, <span class="number">0xa6</span>, </span><br><span class="line">				    <span class="number">0xab</span>, <span class="number">0xf7</span>, <span class="number">0x15</span>, <span class="number">0x88</span>, </span><br><span class="line">				    <span class="number">0x09</span>, <span class="number">0xcf</span>, <span class="number">0x4f</span>, <span class="number">0x3c</span>&#125;;</span><br><span class="line"></span><br><span class="line">	word w[<span class="number">4</span>*(Nr+<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"KEY IS: "</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; key[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	KeyExpansion(key, w);</span><br><span class="line">	<span class="comment">// 测试</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>*(Nr+<span class="number">1</span>); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"w["</span> &lt;&lt; dec &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; hex &lt;&lt; w[i].to_ulong() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试输出结果：</p>
<p><img src="http://img.blog.csdn.net/20141213143023031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="2）加密">2）加密</h2><p>根据 AES 加密的整体流程图（本文开头），可以得出伪代码如下：</p>
<p><img src="http://img.blog.csdn.net/20141213143008999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从伪代码描述中可以看出，AES 加密时涉及到的子程序有<code>SubBytes()</code>、<code>ShiftRows()</code>、<code>MixColumns()</code>和<code>AddRoundKey()</code>。下面我们一个一个进行介绍：</p>
<h3 id="①_S盒变换-SubBytes()">① S盒变换-SubBytes()</h3><p>在密钥扩展部分已经讲过了，S盒是一个 16 行 16 列的表，表中每个元素都是一个字节。S盒变换很简单：函数<code>SubBytes()</code>接受一个 4x4 的字节矩阵作为输入，对其中的每个字节，前四位组成十六进制数 x 作为行号，后四位组成的十六进制数 y 作为列号，查找表中对应的值替换原来位置上的字节。</p>
<h3 id="②_行变换-ShiftRows()">② 行变换-ShiftRows()</h3><p>行变换也很简单，它仅仅是将矩阵的每一行以字节为单位<strong>循环移位</strong>：第一行不变，第二行左移一位，第三行左移两位，第四行左移三位。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20141213143028998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="③_列变换-MixColumns()">③ 列变换-MixColumns()</h3><p>函数<code>MixColumns()</code>同样接受一个 4x4 的字节矩阵作为输入，并对矩阵进行逐列变换，变换方式如下：</p>
<p><img src="http://img.blog.csdn.net/20141213143045019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>注意公式中用到的乘法是<a href="http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplication" target="_blank" rel="external">伽罗华域（GF，有限域）上的乘法</a>，高级加密标准文档 <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf" target="_blank" rel="external">fips-197</a> 上有讲，如果还是不懂，请自行Google。</p>
<p><img src="http://img.blog.csdn.net/20141213143147796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="④_与扩展密钥的异或-AddRoundKey()">④ 与扩展密钥的异或-AddRoundKey()</h3><p>扩展密钥只参与了这一步。根据当前加密的轮数，用<code>w[]</code>中的 4 个扩展密钥与矩阵的 4 个列进行按位异或。如下图：</p>
<p><img src="http://img.blog.csdn.net/20141213143206703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>好了，到这里 AES 加密的各个部分就讲完了。算法实现的 C++ 源码在文章后面第三部分。</p>
<h2 id="3）解密">3）解密</h2><p>根据 AES 解密的整体流程图（本文开头），可以得出伪代码如下：</p>
<p><img src="http://img.blog.csdn.net/20141213143139307?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从伪代码可以看出，我们需要分别实现 S 盒变换、行变换和列变换的逆变换<code>InvShiftRows()</code>、<code>InvSubBytes()</code>和<code>InvMixColumns()</code>。下面就简单的讲一下这三个逆变换：</p>
<h3 id="①_逆行变换-InvShiftRows()">① 逆行变换-InvShiftRows()</h3><p>上面讲到<code>ShiftRows()</code>是对矩阵的每一行进行循环左移，所以<code>InvShiftRows()</code>是对矩阵每一行进行循环右移。</p>
<p><img src="http://img.blog.csdn.net/20141213143154611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="②_逆_S_盒变换-InvSubBytes()">② 逆 S 盒变换-InvSubBytes()</h3><p>与 S 盒变换一样，也是查表，查表的方式也一样，只不过查的是另外一个置换表（S-Box的逆表）。</p>
<h3 id="③_逆列变换-InvMixColumns()">③ 逆列变换-InvMixColumns()</h3><p>与列变换的方式一样，只不过计算公式的系数矩阵发生了变化。如下图：</p>
<p><img src="http://img.blog.csdn.net/20141213143306000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>好了，AES 解密到这里也讲完了。只要写出三个逆变换的函数，然后根据伪代码就很容易实现 AES 解密算法了。</p>
<h1 id="三、C++实现">三、C++实现</h1><p>下面我用 C++ 实现 AES 的加密和解密算法，并实现了对文件的加密和解密。这里我使用 C++ STL 的<code>bitset</code>定义了两个类型：<code>byte</code>和<code>word</code>。需要提到的是，对于有限域上的乘法，我们既可以通过查表（6个结果表），也可以写一个函数来实现。当然，查表的效率会更高，但考虑到贴代码，这里我就用一个函数来实现的。</p>
<p>下面是 AES-128 对一个 128 位数据加密和解密的源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************  </span><br><span class="line">    &gt; File Name: AES.cpp </span><br><span class="line">    &gt; Author: SongLee  </span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com  </span><br><span class="line">    &gt; Created Time: 2014年12月12日 星期五 20时15分50秒  </span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com  </span><br><span class="line"> ************************************************************************/</span> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;8&gt; byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;32&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nr = <span class="number">10</span>;  <span class="comment">// AES-128需要 10 轮加密</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Nk = <span class="number">4</span>;   <span class="comment">// Nk 表示输入密钥的 word 个数</span></span><br><span class="line"></span><br><span class="line">byte S_Box[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>, </span><br><span class="line">	 <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>, <span class="number">0x76</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, </span><br><span class="line">	 <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>, <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, </span><br><span class="line">	 <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>, <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>, </span><br><span class="line">	 <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, </span><br><span class="line">	 <span class="number">0x52</span>, <span class="number">0x3B</span>, <span class="number">0xD6</span>, <span class="number">0xB3</span>, <span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, </span><br><span class="line">	 <span class="number">0x6A</span>, <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>, <span class="number">0xCF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, </span><br><span class="line">	 <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x51</span>, <span class="number">0xA3</span>, <span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>, <span class="number">0x38</span>, <span class="number">0xF5</span>, </span><br><span class="line">	 <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, </span><br><span class="line">	 <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, </span><br><span class="line">	 <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, </span><br><span class="line">	 <span class="number">0xC2</span>, <span class="number">0xD3</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>, <span class="number">0x79</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, </span><br><span class="line">	 <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>, <span class="number">0x65</span>, <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, </span><br><span class="line">	 <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, </span><br><span class="line">	 <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE1</span>, <span class="number">0xF8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>, </span><br><span class="line">	 <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>, <span class="number">0xE6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, </span><br><span class="line">	 <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">byte Inv_S_Box[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x52</span>, <span class="number">0x09</span>, <span class="number">0x6A</span>, <span class="number">0xD5</span>, <span class="number">0x30</span>, <span class="number">0x36</span>, <span class="number">0xA5</span>, <span class="number">0x38</span>, </span><br><span class="line">	 <span class="number">0xBF</span>, <span class="number">0x40</span>, <span class="number">0xA3</span>, <span class="number">0x9E</span>, <span class="number">0x81</span>, <span class="number">0xF3</span>, <span class="number">0xD7</span>, <span class="number">0xFB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x7C</span>, <span class="number">0xE3</span>, <span class="number">0x39</span>, <span class="number">0x82</span>, <span class="number">0x9B</span>, <span class="number">0x2F</span>, <span class="number">0xFF</span>, <span class="number">0x87</span>, </span><br><span class="line">	 <span class="number">0x34</span>, <span class="number">0x8E</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0xC4</span>, <span class="number">0xDE</span>, <span class="number">0xE9</span>, <span class="number">0xCB</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x54</span>, <span class="number">0x7B</span>, <span class="number">0x94</span>, <span class="number">0x32</span>, <span class="number">0xA6</span>, <span class="number">0xC2</span>, <span class="number">0x23</span>, <span class="number">0x3D</span>, </span><br><span class="line">	 <span class="number">0xEE</span>, <span class="number">0x4C</span>, <span class="number">0x95</span>, <span class="number">0x0B</span>, <span class="number">0x42</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x4E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x08</span>, <span class="number">0x2E</span>, <span class="number">0xA1</span>, <span class="number">0x66</span>, <span class="number">0x28</span>, <span class="number">0xD9</span>, <span class="number">0x24</span>, <span class="number">0xB2</span>, </span><br><span class="line">	 <span class="number">0x76</span>, <span class="number">0x5B</span>, <span class="number">0xA2</span>, <span class="number">0x49</span>, <span class="number">0x6D</span>, <span class="number">0x8B</span>, <span class="number">0xD1</span>, <span class="number">0x25</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x72</span>, <span class="number">0xF8</span>, <span class="number">0xF6</span>, <span class="number">0x64</span>, <span class="number">0x86</span>, <span class="number">0x68</span>, <span class="number">0x98</span>, <span class="number">0x16</span>, </span><br><span class="line">	 <span class="number">0xD4</span>, <span class="number">0xA4</span>, <span class="number">0x5C</span>, <span class="number">0xCC</span>, <span class="number">0x5D</span>, <span class="number">0x65</span>, <span class="number">0xB6</span>, <span class="number">0x92</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x6C</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x50</span>, <span class="number">0xFD</span>, <span class="number">0xED</span>, <span class="number">0xB9</span>, <span class="number">0xDA</span>, </span><br><span class="line">	 <span class="number">0x5E</span>, <span class="number">0x15</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0xA7</span>, <span class="number">0x8D</span>, <span class="number">0x9D</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x90</span>, <span class="number">0xD8</span>, <span class="number">0xAB</span>, <span class="number">0x00</span>, <span class="number">0x8C</span>, <span class="number">0xBC</span>, <span class="number">0xD3</span>, <span class="number">0x0A</span>, </span><br><span class="line">	 <span class="number">0xF7</span>, <span class="number">0xE4</span>, <span class="number">0x58</span>, <span class="number">0x05</span>, <span class="number">0xB8</span>, <span class="number">0xB3</span>, <span class="number">0x45</span>, <span class="number">0x06</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xD0</span>, <span class="number">0x2C</span>, <span class="number">0x1E</span>, <span class="number">0x8F</span>, <span class="number">0xCA</span>, <span class="number">0x3F</span>, <span class="number">0x0F</span>, <span class="number">0x02</span>, </span><br><span class="line">	 <span class="number">0xC1</span>, <span class="number">0xAF</span>, <span class="number">0xBD</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x13</span>, <span class="number">0x8A</span>, <span class="number">0x6B</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x3A</span>, <span class="number">0x91</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0x4F</span>, <span class="number">0x67</span>, <span class="number">0xDC</span>, <span class="number">0xEA</span>, </span><br><span class="line">	 <span class="number">0x97</span>, <span class="number">0xF2</span>, <span class="number">0xCF</span>, <span class="number">0xCE</span>, <span class="number">0xF0</span>, <span class="number">0xB4</span>, <span class="number">0xE6</span>, <span class="number">0x73</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x96</span>, <span class="number">0xAC</span>, <span class="number">0x74</span>, <span class="number">0x22</span>, <span class="number">0xE7</span>, <span class="number">0xAD</span>, <span class="number">0x35</span>, <span class="number">0x85</span>, </span><br><span class="line">	 <span class="number">0xE2</span>, <span class="number">0xF9</span>, <span class="number">0x37</span>, <span class="number">0xE8</span>, <span class="number">0x1C</span>, <span class="number">0x75</span>, <span class="number">0xDF</span>, <span class="number">0x6E</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x47</span>, <span class="number">0xF1</span>, <span class="number">0x1A</span>, <span class="number">0x71</span>, <span class="number">0x1D</span>, <span class="number">0x29</span>, <span class="number">0xC5</span>, <span class="number">0x89</span>, </span><br><span class="line">	 <span class="number">0x6F</span>, <span class="number">0xB7</span>, <span class="number">0x62</span>, <span class="number">0x0E</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0xBE</span>, <span class="number">0x1B</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xFC</span>, <span class="number">0x56</span>, <span class="number">0x3E</span>, <span class="number">0x4B</span>, <span class="number">0xC6</span>, <span class="number">0xD2</span>, <span class="number">0x79</span>, <span class="number">0x20</span>, </span><br><span class="line">	 <span class="number">0x9A</span>, <span class="number">0xDB</span>, <span class="number">0xC0</span>, <span class="number">0xFE</span>, <span class="number">0x78</span>, <span class="number">0xCD</span>, <span class="number">0x5A</span>, <span class="number">0xF4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x1F</span>, <span class="number">0xDD</span>, <span class="number">0xA8</span>, <span class="number">0x33</span>, <span class="number">0x88</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x31</span>, </span><br><span class="line">	 <span class="number">0xB1</span>, <span class="number">0x12</span>, <span class="number">0x10</span>, <span class="number">0x59</span>, <span class="number">0x27</span>, <span class="number">0x80</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x60</span>, <span class="number">0x51</span>, <span class="number">0x7F</span>, <span class="number">0xA9</span>, <span class="number">0x19</span>, <span class="number">0xB5</span>, <span class="number">0x4A</span>, <span class="number">0x0D</span>, </span><br><span class="line">	 <span class="number">0x2D</span>, <span class="number">0xE5</span>, <span class="number">0x7A</span>, <span class="number">0x9F</span>, <span class="number">0x93</span>, <span class="number">0xC9</span>, <span class="number">0x9C</span>, <span class="number">0xEF</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xA0</span>, <span class="number">0xE0</span>, <span class="number">0x3B</span>, <span class="number">0x4D</span>, <span class="number">0xAE</span>, <span class="number">0x2A</span>, <span class="number">0xF5</span>, <span class="number">0xB0</span>, </span><br><span class="line">	 <span class="number">0xC8</span>, <span class="number">0xEB</span>, <span class="number">0xBB</span>, <span class="number">0x3C</span>, <span class="number">0x83</span>, <span class="number">0x53</span>, <span class="number">0x99</span>, <span class="number">0x61</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x17</span>, <span class="number">0x2B</span>, <span class="number">0x04</span>, <span class="number">0x7E</span>, <span class="number">0xBA</span>, <span class="number">0x77</span>, <span class="number">0xD6</span>, <span class="number">0x26</span>, </span><br><span class="line">	 <span class="number">0xE1</span>, <span class="number">0x69</span>, <span class="number">0x14</span>, <span class="number">0x63</span>, <span class="number">0x55</span>, <span class="number">0x21</span>, <span class="number">0x0C</span>, <span class="number">0x7D</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮常数，密钥扩展中用到。（AES-128只需要10轮）</span></span><br><span class="line">word Rcon[<span class="number">10</span>] = &#123;<span class="number">0x01000000</span>, <span class="number">0x02000000</span>, <span class="number">0x04000000</span>, <span class="number">0x08000000</span>, <span class="number">0x10000000</span>, </span><br><span class="line">				 <span class="number">0x20000000</span>, <span class="number">0x40000000</span>, <span class="number">0x80000000</span>, <span class="number">0x1b000000</span>, <span class="number">0x36000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/*                              AES算法实现                           */</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/**********************************************************************/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************下面是加密的变换函数**********************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  S盒变换 - 前4位为行号，后4位为列号</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SubBytes</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = mtx[i][<span class="number">7</span>]*<span class="number">8</span> + mtx[i][<span class="number">6</span>]*<span class="number">4</span> + mtx[i][<span class="number">5</span>]*<span class="number">2</span> + mtx[i][<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = mtx[i][<span class="number">3</span>]*<span class="number">8</span> + mtx[i][<span class="number">2</span>]*<span class="number">4</span> + mtx[i][<span class="number">1</span>]*<span class="number">2</span> + mtx[i][<span class="number">0</span>];</span><br><span class="line">		mtx[i] = S_Box[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  行变换 - 按字节循环移位</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShiftRows</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 第二行循环左移一位</span></span><br><span class="line">	byte temp = mtx[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		mtx[i+<span class="number">4</span>] = mtx[i+<span class="number">5</span>];</span><br><span class="line">	mtx[<span class="number">7</span>] = temp;</span><br><span class="line">	<span class="comment">// 第三行循环左移两位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = mtx[i+<span class="number">8</span>];</span><br><span class="line">		mtx[i+<span class="number">8</span>] = mtx[i+<span class="number">10</span>];</span><br><span class="line">		mtx[i+<span class="number">10</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四行循环左移三位</span></span><br><span class="line">	temp = mtx[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		mtx[i+<span class="number">12</span>] = mtx[i+<span class="number">11</span>];</span><br><span class="line">	mtx[<span class="number">12</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  有限域上的乘法 GF(2^8)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">byte <span class="title">GFMul</span><span class="params">(byte a, byte b)</span> </span>&#123; </span><br><span class="line">	byte p = <span class="number">0</span>;</span><br><span class="line">	byte hi_bit_set;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">8</span>; counter++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((b &amp; byte(<span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">			p ^= a;</span><br><span class="line">		&#125;</span><br><span class="line">		hi_bit_set = (byte) (a &amp; byte(<span class="number">0x80</span>));</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (hi_bit_set != <span class="number">0</span>) &#123;</span><br><span class="line">			a ^= <span class="number">0x1b</span>; <span class="comment">/* x^8 + x^4 + x^3 + x + 1 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  列变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MixColumns</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte arr[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)</span><br><span class="line">			arr[j] = mtx[i+j*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">		mtx[i] = GFMul(<span class="number">0x02</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x03</span>, arr[<span class="number">1</span>]) ^ arr[<span class="number">2</span>] ^ arr[<span class="number">3</span>];</span><br><span class="line">		mtx[i+<span class="number">4</span>] = arr[<span class="number">0</span>] ^ GFMul(<span class="number">0x02</span>, arr[<span class="number">1</span>]) ^ GFMul(<span class="number">0x03</span>, arr[<span class="number">2</span>]) ^ arr[<span class="number">3</span>];</span><br><span class="line">		mtx[i+<span class="number">8</span>] = arr[<span class="number">0</span>] ^ arr[<span class="number">1</span>] ^ GFMul(<span class="number">0x02</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x03</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">12</span>] = GFMul(<span class="number">0x03</span>, arr[<span class="number">0</span>]) ^ arr[<span class="number">1</span>] ^ arr[<span class="number">2</span>] ^ GFMul(<span class="number">0x02</span>, arr[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  轮密钥加变换 - 将每一列与扩展密钥进行异或</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRoundKey</span><span class="params">(byte mtx[4*4], word k[4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		word k1 = k[i] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		word k2 = (k[i] &lt;&lt; <span class="number">8</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		word k3 = (k[i] &lt;&lt; <span class="number">16</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		word k4 = (k[i] &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">		</span><br><span class="line">		mtx[i] = mtx[i] ^ byte(k1.to_ulong());</span><br><span class="line">		mtx[i+<span class="number">4</span>] = mtx[i+<span class="number">4</span>] ^ byte(k2.to_ulong());</span><br><span class="line">		mtx[i+<span class="number">8</span>] = mtx[i+<span class="number">8</span>] ^ byte(k3.to_ulong());</span><br><span class="line">		mtx[i+<span class="number">12</span>] = mtx[i+<span class="number">12</span>] ^ byte(k4.to_ulong());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************下面是解密的逆变换函数***********************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  逆S盒变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvSubBytes</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = mtx[i][<span class="number">7</span>]*<span class="number">8</span> + mtx[i][<span class="number">6</span>]*<span class="number">4</span> + mtx[i][<span class="number">5</span>]*<span class="number">2</span> + mtx[i][<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = mtx[i][<span class="number">3</span>]*<span class="number">8</span> + mtx[i][<span class="number">2</span>]*<span class="number">4</span> + mtx[i][<span class="number">1</span>]*<span class="number">2</span> + mtx[i][<span class="number">0</span>];</span><br><span class="line">		mtx[i] = Inv_S_Box[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  逆行变换 - 以字节为单位循环右移</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvShiftRows</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 第二行循环右移一位</span></span><br><span class="line">	byte temp = mtx[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		mtx[i+<span class="number">4</span>] = mtx[i+<span class="number">3</span>];</span><br><span class="line">	mtx[<span class="number">4</span>] = temp;</span><br><span class="line">	<span class="comment">// 第三行循环右移两位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = mtx[i+<span class="number">8</span>];</span><br><span class="line">		mtx[i+<span class="number">8</span>] = mtx[i+<span class="number">10</span>];</span><br><span class="line">		mtx[i+<span class="number">10</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四行循环右移三位</span></span><br><span class="line">	temp = mtx[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		mtx[i+<span class="number">12</span>] = mtx[i+<span class="number">13</span>];</span><br><span class="line">	mtx[<span class="number">15</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvMixColumns</span><span class="params">(byte mtx[4*4])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte arr[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)</span><br><span class="line">			arr[j] = mtx[i+j*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">		mtx[i] = GFMul(<span class="number">0x0e</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x0b</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x0d</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x09</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">4</span>] = GFMul(<span class="number">0x09</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x0e</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x0b</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x0d</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">8</span>] = GFMul(<span class="number">0x0d</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x09</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x0e</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x0b</span>, arr[<span class="number">3</span>]);</span><br><span class="line">		mtx[i+<span class="number">12</span>] = GFMul(<span class="number">0x0b</span>, arr[<span class="number">0</span>]) ^ GFMul(<span class="number">0x0d</span>, arr[<span class="number">1</span>]) </span><br><span class="line">			^ GFMul(<span class="number">0x09</span>, arr[<span class="number">2</span>]) ^ GFMul(<span class="number">0x0e</span>, arr[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************下面是密钥扩展部分***********************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将4个 byte 转换为一个 word.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">Word</span><span class="params">(byte&amp; k1, byte&amp; k2, byte&amp; k3, byte&amp; k4)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">word <span class="title">result</span><span class="params">(0x00000000)</span></span>;</span><br><span class="line">	word temp;</span><br><span class="line">	temp = k1.to_ulong();  <span class="comment">// K1</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">24</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k2.to_ulong();  <span class="comment">// K2</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k3.to_ulong();  <span class="comment">// K3</span></span><br><span class="line">	temp &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">	result |= temp;</span><br><span class="line">	temp = k4.to_ulong();  <span class="comment">// K4</span></span><br><span class="line">	result |= temp;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  按字节 循环左移一位</span><br><span class="line"> *  即把[a0, a1, a2, a3]变成[a1, a2, a3, a0]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">RotWord</span><span class="params">(word&amp; rw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word high = rw &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	word low = rw &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	<span class="keyword">return</span> high | low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  对输入word中的每一个字节进行S-盒变换</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">word <span class="title">SubWord</span><span class="params">(word&amp; sw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i+=<span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = sw[i+<span class="number">7</span>]*<span class="number">8</span> + sw[i+<span class="number">6</span>]*<span class="number">4</span> + sw[i+<span class="number">5</span>]*<span class="number">2</span> + sw[i+<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> col = sw[i+<span class="number">3</span>]*<span class="number">8</span> + sw[i+<span class="number">2</span>]*<span class="number">4</span> + sw[i+<span class="number">1</span>]*<span class="number">2</span> + sw[i];</span><br><span class="line">		byte val = S_Box[row][col];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)</span><br><span class="line">			temp[i+j] = val[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1)]</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyExpansion</span><span class="params">(byte key[4*Nk], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word temp;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// w[]的前4个就是输入的key</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; Nk) </span><br><span class="line">	&#123;</span><br><span class="line">		w[i] = Word(key[<span class="number">4</span>*i], key[<span class="number">4</span>*i+<span class="number">1</span>], key[<span class="number">4</span>*i+<span class="number">2</span>], key[<span class="number">4</span>*i+<span class="number">3</span>]);</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = Nk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">4</span>*(Nr+<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		temp = w[i-<span class="number">1</span>]; <span class="comment">// 记录前一个word</span></span><br><span class="line">		<span class="keyword">if</span>(i % Nk == <span class="number">0</span>)</span><br><span class="line">			w[i] = w[i-Nk] ^ SubWord(RotWord(temp)) ^ Rcon[i/Nk-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			w[i] = w[i-Nk] ^ temp;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************下面是加密和解密函数**************************/</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  加密</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(byte in[4*4], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word key[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">1</span>; round&lt;Nr; ++round)</span><br><span class="line">	&#123;</span><br><span class="line">		SubBytes(in);</span><br><span class="line">		ShiftRows(in);</span><br><span class="line">		MixColumns(in);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">			key[i] = w[<span class="number">4</span>*round+i];</span><br><span class="line">		AddRoundKey(in, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubBytes(in);</span><br><span class="line">	ShiftRows(in);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[<span class="number">4</span>*Nr+i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  解密</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrypt</span><span class="params">(byte in[4*4], word w[4*(Nr+1)</span>])</span><br><span class="line"></span>&#123;</span><br><span class="line">	word key[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[<span class="number">4</span>*Nr+i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=Nr-<span class="number">1</span>; round&gt;<span class="number">0</span>; --round)</span><br><span class="line">	&#123;</span><br><span class="line">		InvShiftRows(in);</span><br><span class="line">		InvSubBytes(in);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">			key[i] = w[<span class="number">4</span>*round+i];</span><br><span class="line">		AddRoundKey(in, key);</span><br><span class="line">		InvMixColumns(in);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	InvShiftRows(in);</span><br><span class="line">	InvSubBytes(in);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">		key[i] = w[i];</span><br><span class="line">	AddRoundKey(in, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/*                              测试                                  */</span>  </span><br><span class="line"><span class="comment">/*                                                                    */</span>  </span><br><span class="line"><span class="comment">/**********************************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	byte key[<span class="number">16</span>] = &#123;<span class="number">0x2b</span>, <span class="number">0x7e</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, </span><br><span class="line">					<span class="number">0x28</span>, <span class="number">0xae</span>, <span class="number">0xd2</span>, <span class="number">0xa6</span>, </span><br><span class="line">					<span class="number">0xab</span>, <span class="number">0xf7</span>, <span class="number">0x15</span>, <span class="number">0x88</span>, </span><br><span class="line">					<span class="number">0x09</span>, <span class="number">0xcf</span>, <span class="number">0x4f</span>, <span class="number">0x3c</span>&#125;;</span><br><span class="line"></span><br><span class="line">	byte plain[<span class="number">16</span>] = &#123;<span class="number">0x32</span>, <span class="number">0x88</span>, <span class="number">0x31</span>, <span class="number">0xe0</span>, </span><br><span class="line">					<span class="number">0x43</span>, <span class="number">0x5a</span>, <span class="number">0x31</span>, <span class="number">0x37</span>,</span><br><span class="line">					<span class="number">0xf6</span>, <span class="number">0x30</span>, <span class="number">0x98</span>, <span class="number">0x07</span>,</span><br><span class="line">					<span class="number">0xa8</span>, <span class="number">0x8d</span>, <span class="number">0xa2</span>, <span class="number">0x34</span>&#125;; </span><br><span class="line">	<span class="comment">// 输出密钥</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"密钥是："</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; key[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	word w[<span class="number">4</span>*(Nr+<span class="number">1</span>)];</span><br><span class="line">	KeyExpansion(key, w);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出待加密的明文</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl &lt;&lt; <span class="string">"待加密的明文："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; plain[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加密，输出密文</span></span><br><span class="line">	encrypt(plain, w);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"加密后的密文："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; plain[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密，输出明文</span></span><br><span class="line">	decrypt(plain, w);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"解密后的明文："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; plain[i].to_ulong() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试用例如下图：</p>
<p><img src="http://img.blog.csdn.net/20141213143350269?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>测试结果截图：</p>
<p><img src="http://img.blog.csdn.net/20141213143411392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>可见，测试结果和预期输出相同，表明对数据的加密和解密成功！！！</p>
<p>下面我们来写 AES 对文件的加密和解密，在对 128 位的数据加解密成功以后，对文件的加解密就很简单了！只需要每次读 128 位，加密以后，将 128 位的密文写入另外一个文件…..如此循环，直到文件尾。下面是对一张图片进行 AES 加密和解密的测试代码（效率先不管了，有时间我再优化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;fstream&gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;8&gt; byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bitset</span>&lt;32&gt; word;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  将一个char字符数组转化为二进制</span><br><span class="line"> *  存到一个 byte 数组中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charToByte</span><span class="params">(byte out[16], <span class="keyword">const</span> <span class="keyword">char</span> s[16])</span></span><br><span class="line"></span>&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)  </span><br><span class="line">			out[i][j]= ((s[i]&gt;&gt;j) &amp; <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  将连续的128位分成16组，存到一个 byte 数组中</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divideToByte</span><span class="params">(byte out[16], <span class="built_in">bitset</span>&lt;128&gt;&amp; data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = (data &lt;&lt; <span class="number">8</span>*i) &gt;&gt; <span class="number">120</span>;</span><br><span class="line">		out[i] = temp.to_ulong();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  将16个 byte 合并成连续的128位</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;128&gt; mergeByte(byte in[<span class="number">16</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; res;</span><br><span class="line">	res.reset();  <span class="comment">// 置0</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = in[i].to_ulong();</span><br><span class="line">		temp &lt;&lt;= <span class="number">8</span>*(<span class="number">15</span>-i);</span><br><span class="line">		res |= temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> keyStr = <span class="string">"abcdefghijklmnop"</span>;</span><br><span class="line">	byte key[<span class="number">16</span>]; </span><br><span class="line">	charToByte(key, keyStr.c_str());</span><br><span class="line">	<span class="comment">// 密钥扩展</span></span><br><span class="line">	word w[<span class="number">4</span>*(Nr+<span class="number">1</span>)];</span><br><span class="line">	KeyExpansion(key, w);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bitset</span>&lt;128&gt; data;</span><br><span class="line">	byte plain[<span class="number">16</span>];</span><br><span class="line">	<span class="comment">// 将文件 flower.jpg 加密到 cipher.txt 中</span></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line">	in.open(<span class="string">"D://flower.jpg"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">	&#123;</span><br><span class="line">		divideToByte(plain, data);</span><br><span class="line">		encrypt(plain, w);</span><br><span class="line">		data = mergeByte(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">		data.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密 cipher.txt，并写入图片 flower1.jpg</span></span><br><span class="line">	in.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://flower1.jpg"</span>, ios::binary);</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">	&#123;</span><br><span class="line">		divideToByte(plain, data);</span><br><span class="line">		decrypt(plain, w);</span><br><span class="line">		data = mergeByte(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">		data.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（全文完）</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要：</strong>作为新一代的加密标准，AES 旨在取代 DES（请看《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">DES加密算法的C++实现</a>》），以适应当今分布式开放网络对数据加密安全性的要求。本文在分析了 AES 加密原理的基础上着重说明了算法实现的具体步骤，并用 C++ 实现了对文件的加密和解密。</p>
<h1 id="一、AES_介绍">一、AES 介绍</h1><p><strong>AES（高级加密标准，Advanced Encryption Standard）</strong>，在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种分组加密标准。这个标准用来替代原先的 DES，目前已经广为全世界所使用，成为对称密钥算法中最流行的算法之一。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DES加密算法的C++实现]]></title>
    <link href="http://yoursite.com/2014/12/06/des-encrypt/"/>
    <id>http://yoursite.com/2014/12/06/des-encrypt/</id>
    <published>2014-12-06T11:21:35.000Z</published>
    <updated>2015-05-10T10:38:47.474Z</updated>
    <content type="html"><![CDATA[<p>《信息安全技术》这门课又在讲 DES 加密算法了，以前用纯C写过一次，这次我用 C++ 重新写了一个，写篇文章以备后用。本文介绍了 DES 算法加密的大致步骤和整体流程。</p>
<h3 id="一、DES算法原理">一、DES算法原理</h3><p>DES算法是一种最通用的对称密钥算法，因为算法本身是公开的，所以其安全性在于密钥的安全性。基于密钥的算法通常有两类：<strong>对称算法</strong>和<strong>公开密钥算法</strong>。对称算法的对称性体现在加密密钥能够从解密密钥推算出来，反之亦然。在大多数对称算法中，加解密的密钥是相同的，DES就是这样。可见，对称密钥算法的加解密密钥都是保密的。而公开密钥算法的加密密钥是公开的，解密密钥是保密的。</p>
<p>下面是 DES 加密算法的整体流程图：<a id="more"></a></p>
<p><img src="http://img.blog.csdn.net/20141206183226328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从上面的流程图可以看出，DES加密主要由四个部分完成：</p>
<ol>
<li>初始置换 IP；</li>
<li><strong>子密钥 Ki 的获取；</strong></li>
<li><strong>密码函数 f ；</strong></li>
<li>尾置换 IP-1 ；</li>
</ol>
<p>其中，第二部分和第三部分是 DES 算法的核心。<strong>注意：</strong>DES 解密算法与加密算法完全相同，只需要将子密钥的使用顺序反过来就行了。</p>
<p>下面分别讲一下各个部分的大致思路。</p>
<h4 id="1）_初始置换IP">1） 初始置换IP</h4><p>这一部分很简单，IP（initial permutation）是一个 8x8 的置换表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> IP[] = &#123; <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">			 <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">			 <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">			 <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">			 <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line">			 <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">			 <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">			 <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>根据表中的规定，将输入的 64 位明文重新进行排序，即将第 58 位放到第 1 位，第 50 位放到第 2 位……以此类推。初始置换以后得到的是一个 64 位的输出。</p>
<h4 id="2）_子密钥_Ki_的获取">2） 子密钥 Ki 的获取</h4><p>下面是获取子密钥 Ki 的流程图：</p>
<p><img src="http://img.blog.csdn.net/20141206183416015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>流程图已经把思路很清楚的表达出来了，很简单：</p>
<ul>
<li><p>用户输出的密钥是 64 位的，根据密钥置换表<code>PC-1</code>，将 64 位变成 56 位密钥。（去掉了奇偶校验位）</p>
</li>
<li><p>将 PC-1 置换得到的 56 位密钥，分为前28位 C0 和后28位 D0，分别对它们进行<strong>循环左移</strong>，C0 左移得到 C1，D0 左移得到 D1。</p>
</li>
<li><p>将 C1 和 D1 合并成 56 位，然后通过<code>PC-2</code>表进行压缩置换，得到当前这一轮的 48 位子密钥 K1 。</p>
</li>
<li><p>然后对 C1 和 D1 进行左移和压缩置换，获取下一轮的子密钥……一共进行16轮，得到 16 个 48 位的子密钥。</p>
</li>
</ul>
<p>这部分需要用到的表 PC-1 和表 PC-2 如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 密钥置换表，将64位密钥变成56位</span></span><br><span class="line"><span class="keyword">int</span> PC_1[] = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">			   <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">			  <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">			  <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">			   <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">			  <span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩置换，将56位密钥压缩成48位子密钥</span></span><br><span class="line"><span class="keyword">int</span> PC_2[] = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line">			   <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">			  <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">			  <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">			  <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">			  <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">			  <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">			  <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每轮左移的位数</span></span><br><span class="line"><span class="keyword">int</span> shiftBits[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="3）_密码函数_f">3） 密码函数 f</h4><p>下面是密码函数<code>f(R, K)</code>的流程图：</p>
<p><img src="http://img.blog.csdn.net/20141206183524406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>密码函数<code>f(R, K)</code>接受两个输入：32 位的数据和 48 位的子密钥。然后：</p>
<ul>
<li><p>通过表 E 进行<strong>扩展置换</strong>，将输入的 32 位数据扩展为 48 位；</p>
</li>
<li><p>将扩展后的 48 位数据与 48 位的子密钥进行<strong>异或</strong>运算；</p>
</li>
<li><p>将异或得到的 48 位数据分成 8 个 6 位的块，每一个块通过对应的一个 S 表产生一个 4 位的输出。其中，每个 S 表都是 4 行 16 列。<strong>具体的置换过程如下：</strong>把 6 位输入中的第 1 位和第 6 位取出来行成一个两位的二进制数 x ，作为 Si 表中的行数（0~3）；把 6 位输入的中间 4 位构成另外一个二进制数 y，作为 Si 表的列数（0~15）；查出 Si 表中 x 行 y 列所对应的整数，将该整数转换为一个 4 位的二进制数。</p>
</li>
<li><p>把通过 S 表置换得到的 8 个 4 位连在一起，形成一个 32 位的数据。然后将该 32 位数据通过表 P 进行置换（称为P-置换），置换后得到一个仍然是 32 位的结果数据，这就是<code>f(R, K)</code>函数的输出。</p>
</li>
</ul>
<p>这部分用到了扩展置换表E，8个S表以及P-置换表，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展置换表，将 32位 扩展至 48位</span></span><br><span class="line"><span class="keyword">int</span> E[] = &#123;<span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">		    <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">		    <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">		   <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">		   <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">		   <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">		   <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S盒，每个S盒是4x16的置换表，6位 -&gt; 4位</span></span><br><span class="line"><span class="keyword">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P置换，32位 -&gt; 32位</span></span><br><span class="line"><span class="keyword">int</span> P[] = &#123;<span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">		    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">		    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">		    <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">		   <span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line">		   <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line">		   <span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="4）_尾置换IP-1">4） 尾置换IP-1</h4><p>合并 L16 和 R16 得到一个 64 位的数据，再经过尾置换后得到的就是 64 位的密文。注意：要将 L16 和 R16 合并成 R16L16（即左右互换）。尾置换表IP-1如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置换表</span></span><br><span class="line"><span class="keyword">int</span> IP_1[] = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">			  <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">			  <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">			  <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">			  <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">			  <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>OK！现在我们可以回到本文的开头，去看看 DES 算法的整体流程图，思路就已经很清楚了。</p>
<h3 id="二、C++实现">二、C++实现</h3><p>在 DES 算法的实现中，我用 C++ STL 中的<code>bitset</code>来操作二进制位，另外，这里我没有考虑时间的优化。下面是对一个 64 位数据进行加密解密的源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************* </span><br><span class="line">    &gt; File Name: Des.cpp</span><br><span class="line">    &gt; Author: SongLee </span><br><span class="line">    &gt; E-mail: lisong.shine@qq.com </span><br><span class="line">    &gt; Created Time: 2014年12月05日 星期日 19时46分32秒 </span><br><span class="line">    &gt; Personal Blog: http://songlee24.github.com </span><br><span class="line"> ************************************************************************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bitset&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; key;                <span class="comment">// 64位密钥</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;48&gt; subKey[<span class="number">16</span>];         <span class="comment">// 存放16轮子密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始置换表</span></span><br><span class="line"><span class="keyword">int</span> IP[] = &#123;<span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">			<span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">			<span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">			<span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">			<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line">			<span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">			<span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">			<span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结尾置换表</span></span><br><span class="line"><span class="keyword">int</span> IP_1[] = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">			  <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">			  <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">			  <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">			  <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">			  <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------下面是生成密钥所用表-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥置换表，将64位密钥变成56位</span></span><br><span class="line"><span class="keyword">int</span> PC_1[] = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">			   <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">			  <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">			  <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">			   <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">			  <span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩置换，将56位密钥压缩成48位子密钥</span></span><br><span class="line"><span class="keyword">int</span> PC_2[] = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line">			   <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">			  <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">			  <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">			  <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">			  <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">			  <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">			  <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每轮左移的位数</span></span><br><span class="line"><span class="keyword">int</span> shiftBits[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------下面是密码函数 f 所用表-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展置换表，将 32位 扩展至 48位</span></span><br><span class="line"><span class="keyword">int</span> E[] = &#123;<span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">		    <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">		    <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">		   <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">		   <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">		   <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">		   <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S盒，每个S盒是4x16的置换表，6位 -&gt; 4位</span></span><br><span class="line"><span class="keyword">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P置换，32位 -&gt; 32位</span></span><br><span class="line"><span class="keyword">int</span> P[] = &#123;<span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">		    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">		    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">		    <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">		   <span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line">		   <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line">		   <span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                    */</span></span><br><span class="line"><span class="comment">/*                            下面是DES算法实现                        */</span></span><br><span class="line"><span class="comment">/*                                                                    */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  密码函数f，接收32位数据和48位子密钥，产生一个32位的输出            </span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;32&gt; f(<span class="built_in">bitset</span>&lt;32&gt; R, <span class="built_in">bitset</span>&lt;48&gt; k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;48&gt; expandR;</span><br><span class="line">	<span class="comment">// 第一步：扩展置换，32 -&gt; 48</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">48</span>; ++i)</span><br><span class="line">		expandR[<span class="number">47</span>-i] = R[<span class="number">32</span>-E[i]];</span><br><span class="line">	<span class="comment">// 第二步：异或</span></span><br><span class="line">	expandR = expandR ^ k;</span><br><span class="line">	<span class="comment">// 第三步：查找S_BOX置换表</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; output;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">48</span>; i=i+<span class="number">6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = expandR[<span class="number">47</span>-i]*<span class="number">2</span> + expandR[<span class="number">47</span>-i-<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">int</span> col = expandR[<span class="number">47</span>-i-<span class="number">1</span>]*<span class="number">8</span> + expandR[<span class="number">47</span>-i-<span class="number">2</span>]*<span class="number">4</span> + expandR[<span class="number">47</span>-i-<span class="number">3</span>]*<span class="number">2</span> </span><br><span class="line">			+ expandR[<span class="number">47</span>-i-<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">int</span> num = S_BOX[i/<span class="number">6</span>][row][col];</span><br><span class="line">		<span class="built_in">bitset</span>&lt;4&gt; binary(num);</span><br><span class="line">		output[<span class="number">31</span>-x] = binary[<span class="number">3</span>];</span><br><span class="line">		output[<span class="number">31</span>-x-<span class="number">1</span>] = binary[<span class="number">2</span>];</span><br><span class="line">		output[<span class="number">31</span>-x-<span class="number">2</span>] = binary[<span class="number">1</span>];</span><br><span class="line">		output[<span class="number">31</span>-x-<span class="number">3</span>] = binary[<span class="number">0</span>];</span><br><span class="line">		x += <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四步：P-置换，32 -&gt; 32</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; tmp = output;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		output[<span class="number">31</span>-i] = tmp[<span class="number">32</span>-P[i]];</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  对56位密钥的前后部分进行左移</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;28&gt; leftShift(<span class="built_in">bitset</span>&lt;28&gt; k, <span class="keyword">int</span> shift)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;28&gt; tmp = k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">27</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i-shift&lt;<span class="number">0</span>)</span><br><span class="line">			k[i] = tmp[i-shift+<span class="number">28</span>];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			k[i] = tmp[i-shift];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  生成16个48位的子密钥</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateKeys</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;56&gt; realKey;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;28&gt; left;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;28&gt; right;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;48&gt; compressKey;</span><br><span class="line">	<span class="comment">// 去掉奇偶标记位，将64位密钥变成56位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">56</span>; ++i)</span><br><span class="line">		realKey[<span class="number">55</span>-i] = key[<span class="number">64</span> - PC_1[i]];</span><br><span class="line">	<span class="comment">// 生成子密钥，保存在 subKeys[16] 中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 前28位与后28位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">28</span>; i&lt;<span class="number">56</span>; ++i)</span><br><span class="line">			left[i-<span class="number">28</span>] = realKey[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">28</span>; ++i)</span><br><span class="line">			right[i] = realKey[i];</span><br><span class="line">		<span class="comment">// 左移</span></span><br><span class="line">		left = leftShift(left, shiftBits[round]);</span><br><span class="line">		right = leftShift(right, shiftBits[round]);</span><br><span class="line">		<span class="comment">// 压缩置换，由56位得到48位子密钥</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">28</span>; i&lt;<span class="number">56</span>; ++i)</span><br><span class="line">			realKey[i] = left[i-<span class="number">28</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">28</span>; ++i)</span><br><span class="line">			realKey[i] = right[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">48</span>; ++i)</span><br><span class="line">			compressKey[<span class="number">47</span>-i] = realKey[<span class="number">56</span> - PC_2[i]];</span><br><span class="line">		subKey[round] = compressKey;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  工具函数：将char字符数组转为二进制</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; charToBitset(<span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">8</span>])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; bits;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; ++j)</span><br><span class="line">			bits[i*<span class="number">8</span>+j] = ((s[i]&gt;&gt;j) &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  DES加密</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; encrypt(<span class="built_in">bitset</span>&lt;64&gt;&amp; plain)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; cipher;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; currentBits;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; left;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; right;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; newLeft;</span><br><span class="line">	<span class="comment">// 第一步：初始置换IP</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		currentBits[<span class="number">63</span>-i] = plain[<span class="number">64</span>-IP[i]];</span><br><span class="line">	<span class="comment">// 第二步：获取 Li 和 Ri</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		left[i-<span class="number">32</span>] = currentBits[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		right[i] = currentBits[i];</span><br><span class="line">	<span class="comment">// 第三步：共16轮迭代</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round)</span><br><span class="line">	&#123;</span><br><span class="line">		newLeft = right;</span><br><span class="line">		right = left ^ f(right,subKey[round]);</span><br><span class="line">		left = newLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四步：合并L16和R16，注意合并为 R16L16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		cipher[i] = left[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		cipher[i] = right[i-<span class="number">32</span>];</span><br><span class="line">	<span class="comment">// 第五步：结尾置换IP-1</span></span><br><span class="line">	currentBits = cipher;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		cipher[<span class="number">63</span>-i] = currentBits[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">	<span class="comment">// 返回密文</span></span><br><span class="line">	<span class="keyword">return</span> cipher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  DES解密</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;64&gt; decrypt(<span class="built_in">bitset</span>&lt;64&gt;&amp; cipher)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; plain;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; currentBits;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; left;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; right;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;32&gt; newLeft;</span><br><span class="line">	<span class="comment">// 第一步：初始置换IP</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		currentBits[<span class="number">63</span>-i] = cipher[<span class="number">64</span>-IP[i]];</span><br><span class="line">	<span class="comment">// 第二步：获取 Li 和 Ri</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		left[i-<span class="number">32</span>] = currentBits[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		right[i] = currentBits[i];</span><br><span class="line">	<span class="comment">// 第三步：共16轮迭代（子密钥逆序应用）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round)</span><br><span class="line">	&#123;</span><br><span class="line">		newLeft = right;</span><br><span class="line">		right = left ^ f(right,subKey[<span class="number">15</span>-round]);</span><br><span class="line">		left = newLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第四步：合并L16和R16，注意合并为 R16L16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">		plain[i] = left[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		plain[i] = right[i-<span class="number">32</span>];</span><br><span class="line">	<span class="comment">// 第五步：结尾置换IP-1</span></span><br><span class="line">	currentBits = plain;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; ++i)</span><br><span class="line">		plain[<span class="number">63</span>-i] = currentBits[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">	<span class="comment">// 返回明文</span></span><br><span class="line">	<span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* 测试：                                                             */</span></span><br><span class="line"><span class="comment">/*     1.将一个 64 位的字符串加密， 把密文写入文件 a.txt              */</span></span><br><span class="line"><span class="comment">/*     2.读取文件 a.txt 获得 64 位密文，解密之后再写入 b.txt          */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s = <span class="string">"romantic"</span>;</span><br><span class="line">	<span class="built_in">string</span> k = <span class="string">"12345678"</span>;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; plain = charToBitset(s.c_str());</span><br><span class="line">	key = charToBitset(k.c_str());</span><br><span class="line">	<span class="comment">// 生成16个子密钥</span></span><br><span class="line">	generateKeys();   </span><br><span class="line">	<span class="comment">// 密文写入 a.txt</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; cipher = encrypt(plain);</span><br><span class="line">	fstream file1;</span><br><span class="line">	file1.open(<span class="string">"D://a.txt"</span>, ios::binary | ios::out);</span><br><span class="line">	file1.write((<span class="keyword">char</span>*)&amp;cipher,<span class="keyword">sizeof</span>(cipher));</span><br><span class="line">	file1.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读文件 a.txt</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; temp;</span><br><span class="line">	file1.open(<span class="string">"D://a.txt"</span>, ios::binary | ios::in);</span><br><span class="line">	file1.read((<span class="keyword">char</span>*)&amp;temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">	file1.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密，并写入文件 b.txt</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; temp_plain = decrypt(temp);</span><br><span class="line">	file1.open(<span class="string">"D://b.txt"</span>, ios::binary | ios::out);</span><br><span class="line">	file1.write((<span class="keyword">char</span>*)&amp;temp_plain,<span class="keyword">sizeof</span>(temp_plain));</span><br><span class="line">	file1.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果（VS2012）：</p>
<p><img src="http://img.blog.csdn.net/20141206183858625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>那么，在对 64 位的数据加解密成功以后，对文件的加解密就很简单了！只需要每次读 64 位，加密以后，将 64 位的密文写入另外一个文件…..如此循环，直到文件尾。下面是对一张图片进行加密和解密的测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> k = <span class="string">"12345678"</span>;</span><br><span class="line">	key = charToBitset(k.c_str());</span><br><span class="line">	generateKeys();   <span class="comment">// 生成16个子密钥</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将文件 flower.jpg 加密到 cipher.txt 中</span></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line">	in.open(<span class="string">"D://flower.jpg"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	<span class="built_in">bitset</span>&lt;64&gt; plain;</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;plain, <span class="keyword">sizeof</span>(plain)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bitset</span>&lt;64&gt; cipher  = encrypt(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;cipher, <span class="keyword">sizeof</span>(cipher));</span><br><span class="line">		plain.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密 cipher.txt，并写入图片 flower1.jpg</span></span><br><span class="line">	in.open(<span class="string">"D://cipher.txt"</span>, ios::binary);</span><br><span class="line">	out.open(<span class="string">"D://flower1.jpg"</span>, ios::binary);</span><br><span class="line">	<span class="keyword">while</span>(in.read((<span class="keyword">char</span>*)&amp;plain, <span class="keyword">sizeof</span>(plain)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bitset</span>&lt;64&gt; temp  = decrypt(plain);</span><br><span class="line">		out.write((<span class="keyword">char</span>*)&amp;temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">		plain.reset();  <span class="comment">// 置0</span></span><br><span class="line">	&#125;</span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（全文完）<br><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《信息安全技术》这门课又在讲 DES 加密算法了，以前用纯C写过一次，这次我用 C++ 重新写了一个，写篇文章以备后用。本文介绍了 DES 算法加密的大致步骤和整体流程。</p>
<h3 id="一、DES算法原理">一、DES算法原理</h3><p>DES算法是一种最通用的对称密钥算法，因为算法本身是公开的，所以其安全性在于密钥的安全性。基于密钥的算法通常有两类：<strong>对称算法</strong>和<strong>公开密钥算法</strong>。对称算法的对称性体现在加密密钥能够从解密密钥推算出来，反之亦然。在大多数对称算法中，加解密的密钥是相同的，DES就是这样。可见，对称密钥算法的加解密密钥都是保密的。而公开密钥算法的加密密钥是公开的，解密密钥是保密的。</p>
<p>下面是 DES 加密算法的整体流程图：]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【动态规划】输出所有的最长公共子序列]]></title>
    <link href="http://yoursite.com/2014/11/29/print-all-LCS/"/>
    <id>http://yoursite.com/2014/11/29/print-all-LCS/</id>
    <published>2014-11-29T08:48:14.000Z</published>
    <updated>2015-05-10T10:34:30.441Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/2014/11/27/dynamic-programming/" target="_blank" rel="external">&lt;&lt; 动态规划求最长公共子序列的长度</a></p>
<p>上篇讲到使用动态规划可以在 <strong>θ(mn)</strong> 的时间里求出 LCS 的长度，本文将讨论如何输出最长公共子序列。</p>
<p><strong>*问题描述：</strong>给定两个序列，例如 X = “ABCBDAB”、Y = “BDCABA”，求它们的最长公共子序列的长度。*</p>
<p>下面是求解时的动态规划表，可以看出 X 和 Y 的最长公共子序列的长度为4：<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20141127164703086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>输出一个最长公共子序列并不难（网上很多相关代码），难点在于输出所有的最长公共子序列，因为 LCS 通常不唯一。总之，我们需要在动态规划表上进行回溯 —— 从<code>table[m][n]</code>，即右下角的格子，开始进行判断：</p>
<ol>
<li><p>如果格子<code>table[i][j]</code>对应的<code>X[i-1] == Y[j-1]</code>，则把这个字符放入 LCS 中，并跳入<code>table[i-1][j-1]</code>中继续进行判断；</p>
</li>
<li><p>如果格子<code>table[i][j]</code>对应的 <code>X[i-1] ≠ Y[j-1]</code>，则比较<code>table[i-1][j]</code>和<code>table[i][j-1]</code>的值，跳入值较大的格子继续进行判断；</p>
</li>
<li><p>直到 i 或 j 小于等于零为止，倒序输出 LCS 。</p>
</li>
</ol>
<p>如果出现<code>table[i-1][j]</code>等于<code>table[i][j-1]</code>的情况，说明最长公共子序列有多个，故两边都要进行回溯（这里用到递归）。</p>
<p><img src="http://img.blog.csdn.net/20141129154238387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从上图的红色路径显示，X 和 Y 的最长公共子序列有 3 个，分别为 “BDAB”、“BCAB”、“BCBA”。</p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划求解并输出所有LCS</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> X = <span class="string">"ABCBDAB"</span>;</span><br><span class="line"><span class="built_in">string</span> Y = <span class="string">"BDCABA"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; table; <span class="comment">// 动态规划表</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; setOfLCS;      <span class="comment">// set保存所有的LCS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 字符串逆序</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> str)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> high = str.length() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> temp = str[low];</span><br><span class="line">		str[low] = str[high];</span><br><span class="line">		str[high] = temp;</span><br><span class="line">		++low;</span><br><span class="line">		--high;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 构造表，并返回X和Y的LCS的长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 表的大小为(m+1)*(n+1)</span></span><br><span class="line">	table = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 第一行和第一列置0</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">				table[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(X[i-<span class="number">1</span>] == Y[j-<span class="number">1</span>])</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				table[i][j] = max(table[i-<span class="number">1</span>][j], table[i][j-<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> table[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 求出所有的最长公共子序列，并放入set中 </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span> lcs_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (X[i-<span class="number">1</span>] == Y[j-<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			lcs_str.push_back(X[i-<span class="number">1</span>]);</span><br><span class="line">			--i;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &gt; table[i][j-<span class="number">1</span>])</span><br><span class="line">				--i;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &lt; table[i][j-<span class="number">1</span>])</span><br><span class="line">				--j;</span><br><span class="line">			<span class="keyword">else</span>   <span class="comment">// 相等的情况</span></span><br><span class="line">			&#123;</span><br><span class="line">				traceBack(i-<span class="number">1</span>, j, lcs_str);</span><br><span class="line">				traceBack(i, j-<span class="number">1</span>, lcs_str);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	setOfLCS.insert(Reverse(lcs_str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = X.length();</span><br><span class="line">	<span class="keyword">int</span> n = Y.length();</span><br><span class="line">	<span class="keyword">int</span> length = lcs(m, n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of LCS is "</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	traceBack(m, n, str);</span><br><span class="line">	<span class="comment">// 倒序输出</span></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator beg = setOfLCS.begin();</span><br><span class="line">	<span class="keyword">for</span>( ; beg!=setOfLCS.end(); ++beg)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="http://img.blog.csdn.net/20141129154444437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>Java版本的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String X;</span><br><span class="line">	<span class="keyword">private</span> String Y;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] table;  <span class="comment">// 动态规划表</span></span><br><span class="line">	<span class="keyword">private</span> TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：带参数的构造器</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(String X, String Y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.X = X;</span><br><span class="line">		<span class="keyword">this</span>.Y = Y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：求两个数中的较大者</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a&gt;b) ? a:b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：构造表，并返回X和Y的LCS的长度</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		table = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>]; <span class="comment">// 表的大小为(m+1)*(n+1)	</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">				<span class="comment">// 第一行和第一列置0</span></span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">					table[i][j] = <span class="number">0</span>;</span><br><span class="line">				<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(X.charAt(i-<span class="number">1</span>)</span> </span>== Y.charAt(j-<span class="number">1</span>))</span><br><span class="line">					table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					table[i][j] = max(table[i-<span class="number">1</span>][j], table[i][j-<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> table[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：回溯，求出所有的最长公共子序列，并放入set中</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String lcs_str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (X.charAt(i-<span class="number">1</span>) == Y.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">				lcs_str += X.charAt(i-<span class="number">1</span>);</span><br><span class="line">				--i;</span><br><span class="line">				--j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &gt; table[i][j-<span class="number">1</span>])</span><br><span class="line">					--i;</span><br><span class="line">				<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(table[i-<span class="number">1</span>][j] &lt; table[i][j-<span class="number">1</span>])</span></span><br><span class="line">					--j</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;  <span class="comment">// 相等的情况</span></span><br><span class="line">					traceBack(i-<span class="number">1</span>, j, lcs_str);</span><br><span class="line">					traceBack(i, j-<span class="number">1</span>, lcs_str);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		set.add(reverse(lcs_str));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：字符串逆序</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">reverse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		StringBuffer strBuf = <span class="keyword">new</span> StringBuffer(str).reverse();</span><br><span class="line">		<span class="keyword">return</span> strBuf.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：外部接口 —— 打印输出</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLCS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = X.length();</span><br><span class="line">		<span class="keyword">int</span> n = Y.length();</span><br><span class="line">		<span class="keyword">int</span> length = lcs(m,n);</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		traceBack(m,n,str);</span><br><span class="line">		<span class="comment">// 倒序输出</span></span><br><span class="line">		System.out.println(<span class="string">"The length of LCS is: "</span> + length);</span><br><span class="line">		<span class="keyword">for</span>(String s : set) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 功能：main方法 —— 程序的入口</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyClass lcs = <span class="keyword">new</span> MyClass(<span class="string">"ABCBDAB"</span>,<span class="string">"BDCABA"</span>);</span><br><span class="line">		lcs.printLCS();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>转载请注明出处，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/2014/11/27/dynamic-programming/">&lt;&lt; 动态规划求最长公共子序列的长度</a></p>
<p>上篇讲到使用动态规划可以在 <strong>θ(mn)</strong> 的时间里求出 LCS 的长度，本文将讨论如何输出最长公共子序列。</p>
<p><strong>*问题描述：</strong>给定两个序列，例如 X = “ABCBDAB”、Y = “BDCABA”，求它们的最长公共子序列的长度。*</p>
<p>下面是求解时的动态规划表，可以看出 X 和 Y 的最长公共子序列的长度为4：<br>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划（Dynamic Programming）]]></title>
    <link href="http://yoursite.com/2014/11/27/dynamic-programming/"/>
    <id>http://yoursite.com/2014/11/27/dynamic-programming/</id>
    <published>2014-11-27T13:50:47.000Z</published>
    <updated>2015-05-10T10:30:16.598Z</updated>
    <content type="html"><![CDATA[<h3 id="一、动态规划">一、动态规划</h3><p><strong>动态规划（Dynamic Programming）</strong>是一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。</p>
<p><strong>基本思想：</strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。通常可以用一个<strong>表</strong>来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路。</p>
<p>采用动态规划求解的问题需要具有<strong>两个特性：</strong><a id="more"></a></p>
<ul>
<li><p><strong>最优子结构（Optimal Substructure）：</strong>问题的一个最优解中所包含的子问题的解也是最优的。</p>
</li>
<li><p><strong>重叠子问题（Overlapping Subproblems）：</strong>用递归算法对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。</p>
</li>
</ul>
<p>问题具有最优子结构性质，我们才能写出最优解的递归方程；具有重叠子问题特性，我们才能通过避免重复计算来减少运行时间。</p>
<p>综上所述，动态规划的关键是 —— 记忆，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。<br><br></p>
<h3 id="二、最长公共子序列（LCS）问题">二、最长公共子序列（LCS）问题</h3><p>下面通过一个具体的例子来学习动态规划方法 —— 最长公共子序列问题。</p>
<p><strong>*最长公共子串（Longest Common Substring）</strong>与<strong>最长公共子序列（Longest Common Subsequence）</strong>的区别： 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序，并不要求连续。*</p>
<p><strong>问题描述：</strong>给定两个序列：<code>X[1...m]</code>和<code>Y[1...n]</code>，求在两个序列中同时出现的最长子序列的长度。</p>
<p>假设 X 和 Y 的序列如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">1.</span>..m] = &#123;A, B, C, B, D, A, B&#125;</span><br><span class="line">Y[<span class="number">1.</span>..n] = &#123;B, D, C, A, B, A&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，X 和 Y 的最长公共子序列有 “BDAB”、“BCAB”、“BCBA”，即长度为4。</p>
<p><strong>1） 穷举法</strong></p>
<p>可能很多人会想到用穷举法来解决这个问题，即求出 X 中所有子序列，看 Y 中是否存在该子序列。</p>
<ul>
<li>X 有多少子序列 —— $2^m$ 个</li>
<li>检查一个子序列是否在 Y 中 —— θ(n)</li>
</ul>
<p>所以穷举法在最坏情况下的时间复杂度是 $θ(n * 2^m)$，也就是说花费的时间是指数级的，这简直太慢了。</p>
<p><strong>2） 动态规划</strong></p>
<p>首先，我们来看看 LCS 问题是否具有动态规划问题的两个特性。</p>
<p><strong>① 最优子结构</strong></p>
<p>设 <code>C[i,j] = |LCS(x[1...i],y[1...j])|</code>，即<code>C[i,j]</code>表示序列<code>X[1...i]</code>和<code>Y[1...j]</code>的最长公共子序列的长度，则 <code>C[m,n] = |LCS(x,y)|</code>就是问题的解。</p>
<p>递归推导式：</p>
<p><img src="http://img.blog.csdn.net/20141127164356104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>在这里就不证明了。从这个递归公式可以看出，问题具有最优子结构性质！</p>
<p><strong>② 重叠子问题</strong></p>
<p>根据上面的递归推导式，可以写出求LCS长度的递归伪代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LCS(x,y,<span class="built_in">i</span>,<span class="built_in">j</span>)</span><br><span class="line">	<span class="keyword">if</span> x<span class="matrix">[i]</span> = y<span class="matrix">[j]</span></span><br><span class="line">		then C<span class="matrix">[i,j]</span> ← LCS(x,y,<span class="built_in">i</span>-<span class="number">1</span>,<span class="built_in">j</span>-<span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span> C<span class="matrix">[i,j]</span> ← max<span class="cell">&#123;LCS(x,y,i-<span class="number">1</span>,j),LCS(x,y,i,j-<span class="number">1</span>)&#125;</span></span><br><span class="line">	<span class="keyword">return</span> C<span class="matrix">[i,j]</span></span><br></pre></td></tr></table></figure></p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的递归求解LCS问题</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the length of LCS for X[0...m-1] and Y[0...n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> &amp;X, <span class="built_in">string</span> &amp;Y, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (X[m-<span class="number">1</span>] == Y[n-<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">return</span> lcs(X, Y, m-<span class="number">1</span>, n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> max(lcs(X, Y, m, n-<span class="number">1</span>), lcs(X, Y, m-<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> X = <span class="string">"ABCBDAB"</span>;</span><br><span class="line">	<span class="built_in">string</span> Y = <span class="string">"BDCABA"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of LCS is "</span> &lt;&lt; lcs(X, Y, X.length(), Y.length());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像这样使用简单的递归，在最坏情况下（X 和 Y 的所有字符都不匹配，即LCS的长度为0）的时间复杂度为 <strong>θ(2^n)</strong>。这和穷举法一样还是指数级的，太慢了。</p>
<p>根据程序中 X 和 Y 的初始值，我们画出部分递归树：</p>
<p><img src="http://img.blog.csdn.net/20141127164646781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>递归树中红框标记的部分被调用了两次。如果画出完整的递归树，我们会看到很多重复的调用，所以这个问题具有重叠子问题的特性。</p>
<p><strong>③ 动态规划求解</strong></p>
<p>简单的递归之所以和穷举法一样慢，因为在递归过程中进行了大量的重复调用。而<strong>动态规划就是要解决这个问题，通过用一个表来保存子问题的结果，避免重复的计算，以空间换时间</strong>。前面我们已经证明，最长公共子序列问题具有动态规划所要求的两个特性，所以 LCS 问题可以用动态规划来求解。</p>
<p>下面是用动态规划（打表）解决LCS问题：</p>
<p><img src="http://img.blog.csdn.net/20141127164703086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>C++代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划求解LCS问题</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回X[0...m-1]和Y[0...n-1]的LCS的长度 </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> &amp;X, <span class="built_in">string</span> &amp;Y, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 动态规划表，大小(m+1)*(n+1)</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; table(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 第一行和第一列置0</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">				table[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(X[i-<span class="number">1</span>] == Y[j-<span class="number">1</span>])</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				table[i][j] = max(table[i-<span class="number">1</span>][j], table[i][j-<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> table[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> X = <span class="string">"ABCBDAB"</span>;</span><br><span class="line">	<span class="built_in">string</span> Y = <span class="string">"BDCABA"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of LCS is "</span> &lt;&lt; lcs(X, Y, X.length(), Y.length());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>容易看出，动态规划解决LCS问题的时间复杂度为 <strong>θ(mn)</strong>，这比简单的递归实现要快多了。空间复杂度是<strong>θ(mn)</strong>，因为使用了一个动态规划表。当然，空间复杂度还可以进行优化，即根据递推式我们可以只保存填下一个位置所用到的几个位置就行了。（关于如何输出LCS请看另一篇：《<a href="http://songlee24.github.io/blog/2014/11/29/printlcs/" target="_blank" rel="external">输出所有的最长公共子序列</a>》）</p>
<p><br><br><br><br></p>
<h3 id="总结：">总结：</h3><p>动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余（重复计算），这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p>
<p>从上面的例子中，我们可以总结动态规划解决最优化问题的一般步骤：</p>
<ol>
<li>分析最优解的性质，并刻划其结构特征。</li>
<li>递归地定义最优值。</li>
<li>以自底向上的方式或自顶向下的记忆化方法计算出最优值。</li>
<li>根据计算最优值时得到的信息，构造一个最优解。</li>
</ol>
<p>步骤(1)—(3)是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤(4)可以省略，若需要求出问题的一个最优解，则必须执行步骤(4)。此时，在步骤(3)中计算最优值时，通常需记录更多的信息，以便在步骤(4)中，根据所记录的信息，快速地构造出一个最优解。</p>
<p>（全文完）</p>
<p><br><br>参考：<br>[1] www.algorithmist.com/index.php/Longest_Common_Subsequence<br>[2] www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、动态规划">一、动态规划</h3><p><strong>动态规划（Dynamic Programming）</strong>是一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。</p>
<p><strong>基本思想：</strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。通常可以用一个<strong>表</strong>来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路。</p>
<p>采用动态规划求解的问题需要具有<strong>两个特性：</strong>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于MFC的一个简单计算器]]></title>
    <link href="http://yoursite.com/2014/10/13/simple-calculator/"/>
    <id>http://yoursite.com/2014/10/13/simple-calculator/</id>
    <published>2014-10-13T03:08:53.000Z</published>
    <updated>2015-05-10T10:24:00.243Z</updated>
    <content type="html"><![CDATA[<p>写一个简单的计算器并不是什么很难的事，主要目的是要通过这个程序来学习和分析其中的核心算法。这个简易计算器的<strong>核心部分</strong>就是对输入的表达式的正确性判断与求值，其中包括对表达式的解析、中缀表达式转后缀表达式、后缀表达式求值等等几个方面。</p>
<p><center><img src="http://img.blog.csdn.net/20141007151700078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></center><br><a id="more"></a><br><br></p>
<h3 id="一、封装核心代码">一、封装核心代码</h3><p>《<a href="http://songlee24.github.io/2014/10/05/arithmetic-expression-01/" target="_blank" rel="external">算术表达式的合法性判断与求值（上）</a>》和《<a href="http://songlee24.github.io/2014/10/10/arithmetic-expression-02/" target="_blank" rel="external">算术表达式的合法性判断与求值（下）</a>》这两篇文章已经对核心算法部分进行了讲解，并附有源码。在此基础上制作一个简单计算器，我们要做的仅仅是封装核心代码并加入MFC工程中。</p>
<p>下面是我封装的一个 Expression 类：</p>
<p><strong>Expression.h</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Expression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Expression(<span class="built_in">string</span> str);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">()</span></span>;         <span class="comment">// 外部接口，判断表达式是否合法</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">()</span></span>;  <span class="comment">// 外部接口，计算表达式的值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line">	<span class="built_in">string</span> expr;  <span class="comment">// 算术表达式</span></span><br><span class="line">	<span class="keyword">int</span> idx;      <span class="comment">// word下标</span></span><br><span class="line">	<span class="keyword">int</span> sym;      <span class="comment">// 单词种别编码</span></span><br><span class="line">	<span class="keyword">int</span> err;      <span class="comment">// 错误</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; , <span class="keyword">const</span> <span class="built_in">string</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">bool</span> Right;   <span class="comment">// 保存表达式test结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">// 获取运算符的优先级</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 通过 种别编码 判定是否是运算符</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; getPostfix(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp;);  <span class="comment">// 中缀转后缀</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">popTwoNumbers</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;&amp;, <span class="keyword">double</span>&amp;, <span class="keyword">double</span>&amp;)</span></span>;  <span class="comment">// 从栈中连续弹出两个操作数</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;  <span class="comment">// 把string转换为double</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">expCalculate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp;)</span></span>;  <span class="comment">// 计算后缀表达式的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Expression.cpp</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Expression.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Expression::Expression( <span class="built_in">string</span> str ):</span><br><span class="line">	expr(str),</span><br><span class="line">	idx(<span class="number">0</span>),</span><br><span class="line">	err(<span class="number">0</span>),</span><br><span class="line">	Right(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口</span></span><br><span class="line"><span class="keyword">bool</span> Expression::test()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!word.empty())  <span class="comment">// 已经test过了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">	<span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">	&#123;</span><br><span class="line">		Right = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 词法正确，进行语法分析</span></span><br><span class="line">		Next();</span><br><span class="line">		E();</span><br><span class="line">		<span class="keyword">if</span> (sym == <span class="number">0</span> &amp;&amp; err == <span class="number">0</span>)  <span class="comment">// 注意要判断两个条件</span></span><br><span class="line">			Right = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Right = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口</span></span><br><span class="line"><span class="keyword">double</span> Expression::calculate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (test())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> expCalculate(getPostfix(word));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------词法分析----------------------------*/</span></span><br><span class="line"><span class="keyword">int</span> Expression::word_analysis(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">		<span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">			|| expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp;</span><br><span class="line">			tmp.push_back(expr[i]);</span><br><span class="line">			<span class="keyword">switch</span> (expr[i])</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">				word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是数字开头</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp;</span><br><span class="line">			<span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp.push_back(expr[i]);</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++i;</span><br><span class="line">				<span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">					<span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						tmp.push_back(expr[i]);</span><br><span class="line">						++i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>  </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果以.开头</span></span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------语法分析----------------------------*/</span></span><br><span class="line"><span class="comment">// 读下一单词的种别编码</span></span><br><span class="line"><span class="keyword">void</span> Expression::Next()</span><br><span class="line">&#123;   </span><br><span class="line">	<span class="keyword">if</span>(idx &lt; word.size())</span><br><span class="line">		sym = word[idx++].second;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sym = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E → T &#123; +T | -T &#125; </span></span><br><span class="line"><span class="keyword">void</span> Expression::E()</span><br><span class="line">&#123;</span><br><span class="line">	T();</span><br><span class="line">	<span class="keyword">while</span>(sym == <span class="number">1</span> || sym == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">		T();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T → F &#123; *F | /F &#125; </span></span><br><span class="line"><span class="keyword">void</span> Expression::T()</span><br><span class="line">&#123;</span><br><span class="line">	F();</span><br><span class="line">	<span class="keyword">while</span>(sym == <span class="number">3</span> || sym == <span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">		F();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F → (E) | d</span></span><br><span class="line"><span class="keyword">void</span> Expression::F()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sym == <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Next();</span><br><span class="line">		E();</span><br><span class="line">		<span class="keyword">if</span> (sym == <span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Next();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			err = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		err = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------求值部分----------------------------*/</span></span><br><span class="line"><span class="keyword">int</span> Expression::prior(<span class="keyword">int</span> sym)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sym)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Expression::isOperator(<span class="keyword">int</span> sym)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sym)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; Expression::getPostfix( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; expr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; output;  <span class="comment">// 输出</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; s;        <span class="comment">// 操作符栈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p = expr[i];</span><br><span class="line">		<span class="keyword">if</span>(isOperator(p.second))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top().second) &amp;&amp; prior(s.top().second)&gt;=prior(p.second))</span><br><span class="line">			&#123;</span><br><span class="line">				output.push_back(s.top());</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			s.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">6</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(s.top().second != <span class="number">6</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				output.push_back(s.top());</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			output.push_back(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		output.push_back(s.top());</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Expression::popTwoNumbers( <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;&amp; s, <span class="keyword">double</span>&amp; first, <span class="keyword">double</span>&amp; second )</span><br><span class="line">&#123;</span><br><span class="line">	first = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	second = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Expression::stringToDouble( <span class="keyword">const</span> <span class="built_in">string</span>&amp; str )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="built_in">stringstream</span> ss;</span><br><span class="line">	ss &lt;&lt; str;</span><br><span class="line">	ss &gt;&gt; d;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Expression::expCalculate( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; postfix )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> first,second;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;postfix.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p = postfix[i];</span><br><span class="line">		<span class="keyword">switch</span> (p.second)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second+first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second-first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second*first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			popTwoNumbers(s, first, second);</span><br><span class="line">			s.push(second/first);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			s.push(stringToDouble(p.first));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> result = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用方法（测试）：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;	</span><br><span class="line">	<span class="function">Expression <span class="title">e</span><span class="params">("(1.5+2.5)</span>*2+0.53")</span>;</span><br><span class="line">	<span class="keyword">if</span>(e.test())   <span class="comment">// 判断表达式是否合法</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.calculate() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、加入MFC工程">二、加入MFC工程</h3><p>OK，核心代码（表达式的合法性判断与求值）已经封装到 Expression 类中，下面要做的就是新建一个 MFC 工程，并把 Expression 类加入工程里，并实现按钮的功能就行了。</p>
<p>在 MFC 对话框上添加二十个 Button 控件和一个 Edit 控件（设置Disable属性为true，只用于显示），如下图：</p>
<p><center><img src="http://img.blog.csdn.net/20141007154354143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></center><br><br><br>给 Edit 控件绑定一个变量 mEdit，然后给各个按钮添加单击响应函数，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“1”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"1"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked2()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“2”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"2"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked3()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“3”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"3"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked4()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“4”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"4"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked5()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“5”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"5"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked6()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“6”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"6"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked7()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“7”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"7"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked8()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“8”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"8"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked9()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“9”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"9"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClicked0()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 数字“0”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"0"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedClear()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “清屏”按钮</span></span><br><span class="line">	mEdit.SetWindowText(_T(<span class="string">""</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedBack()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “后退”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str.Left(str.GetLength()-<span class="number">1</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedLeft()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “左括号”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"("</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedRight()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// “右括号”按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">")"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedDot()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// "."按钮</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"."</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedAdd()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 加号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"+"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedSub()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 减号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"-"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedMul()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 乘号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"*"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedDiv()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 除号</span></span><br><span class="line">	CString str;</span><br><span class="line">	mEdit.GetWindowText(str);</span><br><span class="line">	str = str + _T(<span class="string">"/"</span>);</span><br><span class="line">	mEdit.SetWindowText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCalculatorDlg::OnBnClickedEql()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 等号，计算结果  </span></span><br><span class="line">    CString str;  </span><br><span class="line">    mEdit.GetWindowText(str);  </span><br><span class="line">    <span class="function">CT2CA <span class="title">pszConvertedAnsiString</span><span class="params">(str)</span></span>;  <span class="comment">// 将 TCHAR 转换为 LPCSTR  </span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">exp_str</span><span class="params">(pszConvertedAnsiString)</span></span>; <span class="comment">// 从 LPCSTR 构造 string  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (exp_str != <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Expression <span class="title">e</span><span class="params">(exp_str)</span></span>;  </span><br><span class="line">        <span class="keyword">if</span>(e.test())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">string</span> tmp;  </span><br><span class="line">            <span class="built_in">stringstream</span> ss;  </span><br><span class="line">            ss &lt;&lt; e.calculate();  </span><br><span class="line">            ss &gt;&gt; tmp;  </span><br><span class="line">            str = tmp.c_str();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            str = <span class="string">"输入错误"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mEdit.SetWindowText(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，一个可以计算整数和小数的四则混合运算的简单计算器就完成了。</p>
<p>虽然 Expression 类可以对所有的输入进行解析，并判断其合法性。但是考虑到用户体验，最好还是对各个 Button 的输入进行一定的限制，比如+++++++。这就需要在按钮的响应函数里添加逻辑，详细的就不多说了。</p>
<p><strong>源码下载：</strong><a href="http://download.csdn.net/detail/lisong694767315/8009467" target="_blank" rel="external">http://download.csdn.net/detail/lisong694767315/8009467</a></p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写一个简单的计算器并不是什么很难的事，主要目的是要通过这个程序来学习和分析其中的核心算法。这个简易计算器的<strong>核心部分</strong>就是对输入的表达式的正确性判断与求值，其中包括对表达式的解析、中缀表达式转后缀表达式、后缀表达式求值等等几个方面。</p>
<p><center><img src="http://img.blog.csdn.net/20141007151700078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></center><br>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算术表达式的合法性判断与求值（下）]]></title>
    <link href="http://yoursite.com/2014/10/10/arithmetic-expression-02/"/>
    <id>http://yoursite.com/2014/10/10/arithmetic-expression-02/</id>
    <published>2014-10-10T01:58:01.000Z</published>
    <updated>2015-05-10T10:18:43.177Z</updated>
    <content type="html"><![CDATA[<p><a href="http://songlee24.github.io/2014/10/05/arithmetic-expression-01/" target="_blank" rel="external">&lt;&lt; 算术表达式的合法性判断与求值（上）</a></p>
<p>上一篇讲到，通过编译原理的方法（词法分析和语法分析）来判断字符串表示的算术表达式的合法性。这一篇，接着讲在算术表达式合法的情况下，对表达式进行求值。</p>
<ul>
<li>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。  </li>
<li>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</li>
</ul>
<h3 id="三、算术表达式的求值">三、算术表达式的求值</h3><p>表达式的求值是栈应用的一个典型范例。我们一般通过<strong>后缀表达式（逆波兰式）</strong>进行求值，<a id="more"></a>因为对后缀表达式求值比直接对中缀表达式求值简单很多。<strong>中缀表达式</strong>不仅依赖运算符的优先级，而且还要处理括号，而后缀表达式中已经考虑了运算符的优先级，且没有括号。</p>
<p>所以，这里对表达式的求值分两个步骤进行：首先，把中缀表达式转换为后缀表达式，然后，对后缀表达式求值。</p>
<p><strong>1）中缀转后缀</strong></p>
<p>在把中缀转后缀的过程中，需要考虑操作符的优先级。根据《数据结构与算法分析》一书中的描述，我们需要利用一个<strong>栈</strong>（存放操作符）和一个<strong>输出字符串Output</strong>，从左到右读入中缀表达式：</p>
<ol>
<li>如果字符是操作数，将它添加到 Output。</li>
<li>如果字符是操作符，从栈中弹出操作符，到 Output 中，直到遇到左括号 或 优先级较低的操作符（并不弹出）。然后把这个操作符 push 入栈。</li>
<li>如果字符是左括号，无理由入栈。</li>
<li>如果字符是右括号，从栈中弹出操作符，到 Output 中，直到遇到左括号。（左括号只弹出，不放入输出字符串）</li>
<li>中缀表达式读完以后，如果栈不为空，从栈中弹出所有操作符并添加到 Output 中。</li>
</ol>
<p>好了，下面直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运算符的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是运算符</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀转后缀</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getPostfix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;  <span class="comment">// 操作符栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = expr[i];</span><br><span class="line">        <span class="keyword">if</span>(isOperator(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top()) &amp;&amp; prior(s.top())&gt;=prior(c))</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.top() != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"a+b*c+(d*e+f)*g"</span>;</span><br><span class="line">    <span class="built_in">string</span> postfix = getPostfix(expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; endl &lt;&lt; postfix &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相信应该不需要我再解释什么了，请对照上面的规则看代码。</p>
<p><strong>2）后缀表达式求值</strong></p>
<p>得到了后缀表达式以后，对后缀表达式的求值就变得非常简单了。只需要使用一个栈，从左到右读入后缀表达式：</p>
<ol>
<li>如果字符是操作数，把它压入堆栈。</li>
<li>如果字符是操作符，从栈中弹出两个操作数，执行相应的运算，然后把结果压入堆栈。（如果不能连续弹出两个操作数，说明表达式不正确）</li>
<li>当表达式扫描完以后，栈中存放的就是最后的计算结果。</li>
</ol>
<p>好了，话不多说，直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getPostfix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;  <span class="comment">// 操作符栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = expr[i];</span><br><span class="line">        <span class="keyword">if</span>(isOperator(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top()) &amp;&amp; prior(s.top())&gt;=prior(c))</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.top() != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈中连续弹出两个操作数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popTwoNumbers</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&amp; s, <span class="keyword">int</span>&amp; first, <span class="keyword">int</span>&amp; second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    first = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    second = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expCalculate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; postfix)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first,second;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;postfix.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = postfix[i];</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second+first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second-first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second*first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second/first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            s.push(c-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"5+2*(6-3)-4/2"</span>;</span><br><span class="line">    <span class="built_in">string</span> postfix = getPostfix(expr);</span><br><span class="line">    <span class="keyword">int</span> result = expCalculate(postfix);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，示例中的操作数都是单个的字符（0-9），但是通常的表达式不会是这种特殊情况，这就是我们需要对表达式进行词法解析的原因。</p>
<h3 id="四、解决问题">四、解决问题</h3><p>好了，下面我们就结合上篇讲的<a href="http://songlee24.github.io/blog/2014/10/13/suan-zhu-biao-da-shi-de-qiu-zhi-shang/" target="_blank" rel="external">词法分析</a>对一个含有整数或小数的表达式进行求值。</p>
<p>因为操作数不再是单个字符（个位数），我们需要对表达式进行词法解析。这里经过解析后，将<code>(单词, 种别编码)</code>对存入到一个<code>vector&lt;pair&lt;string, int&gt;&gt;</code>中，所以我们的中缀转后缀、后缀表达式求值都是对这个<code>vector</code>结构进行遍历。</p>
<p>假设表达式已经判断为合法，求值的完整代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - * / ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运算符的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">int</span> sym)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sym)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 种别编码 判定是否是运算符</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">int</span> sym)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sym)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; getPostfix(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; expr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; s;  <span class="comment">// 操作符栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p = expr[i];</span><br><span class="line">        <span class="keyword">if</span>(isOperator(p.second))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; isOperator(s.top().second) &amp;&amp; prior(s.top().second)&gt;=prior(p.second))</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.second == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.top().second != <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output.push_back(s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(s.top());</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈中连续弹出两个操作数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popTwoNumbers</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;&amp; s, <span class="keyword">double</span>&amp; first, <span class="keyword">double</span>&amp; second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    first = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    second = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把string转换为double</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; d;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">expCalculate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; postfix)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> first,second;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;postfix.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p = postfix[i];</span><br><span class="line">        <span class="keyword">switch</span> (p.second)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second+first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second-first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second*first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            popTwoNumbers(s, first, second);</span><br><span class="line">            s.push(second/first);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            s.push(stringToDouble(p.first));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"(1.5+2.5)*2-0.5"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> result = expCalculate(getPostfix(word));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; expr + <span class="string">" = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了防止精度的损失，不论是整数还是小数，在这里都通过<code>stringToDouble()</code>函数转为 double 浮点数。</p>
<p><br><br><br><br><br></p>
<h3 id="附：字符串转数值类型">附：字符串转数值类型</h3><p><strong>方法一：atoi、atof</strong></p>
<p>在C语言的头文件 stdlib.h 里提供了两个函数，用于将字符串转换为整数或浮点数。函数原型分别为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;          <span class="comment">// 字符串转整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;       <span class="comment">// 字符串转浮点数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：stringstream</strong></p>
<p>在C++里，可以利用 stringstream 方便的将 string 转换为 int、float、double：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d; </span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; str;    <span class="comment">// 把字符串写入字符流</span></span><br><span class="line">    ss &gt;&gt; d;      <span class="comment">// 输出到double</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">doubleToString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str; </span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; d;  </span><br><span class="line">    ss &gt;&gt; str;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 stringstream 将 string 转换为 int 或 float 与上面的方法是一样的，只需要改一下变量的类型就可以了。</p>
<p>（全文完）</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://songlee24.github.io/2014/10/05/arithmetic-expression-01/">&lt;&lt; 算术表达式的合法性判断与求值（上）</a></p>
<p>上一篇讲到，通过编译原理的方法（词法分析和语法分析）来判断字符串表示的算术表达式的合法性。这一篇，接着讲在算术表达式合法的情况下，对表达式进行求值。</p>
<ul>
<li>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。  </li>
<li>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</li>
</ul>
<h3 id="三、算术表达式的求值">三、算术表达式的求值</h3><p>表达式的求值是栈应用的一个典型范例。我们一般通过<strong>后缀表达式（逆波兰式）</strong>进行求值，]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算术表达式的合法性判断与求值（上）]]></title>
    <link href="http://yoursite.com/2014/10/05/arithmetic-expression-01/"/>
    <id>http://yoursite.com/2014/10/05/arithmetic-expression-01/</id>
    <published>2014-10-05T01:49:03.000Z</published>
    <updated>2015-05-10T10:19:33.516Z</updated>
    <content type="html"><![CDATA[<p>在写一个计算器时遇到了一个问题，就是对字符串表示的<strong>算术表达式</strong>的合法性判断与求值。下面记录一下我的解决方案。</p>
<h3 id="一、问题描述">一、问题描述</h3><p>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。</p>
<p>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</p>
<h3 id="二、判断表达式的合法性">二、判断表达式的合法性</h3><a id="more"></a>
<p>相信学过《<a href="http://book.douban.com/subject/6091300/" target="_blank" rel="external">编译原理</a>》的人都知道，利用里面讲的分析方法可以对源代码进行解析。而<strong>算术表达式</strong>也是源代码的一部分，所以利用编译方法也可以很容易地判断表达式的合法性。</p>
<p>与源代码相比，算术表达式只包含有很少的字符，所以解析起来也简单很多。下面从词法分析和语法分析两个方面来说明。</p>
<p><strong>1）词法分析</strong></p>
<p>下面先定一下表达式涉及到的单词的种别编码：</p>
<p><img src="http://img.blog.csdn.net/20141006175947479?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>识别上表所列的单词的状态转换图：</p>
<p><img src="http://img.blog.csdn.net/20141006184215899?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line">    <span class="built_in">string</span> expr = <span class="string">"(1.5+5.789)*82-10/2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码将识别出的单词-种别编码对 <code>(单词, 种别编码)</code> 存入一个 <code>vector&lt;pair&lt;string, int&gt;&gt;</code> 中。</p>
<p><strong>2）语法分析</strong></p>
<p>算术表达式的文法 G[E] 如下：  </p>
<blockquote>
<p> E → E+T | E-T | T<br> T → T*F | T/F | F<br> F → (E) | d</p>
</blockquote>
<p>消去非终结符E和T的左递归后，改写 G[E] 文法如下：</p>
<blockquote>
<p>E → TE’<br>E’ → +TE’ | -TE’ | ε<br>T → FT’<br>T’ → *FT’ | /FT’ | ε<br>F → (E) | d</p>
</blockquote>
<p>可以证明上述无递归文法是 LL(1) 文法，可以使用 <strong>递归下降分析法</strong>。递归下降分析法是确定的自上而下分析法，这种分析法要求文法是 LL(1) 文法。它的<strong>基本思想</strong>是：对文法中的每一个非终结符编写一个函数（或子程序），每个函数（或子程序）的功能是识别由该非终结符所表示的语法成分。</p>
<p>构造递归下降分析程序时，每个函数名是相应的非终结符，函数体是根据规则右部符号串的结构编写：</p>
<ul>
<li><p>当遇到终结符 a 时，则编写语句<br>if（当前读来的输入符号 == a）读下一个输入符号；</p>
</li>
<li><p>当遇到非终结符 A 时，则编写语句调用 A( )；</p>
</li>
<li><p>当遇到 A-&gt;ε 规则时，则编写语句<br>if（当前读来的输入符号 不属于 FOLLOW(A)）error()；</p>
</li>
<li><p>当某个非终结符的规则有多个候选式时，按 LL(1) 文法的条件能唯一地选择一个候选式进行推导。</p>
</li>
</ul>
<p>所以我们需要求出 <strong>FOLLOW(E’)</strong> 和 <strong>FOLLOW(T’)</strong>：</p>
<p><img src="http://img.blog.csdn.net/20150510181122458" alt=""></p>
<p>好了，下面直接上代码，在词法分析的基础上进行语法分析：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line"><span class="built_in">string</span> expr = <span class="string">"(1.5+5.789)*82-10/2"</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sym;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*--------------------------------词法分析----------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------语法分析----------------------------*/</span></span><br><span class="line"><span class="comment">// 读下一单词的种别编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; word.size())</span><br><span class="line">        sym = word[idx++].second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sym = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E → TE' </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T();</span><br><span class="line">    E1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E' → +TE' | -TE' | ε </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sym == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        T();</span><br><span class="line">        E1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        T();</span><br><span class="line">        E1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym != <span class="number">7</span> &amp;&amp; sym != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T → FT' </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    F();</span><br><span class="line">    T1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T' → *FT' | /FT' | ε </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sym == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        F();</span><br><span class="line">        T1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        F();</span><br><span class="line">        T1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym != <span class="number">1</span> &amp;&amp; sym != <span class="number">2</span> &amp;&amp; sym != <span class="number">7</span> &amp;&amp; sym != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F → (E) | d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sym == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span>(sym == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            err = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; endl &lt;&lt; <span class="string">"Word Analysis:"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 测试输出</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;::iterator beg = word.begin();</span><br><span class="line">        <span class="keyword">for</span>(;beg!=word.end(); ++beg)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"   ("</span> &lt;&lt; beg-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 词法正确，进行语法分析</span></span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span> (sym == <span class="number">0</span> &amp;&amp; err == <span class="number">0</span>)  <span class="comment">// 注意要判断两个条件</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right Expression."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong Expression."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，还有一种更简单的形式，将文法 G(E) 用<strong>扩充BNF表示法</strong>进行改写：</p>
<blockquote>
<p>E → T { +T | -T }<br>T → F { *F | /F }<br>F → (E) | d</p>
</blockquote>
<p>然后对这种变形文法使用递归下降分析法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; word;</span><br><span class="line"><span class="built_in">string</span> expr = <span class="string">"(1.5+5.789)*82-10/2"</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sym;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*--------------------------------词法分析----------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word_analysis</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;&amp; word, <span class="keyword">const</span> <span class="built_in">string</span> expr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expr.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是 + - x ÷ ( )</span></span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">'('</span> || expr[i] == <span class="string">')'</span> || expr[i] == <span class="string">'+'</span> </span><br><span class="line">            || expr[i] == <span class="string">'-'</span> || expr[i] == <span class="string">'*'</span> || expr[i] == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            tmp.push_back(expr[i]);</span><br><span class="line">            <span class="keyword">switch</span> (expr[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">3</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">4</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">6</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                word.push_back(make_pair(tmp, <span class="number">7</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(expr[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(expr[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    <span class="keyword">while</span>(expr[i]&gt;=<span class="string">'0'</span> &amp;&amp; expr[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp.push_back(expr[i]);</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// .后面不是数字，词法错误</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push_back(make_pair(tmp, <span class="number">5</span>));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以.开头</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 以.开头，词法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------语法分析----------------------------*/</span></span><br><span class="line"><span class="comment">// 读下一单词的种别编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; word.size())</span><br><span class="line">        sym = word[idx++].second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sym = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E → T &#123; +T | -T &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">E</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T();</span><br><span class="line">    <span class="keyword">while</span>(sym == <span class="number">1</span> || sym == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        T();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T → F &#123; *F | /F &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    F();</span><br><span class="line">    <span class="keyword">while</span>(sym == <span class="number">3</span> || sym == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        F();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F → (E) | d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sym == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sym == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span> (sym == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            err = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> err_num = word_analysis(word, expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; endl &lt;&lt; <span class="string">"Word Analysis:"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == err_num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Error!"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 测试输出</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;::iterator beg = word.begin();</span><br><span class="line">        <span class="keyword">for</span>(;beg!=word.end(); ++beg)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"   ("</span> &lt;&lt; beg-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 词法正确，进行语法分析</span></span><br><span class="line">        Next();</span><br><span class="line">        E();</span><br><span class="line">        <span class="keyword">if</span> (sym == <span class="number">0</span> &amp;&amp; err == <span class="number">0</span>)  <span class="comment">// 注意要判断两个条件</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right Expression."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong Expression."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于这种文法形式写程序，<strong>只需要写3个函数（因为只有3个非终结符），而且不需要求 FOLLOW 集合。</strong></p>
<p>测试结果：</p>
<p><img src="http://img.blog.csdn.net/20141006200250847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><br><br><br></p>
<p><a href="http://songlee24.github.io/2014/10/10/arithmetic-expression-02/" target="_blank" rel="external"><span style="font-size:25px">算术表达式的合法性判断与求值（下）&gt;&gt;</span></a></p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写一个计算器时遇到了一个问题，就是对字符串表示的<strong>算术表达式</strong>的合法性判断与求值。下面记录一下我的解决方案。</p>
<h3 id="一、问题描述">一、问题描述</h3><p>问题：给定一个字符串，只包含 <strong>‘+’、’-‘、’*’、’/‘、数字、小数点、’(‘ 、’)’</strong>。</p>
<p>要求：(1) 判断该算术表达式是否合法； (2) 如果合法，计算该表达式的值。</p>
<h3 id="二、判断表达式的合法性">二、判断表达式的合法性</h3>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux编程】C/C++获取目录下文件或目录]]></title>
    <link href="http://yoursite.com/2014/09/20/linux-get-directory/"/>
    <id>http://yoursite.com/2014/09/20/linux-get-directory/</id>
    <published>2014-09-20T09:04:17.000Z</published>
    <updated>2015-05-10T08:46:09.871Z</updated>
    <content type="html"><![CDATA[<p>在Unix/Linux系统中，要获取一个指定目录下所有的文件或文件夹，一般用<code>dirent.h</code>（POSIX标准定义的目录操作头文件）。</p>
<h3 id="一、数据类型">一、数据类型</h3><p>在头文件<code>&lt;dirent.h&gt;</code>中定义了两种主要的数据类型。</p>
<p><strong>DIR</strong>：代表一个目录流的结构。<a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __dirstream</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *__fd;              <span class="comment">/* 'struct hurd_fd' pointer for descriptor.*/</span></span><br><span class="line">    <span class="keyword">char</span> *__data;            <span class="comment">/* Directory block.  */</span></span><br><span class="line">    <span class="keyword">int</span> __entry_data;        <span class="comment">/* Entry number `__data' corresponds to.*/</span></span><br><span class="line">    <span class="keyword">char</span> *__ptr;             <span class="comment">/* Current pointer into the block.*/</span></span><br><span class="line">    <span class="keyword">int</span> __entry_ptr;         <span class="comment">/* Entry number `__ptr' corresponds to.*/</span></span><br><span class="line">    size_t __allocation;          <span class="comment">/* Space allocated for the block.*/</span></span><br><span class="line">    size_t __size;                <span class="comment">/* Total valid data in the block.*/</span></span><br><span class="line">    __libc_lock_define (, __lock) <span class="comment">/* Mutex lock for this structure.*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __dirstream DIR;</span><br></pre></td></tr></table></figure></p>
<p><strong>struct dirent</strong>：包含一个文件或目录信息的结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dirent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> d_ino;                 <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">    off_t d_off;                <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;       <span class="comment">/* the type of d_name 文件类型 */</span>    </span><br><span class="line">    <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>];   <span class="comment">/* file name 文件名，最长255字符 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、函数原型">二、函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DIR* opendir(<span class="keyword">const</span> <span class="keyword">char</span>* dirname);</span><br><span class="line"><span class="comment">/* 打开一个目录：</span><br><span class="line">        成功 - 返回指向DIR类型对象的指针。</span><br><span class="line">        失败 - 返回NULL    */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 关闭目录流：</span><br><span class="line">        成功 - 返回0</span><br><span class="line">        失败 - 返回-1    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *readdir(DIR *dirp);</span><br><span class="line"><span class="comment">/* 读取目录流：</span><br><span class="line">        成功 - 返回指向struct dirent对象的指针。</span><br><span class="line">        失败 - 返回NULL（出错或流末尾）  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readdir_r</span><span class="params">(DIR *dirp, <span class="keyword">struct</span> dirent *entry, <span class="keyword">struct</span> dirent **result)</span></span>;</span><br><span class="line"><span class="comment">/* 读取目录流：用 dirp 当前位置的目录初始化entry，并让 result 指向 entry。</span><br><span class="line">        成功 - 返回0</span><br><span class="line">        失败 - 返回error number   */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 重置目录流的位置到开头 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dirp, <span class="keyword">long</span> <span class="keyword">int</span> loc)</span></span>;</span><br><span class="line"><span class="comment">/* 设置目录流的位置，设置以后readdir()会读取到loc位置的目录。 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">telldir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回目录流的当前位置 */</span></span><br></pre></td></tr></table></figure>
<h3 id="三、示例代码">三、示例代码</h3><p>下面是一段 C 代码，输出指定目录下的所有文件或目录名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;dirent.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	DIR *dp;</span><br><span class="line">	<span class="keyword">struct</span> dirent *dirp;</span><br><span class="line">	<span class="keyword">char</span> dirname[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please input a directory: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,dirname);</span><br><span class="line">	<span class="keyword">if</span>((dp = opendir(dirname)) == NULL)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Can't open %s\n"</span>, dirname);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;dirent.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> dirname;</span><br><span class="line">	DIR *dp;</span><br><span class="line">	<span class="keyword">struct</span> dirent *dirp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input a directory: "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; dirname;</span><br><span class="line">	<span class="keyword">if</span>((dp = opendir(dirname.c_str())) == NULL)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't open "</span> &lt;&lt; dirname &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dirp-&gt;d_name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有些情况下，我们只要输出文件而不需要文件夹（目录），这时可以通过<code>dirent</code>结构体中的<code>d_type</code>进行过滤。<code>d_type</code>表示类型，4表示目录，8表示普通文件，0表示未知设备。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">	<span class="keyword">if</span>(dirp-&gt;d_type == <span class="number">8</span>)  <span class="comment">// 只输出文件名，不输出目录名</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dirp-&gt;d_name &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>如果需要查找指定类型（特定后缀）的文件，可以使用<strong>C++11</strong>的正则表达式进行匹配：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include&lt;regex&gt;</span></span><br><span class="line"><span class="function">regex <span class="title">reg_obj</span><span class="params">(".*\.doc", regex::icase)</span></span>;</span><br><span class="line"><span class="keyword">while</span>((dirp = readdir(dp)) != NULL)</span><br><span class="line">	<span class="keyword">if</span>(regex_match(dirp-&gt;d_name, reg_obj))  <span class="comment">// regex_match()匹配</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dirp-&gt;d_name &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>另外，Unix/linux下提供了POSIX标准的正则库<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html" target="_blank" rel="external"> regex.h </a> 。</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Unix/Linux系统中，要获取一个指定目录下所有的文件或文件夹，一般用<code>dirent.h</code>（POSIX标准定义的目录操作头文件）。</p>
<h3 id="一、数据类型">一、数据类型</h3><p>在头文件<code>&lt;dirent.h&gt;</code>中定义了两种主要的数据类型。</p>
<p><strong>DIR</strong>：代表一个目录流的结构。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
</feed>