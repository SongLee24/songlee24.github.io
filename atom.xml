<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[神奕的博客]]></title>
  <subtitle><![CDATA[李松]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-05-23T02:42:16.659Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Song Lee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2015实习生求职季总结]]></title>
    <link href="http://yoursite.com/2015/05/23/intern-seeking-experience/"/>
    <id>http://yoursite.com/2015/05/23/intern-seeking-experience/</id>
    <published>2015-05-23T01:40:05.000Z</published>
    <updated>2015-05-23T02:42:16.659Z</updated>
    <content type="html"><![CDATA[<body><br>      <!-- BEGIN：嵌入Timeline --><br>      <div id="timeline-embed"></div><br>      <script type="text/javascript">var timeline_config = {width: “100%”,height: “100%”,source: ‘/json/data.json’}</script><br>      <script type="text/javascript" src="/javascript/js/storyjs-embed.js"></script><br>      <!-- END：嵌入Timeline --><br>  </body>]]></content>
    <summary type="html">
    <![CDATA[<body><br>      <!-- BEGIN：嵌入Timeline --><br>      <div id="timeline-embed"></div><br>      <script type="text/javascript">var timeline_conf]]>
    </summary>
    
      <category term="非技术-杂谈" scheme="http://yoursite.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF-%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求最长回文子串]]></title>
    <link href="http://yoursite.com/2015/05/12/longest-palindromic-substring/"/>
    <id>http://yoursite.com/2015/05/12/longest-palindromic-substring/</id>
    <published>2015-05-12T12:53:19.000Z</published>
    <updated>2015-05-12T13:11:43.312Z</updated>
    <content type="html"><![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。<a id="more"></a></p>
<h3 id="解法二：动态规划法$O(n^2)$">解法二：动态规划法$O(n^2)$</h3><p>动态规划法是在暴力解法上进行的优化。通过记录一些我们需要的东西，来避免暴力解法中很多重复的判断。</p>
<p>假设 $dp[i][j]$ 表示子串 $s[i…j]$ 是否是回文，那么对于动态规划表 $dp$ 的打表方式如下：</p>
<ul>
<li><p>初始化：<br>$$\begin{cases}<br>dp[i][i] = true  &amp; \text{(0 &lt;= i &lt;= n-1)}\\<br>dp[i][i-1] = true &amp; \text{(1 &lt;= i &lt;= n-1) }\\<br>others = fasle<br>\end{cases}$$</p>
</li>
<li><p>动态规划的状态转移方程：<br>$$<br>dp[i][j] =<br>\begin{cases}<br>dp[i+1][j-1], &amp; \text{if s[i] == s[j]} \\<br>false, &amp; \text{if s[i] ≠ s[j]}<br>\end{cases}<br>$$</p>
</li>
</ul>
<p>C++代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="comment">// 动态规划表，全部初始化为true</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=len; ++k) &#123;    <span class="comment">// 枚举子串的长度</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-k; ++i) &#123;  <span class="comment">// 枚举子串起始位置</span></span><br><span class="line">			<span class="keyword">int</span> j = i+k-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">				start = i;      <span class="comment">// 记录回文子串的起点和长度</span></span><br><span class="line">				maxlen = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解法三：中心扩展法$O(n^2)$">解法三：中心扩展法$O(n^2)$</h3><p>这个算法思想其实很简单，就是对给定的字符串S，分别以该字符串S中的每一个字符 c 为中心，向两边扩展，记录下以字符 c 为中心的回文子串的长度。时间复杂度为$O(n^2)$，空间复杂度仅为$O(1)$。</p>
<p>但有一点需要注意的是，回文的情况可能是 a b a，也可能是 a b b a。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别向左右扩展，返回扩展后的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right]) </span><br><span class="line">	&#123;</span><br><span class="line">		left--;</span><br><span class="line">		right++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substr(left+<span class="number">1</span>, right-left-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最长回文子串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.size();</span><br><span class="line">	<span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> longest;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> p1 = expand(s, i, i);  <span class="comment">// 奇数</span></span><br><span class="line">		<span class="keyword">if</span> (p1.size() &gt; longest.size())</span><br><span class="line">			longest = p1;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">string</span> p2 = expand(s, i, i+<span class="number">1</span>);  <span class="comment">// 偶数</span></span><br><span class="line">		<span class="keyword">if</span> (p2.size() &gt; longest.size())</span><br><span class="line">			longest = p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br>另外，据说还有一个很巧妙的算法，叫Manacher算法，可以在 $O(n)$ 的时间复杂度里求出最长回文子串。由于这个算法我没有研究过，在这里就不介绍了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>回文串</strong>，就是指正读和反读都一样的字符串，比如<code>&quot;level&quot;</code>或者<code>&quot;noon&quot;</code>等等。</p>
<p>那么，如何求一个字符串的<strong>最长回文子串（Longest Palindromic Substring）</strong>？这里我们有多种解法。</p>
<h3 id="解法一：暴力法">解法一：暴力法</h3><p>暴力解法就是直接枚举所有子串，对每个子串判断是否为回文，时间复杂度为$O(n^3)$。</p>
<p>这是最糟糕的方法，相信面试官问你这个问题，绝对不是想要这个答案。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计并实现一个LRU Cache]]></title>
    <link href="http://yoursite.com/2015/05/10/design-LRU-Cache/"/>
    <id>http://yoursite.com/2015/05/10/design-LRU-Cache/</id>
    <published>2015-05-10T12:33:13.000Z</published>
    <updated>2015-05-10T13:23:03.702Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。<a id="more"></a></p>
<h4 id="2_原理">2 原理</h4><p>Cache 技术所依赖的原理是”程序执行与数据访问的<strong>局部性原理</strong>“，这种局部性表现在两个方面：</p>
<ol>
<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令或数据通常是顺序存放的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到Cache中实现。空间局部性通常是使用较大的高速缓存，并将 预取机制 集成到高速缓存控制逻辑中来实现。</p>
<h4 id="3_替换策略">3 替换策略</h4><p>Cache的容量是有限的，当Cache的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。常用的替换策略有以下几种：</p>
<ol>
<li><p><strong>随机算法（Rand）</strong>：随机法是随机地确定替换的存储块。设置一个随机数产生器，依据所产生的随机数，确定替换块。这种方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p><strong>先进先出算法（FIFO, First In First Out）</strong>：先进先出法是选择那个最先调入的那个块进行替换。当最先调入并被多次命中的块，很可能被优先替换，因而不符合局部性规律。这种方法的命中率比随机法好些，但还不满足要求。</p>
</li>
<li><p><strong>最久未使用算法（LRU, Least Recently Used）</strong>：LRU法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。</p>
</li>
<li><p><strong>最不经常使用算法（LFU, Least Frequently Used）</strong>：将最近一段时期内，访问次数最少的块替换出Cache。</p>
</li>
</ol>
<h4 id="4_概念的扩充">4 概念的扩充</h4><p>如今高速缓存的概念已被扩充，不仅在CPU和主内存之间有Cache，而且在内存和硬盘之间也有Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的Cache──称为Internet临时文件夹或网络内容缓存等。<strong>凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。</strong></p>
<p><br></p>
<h3 id="二、LRU_Cache的实现">二、LRU Cache的实现</h3><p><strong>Google的一道面试题：</strong></p>
<p>Design an LRU cache with all the operations to be done in $O(1)$ .</p>
<h4 id="1_思路分析">1 思路分析</h4><p>对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。</p>
<p>为了能够快速删除最久没有访问的数据项和插入最新的数据项，我们使用 <strong>双向链表</strong> 连接Cache中的数据项，并且保证链表维持数据项从最近访问到最旧访问的顺序。</p>
<ul>
<li><p><strong>插入</strong>：当Cache未满时，新的数据项只需插到双链表头部即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>替换</strong>：当Cache已满时，将新的数据项插到双链表头部，并删除双链表的尾结点即可。时间复杂度为$O(1)$.</p>
</li>
<li><p><strong>查找</strong>：每次数据项被查询到时，都将此数据项移动到链表头部。</p>
</li>
</ul>
<p>经过分析，我们知道使用双向链表可以保证插入和替换的时间复杂度是$O(1)$，但查询的时间复杂度是$O(n)$，因为需要对双链表进行遍历。为了让查找效率也达到$O(1)$，很自然的会想到使用 <strong>hash table</strong> 。</p>
<h4 id="2_代码实现">2 代码实现</h4><p>从上述分析可知，我们需要使用两种数据结构：</p>
<ol>
<li><strong>双向链表（Doubly Linked List）</strong></li>
<li><strong>哈希表（Hash Table）</strong></li>
</ol>
<p>下面是LRU Cache的 C++ 实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的节点结构</span></span><br><span class="line"><span class="keyword">struct</span> LRUCacheNode &#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	LRUCacheNode* prev;</span><br><span class="line">	LRUCacheNode* next;</span><br><span class="line">	LRUCacheNode():key(<span class="number">0</span>),value(<span class="number">0</span>),prev(NULL),next(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LRUCache</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, LRUCacheNode*&gt; m;  <span class="comment">// 代替hash_map</span></span><br><span class="line">	LRUCacheNode* head;     <span class="comment">// 指向双链表的头结点</span></span><br><span class="line">	LRUCacheNode* tail;     <span class="comment">// 指向双链表的尾结点</span></span><br><span class="line">	<span class="keyword">int</span> capacity;           <span class="comment">// Cache的容量</span></span><br><span class="line">	<span class="keyword">int</span> count;              <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> capacity);       <span class="comment">// 构造函数</span></span><br><span class="line">	~LRUCache();                  <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;             <span class="comment">// 查询数据项</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>; <span class="comment">// 未满时插入,已满时替换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeLRUNode</span><span class="params">()</span></span>;                 <span class="comment">// 删除尾结点（最久未使用）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">detachNode</span><span class="params">(LRUCacheNode* node)</span></span>;    <span class="comment">// 分离当前结点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertToFront</span><span class="params">(LRUCacheNode* node)</span></span>; <span class="comment">// 节点插入到头部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LRUCache::LRUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	<span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">	head = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	tail = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">	head-&gt;prev = NULL;</span><br><span class="line">	head-&gt;next = tail;</span><br><span class="line">	tail-&gt;prev = head;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~LRUCache()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">	<span class="keyword">delete</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LRUCache::get(<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);      <span class="comment">// 命中，移至头部 </span></span><br><span class="line">		insertToFront(node);</span><br><span class="line">		<span class="keyword">return</span> node-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::<span class="built_in">set</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.find(key) == m.end())  <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = <span class="keyword">new</span> LRUCacheNode;</span><br><span class="line">		<span class="keyword">if</span>(count == capacity)   <span class="comment">// Cache已满</span></span><br><span class="line">			removeLRUNode();</span><br><span class="line"></span><br><span class="line">		node-&gt;key = key;</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		m[key] = node;          <span class="comment">// 插入哈希表</span></span><br><span class="line">		insertToFront(node);    <span class="comment">// 插入链表头部</span></span><br><span class="line">		++count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LRUCacheNode* node = m[key];</span><br><span class="line">		detachNode(node);</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line">		insertToFront(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::removeLRUNode()</span><br><span class="line">&#123;</span><br><span class="line">	LRUCacheNode* node = tail-&gt;prev;</span><br><span class="line">	detachNode(node);</span><br><span class="line">	m.erase(node-&gt;key);</span><br><span class="line">	--count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::detachNode(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">	node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUCache::insertToFront(LRUCacheNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;next = head-&gt;next;</span><br><span class="line">	node-&gt;prev = head;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">	node-&gt;next-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是Cache">一、什么是Cache</h3><h4 id="1_概念">1 概念</h4><p><strong>Cache</strong>，即<strong>高速缓存</strong>，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。</p>
<p>当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。</p>
<ul>
<li>如果存在（命中），则直接返回该数据；</li>
<li>如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。</li>
</ul>
<p>提供“高速缓存”的<strong>目的</strong>是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trie树|前缀树的介绍与实现]]></title>
    <link href="http://yoursite.com/2015/05/09/prefix-tree/"/>
    <id>http://yoursite.com/2015/05/09/prefix-tree/</id>
    <published>2015-05-09T12:17:12.000Z</published>
    <updated>2015-05-10T12:30:30.917Z</updated>
    <content type="html"><![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center><a id="more"></a></p>
<p>上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li>
<li>从根节点到<strong>某一个节点</strong>，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符互不相同。</li>
</ol>
<p>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p>
<p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做<strong>前缀树（Prefix Tree）</strong>。</p>
<p><br></p>
<h1 id="二、Trie树的优缺点">二、Trie树的优缺点</h1><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p>
<h2 id="优点">优点</h2><ol>
<li><p>插入和查询的效率很高，都为$O(m)$，其中 $m$ 是待插入/查询的字符串的长度。</p>
<ul>
<li>关于查询，会有人说 hash 表时间复杂度是$O(1)$不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。</li>
</ul>
</li>
<li><p>Trie树中不同的关键字不会产生冲突。</p>
</li>
<li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p>
</li>
<li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p>
</li>
<li><p>Trie树可以对关键字按<strong>字典序</strong>排序。</p>
</li>
</ol>
<h2 id="缺点">缺点</h2><ol>
<li><p>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</p>
</li>
<li><p>空间消耗比较大。</p>
</li>
</ol>
<p><br></p>
<h1 id="三、Trie树的应用">三、Trie树的应用</h1><h2 id="1、字符串检索">1、字符串检索</h2><p>检索/查询功能是Trie树最原始的功能。<strong>思路</strong>就是从根节点开始一个一个字符进行比较：</p>
<ul>
<li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li>
<li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、词频统计">2、词频统计</h2><p>Trie树常被搜索引擎系统用于文本词频统计    。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量<code>count</code>来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后<code>count</code>置1。</p>
<p><strong>注意：第一、第二种应用也都可以用 hash table 来做。</strong></p>
<h2 id="3、字符串排序">3、字符串排序</h2><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p>
<h2 id="4、前缀匹配">4、前缀匹配</h2><p>例如：找出一个字符串集合中所有以<code>ab</code>开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以<code>a-&gt;b-&gt;</code>开头的路径上的关键字即可。</p>
<p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h2 id="5、作为其他数据结构和算法的辅助结构">5、作为其他数据结构和算法的辅助结构</h2><p>如后缀树，AC自动机等。</p>
<p><br></p>
<h1 id="四、Trie树的实现">四、Trie树的实现</h1><p>这里为了方便，我们假设所有的关键字都由 a-z 的字母组成。下面是 trie 树的一种典型实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ALPHABET_SIZE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> trie_node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">	trie_node *children[ALPHABET_SIZE]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;*trie;</span><br><span class="line"></span><br><span class="line">trie_node* create_trie_node()</span><br><span class="line">&#123;</span><br><span class="line">	trie_node* pNode = <span class="keyword">new</span> trie_node();</span><br><span class="line">	pNode-&gt;count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ALPHABET_SIZE; ++i)</span><br><span class="line">		pNode-&gt;children[i] = NULL;</span><br><span class="line">	<span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trie_insert</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;children[*p-<span class="string">'a'</span>] == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;children[*p-<span class="string">'a'</span>] = create_trie_node();</span><br><span class="line">		&#125;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 查询：不存在返回0，存在返回出现的次数</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trie_search</span><span class="params">(trie root, <span class="keyword">char</span>* key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	trie_node* node = root;</span><br><span class="line">	<span class="keyword">char</span>* p = key;</span><br><span class="line">	<span class="keyword">while</span>(*p &amp;&amp; node!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node = node-&gt;children[*p-<span class="string">'a'</span>];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(node == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 关键字集合</span></span><br><span class="line">	<span class="keyword">char</span> keys[][<span class="number">8</span>] = &#123;<span class="string">"the"</span>, <span class="string">"a"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>, <span class="string">"any"</span>, <span class="string">"by"</span>, <span class="string">"bye"</span>, <span class="string">"their"</span>&#125;;</span><br><span class="line">	trie root = create_trie_node();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建trie树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		trie_insert(root, keys[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检索字符串</span></span><br><span class="line">	<span class="keyword">char</span> s[][<span class="number">32</span>] = &#123;<span class="string">"Present in trie"</span>, <span class="string">"Not present in trie"</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"the"</span>, trie_search(root, <span class="string">"the"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"these"</span>, trie_search(root, <span class="string">"these"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"their"</span>, trie_search(root, <span class="string">"their"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s --- %s\n"</span>, <span class="string">"thaw"</span>, trie_search(root, <span class="string">"thaw"</span>)&gt;<span class="number">0</span>?s[<span class="number">0</span>]:s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于Trie树，我们一般只需要插入和搜索操作。上面这段代码实现了一棵Trie树，该Trie树可以用来检索单词和统计词频。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文尝试用尽量简洁的语言介绍一种树形数据结构 —— Trie树。</p>
<h1 id="一、什么是Trie树">一、什么是Trie树</h1><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p>
<p><center><br><img src="http://img.blog.csdn.net/20150509003807271" alt=""><br></center>]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑排序（Topological Sorting）]]></title>
    <link href="http://yoursite.com/2015/05/07/topological-sorting/"/>
    <id>http://yoursite.com/2015/05/07/topological-sorting/</id>
    <published>2015-05-07T15:23:52.000Z</published>
    <updated>2015-05-10T12:13:59.727Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。<a id="more"></a></p>
<p>例如，下面这个图：</p>
<center><br><img src="http://img.blog.csdn.net/20150507001028284" alt=""><br></center>

<p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环。</li>
</ol>
<center><br><img src="http://img.blog.csdn.net/20150507001759702" alt=""><br></center>

<p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p>
<p>通常，一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</p>
<p><br></p>
<h3 id="二、拓扑排序的应用">二、拓扑排序的应用</h3><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p>
<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 <a, b=""> 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</a,></p>
<p><br></p>
<h3 id="三、拓扑排序的实现">三、拓扑排序的实现</h3><p>根据上面讲的方法，我们关键是要<strong>维护一个入度为0的顶点的集合</strong>。</p>
<p>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用<strong>邻接表</strong>来存储图，C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类声明************************/</span></span><br><span class="line"><span class="keyword">class</span> Graph</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> V;             <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;    <span class="comment">// 邻接表</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;      <span class="comment">// 维护一个入度为0的顶点的集合</span></span><br><span class="line">	<span class="keyword">int</span>* indegree;     <span class="comment">// 记录每个顶点的入度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);                   <span class="comment">// 构造函数</span></span><br><span class="line">	~Graph();                       <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;     <span class="comment">// 添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">topological_sort</span><span class="params">()</span></span>;        <span class="comment">// 拓扑排序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类定义************************/</span></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line"></span><br><span class="line">	indegree = <span class="keyword">new</span> <span class="keyword">int</span>[V];  <span class="comment">// 入度全部初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		indegree[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph::~Graph()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] adj;</span><br><span class="line">	<span class="keyword">delete</span> [] indegree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w); </span><br><span class="line">	++indegree[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Graph::topological_sort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">		<span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">			q.push(i);         <span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;             <span class="comment">// 计数，记录当前已经输出的顶点数 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = q.front();      <span class="comment">// 从队列中取出一个顶点</span></span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;      <span class="comment">// 输出该顶点</span></span><br><span class="line">		++count;</span><br><span class="line">		<span class="comment">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class="line">		<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator beg = adj[v].begin();</span><br><span class="line">		<span class="keyword">for</span>( ; beg!=adj[v].end(); ++beg)</span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[*beg]))</span><br><span class="line">				q.push(*beg);   <span class="comment">// 若入度为0，则入栈</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(count &lt; V)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;           <span class="comment">// 没有输出全部顶点，有向图中有回路</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;            <span class="comment">// 拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下DAG图：</p>
<p><img src="http://img.blog.csdn.net/20150507013500102" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(6)</span></span>;   <span class="comment">// 创建图</span></span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	g.topological_sort();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>
<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的<code>queue</code>。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为$O(V+E)$。</p>
<p><br><br><br><br><br><br><br><br><br>另外，拓扑排序还可以采用 <a href="http://songlee24.github.io/2014/07/04/depth-first-search/" target="_blank" rel="external">深度优先搜索（DFS）</a>的思想来实现，详见《<a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank" rel="external">topological sorting via DFS</a>》。</p>
<p><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是拓扑排序">一、什么是拓扑排序</h3><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解公钥与私钥]]></title>
    <link href="http://yoursite.com/2015/05/03/public-key-and-private-key/"/>
    <id>http://yoursite.com/2015/05/03/public-key-and-private-key/</id>
    <published>2015-05-03T05:05:36.000Z</published>
    <updated>2015-05-10T12:08:33.440Z</updated>
    <content type="html"><![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="external">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/" target="_blank" rel="external">AES加密算法</a>》。<a id="more"></a></p>
<p><strong>2、公钥算法</strong></p>
<p><strong>公钥加密算法</strong>，也就是 <strong>非对称加密算法</strong>，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥：</p>
<ul>
<li>公钥和私钥成对出现</li>
<li>公开的密钥叫公钥，只有自己知道的叫私钥</li>
<li>用公钥加密的数据只有对应的私钥可以解密</li>
<li>用私钥加密的数据只有对应的公钥可以解密</li>
<li>如果可以用公钥解密，则必然是对应的私钥加的密</li>
<li>如果可以用私钥解密，则必然是对应的公钥加的密</li>
</ul>
<p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p>
<p><br></p>
<h3 id="二、实现数据的安全传输">二、实现数据的安全传输</h3><p>要实现数据的安全传输，当然就要对数据进行加密了。</p>
<p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用<strong>非对称算法</strong>，过程如下：</p>
<ol>
<li>首先 接收方 生成一对密钥，即私钥和公钥；</li>
<li>然后，接收方 将公钥发送给 发送方；</li>
<li>发送方用收到的公钥对数据加密，再发送给接收方；</li>
<li>接收方收到数据后，使用自己的私钥解密。</li>
</ol>
<p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p>
<p><img src="http://img.blog.csdn.net/20150502122610368" alt=""></p>
<p><br></p>
<h3 id="三、对信息进行数字签名">三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常<strong>“数字签名”</strong>是用来验证发送方的身份并帮助保护数据的完整性。</p>
<p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p>
<ol>
<li>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</li>
<li>保证信息自签发后到收到为止未曾作过任何修改。</li>
</ol>
<p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p>
<p><br></p>
<h3 id="四、公钥算法的缺点">四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是<strong>效率非常低</strong>，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p>
<ol>
<li>首先，发送方使用对称算法对原始信息进行加密。</li>
<li>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</li>
<li>接收方 将公钥发送给 发送方。</li>
<li>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</li>
<li>接收方用私钥进行解密得到对称算法的密钥。</li>
<li>发送方再把已加密的原始信息发送给接收方。</li>
<li>接收方使用对称算法的密钥进行解密。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150502122733376" alt=""></p>
<p><br><br><br><br><br><strong>总结：</strong></p>
<ol>
<li><p>每个用户都有一对私钥和公钥。  </p>
<ul>
<li>私钥用来进行解密和签名，是给自己用的。</li>
<li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li>
</ul>
</li>
<li><p>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。  </p>
</li>
<li><p>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。</p>
</li>
</ol>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
<p>图片来源：www.cnblogs.com/chnking/archive/2007/08/30/875947.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直都对公钥和私钥的概念不清不楚，以至于在 腾讯面试 被问到“如何在一个不安全的环境中实现安全的数据通信？”时，并没有答上来。今天查阅了一些资料，决定写一篇总结文章来加深自己的理解。</p>
<h3 id="一、公钥算法与私钥算法">一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/">AES加密算法</a>》。]]>
    
    </summary>
    
      <category term="Basic-信息安全" scheme="http://yoursite.com/categories/Basic-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字节序：Big Endian 和 Little Endian]]></title>
    <link href="http://yoursite.com/2015/05/02/endianess/"/>
    <id>http://yoursite.com/2015/05/02/endianess/</id>
    <published>2015-05-02T04:56:43.000Z</published>
    <updated>2015-05-10T12:03:45.446Z</updated>
    <content type="html"><![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：<a id="more"></a></p>
<ul>
<li><p>Motorola 6800，PowerPC 970，SPARC（除V9外）等处理器采用 Big Endian方式存储数据；</p>
</li>
<li><p>x86系列，VAX，PDP-11等处理器采用Little Endian方式存储数据。</p>
</li>
</ul>
<p>另外，还有一些处理器像ARM, DEC Alpha的字节序是可配置的。</p>
<p><br></p>
<h3 id="二、大端与小端">二、大端与小端</h3><p>那么，到底什么是大端，什么是小端？ 如下图：</p>
<center><br><img src="http://img.blog.csdn.net/20150501200116979" alt=""><br></center>

<p>我相信上面的图已经够直观了。也就是说：</p>
<ul>
<li>Big Endian 是指低地址端 存放 高位字节。</li>
<li>Little Endian 是指低地址端 存放 低位字节。</li>
</ul>
<p><strong>各自的优势：</strong></p>
<ol>
<li>Big Endian：符号位的判定固定为第一个字节，容易判断正负。</li>
<li>Little Endian：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。</li>
</ol>
<p><br></p>
<h3 id="三、为什么要注意字节序">三、为什么要注意字节序</h3><p>如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。</p>
<p>但是，如果你的程序要跟别人的程序产生交互呢？ 比如，当一个 C/C++ 的程序要与一个 Java 程序交互时：</p>
<ul>
<li><p>C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的 x86 处理器是 Little Endian</p>
</li>
<li><p>JAVA编写的程序则唯一采用 Big Endian 方式来存储数据</p>
</li>
</ul>
<p>试想，如果你的C/C++程序将变量 <code>a = 0x12345678</code> 的首地址传递给了Java程序，由于Java采取 Big Endian 方式存储数据，很自然的它会将你的数据翻译为 <code>0x78563412</code>。显然，问题就出现了！！！</p>
<p>另外，网络传输一般采用 Big Endian，也被称之为<strong>网络字节序</strong>，或<strong>网络序</strong>。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。</p>
<p><br></p>
<h3 id="四、判断机器的字节序">四、判断机器的字节序</h3><p>由于 C/C++ 存储数据时的字节序依赖所在平台的CPU，所以我们可以通过C/C++程序判定机器的端序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Endianness</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span>( *((<span class="keyword">char</span>*)&amp;a) == <span class="number">0x12</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Big Endian"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Little Endian"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="五、网络序和主机序">五、网络序和主机序</h3><p><strong>网络字节序</strong>：TCP/IP各层协议将字节序定义为 Big Endian，因此TCP/IP协议中使用的字节序是大端序。</p>
<p><strong>主机字节序</strong>：整数在内存中存储的顺序，现在 Little Endian 比较普遍。（不同的 CPU 有不同的字节序）</p>
<p>在进行网络通信时 通常需要调用相应的函数进行主机序和网络序的转换。Berkeley socket API 定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、字节序">一、字节序</h3><p><strong>字节序</strong>，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如：如果C/C++中的一个<code>int</code>型变量  a 的起始地址是<code>&amp;a = 0x100</code>，那么 a 的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。</p>
<p>根据整数 a 在连续的 4 byte 内存中的存储顺序，字节序被分为<strong>大端序（Big Endian）</strong> 与 <strong>小端序（Little Endian）</strong>两类。 然后就牵涉出两大CPU派系：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】三个经典同步问题]]></title>
    <link href="http://yoursite.com/2015/04/30/linux-three-syn-problems/"/>
    <id>http://yoursite.com/2015/04/30/linux-three-syn-problems/</id>
    <published>2015-04-30T13:37:46.000Z</published>
    <updated>2015-05-10T11:58:29.924Z</updated>
    <content type="html"><![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/" target="_blank" rel="external">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。<a id="more"></a></p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。</p>
</li>
<li><p>整理思路：这里比较简单，只有生产者和消费者两个进程，且这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步的PV操作的位置。</p>
</li>
<li><p>信号量设置：信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量<code>full</code>用于记录当前缓冲池中“满”缓冲区数，初值为 0；信号量<code>empty</code>用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
</li>
</ol>
<p><strong>代码示例：</strong>（semaphore类的封装见下文）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;           <span class="comment">// 临界区互斥信号量</span></span><br><span class="line"><span class="function">semaphore <span class="title">empty</span><span class="params">("/home", N)</span></span>;       <span class="comment">// 记录空缓冲区数，初值为N</span></span><br><span class="line"><span class="function">semaphore <span class="title">full</span><span class="params">("/home/songlee",0)</span></span>; <span class="comment">// 记录满缓冲区数，初值为0</span></span><br><span class="line"><span class="keyword">int</span> buffer[N];                     <span class="comment">// 缓冲区，大小为N</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* producer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	empty.P();                 <span class="comment">// empty减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	buffer[i] = <span class="number">10</span> + rand() % <span class="number">90</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Producer %d write Buffer[%d]: %d\n"</span>,arg,i+<span class="number">1</span>,buffer[i]);</span><br><span class="line">	i = (i+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	full.V();                  <span class="comment">// full加1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* consumer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	full.P();                  <span class="comment">// full减1</span></span><br><span class="line">	mutex.P();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"                               \033[1;31m"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Consumer %d read Buffer[%d]: %d\n"</span>,arg,j+<span class="number">1</span>,buffer[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\033[0m"</span>);</span><br><span class="line">	j = (j+<span class="number">1</span>) % N;</span><br><span class="line"></span><br><span class="line">	mutex.V();</span><br><span class="line">	empty.V();                 <span class="comment">// empty加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开10个生产者线程，10个消费者线程</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, producer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; ++k)</span><br><span class="line">		pthread_create(&amp;id[k], NULL, consumer, (<span class="keyword">void</span>*)(k+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行输出结果：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Producer <span class="number">1</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">2</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">Producer <span class="number">3</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">Producer <span class="number">5</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">4</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">1</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">83</span></span><br><span class="line">Producer <span class="number">6</span> <span class="command">write</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">2</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">26</span></span><br><span class="line">                               Consumer <span class="number">3</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">37</span></span><br><span class="line">                               Consumer <span class="number">4</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">35</span></span><br><span class="line">                               Consumer <span class="number">5</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">33</span></span><br><span class="line">                               Consumer <span class="number">6</span> <span class="command">read</span> Buffer[<span class="number">1</span>]: <span class="number">35</span></span><br><span class="line">Producer <span class="number">7</span> <span class="command">write</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">Producer <span class="number">8</span> <span class="command">write</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">10</span> <span class="command">write</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">9</span> <span class="command">read</span> Buffer[<span class="number">2</span>]: <span class="number">56</span></span><br><span class="line">                               Consumer <span class="number">10</span> <span class="command">read</span> Buffer[<span class="number">3</span>]: <span class="number">22</span></span><br><span class="line">Producer <span class="number">9</span> <span class="command">write</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br><span class="line">                               Consumer <span class="number">7</span> <span class="command">read</span> Buffer[<span class="number">4</span>]: <span class="number">79</span></span><br><span class="line">                               Consumer <span class="number">8</span> <span class="command">read</span> Buffer[<span class="number">5</span>]: <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、读者-写者问题">二、读者-写者问题</h3><p><strong>问题描述：</strong></p>
<p>有读者和写者两组并发线程，共享一个文件，当两个或以上的读线程同时访问共享数据时不会产生副作用，但若某个写线程和其他线程（读线程或写线程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：由题目分析可知，读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
</li>
<li><p>整理思路：写者是比较简单的，它与任何线程互斥，用互斥信号量的 PV 操作即可解决。读者的问题比较复杂，它必须实现与写者的互斥，多个读者还可以同时读。所以，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时，不同的读者对计数器的访问也应该是互斥的。</p>
</li>
<li><p>信号量设置：首先设置一个计数器<code>count</code>，用来记录当前的读者数量，初值为0；设置互斥信号量<code>mutex</code>，用于保护更新 count 变量时的互斥；设置互斥信号量<code>rw</code>用于保证读者和写者的互斥访问。</p>
</li>
</ol>
<p><strong>代码示例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;           <span class="comment">// 记录当前的读者数量</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/",1)</span></span>;  <span class="comment">// 用于保护更新count变量时的互斥</span></span><br><span class="line"><span class="function">semaphore <span class="title">rw</span><span class="params">("/home",1)</span></span>; <span class="comment">// 用于保证读者和写者的互斥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* writer(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	rw.P();              <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d start writing...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  Writer %d finish writing...\n"</span>, arg);</span><br><span class="line">	</span><br><span class="line">	rw.V();              <span class="comment">// 释放共享文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* reader(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当第一个读线程读文件时</span></span><br><span class="line">		rw.P();          <span class="comment">// 阻止写线程写</span></span><br><span class="line">	++count;             <span class="comment">// 读者计数器加1</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d start reading...\n"</span>, arg);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reader %d finish reading...\n"</span>, arg);</span><br><span class="line"></span><br><span class="line">	mutex.P();           <span class="comment">// 互斥访问count变量</span></span><br><span class="line">	--count;             <span class="comment">// 读者计数器减1</span></span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)       <span class="comment">// 当最后一个读线程读完文件</span></span><br><span class="line">		rw.V();          <span class="comment">// 允许写线程写</span></span><br><span class="line">	mutex.V();           <span class="comment">// 释放count变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pthread_t id[<span class="number">8</span>];     <span class="comment">// 开6个读线程，2个写线程</span></span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">2</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">3</span>], NULL, writer, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;id[<span class="number">4</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">3</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">5</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">4</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">6</span>], NULL, reader, (<span class="keyword">void</span>*)<span class="number">5</span>);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">7</span>], NULL ,reader, (<span class="keyword">void</span>*)<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Reader</span> <span class="number">2</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">1</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">2</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">3</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">4</span> finish reading...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">1</span> finish writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> start writing...</span><br><span class="line">  <span class="variable">Writer</span> <span class="number">2</span> finish writing...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> start reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">5</span> finish reading...</span><br><span class="line"><span class="variable">Reader</span> <span class="number">6</span> finish reading...</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、哲学家进餐问题">三、哲学家进餐问题</h3><p><strong>问题描述：</strong></p>
<p>一张圆桌上坐着 5 名哲学家，桌子上每两个哲学家之间摆了<strong>一根</strong>筷子，桌子的中间是一碗米饭，如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150430145440864" alt=""></p>
<p>哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><strong>分析：</strong></p>
<ol>
<li><p>关系分析：5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li><p>整理思路：显然这里有 5 个线程，那么要如何让一个哲学家拿到左右两个筷子而不造成死锁或饥饿现象？解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或死锁现象的发生。</p>
</li>
<li><p>信号量设置：定义互斥信号量数组<code>chopstick[5] = {1,1,1,1,1}</code>用于对 5 根筷子的互斥访问。</p>
</li>
</ol>
<p><strong>示例代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;  <span class="comment">// 信号量数组</span></span><br><span class="line">Pi()                                  <span class="comment">// i号哲学家的线程</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		P(chopstick[i]);              <span class="comment">// 取左边筷子</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 取右边筷子</span></span><br><span class="line">		eat;                          <span class="comment">// 进餐</span></span><br><span class="line">		V(chopstick[i]);              <span class="comment">// 放回左边筷子</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);        <span class="comment">// 放回右边筷子</span></span><br><span class="line">		think;                        <span class="comment">// 思考</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的伪代码存在一个问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完<code>P(chopstick[i])</code>），筷子已经被拿光了，等到他们再想拿右边的筷子的时候，就全被阻塞了，这就出现了死锁。</p>
<p>为了防止死锁的发生，可以对哲学家线程施加一些限制条件，比如：</p>
<ul>
<li>至多允许四个哲学家同时进餐；</li>
<li>仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子；</li>
<li>对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再抓他右边的筷子，而偶数号哲学家刚好相反。</li>
</ul>
<p>这里，我们采用第二种方法来改进上面的算法，即当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;  <span class="comment">// sleep</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;semaphore*&gt; chopstick;   <span class="comment">// 信号量数组</span></span><br><span class="line"><span class="function">semaphore <span class="title">mutex</span><span class="params">("/", 1)</span></span>;  <span class="comment">// 设置取左右筷子的信号量 &lt;-- 关键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P1(<span class="keyword">void</span>* arg)  <span class="comment">// 第1个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 1 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P2(<span class="keyword">void</span>* arg)  <span class="comment">// 第2个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 2 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">1</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P3(<span class="keyword">void</span>* arg)  <span class="comment">// 第3个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 3 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">2</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P4(<span class="keyword">void</span>* arg)  <span class="comment">// 第4个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 4 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">3</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* P5(<span class="keyword">void</span>* arg)  <span class="comment">// 第5个哲学家线程</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex.P();                 <span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;P();         <span class="comment">// 取左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;P();         <span class="comment">// 取右边筷子</span></span><br><span class="line">	mutex.V();                 <span class="comment">// 释放取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Philosopher 5 eat.\n"</span>);</span><br><span class="line"></span><br><span class="line">	chopstick[<span class="number">4</span>]-&gt;V();          <span class="comment">// 放回左边筷子</span></span><br><span class="line">	chopstick[<span class="number">0</span>]-&gt;V();          <span class="comment">// 放回右边筷子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	semaphore *sem1 = <span class="keyword">new</span> semaphore(<span class="string">"/home"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem2 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem3 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/java"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem4 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/ADT"</span>, <span class="number">1</span>);</span><br><span class="line">	semaphore *sem5 = <span class="keyword">new</span> semaphore(<span class="string">"/home/songlee/Test"</span>, <span class="number">1</span>);</span><br><span class="line">	chopstick.push_back(sem1);</span><br><span class="line">	chopstick.push_back(sem2);</span><br><span class="line">	chopstick.push_back(sem3);</span><br><span class="line">	chopstick.push_back(sem4);</span><br><span class="line">	chopstick.push_back(sem5);</span><br><span class="line"></span><br><span class="line">	pthread_t id;</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;id, NULL, P1, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P2, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P3, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P4, NULL);</span><br><span class="line">	pthread_create(&amp;id, NULL, P5, NULL);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">delete</span> sem1;</span><br><span class="line">	<span class="keyword">delete</span> sem2;</span><br><span class="line">	<span class="keyword">delete</span> sem3;</span><br><span class="line">	<span class="keyword">delete</span> sem4;</span><br><span class="line">	<span class="keyword">delete</span> sem5;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行的结果如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Philosopher</span> <span class="number">2</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">1</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">3</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">4</span> eat.</span><br><span class="line"><span class="variable">Philosopher</span> <span class="number">5</span> eat.</span><br></pre></td></tr></table></figure></p>
<p>注意：创建信号量时的 路径参数 请改成你的系统中存在的路径！！！</p>
<p><br><br><br><br></p>
<h3 id="附：semaphore类的封装">附：semaphore类的封装</h3><p>上面的代码中都使用了这个<code>semaphore</code>类，实现如下：</p>
<ul>
<li><strong>semaphore.h</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> semaphore &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	semaphore(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>); <span class="comment">/*构造函数*/</span></span><br><span class="line">	~semaphore();                <span class="comment">/*析构函数*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>;                    <span class="comment">/*P操作*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>;                    <span class="comment">/*V操作*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>semaphore.cpp</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.h"</span></span><br><span class="line"></span><br><span class="line">semaphore::semaphore(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">semaphore::~semaphore()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::P()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> semaphore::V()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">int</span> semaphore::init_sem(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，要创建不同的信号量，必须传递不同的路径参数（这样获取的 key 值才会不一样）。</p>
<p>注意，本文的关注点并不在于 linux 下如何创建信号量以及如何封装起来才更方便，而是通过几个经典的同步实例，了解在多线程环境下如何解决这类线程同步问题。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在了解了《<a href="http://songlee24.github.io/blog/2015/04/29/syn-mut-differ/">同步与互斥的区别 </a>》之后，我们来看看几个经典的线程同步的例子。相信通过具体场景可以让我们学会分析和解决这类线程同步的问题，以便以后应用在实际的项目中。</p>
<h3 id="一、生产者-消费者问题">一、生产者-消费者问题</h3><p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux多线程】同步与互斥的区别]]></title>
    <link href="http://yoursite.com/2015/04/29/linux-syn-mut-difference/"/>
    <id>http://yoursite.com/2015/04/29/linux-syn-mut-difference/</id>
    <published>2015-04-29T15:45:11.000Z</published>
    <updated>2015-05-10T11:56:23.819Z</updated>
    <content type="html"><![CDATA[<p>同步与互斥这两个概念经常被混淆，所以在这里说一下它们的区别。</p>
<h3 id="一、同步与互斥的区别">一、同步与互斥的区别</h3><h4 id="1-_同步">1. 同步</h4><p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。</p>
<p>例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;   <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">T1() &#123;</span><br><span class="line">	...</span><br><span class="line">	x;           <span class="comment">// 语句x</span></span><br><span class="line">	V(S);        <span class="comment">// 告诉线程T2，语句x已经完成</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);        <span class="comment">// 检查语句x是否运行完成</span></span><br><span class="line">	y;           <span class="comment">// 检查无误，运行y语句</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-_互斥">2. 互斥</h4><p><strong>互斥</strong>，又称<strong>间接制约关系</strong>，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。</p>
<p>例如，打印机就是一种临界资源，而访问打印机的代码片段称为临界区，故每次只允许一个线程进入临界区。—— 我们同样可以使用信号量解决互斥问题，只需把临界区置于 P(S) 和 V(S) 之间，即可实现两线程对临界资源的互斥访问。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">1</span>;   <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">T1() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	线程T1的临界区;  <span class="comment">// 访问临界资源</span></span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	线程T2的临界区;  <span class="comment">// 访问临界资源</span></span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、一个同步的例子">二、一个同步的例子</h3><p>如下图，为了求出 1 到 n 的平均值，需要三个线程协调它们的工作次序来完成，这就是同步：</p>
<p><img src="http://img.blog.csdn.net/20150429225128423" alt=""></p>
<p>为了使多个线程按顺序正确执行，应设置若干个初始值为 0 的信号量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;pthread.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>"semaphore.hpp"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sem1, sem2;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;  <span class="comment">/*1...n的平均值*/</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> average = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* t1(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		sum += i;</span><br><span class="line">	sem_v(sem1);  <span class="comment">/*V操作，通知t2求和已完成*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* t2(<span class="keyword">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	sem_p(sem1);  <span class="comment">/*P操作，等待t1完成*/</span>	</span><br><span class="line">	average = (<span class="keyword">double</span>)sum/n;</span><br><span class="line">	sem_v(sem2);  <span class="comment">/*V操作，通知main求平均已完成*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	sem1 = creat_sem(<span class="string">"/"</span> , <span class="number">0</span>); <span class="comment">/*创建信号量*/</span></span><br><span class="line">	sem2 = creat_sem(<span class="string">"/home"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	pthread_t id[<span class="number">2</span>];</span><br><span class="line">	pthread_create(&amp;id[<span class="number">0</span>], NULL, t1, NULL);</span><br><span class="line">	pthread_create(&amp;id[<span class="number">1</span>], NULL, t2, NULL);</span><br><span class="line"></span><br><span class="line">	sem_p(sem2);  <span class="comment">/*P操作，等待t2完成*/</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is: "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The average is: "</span> &lt;&lt; average &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	del_sem(sem1); <span class="comment">/*删除信号量*/</span></span><br><span class="line">	del_sem(sem2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是信号量的相关函数，详见《<a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">信号量</a>》。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semaphore.hpp</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建信号量，返回其ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">/*信号量集ID*/</span></span><br><span class="line">	key_t key;</span><br><span class="line">    <span class="comment">/*获取key值*/</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(path, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建信号量集，其中只有一个信号量*/</span></span><br><span class="line">    <span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	init_sem(sem_id, value);</span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程 t2 需要等待线程 t1 （求和）完成以后才能够执行；主线程 main 需要等待线程 t2 （求平均）完成以后才能够执行输出。编译运行结果如下：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -lpthread -o <span class="keyword">synchronized</span> <span class="keyword">synchronized</span>.cpp </span><br><span class="line">$ ./<span class="keyword">synchronized</span> </span><br><span class="line">The sum <span class="keyword">is</span>: <span class="number">55</span></span><br><span class="line">The average <span class="keyword">is</span>: <span class="number">5.5</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<p><strong>总结：</strong></p>
<ol>
<li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li>
<li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li>
<li>互斥是一种特殊的同步。</li>
</ol>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>同步与互斥这两个概念经常被混淆，所以在这里说一下它们的区别。</p>
<h3 id="一、同步与互斥的区别">一、同步与互斥的区别</h3><h4 id="1-_同步">1. 同步</h4><p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。</p>
<p>例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Linux编程】进程间通信（IPC）]]></title>
    <link href="http://yoursite.com/2015/04/21/linux-IPC/"/>
    <id>http://yoursite.com/2015/04/21/linux-IPC/</id>
    <published>2015-04-21T12:51:21.000Z</published>
    <updated>2015-05-10T11:50:29.559Z</updated>
    <content type="html"><![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。<a id="more"></a></p>
<h3 id="1、特点：">1、特点：</h3><ol>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ol>
<h3 id="2、原型：">2、原型：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[2])</span></span>;    <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。如下图：</p>
<p><img src="http://img.blog.csdn.net/20150419222058628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>要关闭管道只需将这两个文件描述符关闭即可。</p>
<h3 id="3、例子">3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150419223853807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">	pid_t pid;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">		read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="二、FIFO">二、FIFO</h2><p><strong>FIFO</strong>，也称为命名管道，它是一种文件类型。</p>
<h3 id="1、特点">1、特点</h3><ol>
<li><p>FIFO可以在无关的进程之间交换数据，与无名管道不同。</p>
</li>
<li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
</li>
</ol>
<h3 id="2、原型">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中的 mode 参数与<code>open</code>函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p>
<p>当 open 一个FIFO时，是否设置非阻塞标志（<code>O_NONBLOCK</code>）的区别：</p>
<ul>
<li><p>若没有指定<code>O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p>
</li>
<li><p>若指定了<code>O_NONBLOCK</code>，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p>
</li>
</ul>
<h3 id="3、例子-1">3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：</p>
<ul>
<li><p><strong>write_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;   <span class="comment">// exit</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;    <span class="comment">// O_WRONLY</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;time.h&gt;     <span class="comment">// time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	time_t tp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO </span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">		n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">		<span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read_fifo.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;fcntl.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line">		perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">// 以读打开FIFO</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">	close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>在两个终端里用 gcc 分别编译运行上面两个文件，可以看到输出结果如下：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./write_fifo </span><br><span class="line">I am <span class="number">5954</span> <span class="keyword">process</span>.</span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Send message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[songlee@localhost]$ ./read_fifo </span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">28</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">29</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">31</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">32</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">33</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">35</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2015</span></span><br><span class="line">Read message: <span class="keyword">Process</span> <span class="number">5954</span><span class="attribute">'s</span> <span class="typename">time</span> <span class="keyword">is</span> Mon Apr <span class="number">20</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">37</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p><br><br><br>上述例子可以扩展成 客户进程—服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：</p>
<p><img src="http://img.blog.csdn.net/20150420131002360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><br></p>
<h2 id="三、消息队列">三、消息队列</h2><p><strong>消息队列</strong>，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<h3 id="1、特点-1">1、特点</h3><ol>
<li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ol>
<h3 id="2、原型-1">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(key_t key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, size_t size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p>
<ul>
<li>如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位。</li>
<li>key参数为<code>IPC_PRIVATE</code>。</li>
</ul>
<p>函数<code>msgrcv</code>在读取消息队列时，type参数有下面几种情况：</p>
<ul>
<li><code>type == 0</code>，返回队列中的第一个消息；</li>
<li><code>type &gt; 0</code>，返回队列中消息类型为 type 的第一个消息；</li>
<li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li>
</ul>
<p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）</p>
<h3 id="3、例子-2">3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p>
<ul>
<li><p><strong>msg_server.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环读取消息</span></span><br><span class="line">	<span class="keyword">for</span>(;;) </span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">		msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">		<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">		msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msg_client.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MSG_FILE "/etc/passwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印key值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加消息，类型为888</span></span><br><span class="line">	msg.mtype = <span class="number">888</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">	msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取类型为777的消息</span></span><br><span class="line">	msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="四、信号量">四、信号量</h2><p><strong>信号量（semaphore）</strong>与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<h3 id="1、特点-2">1、特点</h3><ol>
<li><p>信号量用于进程间同步，若要在进程间传递数据需要结合<em>共享内存</em>。</p>
</li>
<li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p>
</li>
<li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
</li>
<li><p>支持信号量组。</p>
</li>
</ol>
<h3 id="2、原型-2">2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做<strong>二值信号量（Binary Semaphore）</strong>。而可以取多个正整数的信号量被称为通用信号量。</p>
<p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(key_t key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], size_t numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 。</p>
<p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sembuf </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 sem_op 是一次操作中的信号量的改变量：</p>
<ul>
<li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们。</p>
</li>
<li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p>
<ul>
<li>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</li>
<li>当相应的资源数不能满足请求时，这个操作与<code>sem_flg</code>有关。<ul>
<li>sem_flg 指定<code>IPC_NOWAIT</code>，则semop函数出错返回<code>EAGAIN</code>。</li>
<li>sem_flg 没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p>
<ul>
<li>当信号量已经为0，函数立即返回。</li>
<li>如果信号量的值不为0，则依据<code>sem_flg</code>决定函数动作：<ul>
<li>sem_flg指定<code>IPC_NOWAIT</code>，则出错返回<code>EAGAIN</code>。</li>
<li>sem_flg没有指定<code>IPC_NOWAIT</code>，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：<ol>
<li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR  </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p>
<ul>
<li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li>
<li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li>
</ul>
<h3 id="3、例子-3">3、例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">	<span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	tmp.val = value;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//	若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//	若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//	释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//	如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">	sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">	sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">	sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> semun tmp;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;  <span class="comment">// 信号量集ID</span></span><br><span class="line">	key_t key;  </span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量集，其中只有一个信号量</span></span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化：初值设为0资源被占用</span></span><br><span class="line">	init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"Fork Error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/*子进程*/</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process child: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);  <span class="comment">/*释放资源*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">/*父进程*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		sem_p(sem_id);   <span class="comment">/*等待资源*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Process father: pid=%d\n"</span>, getpid());</span><br><span class="line">		sem_v(sem_id);   <span class="comment">/*释放资源*/</span></span><br><span class="line">		del_sem(sem_id); <span class="comment">/*删除信号量集*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子如果不加信号量，则父进程会先执行完毕。这里加了信号量让父进程等待子进程执行完以后再执行。</p>
<p><br></p>
<h2 id="五、共享内存">五、共享内存</h2><p><strong>共享内存（Shared Memory）</strong>，指两个或多个进程共享一个给定的存储区。</p>
<h3 id="1、特点-3">1、特点</h3><ol>
<li><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>
</li>
<li><p>因为多个进程可以同时操作，所以需要进行同步。</p>
</li>
<li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p>
</li>
</ol>
<h3 id="2、原型-3">2、原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(key_t key, size_t size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="keyword">void</span> *shmat(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag);</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p>
<p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p>
<p><code>shmdt</code>函数是用来断开<code>shmat</code>建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p>
<p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code>IPC_RMID</code>（从系统中删除该共享内存）。</p>
<h3 id="3、例子-4">3、例子</h3><p>下面这个例子，使用了<strong>【共享内存+信号量+消息队列】</strong>的组合来实现服务器进程与客户进程间的通信。</p>
<ul>
<li>共享内存用来传递数据；</li>
<li>信号量用来同步；</li>
<li>消息队列用来 在客户端修改了共享内存后 通知服务器读取。</li>
</ul>
<p><strong>Server.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    tmp.val = value;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Init Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun tmp;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, tmp) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Delete Semaphore Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat_sem</span><span class="params">(key_t key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id;</span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	init_sem(sem_id, <span class="number">1</span>);  <span class="comment">/*初值设为1资源未占用*/</span></span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">char</span> data[] = <span class="string">"this is server"</span>;</span><br><span class="line">	<span class="keyword">struct</span> shmid_ds buf1;  <span class="comment">/*用于删除共享内存*/</span></span><br><span class="line">	<span class="keyword">struct</span> msqid_ds buf2;  <span class="comment">/*用于删除消息队列*/</span></span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;  <span class="comment">/*消息队列用于通知对方更新了共享内存*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, IPC_CREAT|<span class="number">0666</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Create Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建信号量</span></span><br><span class="line">	semid = creat_sem(key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		msgrcv(msqid, &amp;msg, <span class="number">1</span>, <span class="number">888</span>, <span class="number">0</span>); <span class="comment">/*读取类型为888的消息*/</span></span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'q'</span>)  <span class="comment">/*quit - 跳出循环*/</span> </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(msg.mtext == <span class="string">'r'</span>)  <span class="comment">/*read - 读共享内存*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			sem_p(semid);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,shm);</span><br><span class="line">			sem_v(semid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除共享内存、消息队列、信号量*/</span></span><br><span class="line">	shmctl(shmid, IPC_RMID, &amp;buf1);</span><br><span class="line">	msgctl(msqid, IPC_RMID, &amp;buf2);</span><br><span class="line">	del_sem(semid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Client.c</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/shm.h&gt;  <span class="comment">// shared memory</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/sem.h&gt;  <span class="comment">// semaphore</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/msg.h&gt;  <span class="comment">// message queue</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string.h&gt;   <span class="comment">// memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列结构</span></span><br><span class="line"><span class="keyword">struct</span> msg_form &#123;</span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体，用于semctl初始化</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>              val; <span class="comment">/*for SETVAL*/</span></span><br><span class="line">    <span class="keyword">struct</span> semid_ds *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作:</span></span><br><span class="line"><span class="comment">//  若信号量值为1，获取资源并将信号量值-1 </span></span><br><span class="line"><span class="comment">//  若信号量值为0，进程挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = -<span class="number">1</span>; <span class="comment">/*P操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"P operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作：</span></span><br><span class="line"><span class="comment">//  释放资源并将信号量值+1</span></span><br><span class="line"><span class="comment">//  如果有进程正在挂起等待，则唤醒它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sembuf sbuf;</span><br><span class="line">    sbuf.sem_num = <span class="number">0</span>; <span class="comment">/*序号*/</span></span><br><span class="line">    sbuf.sem_op = <span class="number">1</span>;  <span class="comment">/*V操作*/</span></span><br><span class="line">    sbuf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sbuf, <span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"V operation Error"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	<span class="keyword">int</span> shmid, semid, msqid;</span><br><span class="line">	<span class="keyword">char</span> *shm;</span><br><span class="line">	<span class="keyword">struct</span> msg_form msg;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">/*while循环条件*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取key值</span></span><br><span class="line">	<span class="keyword">if</span>((key = ftok(<span class="string">"."</span>, <span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取共享内存</span></span><br><span class="line">	<span class="keyword">if</span>((shmid = shmget(key, <span class="number">1024</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接共享内存</span></span><br><span class="line">	shm = (<span class="keyword">char</span>*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">int</span>)shm == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"Attach Shared Memory Error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建消息队列</span></span><br><span class="line">	<span class="keyword">if</span> ((msqid = msgget(key, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"msgget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取信号量</span></span><br><span class="line">	<span class="keyword">if</span>((semid = semget(key, <span class="number">0</span>, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"semget error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 写数据</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*                 IPC                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input r to send data to server.  *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*    Input q to quit.                 *\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"***************************************\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please input command: "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">		<span class="keyword">switch</span>(c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Data to send: "</span>);</span><br><span class="line">				sem_p(semid);  <span class="comment">/*访问资源*/</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>, shm);</span><br><span class="line">				sem_v(semid);  <span class="comment">/*释放资源*/</span></span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">				msg.mtype = <span class="number">888</span>;  </span><br><span class="line">				msg.mtext = <span class="string">'r'</span>;  <span class="comment">/*发送消息通知服务器读数据*/</span></span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">				msg.mtype = <span class="number">888</span>;</span><br><span class="line">				msg.mtext = <span class="string">'q'</span>;</span><br><span class="line">				msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Wrong input!\n"</span>);</span><br><span class="line">				<span class="comment">/*清空标准输入缓冲区*/</span></span><br><span class="line">				<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	shmdt(shm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：当<code>scanf()</code>输入字符或字符串时，缓冲区中遗留下了<code>\n</code>，所以每次输入操作后都需要清空标准输入的缓冲区。但是由于 gcc 编译器不支持<code>fflush(stdin)</code>（它只是标准C的扩展），所以我们使用了替代方案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span> &amp;&amp; c!=EOF);</span><br></pre></td></tr></table></figure></p>
<p>注释已经很详细了，所以代码的其他部分我就不解释了，下面是运行结果截图：</p>
<p><img src="http://img.blog.csdn.net/20150421203538923" alt=""></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>进程间通信（IPC，InterProcess Communication）</strong>是指在不同进程之间传播或交换信息。IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>
<h2 id="一、管道">一、管道</h2><p><strong>管道</strong>，通常指无名管道，是 UNIX 系统IPC最古老的形式。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="System-Linux" scheme="http://yoursite.com/categories/System-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可利用空间表（Free List）]]></title>
    <link href="http://yoursite.com/2015/04/08/free-list/"/>
    <id>http://yoursite.com/2015/04/08/free-list/</id>
    <published>2015-04-08T03:11:00.000Z</published>
    <updated>2015-05-10T11:47:00.859Z</updated>
    <content type="html"><![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br><a id="more"></a><br>为了避免频繁的new/delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从free list中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p>
<p>要求：</p>
<ol>
<li>实现一个对固定大小内存块进行管理的通用FreeList类，给出定义和实现。要求不能使用STL中的容器类。定义类的接口和实现时注意通用性、健壮性和可测试性。</li>
<li>如果该类的对象可能会被多个thread同时访问，请描述如何怎样保证线程安全。有没有办法在保证线程安全的同时尽可能增大并发度？如果有也请描述你的思路。</li>
</ol>
</blockquote>
<p><br></p>
<h3 id="一、介绍">一、介绍</h3><p>“可利用空间表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即<strong>可利用空间表（free list）</strong>。</p>
<p>当用户请求分配时，系统从可利用空间表中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到可利用空间表中，因此，可利用空间表亦称为“存储池”。</p>
<p>可利用空间表有三种结点结构：</p>
<ol>
<li><p><strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。</p>
</li>
<li><p><strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。</p>
</li>
<li><p><strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即可利用空间表中只有一个大小为整个存储区的结点。随着分配和回收的进行，可利用空间表的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是可利用空间表中的任一结点都能满足，而需要按照申请的长度在可利用空间表中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略：</p>
<ul>
<li><p><strong>首次适配法</strong>：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）</p>
</li>
<li><p><strong>最佳适配法</strong>：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）</p>
</li>
<li><p><strong>最差适配法</strong>：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）</p>
</li>
</ul>
</li>
</ol>
<p>三种分配策略适合于不同的情况，<code>首次适配法</code>的优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足 —— 这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。<code>最佳适配法</code>的优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统。<code>最差适配法</code>的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</p>
<p><br></p>
<h3 id="二、C++实现">二、C++实现</h3><p>根据题目要求，实现一个对固定大小内存块进行管理的通用FreeList类，即结点大小相同。其实这是最简单的一种实现，注意几个实现要点：</p>
<ul>
<li><p>一个静态成员指针static FreeList* freelist，用来指向可利用空间表。</p>
</li>
<li><p>重载 new 和 delete。</p>
</li>
</ul>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">class</span> FreeList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> FreeList&lt;Elem&gt; *freelist;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Elem element;</span><br><span class="line">	FreeList *next;</span><br><span class="line">	FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next=NULL);</span><br><span class="line">	FreeList(FreeList* next=NULL);</span><br><span class="line">	<span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>;    <span class="comment">// 重载new</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;   <span class="comment">// 重载delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;* FreeList&lt;Elem&gt;::freelist = NULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(<span class="keyword">const</span> Elem&amp; elem, FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;element = elem;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line">FreeList&lt;Elem&gt;::FreeList(FreeList* next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span>* FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*freelist没有可用空间，就从系统分配*/</span></span><br><span class="line">	<span class="keyword">if</span>(freelist == NULL)  </span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">new</span> FreeList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*否则，从freelist表头摘取结点*/</span></span><br><span class="line">	FreeList&lt;Elem&gt;* temp = freelist;</span><br><span class="line">	freelist = freelist-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt;</span><br><span class="line"><span class="keyword">void</span> FreeList&lt;Elem&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*把要释放的结点空间加入到freelist中*/</span></span><br><span class="line">	((FreeList&lt;Elem&gt;*)ptr)-&gt;next = freelist;</span><br><span class="line">	freelist = (FreeList&lt;Elem&gt;*)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>至于线程安全的问题，在多线程的环境下，线程同步的方式有多种：临界区、事件、互斥量、信号量。比如，我们可以把访问该类对象的代码段设置为 Critical Section，这样同一时间就只有一个线程可以执行这段代码。为了尽可能增大并发度，更好的方式是将代码改造成对临界数据的保护而不是对临界代码的保护，这样就可以令不会同时访问相同临界数据的线程完全并行地执行。</p>
<p>这是我个人的观点，如果你有更好的想法，欢迎交流和指正！</p>
<p><br><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写这篇文章的动因是因为 2015 年 04 月 02 日的阿里在线笔试题考到了这个知识点。我当时模模糊糊的写了一些，估计写的也不对，所以在这里总结一下。</p>
<h3 id="原题">原题</h3><blockquote>
<p>常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。<br>]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2051-最小的K个数（Top K问题）]]></title>
    <link href="http://yoursite.com/2015/03/21/hua-wei-OJ2051/"/>
    <id>http://yoursite.com/2015/03/21/hua-wei-OJ2051/</id>
    <published>2015-03-21T11:36:34.000Z</published>
    <updated>2015-05-10T11:39:10.276Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组<a id="more"></a></li>
</ol>
<p><strong>输出：</strong></p>
<p>输出一个整数数组</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 5 7 2</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、Top_K问题">二、Top K问题</h1><p>对于 Top K 问题有很多种解法。</p>
<h2 id="解法一：排序">解法一：排序</h2><p>相信很多人会首先想到这种方法，先把数组按升序/降序进行排序，然后输出 K 个最小/最大的数。</p>
<ul>
<li>常规的排序方法时间复杂度至少是$Θ(nlog_2n)$。（<a href="http://songlee24.github.io/2014/04/03/implementation-of-internal-sortings/" target="_blank" rel="external">快排或堆排序</a>）</li>
<li>可能你会说，我们可以使用<a href="http://songlee24.github.io/2014/06/22/linear-sorting-algorithms/" target="_blank" rel="external">线性时间的排序算法</a>。当然可以，但通常它们对输入的数组有一定的要求。比如计数排序要求 n 个数都是正整数，且它们的取值范围不太大。</li>
</ul>
<h2 id="解法二：部分排序_$O(n*k)$">解法二：部分排序 $O(n*k)$</h2><p>由于我们只需要找出最小/最大的 k 个数，所以我们可以进行部分排序，比如<strong>简单选择排序</strong> 和 <strong>冒泡排序</strong>，它们每一趟都能把一个最小/最大元素放在最终位置上，所以进行 k 趟就能把 n 个数中的前 k 个排序出来。</p>
<p>部分简单选择排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123; <span class="comment">// k趟</span></span><br><span class="line">		<span class="keyword">int</span> Min = i;         <span class="comment">// 记录最小元素的位置</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[Min])</span><br><span class="line">				Min = j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Min != i)  <span class="comment">// 与A[i]交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[Min];</span><br><span class="line">			A[Min] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>部分冒泡排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)  <span class="comment">// k趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j)  <span class="comment">// 一趟冒泡过程</span></span><br><span class="line">			<span class="keyword">if</span>(A[j-<span class="number">1</span>] &gt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = A[j-<span class="number">1</span>];</span><br><span class="line">				A[j-<span class="number">1</span>] = A[j];</span><br><span class="line">				A[j] = tmp;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="keyword">false</span>)  <span class="comment">// 已经有序</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，$O(nlog_2n)$ 与 $O(n*k)$ 哪一个更好呢？这取决于 k 的大小。在 k 较小的情况下，即 $k &lt;= log_2n$，可以选择部分排序。</p>
<h2 id="解法三：快排划分_$O(n*log_2k)$">解法三：快排划分 $O(n*log_2k)$</h2><p>根据基于快排<code>partition</code>操作的《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/33419201" target="_blank" rel="external">第k顺序统计量的求解</a>》，我们知道，当我们求出第 k 顺序统计量时，位于它前面的元素都比它小，位于它后面的元素都比它大。这时，数组的前 k 个数就是最小的 k 个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[high]&gt;=pivot)</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[low]&lt;=pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(low == high)</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = partition(A, low, high);</span><br><span class="line">	<span class="keyword">int</span> i = pos - low + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">		<span class="keyword">return</span> pos;  <span class="comment">// 返回前k个数的</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; k)</span><br><span class="line">		<span class="keyword">return</span> topK(A, low, pos, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> topK(A, pos+<span class="number">1</span>, high, k-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们说这个算法的平均时间复杂度是线性的，更准确地说，是 $O(n∗log_2k)$。另外，为了避免特殊数据下的算法退化，最好使用随机化版本的划分操作。</p>
<h2 id="解法四：大根堆_$O(n∗log_2k)$">解法四：大根堆 $O(n∗log_2k)$</h2><p>参见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/24846247" target="_blank" rel="external">堆排序</a>》，可以用大小为 k 的大根堆来存储最小的 k 个数。大根堆的堆顶元素就是最小 k 个数中最大的一个。每次新考虑一个数 X：</p>
<ul>
<li><p>如果 X 比堆顶的元素 Y 大，则不需要改变原来的堆，因为这个元素比最小的 k 个数都大。</p>
</li>
<li><p>如果 X 比堆顶元素 Y 小，那么用 X 替换堆顶的元素 Y。在 X 替换堆顶元素 Y 之后，大根堆的结构可能被破坏，需要进行向下调整。调整过程的时间复杂度是 $O(log_2k)$ 。</p>
</li>
</ul>
<p>遍历完成以后，数组的前 k 个数就是最小的 k 个数，但是它们并非有序，而是以堆的形式存在。C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> temp = A[i];  <span class="comment">// 暂存A[i]  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> largest=<span class="number">2</span>*i+<span class="number">1</span>; largest&lt;len; largest=<span class="number">2</span>*largest+<span class="number">1</span>)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">if</span>(largest!=len-<span class="number">1</span> &amp;&amp; A[largest+<span class="number">1</span>]&gt;A[largest])  </span><br><span class="line">			++largest;         <span class="comment">// 如果右子结点大  </span></span><br><span class="line">		<span class="keyword">if</span>(temp &lt; A[largest])  </span><br><span class="line">		&#123;  </span><br><span class="line">			A[i] = A[largest];  </span><br><span class="line">			i = largest;         <span class="comment">// 记录交换后的位置  </span></span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	A[i] = temp;    <span class="comment">// 被筛选结点的值放入最终位置  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)  <span class="comment">// 从i=n/2-1到0，反复调整堆</span></span><br><span class="line">		AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 维护 A[0...k-1] 这个大根堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BuildMaxHeap(A, k);  <span class="comment">// 先用前面的k个数建大根堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i] &lt; A[<span class="number">0</span>])  <span class="comment">// 如果小于堆顶元素，替换之</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = A[<span class="number">0</span>];</span><br><span class="line">			A[<span class="number">0</span>] = A[i];</span><br><span class="line">			A[i] = tmp;</span><br><span class="line">			AdjustDown(A, <span class="number">0</span>, k);  <span class="comment">// 向下调整</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：找最小的 $k$ 个数，就维护一个大根堆；找最大的 $k$ 个数，就维护一个小根堆。</p>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>第二部分已经讲解地很清楚了，几种解法都可以，只要注意输入输出的格式就行了。</p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>输入n个整数，输出其中最小的k个。</p>
<p><strong>输入：</strong></p>
<ol>
<li>输入 n 和 k </li>
<li>输入一个整数数组]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ1964-求解立方根（牛顿迭代法）]]></title>
    <link href="http://yoursite.com/2015/03/20/hua-wei-OJ1964/"/>
    <id>http://yoursite.com/2015/03/20/hua-wei-OJ1964/</id>
    <published>2015-03-20T11:32:16.000Z</published>
    <updated>2015-05-10T11:35:27.608Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<ul>
<li>计算一个数字的立方根，不使用库函数。</li>
<li>函数原型<code>double getCubeRoot(double input)</code></li>
</ul>
<p><strong>输入：</strong><a id="more"></a></p>
<p>待求解参数 double类型</p>
<p><strong>输出：</strong></p>
<p>输出参数的立方根，保留一位小数</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">216</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.0</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、解题报告">二、解题报告</h1><p>本题要求一个数的立方根的近似值，精确到小数点后的一位。这里使用 <a href="http://baike.baidu.com/view/643093.htm" target="_blank" rel="external"><strong>牛顿迭代法</strong></a> 求近似值。</p>
<p>牛顿迭代法，又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），<strong>它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法</strong>。多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x) = 0$的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程$f(x) = 0$的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。另外该方法广泛用于计算机编程中。</p>
<p>设 $r$ 是的根，选取 $x_0$ 作为 $r$ 的初始近似值：</p>
<ul>
<li><p>过点$(x_0,f(x_0))$做曲线$y=f(x)$的切线L，L的方程为 $y=f(x_0)+f’(x_0)(x-x_0)$，求出L与x轴交点的横坐标 $x_1 = x_0-\frac{f(x_0)}{f’(x_0)}$，称 $x_1$为 $r$ 的一次近似值。</p>
</li>
<li><p>过点 $(x_1,f(x_1))$ 做曲线 $y=f(x)$ 的切线，并求该切线与x轴交点的横坐标 $x_2 = x_1-\frac{f(x_1)}{f’(x_1)}$，称 $x_2$ 为 $r$ 的二次近似值。</p>
</li>
<li><p>重复以上过程，得 $r$ 的近似值序列。其中， $x_{n+1} = x_n-\frac{f(x_n)}{f’(x_n)}$ 称为 $r$ 的 $n+1$ 次近似值，上式称为<strong>牛顿迭代公式</strong>。</p>
</li>
</ul>
<hr>
<p>首先确定我们的函数 $f(x)$：</p>
<p>$$f(x) = x^3 - m$$</p>
<p>其中 $m$ 是一个常数，程序的输入。求导函数：</p>
<p>$$f’(x) = 3x^2$$</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> E 0.01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> num)</span> <span class="comment">// 函数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x*x-num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> _f(<span class="keyword">double</span> x)  <span class="comment">// 导函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>*x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getCubeRoot</span><span class="params">(<span class="keyword">double</span> input)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x0;  </span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		x0 = r;</span><br><span class="line">		r = x0 - f(x0,input)/_f(x0);</span><br><span class="line">	&#125; <span class="keyword">while</span>(f(r,input) &gt; E || f(r,input) &lt; -E);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">double</span> result = getCubeRoot(x); </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<ul>
<li>计算一个数字的立方根，不使用库函数。</li>
<li>函数原型<code>double getCubeRoot(double input)</code></li>
</ul>
<p><strong>输入：</strong>]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2288-合唱队（最长递增子序列）]]></title>
    <link href="http://yoursite.com/2015/03/19/hua-wei-OJ2288/"/>
    <id>http://yoursite.com/2015/03/19/hua-wei-OJ2288/</id>
    <published>2015-03-19T11:26:41.000Z</published>
    <updated>2015-05-10T11:31:34.675Z</updated>
    <content type="html"><![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K) 。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。<a id="more"></a></p>
<p><strong>输入：</strong></p>
<p>第一行整数 N，表示同学的总数<br>第二行整数数组，空格隔开，表示 N 位同学身高</p>
<p><strong>输出：</strong></p>
<p>最少需要几位同学出列</p>
<p><strong>样例输入：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">186 186 150 200 160 130 197 200</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="二、最长递增子序列">二、最长递增子序列</h1><p><strong>最长递增子序列（Longest Increasing Subsequence）</strong>是指找到一个给定序列的最长子序列的长度，使得子序列中的所有元素单调递增。</p>
<p>例如：{ 3，5，7，1，2，8 }  的 LIS 是 { 3，5，7，8 }，长度为 4。</p>
<h2 id="解法一：转化为求最长公共子序列">解法一：转化为求最长公共子序列</h2><p>其实可以把 求最长递增子序列问题 转化为 求最长公共子序列的问题。</p>
<ul>
<li>设数组 { 3， 5， 7， 1， 2， 8 } 为 A</li>
<li>对数组 A 排序，排序后的数组为 B = { 1， 2， 3， 5， 7， 8 }。</li>
<li>于是，求数组 A 的最长递增子序列，就是求数组 A 与数组 B 的最长公共子序列。</li>
</ul>
<p>最长公共子序列的求法见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/41548557" target="_blank" rel="external">动态规划DP</a>》。本方法的时间复杂度是 </p>
<p>$$Θ(nlgn)+ Θ(n^2) = Θ(n^2)$$</p>
<h2 id="解法二：动态规划法">解法二：动态规划法</h2><p>虽然解法一也是使用动态规划，但是与解法一不同的是，解法二不进行转化，而是直接在原问题上采用动态规划法。</p>
<p><strong>最优子结构：</strong></p>
<p>对于长度为 N 的数组 $A[N] = { a<em>0, a_1, a_2, …, a</em>{n-1}}$，假设我们想求以 $a_i$ 结尾的最大递增子序列长度，设为$L[i]$，那么</p>
<p>$$<br>L[i] =<br>\begin{cases}<br>max(L[j]) + 1,  &amp; \text{where $j &lt; i$ and $A[j] &lt; A[i]$} \[2ex]<br>1, &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
<p>也就是 $j$ 的范围是 0 到 $i–1$。这样，想求 $a_i$ 结尾的最大递增子序列的长度，我们就需要遍历 $i$ 之前的所有位置 $j$（0到 i-1），找出$A[j] &lt; A[i]$，计算这些 $j$ 中，能产生最大 $L[j]$ 的 $j$，之后就可以求出 $L[i]$。之后对每一个$A[N]$中的元素都计算以他们各自结尾的最大递增子序列的长度，这些长度的最大值，就是我们要求的问题——数组$A$的最大递增子序列的长度。</p>
<p><strong>重叠子问题：</strong></p>
<p>根据上述推导式采用递归实现的话，有些子问题会被计算很多次。</p>
<p><strong>动态规划法：</strong></p>
<p>综上所述，LIS 问题具有动态规划需要的两个性质，可以使用动态规划求解该问题。设数组 A = { 3，5，7，1，2，8 }，则：</p>
<center><br><img src="http://img.blog.csdn.net/20150424101652021" alt=""><br></center>

<p>具体的打表方式如下：</p>
<ul>
<li>初始化对角线为 1；</li>
<li>对每一个 i，遍历 j（0 到 i-1）：<ul>
<li>若<code>A[i] &lt;= A[j]</code>，置 1。</li>
<li>若<code>A[i] &gt; A[j]</code>，取第 j 行的<strong>最大值</strong>加 1。</li>
</ul>
</li>
</ul>
<p>打完表以后，最后一行的最大值就是最长递增子序列的长度。由于每次都进行遍历，故时间复杂度还是 $Θ(n^2)$ 。</p>
<p>通常在实现的时候我们不会创建一整个表，因为这样太浪费空间。由打表的过程可知，我们只需要一个一维数组来保存每一行的最大值即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LIS 的动态规划方式实现</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLISLength</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* 一维数组 */</span></span><br><span class="line">   <span class="keyword">int</span>* lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化为1 */</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">      lis[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 计算每个i对应的lis最大值，即打表的过程 */</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)     <span class="comment">// 0到i-1</span></span><br><span class="line">         <span class="keyword">if</span> ( A[i] &gt; A[j] &amp;&amp; lis[i] &lt; lis[j]+<span class="number">1</span>)</span><br><span class="line">            lis[i] = lis[j] + <span class="number">1</span>;  <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 数组中最大的那个，就是最长递增子序列的长度 */</span></span><br><span class="line">   <span class="keyword">int</span> maxlis = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> ( maxlis &lt; lis[i] )</span><br><span class="line">         maxlis = lis[i];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> [] lis;</span><br><span class="line">   <span class="keyword">return</span> maxlis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; getLISLength(arr, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三：Θ(nlgn)的方案">解法三：Θ(nlgn)的方案</h2><p>本解法的具体操作如下：</p>
<ul>
<li>开一个栈，依次读取数组元素 x 与栈顶元素 top：<ul>
<li>如果 x &gt; top，将 x 入栈；</li>
<li>如果 x &lt; top，则二分查找栈中第一个 大于等于x 的数，并用 x 替换它。</li>
</ul>
</li>
</ul>
<p>遍历结束之后，最长递增序列长度即为栈的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLISLength</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 模拟栈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.size()==<span class="number">0</span> || v.back()&lt;A[i])</span><br><span class="line">			v.push_back(A[i]);</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">// 二分查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> mid, low=<span class="number">0</span>, high=v.size()-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">			&#123;</span><br><span class="line">				mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(v[mid] &lt; A[i])</span><br><span class="line">					low = mid + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					high = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v[low] = A[i];  <span class="comment">// 替换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了二分搜索，故时间复杂度变成了 $Θ(nlgn)$。</p>
<p>特别注意的是：本方法<strong>只能</strong>用于求最长递增子序列的长度，千万不要以为栈中的序列就是最长递增子序列：</p>
<ul>
<li><p>例一：原序列为1，5，8，3，6，7<br>栈为1，5，8，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6；再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。</p>
</li>
<li><p>例二：原序列为1，5，8，3<br>则最终栈为1，3，8。明显这不是最长递增子序列！</p>
</li>
</ul>
<p><br></p>
<h1 id="三、解题报告">三、解题报告</h1><p>根据题意可知，我们需要求出一个“中间点”，使得其左边的【最长递增子序列】和其右边的【最长递减子序列】之和最大。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">	<span class="keyword">int</span> *A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lis[i]表示以A[i]为结尾的最长递增子序列的长度</span></span><br><span class="line">	<span class="keyword">int</span> *lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];  </span><br><span class="line">	<span class="comment">// lds[i]表示以A[i]为起点的最长递减子序列的长度</span></span><br><span class="line">	<span class="keyword">int</span> *lds = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		lis[i] = <span class="number">1</span>;</span><br><span class="line">		lds[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt; A[j] &amp;&amp; lis[i] &lt; lis[j]+<span class="number">1</span>)</span><br><span class="line">				lis[i] = lis[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>; j&gt;i; --j)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt; A[j] &amp;&amp; lds[i] &lt; lds[j]+<span class="number">1</span>)</span><br><span class="line">				lds[i] = lds[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxl = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="keyword">if</span>(maxl &lt; lis[i]+lds[i])</span><br><span class="line">			maxl = lis[i] + lds[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; len - maxl + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] lis;</span><br><span class="line">	<span class="keyword">delete</span> [] lds;</span><br><span class="line">	<span class="keyword">delete</span> [] A;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br></p>
<p>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、题目描述">一、题目描述</h1><p><strong>描述：</strong></p>
<p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K) 。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华为OJ2011-最长公共子串]]></title>
    <link href="http://yoursite.com/2015/03/18/hua-wei-OJ2011/"/>
    <id>http://yoursite.com/2015/03/18/hua-wei-OJ2011/</id>
    <published>2015-03-18T11:19:52.000Z</published>
    <updated>2015-05-10T11:24:31.089Z</updated>
    <content type="html"><![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串<a id="more"></a></p>
<p><strong>输出：</strong></p>
<p>输出一个整数</p>
<p><strong>样例输入：</strong><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">asdfas</span> werasdfaswer</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="二、解题报告">二、解题报告</h3><p>与最长公共子序列（参见《<a href="http://songlee24.github.io/2014/11/27/dynamic-programming/" target="_blank" rel="external">动态规划DP</a>》）一样，最长公共子串也可以使用动态规划解决，只不过思路不太一样。准确地说，是打表的方式不一样。</p>
<p>举个例子：s1 = <code>bab</code>，s2 = <code>caba</code>。表如下</p>
<center><br><img src="http://img.blog.csdn.net/20150423105150153" alt=""><br></center>

<p>具体打表的方法是：</p>
<ul>
<li>第一行、第一列初始化为 0；</li>
<li>对于其他的格子：<ul>
<li>若对应的两个字符相等，格子的值设为左上角的值加 1。</li>
<li>若对应的两个字符不相等，直接置 0 。</li>
</ul>
</li>
</ul>
<p><br><br>这样的话，表中的最大元素就是 最长公共子串 的<strong>长度</strong>。并且也可以很容易看出最长公共子串有 2 个，分别是<code>ba</code>和<code>ab</code>。</p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLCStringLength</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> input, s1, s2;</span><br><span class="line">	getline(<span class="built_in">cin</span>, input);</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">	ss &gt;&gt; s1;</span><br><span class="line">	ss &gt;&gt; s2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getLCStringLength(s1, s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="三、扩展">三、扩展</h3><p>如何输出所有的最长公共子串？</p>
<p>很简单，我们记录下 s1 和 s2 的公共子串分别在 s1 、s2 中起始位置（即表中值为 1 的坐标）。打表完成以后，我们已经知道了最长公共子串的长度<code>length</code>，通过<code>substr()</code>判断即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.substr(i-<span class="number">1</span>, length) == s2.substr(j-<span class="number">1</span>, length)</span><br></pre></td></tr></table></figure></p>
<p>C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCString</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1 == <span class="string">""</span> || s2 == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = s1.size();</span><br><span class="line">	<span class="keyword">int</span> n = s2.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; table(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> biggest = <span class="number">0</span>;  <span class="comment">// 记录表中最大值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; firstPos;  <span class="comment">// 记录子串开始的坐标 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; ++i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; ++j)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="comment">// 第一行和第一列置0  </span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)  </span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])  </span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span>(table[i][j] &gt; biggest)</span><br><span class="line">					biggest = table[i][j];</span><br><span class="line">				<span class="keyword">if</span>(table[i][j] == <span class="number">1</span>) </span><br><span class="line">					firstPos.push_back(make_pair(i, j));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">// 不相等置0</span></span><br><span class="line">				table[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出所有的最长公共子串</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator beg = firstPos.begin();</span><br><span class="line">	<span class="keyword">for</span>( ; beg!=firstPos.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start1 = beg-&gt;first-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> start2 = beg-&gt;second-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s1.substr(start1, biggest) == s2.substr(start2, biggest))</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s1.substr(start1, biggest) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"hello,world,james"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"james is saying hello"</span>;</span><br><span class="line">	printLCString(s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、题目描述">一、题目描述</h3><p><strong>描述：</strong></p>
<p> 计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符区分大小写。</p>
<p><strong>输入：</strong></p>
<p>输入两个字符串]]>
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
      <category term="试题-OJ" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-OJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（二）]]></title>
    <link href="http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/"/>
    <id>http://yoursite.com/2015/03/17/cracking-the-coding-interview-02/</id>
    <published>2015-03-16T18:40:53.000Z</published>
    <updated>2015-05-10T11:17:34.068Z</updated>
    <content type="html"><![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）<a id="more"></a></p>
<ul>
<li>进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行 pop 操作。</li>
</ul>
<p><strong>3.4</strong> 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</p>
<ul>
<li>每次只能移动一个盘子</li>
<li>盘子只能从柱子顶端滑出移到下一根柱子</li>
<li>盘子只能叠在比它大的盘子上</li>
</ul>
<p>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><strong>3.5</strong> 实现一个<code>MyQueue</code>类，该类用两个栈来实现一个队列。</p>
<p><strong>3.6</strong> 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code>和<code>isEmpty</code>。</p>
<p><strong>3.7</strong> 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>等。</p>
<p><br><br></p>
<h3 id="4、树与图">4、树与图</h3><p><strong>4.1</strong> 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</p>
<p><strong>4.2</strong> 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</p>
<p><strong>4.3</strong> 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</p>
<p><strong>4.4</strong> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</p>
<p><strong>4.5</strong> 实现一个函数，检查一棵二叉树是否为二叉查找树。</p>
<p><strong>4.6</strong> 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</p>
<p><strong>4.7</strong> 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</p>
<p><strong>4.8</strong> 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</p>
<p><strong>4.9</strong> 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</p>
<p><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>3.1 描述如何只用一个数组来实现三个栈。</strong></p>
<p>这个问题的难易程度取决于每个栈是<em>固定分割</em> 还是 <em>动态分割</em>。</p>
<ul>
<li><strong>固定分割</strong>：也就是每个栈分配固定大小的空间。这是最简单的实现方法，但是效率不高，因为即使某个栈是空的，它的空间也不能被别的栈使用。下面是每个栈占数组1/3的实现代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100</span>;  <span class="comment">// 每个栈的大小</span></span><br><span class="line">	<span class="keyword">int</span> tops[<span class="number">3</span>];                  <span class="comment">// 3个栈的栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>*size];              <span class="comment">// 共享的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">absTopOfStack</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// 返回栈顶指针在数组中的绝对量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">		tops[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::absTopOfStack(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> flag * size + tops[flag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tops[flag] == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(tops[flag]+<span class="number">1</span> &gt;= size) <span class="comment">/*检查有无空闲空间*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Out of space.\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		++tops[flag];</span><br><span class="line">		arr[absTopOfStack(flag)] = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = arr[absTopOfStack(flag)];</span><br><span class="line">	arr[absTopOfStack(flag)] = <span class="number">0</span>;   <span class="comment">/*清零*/</span></span><br><span class="line">	--tops[flag];  <span class="comment">/*指针自减*/</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> arr[absTopOfStack(flag)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>动态分割</strong>：允许栈的大小灵活可变，要实现起来难度有点大。</p>
<ul>
<li><p><strong>思路一</strong>：我们可以先考虑<em>用一个数组实现两个栈</em>，思路很简单：分别用数组的两端作为两个栈的起点，向中间扩展，若两个栈中的元素总和不超过n，两个栈不会重叠。基于同样的想法，我们可以把第三个栈实现在数组的中部，当前两个栈中有一个满了（即将重叠第三个栈时），平移第三个栈以扩展栈空间。这种方法由于需要搬移元素所以效率不高。</p>
</li>
<li><p><strong>思路二</strong>：链式栈。通过链表的方式来实现栈，如下图：</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150407021806320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>链式栈</strong>是在一个数组上实现多个栈（3个、4个、5个…）的通用解决方案。下面是示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;       <span class="comment">// 存储关键字</span></span><br><span class="line">	<span class="keyword">int</span> preIndex;  <span class="comment">// 记录上一个元素的位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> top1, top2, top3;</span><br><span class="line">	<span class="keyword">int</span> array_size;  <span class="comment">// 数组的大小，即栈的最大容量</span></span><br><span class="line">	<span class="keyword">int</span> current_ptr; <span class="comment">// 下一个元素入栈的位置</span></span><br><span class="line">	Node* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stacks(<span class="keyword">int</span> size);</span><br><span class="line">	~Stacks();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;  <span class="comment">// flag用0,1,2分别表示对3个栈进行操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stacks::Stacks(<span class="keyword">int</span> size):array_size(size),</span><br><span class="line">	top1(-<span class="number">1</span>),top2(-<span class="number">1</span>),top3(-<span class="number">1</span>),current_ptr(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arr = <span class="keyword">new</span> Node[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stacks::~Stacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stacks::isEmpty(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> top1 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> top2 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> top3 == -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error flag of stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stacks::push(<span class="keyword">int</span> value, <span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(current_ptr == array_size) <span class="comment">// 栈已满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is full.\n"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		arr[current_ptr].key = value;</span><br><span class="line">		<span class="keyword">switch</span> (flag)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top1;</span><br><span class="line">			top1 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top2;</span><br><span class="line">			top2 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			arr[current_ptr].preIndex = top3;</span><br><span class="line">			top3 = current_ptr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++current_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::pop(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(isEmpty(flag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		value = arr[top1].key;</span><br><span class="line">		top1 = arr[top1].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		value = arr[top2].key;</span><br><span class="line">		top2 = arr[top2].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		value = arr[top3].key;</span><br><span class="line">		top3 = arr[top3].preIndex;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stacks::top(<span class="keyword">int</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top1].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top2].key;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[top3].key;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.2 请设计一个栈，除pop与push方法，还支持min方法，可返回栈元素中的最小值。pop、push和min三个方法的时间复杂度必须为O(1)。</strong></p>
<p>通常来说<code>pop</code>和<code>push</code>方法的时间复杂度就是O(1)，关键是<code>min</code>方法。</p>
<p>可能有人会想 在Stack类里添加一个int型的变量用来记录最小值。当新元素入栈时，比较新元素与最小值，若新元素更小则更新最小值，此时<code>push</code>的时间效率是O(1)；但是当 minValue 出栈时，我们需要遍历整个栈，找出新的最小值，此时<code>pop</code>操作的时间效率就不符合O(1)的要求了。</p>
<ul>
<li><strong>思路一</strong>：记录每种状态下的最小值。通过给栈元素增加一个 min 字段，每个元素在入栈时记录当前状态下的最小值。这么一来，要找到最小值，直接查看栈顶元素的 min 就行了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	node n;</span><br><span class="line">	n.value = v;</span><br><span class="line">	n.min = v &lt; min() ? v : min();</span><br><span class="line">	s.push(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> top = s.top().value;</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> s.top().min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：利用辅助栈保存最小值。这种方法比思路一更节省空间一些 ———— 因为思路一中每个栈元素都要记录 min，而使用辅助栈，当入栈元素大于当前最小值时，不需要记录。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_s;  <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现***********/</span></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(v &lt;= min())</span><br><span class="line">		min_s.push(v);</span><br><span class="line">	s.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> top = s.top();</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="keyword">if</span>(top == min())</span><br><span class="line">		min_s.pop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::min()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(min_s.empty())</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> min_s.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong> 3.3 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）</strong></p>
<p>根据题意，<code>SetOfStacks</code>中应该有一个栈数组，而<code>push</code>和<code>pop</code>都是操作栈数组中的最后一个栈。入栈时若最后一个栈被填满，就需新建一个栈；出栈后若最后一个栈为空，就必须从栈数组中移除这个栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SetOfStacks</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; stacks;</span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 一个栈的最大存储量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SetOfStacks(<span class="keyword">int</span> cap);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********实现**********/</span></span><br><span class="line">SetOfStacks::SetOfStacks(<span class="keyword">int</span> cap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;capacity = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SetOfStacks::push(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!stacks.empty() &amp;&amp; stacks.back().size() &lt; capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		stacks.back().push(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 必须新建一个栈</span></span><br><span class="line">		s.push(v);</span><br><span class="line">		stacks.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SetOfStacks::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(stacks.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to pop an empty stack.\n"</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value = stacks.back().top();</span><br><span class="line">	stacks.back().pop();</span><br><span class="line">	<span class="keyword">if</span>(stacks.back().empty())</span><br><span class="line">		stacks.pop_back();  <span class="comment">// 移除</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶：实现一个popAt(int index)方法，根据指定的子栈，执行 pop 操作。</strong></p>
<p>设想当弹出 栈1 的栈顶元素时，我们需要移出 栈2 的栈底元素，并将其推到栈1中。随后，将栈3的栈底元素推入栈2，将栈4的栈底元素推入栈3，以此类推。</p>
<p>有人可能会说，没必要执行“推入”操作，有些栈不填满也可以啊！而且还降低了时间复杂度。但是若之后有人假定所有的栈（最后一个栈除外）都是填满的，就可能出现意想不到的 error！这个问题并没有“标准答案”，你应该跟面试官讨论各种做法的优劣。</p>
<p><br><br><strong>3.4 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：</strong></p>
<ul>
<li><strong>每次只能移动一个盘子</strong></li>
<li><strong>盘子只能从柱子顶端滑出移到下一根柱子</strong></li>
<li><strong>盘子只能叠在比它大的盘子上</strong></li>
</ul>
<p><strong>请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。</strong></p>
<p><img src="http://img.blog.csdn.net/20150407021526401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>首先我们从最简单的开始整理自己的思路：</p>
<ul>
<li>当<code>n=1</code>时，因为只有一个盘子，所以可以直接将盘子1从柱1移至柱3.</li>
<li>当<code>n=2</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1从柱1移至柱2。</li>
<li>将盘子2从柱1移至柱3。</li>
<li>将盘子1从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=3</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将上面两个盘子从柱1移至柱2，同上。</li>
<li>将盘子3移至柱3。</li>
<li>将盘子1、2从柱2移至柱3。</li>
</ol>
</li>
<li>当<code>n=4</code>时，可以这样将所有盘子从柱1移至柱3：<ol>
<li>将盘子1、2、3移至柱2，具体做法参见前面。</li>
<li>将盘子4移至柱3。</li>
<li>将盘子1、2、3移至柱3。</li>
</ol>
</li>
</ul>
<p>把柱1上的盘子移至柱3，需要柱2作为缓冲。可以看出，上面的过程是递归的，很自然地就可以导出递归算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Tower</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; disks;  <span class="comment">// 用整数的大小表示盘子的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> d)</span></span>;             <span class="comment">// 向柱子上添加盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveButtomTo</span><span class="params">(Tower &amp;t)</span></span>; <span class="comment">// 移动最下面那块盘子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveDisks</span><span class="params">(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span></span>;  <span class="comment">// 利用buf将n块盘子移至dest</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************实现*********************/</span></span><br><span class="line"><span class="keyword">void</span> Tower::add(<span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!disks.empty() &amp;&amp; disks.top() &lt;= d) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error placing disk "</span> &lt;&lt; d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		disks.push(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Tower::moveButtomTo(Tower &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> top = disks.top();</span><br><span class="line">	disks.pop();</span><br><span class="line">	t.add(top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现 —— 注意使用引用</span></span><br><span class="line"><span class="keyword">void</span> Tower::moveDisks(<span class="keyword">int</span> n, Tower &amp;dest, Tower &amp;buf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/*将上面的n-1块盘子移至缓冲区*/</span></span><br><span class="line">		moveDisks(n-<span class="number">1</span>, buf, dest);</span><br><span class="line">		<span class="comment">/*将最下面那块盘子移至目的地*/</span></span><br><span class="line">		moveButtomTo(dest);</span><br><span class="line">		<span class="comment">/*将缓冲区的n-1块盘子移至目的地*/</span></span><br><span class="line">		buf.moveDisks(n-<span class="number">1</span>, dest, *<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************测试*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tower tower[<span class="number">3</span>];  <span class="comment">// 3根柱子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">		tower[<span class="number">0</span>].add(i);</span><br><span class="line">	<span class="comment">// 移动</span></span><br><span class="line">	tower[<span class="number">0</span>].moveDisks(<span class="number">5</span>, tower[<span class="number">2</span>], tower[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.5 实现一个MyQueue类，该类用两个栈来实现一个队列。</strong></p>
<p>队列和栈的主要区别就是元素进出顺序。假设两个栈分别是 Newest 和 Oldest，为了用这两个栈达到先进先出（FIFO）的效果，在入队时我们将元素压入 Newest 栈，然后将 Newest 的元素弹出，压入 Oldest 栈中（这样就达到了反转的效果），在出队时，我们从 Oldest 栈中弹出元素。</p>
<p>注意，为了避免频繁的执行从 Newest 到 Oldest 的反转操作，我们规定：只有在发现 Oldest 为空时，才执行反转操作 —— 将 Newest 中的所有元素弹出并压入 Oldest 中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Newest;  <span class="comment">// 新入队的元素</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Oldest;  <span class="comment">// 准备出队的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverseStacks</span><span class="params">()</span></span>;  <span class="comment">// 将Newest元素弹出，压入Oldest </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;           <span class="comment">// 队列大小</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span></span>;  <span class="comment">// 入队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span>;        <span class="comment">// 出队</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>;            <span class="comment">// 队首元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Oldest为空才进行反转，避免频繁操作</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::reverseStacks()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Oldest.empty())  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!Newest.empty()) &#123;</span><br><span class="line">			Oldest.push(Newest.top());</span><br><span class="line">			Newest.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Oldest.size()+Newest.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入Newest，最新元素始终位于它的顶端</span></span><br><span class="line"><span class="keyword">void</span> MyQueue::enqueue(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">	Newest.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Oldest出队</span></span><br><span class="line"><span class="keyword">int</span> MyQueue::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">int</span> value = Oldest.top();</span><br><span class="line">	Oldest.pop();</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyQueue::top()</span><br><span class="line">&#123;</span><br><span class="line">	reverseStacks();</span><br><span class="line">	<span class="keyword">return</span> Oldest.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>3.6 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek和isEmpty。</strong></p>
<p>可以想到的一种做法是，搜索整个栈，找出最小元素，将其压入另一个栈；然后，在剩余元素中找出最小的，并将其入栈。但这种做法实际上需要两个额外的栈，一个用来存放最终的有序序列，一个在搜索时用作缓冲区。</p>
<p>那么，只使用一个额外的栈怎么做呢？可以从S1逐一弹出元素，然后按顺序插入S2中，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150407021739968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>S1是未排序的，S2是排好序的：</p>
<ul>
<li><p>从S1中弹出5，我们需要在S2中找到合适的位置插入这个数，所以将 12 和 8 移至 S1 中，然后将 5 压入 S2。</p>
</li>
<li><p>那么 8 和 12 需不需要移回 S2 呢？其实不需要，对于这两个数，我们可以像处理 5 那样重复相关步骤就可以了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Sort(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = s.top();</span><br><span class="line">		s.pop();          <span class="comment">// 弹出元素存到临时变量</span></span><br><span class="line">		<span class="keyword">while</span>(!r.empty() &amp;&amp; r.top() &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(r.top());</span><br><span class="line">			r.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		r.push(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>3.7 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 enqueue、dequeueAny、dequeueDog 和 dequeueCat 等。</strong></p>
<p><strong>思路一</strong>：只维护一个队列。那么 dequeueAny 就容易实现，而 dequeueDog 和 dequeueCat 就需迭代访问整个队列，找到第一只被收养的狗或猫。这种解法明显效率不高。</p>
<p><strong>思路二</strong>：为猫和狗各维护一个队列。那么 dequeueDog 和 dequeueCat 很容易实现，而 dequeueAny 需要比较猫队列与狗队列的队首，看哪个“更老”。为了方便 dequeueAny 的实现，我们给每个动物加一个额外的变量，以标记进入队列的先后顺序。这种解法显然更简单更高效！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> order;    <span class="comment">// 标记先后顺序</span></span><br><span class="line">	Animal(<span class="built_in">string</span> s):name(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******* 狗 *******/</span></span><br><span class="line"><span class="keyword">class</span> Dog : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dog(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* 猫 *******/</span></span><br><span class="line"><span class="keyword">class</span> Cat : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cat(<span class="built_in">string</span> s):Animal(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******队列*******/</span></span><br><span class="line"><span class="keyword">class</span> Queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;Dog&gt; dogs;</span><br><span class="line">	<span class="built_in">list</span>&lt;Cat&gt; cats;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue():order(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Dog d)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		d.order = order++;</span><br><span class="line">		dogs.push_back(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Cat c)</span>  <span class="comment">// 重载</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		c.order = order++;</span><br><span class="line">		cats.push_back(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Dog <span class="title">dequeueDog</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Dog d = dogs.front();</span><br><span class="line">		dogs.pop_front();</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Cat <span class="title">dequeueCat</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Cat c = cats.front();</span><br><span class="line">		cats.pop_front();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Animal <span class="title">dequeueAny</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dogs.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">		<span class="keyword">if</span>(cats.size() == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dogs.front().order &lt; cats.front().order)</span><br><span class="line">			<span class="keyword">return</span> dequeueDog();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> dequeueCat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br></p>
<hr>
<p><strong>下面的题是关于树或图，做下面的题之前，首先我们要能够创建一棵二叉树或一个图：</strong></p>
<ul>
<li><strong>创建二叉树</strong>：二叉树是什么相信就不用我多说了，可以递归地根据输入创建一棵二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">&#125; *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归地创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		T = NULL;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = x;</span><br><span class="line">	createBinaryTree(T-&gt;left);</span><br><span class="line">	createBinaryTree(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	createBinaryTree(T); </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>创建二叉查找树</strong>： 可以由一个数组生成一棵二叉查找树，见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757" target="_blank" rel="external">二叉查找树（BST）</a>》。</p>
</li>
<li><p><strong>创建图</strong>：图有两种存储方式，邻接矩阵和邻接表，这里采用邻接表来创建图。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Graph  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">int</span> V;                         <span class="comment">// 顶点数  </span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;                <span class="comment">// 邻接表  </span></span><br><span class="line"> </span><br><span class="line">	Graph(<span class="keyword">int</span> V);                  <span class="comment">// 构造函数  </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;    <span class="comment">// 向图中添加边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span>  </span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;  </span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加边，构造邻接表 */</span>  </span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)  </span><br><span class="line">&#123;  </span><br><span class="line">	adj[v].push_back(w);          <span class="comment">// 将w添加到v的链表  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><strong>4.1 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。</strong></p>
<p>本题明确地给出了平衡树的定义，我们的解法就是根据定义直接递归检查每棵子树的高度。代码中的 checkHeight 方法以递归方式获取左右子树的高度。若子树是平衡的，返回该子树的实际高度；若子树不平衡，返回-1，这时所有递归都会立即返回：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line"> * 平衡返回高度，不平衡返回-1</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查左子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> leftHeight = checkHeight(T-&gt;left);</span><br><span class="line">	<span class="keyword">if</span>(leftHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查右子树是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> rightHeight = checkHeight(T-&gt;right);</span><br><span class="line">	<span class="keyword">if</span>(rightHeight == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查当前结点是否平衡 */</span></span><br><span class="line">	<span class="keyword">int</span> diff = leftHeight&gt;rightHeight ? </span><br><span class="line">		leftHeight-rightHeight : rightHeight-leftHeight;</span><br><span class="line">	<span class="keyword">if</span>(diff &gt; <span class="number">1</span>)  <span class="comment">// 不平衡，返回-1</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>          <span class="comment">// 平衡，返回高度</span></span><br><span class="line">		<span class="keyword">return</span> leftHeight&gt;rightHeight ? leftHeight+<span class="number">1</span> : rightHeight+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkHeight(T) == -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.2 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。</strong></p>
<p>只需通过图的遍历，比如深度优先搜索或广度优先搜索，就能解决这个问题。</p>
<p>我们从其中一个结点出发，在遍历过程中检查是否找到另一个结点。在这个算法中，访问过的结点都应标记为“已访问”，以免循环和重复访问结点。下面的示例代码使用了广度优先搜索：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPathExist</span><span class="params">(Graph g, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;  <span class="comment">// 当做队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> V = g.getVertexNum();  <span class="comment">// 顶点个数</span></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)  </span><br><span class="line">		visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">	visited[start] = <span class="keyword">true</span>; <span class="comment">// 将当前顶点标记为已访问并压入队列</span></span><br><span class="line">	<span class="built_in">queue</span>.push_back(start);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node = <span class="built_in">queue</span>.front(); <span class="comment">// 出队</span></span><br><span class="line">		<span class="built_in">queue</span>.pop_front();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=g.adj[node].begin(); i!=g.adj[node].end(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[*i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(*i == end)  <span class="comment">// 是否等于另一个结点</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">					<span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.3 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。</strong></p>
<p>要让二叉查找树的高度最小，就必须让左右子树的结点数越接近越好。根据二叉查找树的性质（中序遍历的序列是一个递增的有序序列），可以让该数组中间的值成为根节点，前半区间成为左子树，后半区间成为右子树。然后，每一个区间中间的值又成为子树的根节点，以此类推。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* createMinBST(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &gt; high)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span> NULL; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">	TreeNode* T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	T-&gt;data = A[mid];</span><br><span class="line">	T-&gt;left = createMinBST(A, low, mid-<span class="number">1</span>);</span><br><span class="line">	T-&gt;right = createMinBST(A, mid+<span class="number">1</span>, high);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>4.4 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。</strong></p>
<p>根据题意，你可能认为这个问题需要一层一层遍历，每一层构成一个链表。但其实可以用任意方式遍历树，只要记住结点位于哪一层即可。</p>
<p>下面是使用先序遍历实现的一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLevelLists</span><span class="params">(BiTree T, <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;TreeNode*&gt;&gt; &amp;lists, <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)   <span class="comment">/*递归终止条件*/</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lists.size() &lt;= level)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>&lt;TreeNode*&gt; lst;</span><br><span class="line">		lst.push_back(T);</span><br><span class="line">		lists.push_back(lst);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		lists.at(level).push_back(T);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	createLevelLists(T-&gt;left, lists, level+<span class="number">1</span>);  <span class="comment">// 左子树</span></span><br><span class="line">	createLevelLists(T-&gt;right, lists, level+<span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以使用其他遍历方式，比如层序遍历、广度优先搜索。</p>
<p><br><br><strong>4.5 实现一个函数，检查一棵二叉树是否为二叉查找树。</strong></p>
<ul>
<li><strong>思路一</strong>：检查中序序列是否是升序。这是二叉查找树的性质，但<strong>需要注意的是</strong>，这种方法无法正确处理树中的重复值。若假定这棵树不包含重复值，则这种方法是有效的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inOrder</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*检查左子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;left, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查当前结点*/</span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= last)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	last = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查右子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(!inOrder(T-&gt;right, last))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = INT_MIN;</span><br><span class="line">	<span class="keyword">return</span> inOrder(T, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路二</strong>：自上而下传递最小和最大值，判断每个结点是否在范围内。假定根结点的值是20，最开始的范围是（<code>INT_MIN</code>,<code>INT_MAX</code>），根结点明显在这个范围内。然后判断左孩子是否在（<code>INT_MIN</code>, 20）这个范围内，右孩子是否在（20 ,<code>INT_MAX</code>）这个范围内。以此类推，递归下去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)  <span class="comment">/*递归终止条件*/</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt;= min || T-&gt;data &gt; max)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!checkBST(T-&gt;left,min,T-&gt;data) || !checkBST(T-&gt;right,T-&gt;data,max))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(BiTree T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> checkBST(T, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.6 设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。</strong></p>
<p>见《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/42592757#t2" target="_blank" rel="external">BST的前驱与后继</a>》，本题要求的是中序遍历中的后继结点。求一个结点 x 的后继，有两种情况：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继是右子树中值最小的结点，即右子树最左边的结点。</p>
</li>
<li><p>若结点 x 的右子树为空，表示已遍访 x 的子树。我们必须回到 x 的父结点，记父结点为 p ：</p>
<ul>
<li><p>如果 x 是 p 的左儿子，那么下一个要访问的结点就是 p ；</p>
</li>
<li><p>如果 x 是 p 的右儿子，表示已遍访 p 的子树，这时需从 p 往上继续访问，直到遇到一个祖先结点 pp，它的左儿子也是结点 x 的祖先。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* successor_BST(TreeNode* n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* tmp = n-&gt;right;</span><br><span class="line">		<span class="keyword">while</span>(tmp-&gt;left!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* p = n-&gt;parent;</span><br><span class="line">		<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right==n)</span><br><span class="line">		&#123;</span><br><span class="line">			n = p;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.7 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。</strong></p>
<p>我们在解题之前应该先要问问面试官，这棵树的结点是否包含指向父结点的指针。</p>
<ul>
<li><p><strong>情况一</strong>：如果每个结点中包含指向父结点的指针，那么就可以直接向上追踪 p 和 q 的路径，直到两者相交。当然，在向上追踪的过程中我们需要标记结点是否已经被访问过，比如可以给结点添加<code>isVisited</code>域、或者将已访问结点映射到散列表。</p>
</li>
<li><p><strong>情况二</strong>：如果结点不包含指向父结点的指针，又不得将额外的结点储存在另外的数据结构中。那么我们的做法就是：从上向下判断，若 p 和 q 都在某结点的左边，就到左子树中查找共同祖先；若都在该结点的右边，则在右子树中查找共同祖先。要是 p 和 q 不在同一边，那么就表示已经找到第一个共同祖先了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若p为root的子孙，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(root == p)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> cover(root-&gt;left, p) || cover(root-&gt;right, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* getCommonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	<span class="keyword">if</span>(T == p || T == q)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> pAtLeft = cover(T-&gt;left, p);</span><br><span class="line">	<span class="keyword">bool</span> qAtLeft = cover(T-&gt;left, q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*若p和q不在同一边，则表示已经找到第一个共同祖先*/</span></span><br><span class="line">	<span class="keyword">if</span>(pAtLeft != qAtLeft)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="comment">/*若在同一边，遍访那一边*/</span></span><br><span class="line">	TreeNode* child = pAtLeft ? T-&gt;left : T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(child, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* commonAncester(BiTree T, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cover(T, p) || !cover(T, q))  <span class="comment">// --错误检查--</span></span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> getCommonAncester(T, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>4.8 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）</strong></p>
<p>首先考虑小数据量的情况，可以求出两棵树的前序和中序遍历序列，若 T2 前序遍历是 T1 前序遍历的子串，并且 T2 中序遍历是 T1 中序遍历的子串，则 T2 为 T1 的子树。假设T1的节点数为 N，T2的节点数为 M。遍历两棵树的时间复杂度是 O(N + M)， 判断字符串是否为另一个字符串的子串的复杂性也是 O(N + M)（比如使用KMP算法）。所以总的时间复杂度是<code>O(N+M)</code>，所需的空间也是<code>O(N+M)</code>。———— 这里需要注意一点：对于左结点或者右结点为 null 的情况，需要在字符串中插入特殊字符表示。</p>
<p>对于简单的情形，上面的解法还算不错。但是当数据量非常大时，暂存前序和中序序列可能要占用太多的内存，所以我们考虑另一种解法：遍历 T1，每当 T1 的某个节点与 T2 的根节点值相同时，就判断两棵子树是否相同。假设 T2 的根节点在 T1 中出现了 k 次，那么算法的时间复杂度就是<code>O(N + k*M)</code>，最坏情况下是<code>O(N*M)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配两棵子树，完全一样返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL &amp;&amp; t2 == NULL) <span class="comment">/*若两者都为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL || t2 == NULL) <span class="comment">/*若只有一个为空*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data != t2-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> matchTree(t1-&gt;left,t2-&gt;left) &amp;&amp; matchTree(t1-&gt;right,t2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历大树t1，当某个结点与t2根结点相同，matchTree判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1 == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">/*大的树已经空了，还未找到子树*/</span></span><br><span class="line">	<span class="keyword">if</span>(t1-&gt;data == t2-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(matchTree(t1, t2))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subTree(t1-&gt;left, t2) || subTree(t1-&gt;right, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containTree</span><span class="params">(BiTree t1, BiTree t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t2 == NULL)  <span class="comment">/*空树一定是子树*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">	<span class="keyword">return</span> subTree(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的两种解法，哪种解法比较好呢？</p>
<ul>
<li><p>方法一会占用 O(N + M) 的内存，而另外一种解法只会占用 O(logN + logM) 的内存（递归的栈内存）。当考虑扩展性时，内存使用的多寡是个很重要的因素。</p>
</li>
<li><p>方法一的时间复杂度为O(N + M)，方法二最差的时间复杂度是O(N*M)。但是最差情况的时间复杂度并没有代表性，我们需要进一步观察，因为更可能的情况是很早就发现两棵树的不同，早早的退出了 matchTree。</p>
</li>
</ul>
<p>总的来说，在空间效率上，第二种解法更好。在时间上，需要通过实际数据来验证。</p>
<p><br><br><strong>4.9 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。</strong></p>
<p>下面我们采用简化推广法来解题。</p>
<p><strong>Step 1 </strong>： 简化——假设路径必须从根节点开始，但可以在任意结点结束，该怎么解决？</p>
<p>在这种情况下，问题就会变得容易很多。我们可以从根节点开始，向下访问子节点，计算每条路径上到当前节点为止的数值总和，若与给定值相同则打印当前路径。注意，就算找到总和，仍要继续访问这条路径（因为可能存在正负相抵消的情况）。</p>
<p><strong>Step 2 </strong>： 推广——路径可从任意结点开始</p>
<p>如果路径可以从任意结点开始，在任意结点结束。在这种情况下我们稍作调整，对于每个结点，都向“上”检查是否有总和为 sum 的路径。具体来讲就是：递归访问每个结点 p 时，我们将 root 到 p 的完整 path 传入函数；然后，函数会从 p 到 root 逆序将结点上的值加起来，当每条子路径的总和等于 sum 时，打印该条子路径。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印从start到end的路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> path[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求一棵子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == NULL)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> leftDepth = depth(n-&gt;left);</span><br><span class="line">		<span class="keyword">int</span> rightDepth = depth(n-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> leftDepth&gt;rightDepth ? leftDepth+<span class="number">1</span> : rightDepth+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum, <span class="keyword">int</span> path[], <span class="keyword">int</span> level)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*将当前结点插入路径*/</span></span><br><span class="line">	path[level] = T-&gt;data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从当前结点到root结点，看是否存在和为sum的路径*/</span></span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		t += path[i];</span><br><span class="line">		<span class="keyword">if</span>(t == sum)</span><br><span class="line">			print(path, i, level);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*递归*/</span></span><br><span class="line">	findSum(T-&gt;left, sum, path, level+<span class="number">1</span>);</span><br><span class="line">	findSum(T-&gt;right, sum, path, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSum</span><span class="params">(BiTree T, <span class="keyword">int</span> sum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = depth(T);</span><br><span class="line">	<span class="keyword">int</span> *path = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(dep*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	findSum(T, sum, path, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(path);<span class="comment">/*释放内存*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="3、栈与队列">3、栈与队列</h3><p><strong>3.1</strong> 描述如何只用一个数组来实现三个栈。</p>
<p><strong>3.2</strong> 请设计一个栈，除<code>pop</code>与<code>push</code>方法，还支持<code>min</code>方法，可返回栈元素中的最小值。<code>pop</code>、<code>push</code>和<code>min</code>三个方法的时间复杂度必须为<code>O(1)</code>。</p>
<p><strong>3.3</strong> 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cracking the Coding Interview 150题（一）]]></title>
    <link href="http://yoursite.com/2015/03/16/cracking-the-coding-interview-01/"/>
    <id>http://yoursite.com/2015/03/16/cracking-the-coding-interview-01/</id>
    <published>2015-03-16T15:50:18.000Z</published>
    <updated>2015-05-10T11:14:29.828Z</updated>
    <content type="html"><![CDATA[<h3 id="1、数组与字符串">1、数组与字符串</h3><p><strong>1.1</strong> 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p>
<p><strong>1.2</strong> 用C或C++实现<code>void reverse(char* str)</code>函数，即反转一个null结尾的字符串。</p>
<p><strong>1.3</strong> 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>1.4</strong> 编写一个方法，将字符串中的空格全部替换为“%20”。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。示例：输入<code>Mr John Smith</code>，输出<code>Mr%20John%20Smith</code>。<a id="more"></a></p>
<p><strong>1.5</strong> 利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。</p>
<p><strong>1.6</strong> 给定一幅由 N x N 矩阵表示的图像，其中每个像素的大小为 4 字节，编写一个方法，将图像旋转90度。不占用额外内存空间能否做到？</p>
<p><strong>1.7</strong> 编写一个算法，若 M x N 矩阵中某个元素为0，则将其所在的行与列清零。</p>
<p><strong>1.8</strong> 假定有一个方法<code>isSubstring</code>，可检查一个单词是否为其他字符串的子串。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成，要求只能调用一次<code>isSubstring</code>。（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串。）</p>
<p><br><br></p>
<h3 id="2、链表">2、链表</h3><p><strong>2.1</strong> 编写代码，移除未排序链表中的重复结点。如果不得使用临时缓冲区，又该怎么解决？</p>
<p><strong>2.2</strong> 实现一个算法，找出单向链表中倒数第 k 个结点。</p>
<p><strong>2.3</strong> 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。示例：</p>
<ul>
<li>输入：单向链表<code>a-&gt;b-&gt;c-&gt;d-&gt;e</code>中的结点c</li>
<li>结果：不返回任何数据，但该链表变为<code>a-&gt;b-&gt;d-&gt;e</code>。</li>
</ul>
<p><strong>2.4</strong> 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前。</p>
<p><strong>2.5</strong> 给定两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。示例：</p>
<ul>
<li>输入：（<code>7-&gt;1-&gt;6</code>）+（<code>5-&gt;9-&gt;2</code>），即 617+295</li>
<li>输出：<code>2-&gt;1-&gt;9</code>，即 912</li>
</ul>
<p>假设这些数位是正向存放的，请再做一遍。示例：</p>
<ul>
<li>输入：（<code>6-&gt;1-&gt;7</code>）+（<code>2-&gt;9-&gt;5</code>），即 617+295</li>
<li>输出：<code>9-&gt;1-&gt;2</code>，即 912</li>
</ul>
<p><strong>2.6</strong> 给定一个有环链表，实现一个算法返回环路的开头结点。有环链表的定义：在链表中某个结点的 next 元素指向在它前面出现过的结点，则表明该链表存在环路。示例：</p>
<ul>
<li>输入：<code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>（C结点出现了两次）</li>
<li>输出：C</li>
</ul>
<p><strong>2.7</strong> 编写一个函数，检查链表是否为回文。</p>
<p><br><br><br><br><br><br><br><br><br><br></p>
<h3 id="参考答案（C++）">参考答案（C++）</h3><hr>
<p><strong>1.1</strong> 如果允许使用数据结构，我首先想到的是<code>map</code>，下标操作<code>map[&#39;key&#39;]</code>在 key 存在时执行搜索操作，否则执行插入操作。示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; amap;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		amap[A[i]] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator beg = amap.begin();</span><br><span class="line">	<span class="keyword">for</span>(;beg!=amap.end(); ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(beg-&gt;second &gt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不允许使用额外的数据结构，该如何处理呢？假定字符集为 ASCII，那么我们可以创建一个标记数组，索引 i 对应的 bool 值指示该字符串是否含有字母表第 i 个字符。若这个字符第二次出现，则立即返回 false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">int</span> len)</span>   <span class="comment">// 假定字符集为 ASCII</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">256</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> char_set[<span class="number">256</span>] = &#123;<span class="keyword">false</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(char_set[A[i]]) <span class="comment">// 字符已经出现过</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		char_set[A[i]] = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.2</strong> 根据函数的原型<code>void reverse(char* str)</code>，我们并不知道字符串的长度，所以需要先求出长度再进行反转：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* tmp = str;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*tmp++ != <span class="string">'\0'</span>)  <span class="comment">// 求出字符串的长度</span></span><br><span class="line">		++len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> high = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)    <span class="comment">// 反转</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c = str[low];</span><br><span class="line">		str[low] = str[high];</span><br><span class="line">		str[high] = c;</span><br><span class="line">		++low;</span><br><span class="line">		--high;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.3</strong> 由题意可知，这是一个变位词的问题，可以看我的另一篇文章《<a href="http://blog.csdn.net/lisonglisonglisong/article/details/28705787" target="_blank" rel="external">变位词问题</a>》。通常的做法是把两个字符串按字母表顺序排序，比较排序后的字符串是否相等：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> i, <span class="keyword">char</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.length() != s2.length())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 泛型算法 sort() 采用的是快速排序算法</span></span><br><span class="line">	sort(s1.begin(), s1.end(), myfunction);</span><br><span class="line">	sort(s2.begin(), s2.end(), myfunction);</span><br><span class="line">	<span class="keyword">if</span>(!s1.compare(s2))  <span class="comment">// 相等返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一种方法就是：检查两个字符串的各字符数是否相同。（假定字符集为ASCII）我们只需创建一个大小 256 的整型数组，遍历第一个字符串，给每个字符计数；遍历第二个字符串，递减对应字符的数量。最后判断数组元素是否全部为0。</p>
<p><br><br><strong>1.4</strong> 本题的思路就是进行两次扫描。第一次扫描记录字符串中有多少空格，从而计算最终字符串的长度；第二次扫描从后往前移动字符并插入20%。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">			++spaceNum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> newLen = len + spaceNum*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] != <span class="string">' '</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			str[newLen - <span class="number">1</span>] = str[i];</span><br><span class="line">			newLen = newLen - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[newLen - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">			str[newLen - <span class="number">2</span>] = <span class="string">'2'</span>;</span><br><span class="line">			str[newLen - <span class="number">3</span>] = <span class="string">'%'</span>;</span><br><span class="line">			newLen = newLen - <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.5</strong> 本题思路很简单：遍历字符串，将字符和对应的重复次数拷贝到新字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int转string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">stringstream</span> ss;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	ss &lt;&lt; n;</span><br><span class="line">	ss &gt;&gt; str;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">compress</span><span class="params">(<span class="built_in">string</span> str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> tmp;</span><br><span class="line">	<span class="keyword">char</span> c = str[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;str.length(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == c)</span><br><span class="line">			++count;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmp = tmp + c + int2string(count);</span><br><span class="line">			c = str[i];</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp = tmp + c + int2string(count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> str.length()&gt;tmp.length() ? tmp:str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.6</strong> 归纳题意，简言之就是：对N阶方阵进行原地转置。（思路就是对每一层执行环状旋转，将上边移到右边、右边移到下边、下边移到左边、左边移到上边）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> **mtx, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> layer=<span class="number">0</span>; layer &lt; n/<span class="number">2</span>; ++layer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> first = layer;</span><br><span class="line">		<span class="keyword">int</span> last = n-<span class="number">1</span>-layer;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=first; i&lt;last; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> offset = i - first;</span><br><span class="line">			<span class="comment">// 暂存上边：top = mtx[first][i]</span></span><br><span class="line">			<span class="keyword">int</span> top = *((<span class="keyword">int</span>*)mtx+first*n+i);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 左到上：mtx[first][i] = mtx[last-offset][first]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+first*n+i) = *((<span class="keyword">int</span>*)mtx+(last-offset)*n+first);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 下到左：mtx[last-offset][first] = mtx[last][last-offset]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+(last-offset)*n+first) = *((<span class="keyword">int</span>*)mtx+last*n+(last-offset));</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 右到下：mtx[last][last-offset] = mtx[i][last]</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+last*n+(last-offset)) = *((<span class="keyword">int</span>*)mtx+i*n+last);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 上到右：mtx[i][last] = top</span></span><br><span class="line">			*((<span class="keyword">int</span>*)mtx+i*n+last) = top;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意二维数组作参数传递的问题，另外调用的时候像这样<code>rotate((int**)A, 4)</code>。这个算法的时间复杂度为<code>O(n^2)</code>，已是最优的做法。</p>
<p><br><br><strong>1.7</strong> 这个问题貌似很简单，直接遍历嘛！只要发现为零的元素，就将其所在的行与列清零。不过这个方法有个陷阱：清零以后会导致连锁效应，最后整个矩阵都变成 0。我们的做法是：遍历两遍，第一遍记录要清零的行与列，第二遍再执行清零操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZero</span><span class="params">(<span class="keyword">int</span> **mtx, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> *row = <span class="keyword">new</span> <span class="keyword">bool</span>[m](); <span class="comment">// 默认初始化为false</span></span><br><span class="line">	<span class="keyword">bool</span> *col = <span class="keyword">new</span> <span class="keyword">bool</span>[n]();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(*((<span class="keyword">int</span>*)mtx+i*n+j) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				row[i] = <span class="keyword">true</span>;</span><br><span class="line">				col[j] = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(row[i] || col[j])</span><br><span class="line">			&#123;</span><br><span class="line">				*((<span class="keyword">int</span>*)mtx+i*n+j) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] row;</span><br><span class="line">	<span class="keyword">delete</span> [] col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>1.8</strong> 如果<code>x = wat</code>，<code>y = erbottle</code>，则<code>s1 = xy</code>，<code>s2 = yx</code>。不论x和y之间的分割点在何处，我们会发现<code>yx</code>肯定是<code>xyxy</code>的子串。即，s2总是s1s1的子串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRotation</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.length() == s2.length() &amp;&amp; s1.length()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> isSubstring(s1+s1, s2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br><br>在解决链表问题时，首先我们得学会<strong>如何创建链表</strong>，下面是单链表创建和打印的示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node </span><br><span class="line">&#123;</span><br><span class="line">	node* next;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据数组创建单链表：尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	node *head = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	node *s, *tail = head;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		s = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">		s-&gt;data = A[i++];</span><br><span class="line">		tail-&gt;next = s;</span><br><span class="line">		tail = s;</span><br><span class="line">	&#125;</span><br><span class="line">	tail-&gt;next = NULL;</span><br><span class="line">	<span class="keyword">return</span> head;  <span class="comment">/*头结点不保存数据*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(p!=NULL)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.1</strong> 要想移除链表中的重复结点，我们只需在遍历的过程中，将每个未重复结点加入一个缓冲区。若发现有结点在缓冲区已经存在（即重复），则将该结点从链表中移除。只需遍历一次即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; buffer;   <span class="comment">// 这里使用set容器</span></span><br><span class="line">	node *p = L-&gt;next;</span><br><span class="line">	node *pre = L;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> data = p-&gt;data;</span><br><span class="line">		<span class="keyword">if</span>(buffer.find(data) == buffer.end())</span><br><span class="line">		&#123;</span><br><span class="line">			buffer.insert(data);</span><br><span class="line">			pre = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">/* 重复 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;next = p-&gt;next;</span><br><span class="line">			node* q = p;  <span class="comment">// 记录删除的结点</span></span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(q);  <span class="comment">// 释放</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不借助额外的缓冲区，那么就只能两两比较以判断是否重复，时间复杂度为<code>O(n^2)</code>。需要使用两个指针来迭代：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == NULL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	node* current = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(current!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node* runner = current;</span><br><span class="line">		<span class="keyword">while</span>(runner-&gt;next!=NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(runner-&gt;next-&gt;data == current-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				node* p = runner-&gt;next;</span><br><span class="line">				runner-&gt;next = runner-&gt;next-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				runner = runner-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		current = current-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.2</strong> 本题有多种解法。</p>
<ul>
<li><p>解法一：有人可能首先会想到：这太简单了，先遍历一次链表获取长度 length，那么倒数第 k 个结点就是第 (length - k)个结点。但是，你觉得这会是面试官想要的答案吗？？</p>
</li>
<li><p>解法二：<strong>递归</strong>。先通过递归到达链表的末尾，然后从后往前进行计数，每次递归调用返回时，将计数器加1。当计数器等于 k 时，访问的就是链表倒数第 k 个元素。（注意计数器 i 需要<strong>传引用</strong>）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node* kthToLast(node* head, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	node* p = kthToLast(head-&gt;next, k, i);</span><br><span class="line">	i = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法三：<strong>迭代法</strong>。相比于递归，迭代法通常不太直观但效率更高。思路就是：用两个指针 p1 和 p2 指向链表中两个距离为k的结点，然后以相同速度移动这两个指针，当其中一个指针指向链表的尾结点时，另一个指针指向的就是倒数第k个结点。（<strong>“快行指针”技巧</strong>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">node* kthToLast(LinkList L, <span class="keyword">int</span> k)    <span class="comment">// 时间复杂度O(n)，空间复杂度O(1)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个指针</span></span><br><span class="line">	node* p1 = L-&gt;next;</span><br><span class="line">	node* p2 = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p2向前移动k个结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k-<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p2 == NULL)  <span class="comment">/*错误检查*/</span></span><br><span class="line">			<span class="keyword">return</span> NULL;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p2 == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动p1与p2</span></span><br><span class="line">	<span class="keyword">while</span>(p2-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>2.3</strong>  本题中，你访问不到链表的首结点，只能访问待删除结点及之后的结点。所以我们的做法是：直接将后继结点的数据复制到当前结点，然后删除这个后继结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNode</span><span class="params">(node* c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==NULL || c-&gt;next==NULL) <span class="comment">// 尾结点无法删除</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	node* next = c-&gt;next;</span><br><span class="line">	c-&gt;data = next-&gt;data;</span><br><span class="line">	c-&gt;next = next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.4</strong> 链表不同于数组，在用现有元素创建新的链表时，我们不必移动和交换元素，只是改变元素的 next 指针的指向。所以本题的思路也很简单：遍历链表，将小于 x 的元素连接成一个链表，将大于等于 x 的元素连接成一个链表，最后合并两个链表即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">partition</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node* biggerHead = NULL;</span><br><span class="line">	node* biggerTail = NULL;</span><br><span class="line">	node* smallerHead = NULL;</span><br><span class="line">	node* smallerTail = NULL;</span><br><span class="line"></span><br><span class="line">	node* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		node* next = p-&gt;next;</span><br><span class="line">		p-&gt;next = NULL;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data &lt; x)</span><br><span class="line">		&#123;   <span class="comment">/*将比x小的结点插入smaller链表的尾部*/</span></span><br><span class="line">			<span class="keyword">if</span>(smallerHead == NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				smallerHead = p;</span><br><span class="line">				smallerTail = smallerHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				smallerTail-&gt;next = p;</span><br><span class="line">				smallerTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;   <span class="comment">/*将比x大的结点插入bigger链表的尾部*/</span></span><br><span class="line">			<span class="keyword">if</span>(biggerHead == NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				biggerHead = p;</span><br><span class="line">				biggerTail = biggerHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				biggerTail-&gt;next = p;</span><br><span class="line">				biggerTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*遍历结束，合并两个链表*/</span></span><br><span class="line">	<span class="keyword">if</span>(smallerHead == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;next = biggerHead;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	smallerTail-&gt;next = biggerHead;</span><br><span class="line">	L-&gt;next = smallerHead;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>2.5</strong>  本题的思路是逐个结点对应相加，然后判断是否进位。我们使用递归来模拟这个加法过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">add</span><span class="params">(LinkList L1, LinkList L2, <span class="keyword">int</span> carry)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/*两个链表全部为空且进位为0，则函数返回*/</span></span><br><span class="line">	<span class="keyword">if</span>(L1==NULL &amp;&amp; L2==NULL &amp;&amp; carry==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">	node* result = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> value = carry;</span><br><span class="line">	<span class="keyword">if</span>(L1!=NULL)</span><br><span class="line">		value+=L1-&gt;data;</span><br><span class="line">	<span class="keyword">if</span>(L2!=NULL)</span><br><span class="line">		value+=L2-&gt;data;</span><br><span class="line"></span><br><span class="line">	result-&gt;data = value%<span class="number">10</span>;  <span class="comment">/*取个位*/</span></span><br><span class="line"></span><br><span class="line">	node* more = add(L1==NULL?NULL:L1-&gt;next, </span><br><span class="line">    				L2==NULL?NULL:L2-&gt;next, </span><br><span class="line">                    value&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	result-&gt;next = more;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里<code>add</code>之后返回的链表没有“头指针”。</p>
<p><br><br><strong>2.6</strong> 这个问题是由经典面试题——<strong>检查链表是否存在回路</strong>——演变而来。</p>
<p><img src="http://img.blog.csdn.net/20150324231307367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图所示，如果链表中存在回路，那么我们遍历时会陷入死循环。那么，我们如何检测链表是否存在环 以及 寻找环的入口点呢？答案是<strong>“快慢指针”</strong>。</p>
<p>① 设置两个指针（fast、slow），初始值都指向头，slow每次前进一步，fast每次前进二步。如果链表存在环，则fast必定先进入环，而slow后进入环，两个指针必定相遇。这是<strong>检测</strong>。</p>
<p>② 在fast和slow第一次相遇的时候，假定slow走了n步，环路的入口是在p步，<br>   c为fast和slow相交点距离环路入口的距离。那么，slow走的路径： p+c ＝ n；<br>   fast走的路径： p+c+k*L = 2*n（L为环路的周长，k是整数），即n = k*L<br>   显然，如果从p+c点开始，slow再走n步的话，还可以回到p+c这个点。<br>   同时，fast从头开始走，步长为1，经过n步，也会达到p+c这点。<br>   显然，在这个过程中fast和slow只有前p步骤走的路径不同。所以当p1和p2再次重合的时候，必然是在链表的环路入口点上。</p>
<p>③ 综上所述，可得出如下算法：</p>
<ul>
<li><p>创建两个指针：fast和slow</p>
</li>
<li><p>slow每走一步，fast就走两步</p>
</li>
<li><p>两者碰在一起时，将slow重新指向链表头，fast保持不变</p>
</li>
<li><p>以相同速度移动slow和fast，一次一步，然后返回新的碰撞处。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">node* findLoopEntrance(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	node* slow = L-&gt;next;</span><br><span class="line">	node* fast = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)  <span class="comment">/*碰撞*/</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fast==NULL || fast-&gt;next==NULL)</span><br><span class="line">		<span class="keyword">return</span> NULL;  <span class="comment">/*没有环路*/</span></span><br><span class="line"></span><br><span class="line">	slow = L-&gt;next;   <span class="comment">/*重新指向链表头*/</span></span><br><span class="line">	<span class="keyword">while</span>(slow!=fast)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong>2.7</strong> 所谓“回文”指正向看和反向看是一样的。在链表中可以定义为 <code>0-&gt;1-&gt;2-&gt;1-&gt;0</code>。</p>
<ul>
<li><p>解法一：根据定义，先将整个链表反转，然后比较反转链表和原始链表。若两者相同，则该链表为回文。（只需比较链表的前半部分）</p>
</li>
<li><p>解法二：迭代法。先进行迭代，将链表的前半部分入栈，再继续进行迭代，与后半部分进行比较。每次迭代时，比较当前结点和栈顶元素，若完成迭代时比较结果完全相同，则该链表为回文。（在链表长度未知的情况下，可以使用<strong>“快慢指针</strong>”将前半部分入栈）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(LinkList L)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	node* fast = L-&gt;next;</span><br><span class="line">	node* slow = L-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**将链表的前半部分入栈**/</span></span><br><span class="line">	<span class="keyword">while</span>(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		s.push(slow-&gt;data);</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**链表有奇数个元素，跳过中间元素**/</span></span><br><span class="line">	<span class="keyword">if</span>(fast!=NULL)</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**比较**/</span></span><br><span class="line">	<span class="keyword">while</span>(slow!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> top = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="keyword">if</span>(top!=slow-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br>个人站点：<a href="http://songlee24.github.io/" target="_blank" rel="external">http://songlee24.github.com</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1、数组与字符串">1、数组与字符串</h3><p><strong>1.1</strong> 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？</p>
<p><strong>1.2</strong> 用C或C++实现<code>void reverse(char* str)</code>函数，即反转一个null结尾的字符串。</p>
<p><strong>1.3</strong> 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>1.4</strong> 编写一个方法，将字符串中的空格全部替换为“%20”。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。示例：输入<code>Mr John Smith</code>，输出<code>Mr%20John%20Smith</code>。]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-CareerCup" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-CareerCup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试题之strcpy/strlen/strcat/strcmp的实现]]></title>
    <link href="http://yoursite.com/2015/03/15/string-operating-function/"/>
    <id>http://yoursite.com/2015/03/15/string-operating-function/</id>
    <published>2015-03-15T09:15:22.000Z</published>
    <updated>2015-05-10T11:11:47.072Z</updated>
    <content type="html"><![CDATA[<p>阿里的电面要我用C/C++实现一个字符串拷贝的函数，虽然以前写过 strcpy 的函数实现，但时间过去很久了，再加上有点紧张，突然就措手不及了。最后写是写出来了，但没考虑异常的情况，面试官好像很不满意。(T_T)，写篇文章记录一下，以免日后重蹈覆辙。</p>
<h3 id="一、字符串拷贝strcpy">一、字符串拷贝strcpy</h3><p>函数<code>strcpy</code>的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">strcpy</span>(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span><br><span class="line">&#123;</span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL)); </span><br><span class="line">	<span class="keyword">char</span> *address = des;  </span><br><span class="line">	<span class="keyword">while</span>((*des++ = *src++) != <span class="string">'\0'</span>)  </span><br><span class="line">		;  </span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要知道 strcpy 会拷贝’\0’，还有要注意：</p>
<ul>
<li><p>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。</p>
</li>
<li><p>要判断源指针和目的指针为空的情况，思维要严谨，这里使用<code>assert</code>（见文末）。</p>
</li>
<li><p>要用一个临时变量保存目的串的首地址，最后返回这个首地址。</p>
</li>
<li><p>函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。</p>
</li>
</ul>
<p><br></p>
<h3 id="二、字符串长度strlen">二、字符串长度strlen</h3><p>函数<code>strlen</code>的原型是<code>size_t strlen(const char *s)</code>，其中 size_t 就是 unsigned int。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	assert(str != NULL);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((*str++) != <span class="string">'\0'</span>)</span><br><span class="line">		++len;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>strlen 与 sizeof 的区别：</p>
<ul>
<li><p>sizeof是运算符，strlen是库函数。</p>
</li>
<li><p>sizeof可以用类型、变量做参数，而strlen只能用 char* 变量做参数，且必须以<code>\0</code>结尾。</p>
</li>
<li><p>sizeof是在编译的时候计算类型或变量所占内存的大小，而strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度。</p>
</li>
<li><p>数组做sizeof的参数不退化，传递给strlen就退化为指针了。</p>
</li>
</ul>
<p><br></p>
<h3 id="三、字符串连接strcat">三、字符串连接strcat</h3><p>函数<code>strcat</code>的原型是<code>char* strcat(char* des, char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">strcat</span>(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)   <span class="comment">// const表明为输入参数 </span></span><br><span class="line">&#123;  </span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL));</span><br><span class="line">	<span class="keyword">char</span>* address = des;</span><br><span class="line">	<span class="keyword">while</span>(*des != <span class="string">'\0'</span>)  <span class="comment">// 移动到字符串末尾</span></span><br><span class="line">		++des;</span><br><span class="line">	<span class="keyword">while</span>(*des++ = *src++)</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="四、字符串比较strcmp">四、字符串比较strcmp</h3><p>函数<code>strcmp</code>的原型是<code>int strcmp(const char *s1,const char *s2)</code>。  </p>
<ul>
<li>若s1==s2，返回零；</li>
<li>若s1&gt;s2，返回正数；</li>
<li>若s1&lt;s2，返回负数。</li>
</ul>
<p>即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇<code>\0</code>为止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	assert((s1!=NULL) &amp;&amp; (s2!=NULL));</span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1 == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
<h3 id="附：assert()断言">附：assert()断言</h3><p><code>assert</code>是宏，而不是函数。它的原型定义在头文件 assert.h 中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>宏 assert 经常用于在函数开始处检验传入参数的合法性，可以将其看作是异常处理的一种高级形式。<strong>assert 的作用是</strong>先计算表达式expression，然后判断：</p>
<ul>
<li><p>如果表达式值为假，那么它先向stderr打印错误信息，然后通过调用 abort 来终止程序运行。</p>
</li>
<li><p>如果表达式值为真，继续运行后面的程序。</p>
</li>
</ul>
<p>注意：<code>assert</code>只在 DEBUG 下生效，在调试结束后，可以通过在<code>#include &lt;assert.h&gt;</code>语句之前插入<code>#define NDEBUG</code>来禁用assert调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阿里的电面要我用C/C++实现一个字符串拷贝的函数，虽然以前写过 strcpy 的函数实现，但时间过去很久了，再加上有点紧张，突然就措手不及了。最后写是写出来了，但没考虑异常的情况，面试官好像很不满意。(T_T)，写篇文章记录一下，以免日后重蹈覆辙。</p>
<h3 id="一、字符串拷贝strcpy">一、字符串拷贝strcpy</h3><p>函数<code>strcpy</code>的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。]]>
    
    </summary>
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
      <category term="试题-笔试面试" scheme="http://yoursite.com/categories/%E8%AF%95%E9%A2%98-%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树（BST）]]></title>
    <link href="http://yoursite.com/2015/01/13/binary-search-tree/"/>
    <id>http://yoursite.com/2015/01/13/binary-search-tree/</id>
    <published>2015-01-12T16:08:39.000Z</published>
    <updated>2015-05-10T11:02:28.213Z</updated>
    <content type="html"><![CDATA[<p><strong>二叉查找树（Binary Search Tree）</strong>又叫二叉排序树（Binary Sort Tree），它是一种数据结构，支持多种动态集合操作，如 Search、Insert、Delete、Minimum 和 Maximum 等。</p>
<p>二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。</p>
</li>
<li><p>左、右子树本身也分别是一棵二叉查找树（二叉排序树）。<a id="more"></a></p>
</li>
</ol>
<p>可以看出，二叉查找树是一个递归的数据结构，且对二叉查找树进行中序遍历，可以得到一个<strong>递增</strong>的有序序列。</p>
<p>首先，我们来定义一下 BST 的结点结构体，结点中除了 key 域，还包含域 left, right 和 parent，它们分别指向结点的左儿子、右儿子和父节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	Node* left;</span><br><span class="line">	Node* right;</span><br><span class="line">	Node* parent;</span><br><span class="line">&#125; *BSTree;</span><br></pre></td></tr></table></figure></p>
<h3 id="一、BST的插入与构造">一、BST的插入与构造</h3><p>二叉查找树作为一种动态结构，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在结点的关键字等于给定值时再进行插入。</p>
<p>由于二叉查找树是递归定义的，插入结点的过程是：若原二叉查找树为空，则直接插入；否则，若关键字 k 小于根结点关键字，则插入到左子树中，若关键字 k 大于根结点关键字，则插入到右子树中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入：将关键字k插入到二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k, Node* parent=NULL)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		T-&gt;key = k;</span><br><span class="line">		T-&gt;left = NULL;</span><br><span class="line">		T-&gt;right = NULL;</span><br><span class="line">		T-&gt;parent = parent;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 返回1表示成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 树中存在相同关键字</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;left, k, T);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;right, k, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造</strong>一棵二叉查找树就是依次输入数据元素，并将它们插入到二叉排序树中的适当位置。具体过程是：每读入一个元素，就建立一个新结点；若二叉查找树为空，则新结点作为根结点；若二叉查找树非空，则将新结点的值与根结点的值比较，如果小于根结点的值，则插入到左子树中，否则插入到右子树中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 构造：用数组arr[]创建二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T = NULL;  <span class="comment">// 初始时为空树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		BST_Insert(T, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，插入的新结点一定是某个叶结点。另外，插入操作既可以递归实现，也可以使用非递归（迭代）实现。通常来说非递归的效率会更高。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 非递归插入：将关键字k插入到二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert_NonRecur</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node* pre = NULL;  <span class="comment">// 记录上一个结点</span></span><br><span class="line">	Node* t = T;</span><br><span class="line">	<span class="keyword">while</span>(t != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		pre = t;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; t-&gt;key)</span><br><span class="line">			t = t-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; t-&gt;key)</span><br><span class="line">			t = t-&gt;right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	node-&gt;key = k;</span><br><span class="line">	node-&gt;left = NULL;</span><br><span class="line">	node-&gt;right = NULL;</span><br><span class="line">	node-&gt;parent = pre;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pre == NULL)</span><br><span class="line">		T = node;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; pre-&gt;key)</span><br><span class="line">			pre-&gt;left = node;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pre-&gt;right = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、BST的查找">二、BST的查找</h3><p>对于二叉查找树，最常见的操作就是查找树中的某个关键字。除了Search操作外，二叉查找树还能支持如 Minimum（最小值）、Maximum（最大值）、Predecessor（前驱）、Successor（后继）等查询。对于高度为 h 的树，这些操作都可以在 Θ(h) 时间内完成。</p>
<p><strong>1. 查找</strong></p>
<p>BST 的查找是从根结点开始，若二叉树非空，将给定值与根结点的关键字比较，若相等，则查找成功；若不等，则当给定值小于根结点关键字时，在根结点的左子树中查找，否则在根结点的右子树中查找。显然，这是一个递归的过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 递归查找：返回指向包含关键字k的结点的指针</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Search(BSTree T, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == NULL || k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Search(T-&gt;left, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> BST_Search(T-&gt;right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用非递归的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 非递归查找：返回指向包含关键字k的结点的指针</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Search_NonRecur(BSTree T, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T != NULL &amp;&amp; k != T-&gt;key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &lt; T-&gt;key)</span><br><span class="line">			T = T-&gt;left;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T = T-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 最大值与最小值</strong></p>
<p>由二叉查找树的性质可知，最左下结点即为关键字最小的结点，最右下结点即为关键字最大的结点。此过程无需比较，只需要沿着最左和最右的路径查找下去，直到遇到 NULL 为止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 最小值：查找二叉查找树中关键字最小的结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Minimum(BSTree T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T-&gt;left != NULL)</span><br><span class="line">		T = T-&gt;left;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 最大值：查找二叉查找树中关键字最大的结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Maximum(BSTree T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(T-&gt;right != NULL)</span><br><span class="line">		T = T-&gt;right;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 前驱与后继</strong></p>
<p>给定一个二叉查找树的结点，求出它在<strong>中序遍历</strong>中的前驱与后继。如果所有的关键字均不相同，则某结点 x 的后继是：</p>
<ul>
<li><p>若结点 x 的右子树不为空，则 x 的后继就是它的右子树中关键字值最小的结点；</p>
</li>
<li><p>若结点 x 的右子树为空，为了找到其后继，从结点 x 开始向上查找，直到遇到一个祖先结点 y，它的左儿子也是结点 x 的祖先，则结点 y 就是结点 x 的后继。如下图</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150110234933625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 后继：查找给定结点在中序遍历中的后继结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Successor(Node* node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;right != NULL)</span><br><span class="line">		<span class="keyword">return</span> BST_Minimum(node-&gt;right);</span><br><span class="line">	Node* p = node-&gt;parent;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;right == node)</span><br><span class="line">	&#123;</span><br><span class="line">		node = p;</span><br><span class="line">		p = p-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求前驱（predecessor）的过程对称，对于某个结点 x ，它的前驱是：</p>
<ul>
<li><p>若结点 x 的左子树不为空，则 x 的前驱是它的左子树中关键字值最大的结点；</p>
</li>
<li><p>若结点 x 的左子树为空，为了找到其前驱，从结点 x 开始向上查找，直到遇到一个祖先结点 y，它的右儿子也是结点 x 的祖先，则结点 y 就是结点 x 的前驱。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 前驱：查找给定结点在中序遍历中的前驱结点</span><br><span class="line"> */</span></span><br><span class="line">Node* BST_Predecessor(Node* node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;left != NULL)</span><br><span class="line">		<span class="keyword">return</span> BST_Maximum(node-&gt;left);</span><br><span class="line">	Node* p = node-&gt;parent;</span><br><span class="line">	<span class="keyword">while</span>(p!=NULL &amp;&amp; p-&gt;left == node)</span><br><span class="line">	&#123;</span><br><span class="line">		node = p;</span><br><span class="line">		p = p-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以在这里讨论如何求中序序列的后继，主要是为了后面讲删除操作做铺垫。</p>
<h3 id="三、BST的删除">三、BST的删除</h3><p>二叉查找树的删除操作是相对复杂一点，它要按 3 种情况来处理：</p>
<ul>
<li><p>若被删除结点 z 是叶子结点，则直接删除，不会破坏二叉排序树的性质；</p>
</li>
<li><p>若结点 z 只有左子树或只有右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置；</p>
</li>
<li><p>若结点 z 既有左子树，又有右子树，则用 z 的后继（Successor）代替 z，然后从二叉查找树中删除这个后继，这样就转换成了第一或第二种情况。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_Delete</span><span class="params">(BSTree &amp;T,Node* z)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(z-&gt;left == NULL &amp;&amp; z-&gt;right == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = NULL;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = NULL;  <span class="comment">// 只剩一个结点的情况</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;left != NULL &amp;&amp; z-&gt;right == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		z-&gt;left-&gt;parent = z-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = z-&gt;left;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = z-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = z-&gt;left;  <span class="comment">// 删除左斜单支树的根结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;left == NULL &amp;&amp; z-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		z-&gt;right-&gt;parent = z-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span>(z-&gt;parent != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(z-&gt;parent-&gt;left == z)</span><br><span class="line">				z-&gt;parent-&gt;left = z-&gt;right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z-&gt;parent-&gt;right = z-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			T = z-&gt;right;  <span class="comment">// 删除右斜单支树的根结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node* s = BST_Successor(z);</span><br><span class="line">		z-&gt;key = s-&gt;key;   <span class="comment">// s的关键字替换z的关键字</span></span><br><span class="line">		BST_Delete(T, s);  <span class="comment">// 转换为第一或第二种情况</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个高度为 h 的二叉查找树来说，删除操作和插入操作一样，都可以在 Θ(h) 时间内完成。</p>
<h3 id="四、随机构造的二叉查找树">四、随机构造的二叉查找树</h3><p>二叉查找树可以实现任何一种基本的动态集合操作，且各基本操作的运行时间都是 Θ(h)。当树的高度较低时，这些操作执行的较快；但是，当树的高度较高时，性能会变差。比如，<strong>如果各元素是按严格增长的顺序插入的，那么构造出来的树就是一个高度为 n-1 的链。</strong> 为了尽量减少这种最坏情况的出现，我们可以随机地构造二叉查找树，即随机地将各关键字插入一棵初始为空的树来构造 BST。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;ctime&gt;</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机构造二叉查找树</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T = NULL;  </span><br><span class="line">	<span class="comment">// 随机遍历数组，进行插入操作</span></span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">		BST_Insert(T, arr[j]);</span><br><span class="line">		swap(arr[j], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><br><br></p>
<h3 id="附：随机遍历数组">附：随机遍历数组</h3><p>在随机构造二叉查找树时，需要解决 随机遍历数组 的问题，即随机遍历一个数组中的所有元素，既不重复也不遗漏。这里能想到的一种思路是：先随机生成<code>0...n-1</code>之间的一个数，然后与数组最后一个数交换，然后再随机生成<code>0...n-2</code>之间的一个数，与数组倒数第二个数交换，直到整个数组遍历结束。显然这个算法的时间复杂度是 O(n)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;  <span class="comment">// srand rand</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;ctime&gt;    <span class="comment">// time</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> tmp = a;  </span><br><span class="line">	a = b;  </span><br><span class="line">	b = tmp;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机遍历数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse_Random</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">" "</span>;   <span class="comment">// 输出</span></span><br><span class="line">		swap(arr[j], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	Traverse_Random(arr, <span class="number">9</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>（全文完）</p>
<p><br><br><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>二叉查找树（Binary Search Tree）</strong>又叫二叉排序树（Binary Sort Tree），它是一种数据结构，支持多种动态集合操作，如 Search、Insert、Delete、Minimum 和 Maximum 等。</p>
<p>二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。</p>
</li>
<li><p>左、右子树本身也分别是一棵二叉查找树（二叉排序树）。]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Basic-算法与数据结构" scheme="http://yoursite.com/categories/Basic-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习之构造函数中的异常处理]]></title>
    <link href="http://yoursite.com/2015/01/12/cpp-exception-in-constructor/"/>
    <id>http://yoursite.com/2015/01/12/cpp-exception-in-constructor/</id>
    <published>2015-01-12T09:06:05.000Z</published>
    <updated>2015-05-10T10:59:43.206Z</updated>
    <content type="html"><![CDATA[<p>构造函数中可不可以抛出异常？当然可以。从语法上来说，是可以的；从实际情况来看，现在的软件系统日渐庞大和复杂，很难保证 Constructor 在执行过程中完全不发生一点异常。</p>
<p>那么，如果构造函数中抛出异常，会发生什么情况呢？</p>
<h3 id="一、构造函数中抛出异常将导致对象的析构函数不被执行。">一、构造函数中抛出异常将导致对象的析构函数不被执行。</h3><p>C++仅能 delete 被完全构造的对象（fully constructed objects），只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。所以如果在构造函数中抛出一个异常，这个异常将传递到创建对象的地方（程序控制权也会随之转移），这样对象就只是部分被构造，它的析构函数将不会被执行。<a id="more"></a></p>
<p>看下面的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************类定义**********************/</span></span><br><span class="line"><span class="keyword">class</span> person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str):name(str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//throw exception("测试：在构造函数中抛出一个异常");</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造一个对象！"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁一个对象！"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************测试类**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">person <span class="title">me</span><span class="params">("songlee")</span></span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(exception e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意上面的 me 是一个局部对象，所以离开<code>try{}</code>的作用域，会自动执行析构函数。运行上述代码，输出结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造一个对象！</span><br><span class="line">销毁一个对象！</span><br></pre></td></tr></table></figure></p>
<p>如果在构造函数中抛出一个异常（去掉注释），输出结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试：在构造函数中抛出一个异常</span><br></pre></td></tr></table></figure></p>
<p>可以看出，析构函数没有被自动执行。为什么<em>“构造一个对象！”</em>也没有输出呢？因为程序控制权转移了，所以在异常点以后的语句都不会被执行。</p>
<h3 id="二、构造函数抛出异常可能导致内存泄露">二、构造函数抛出异常可能导致内存泄露</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B() &#123; </span><br><span class="line">		<span class="comment">//throw exception("测试：在B的构造函数中抛出一个异常");</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造 B 对象!"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~B()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁 B 对象!"</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Tester &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address);</span><br><span class="line">	~Tester();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> theName;</span><br><span class="line">	<span class="built_in">string</span> theAddress;</span><br><span class="line">	A *a;</span><br><span class="line">	B *b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面声明了三个类（A、B、Tester）,其中Tester类的构造函数和析构函数定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tester::Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address):</span><br><span class="line">	theName(name),</span><br><span class="line">	theAddress(address)</span><br><span class="line">&#123;</span><br><span class="line">	a = <span class="keyword">new</span> A();</span><br><span class="line">	b = <span class="keyword">new</span> B();  <span class="comment">// &lt;——</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造 Tester 对象!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tester::~Tester()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁 Tester 对象!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造函数中，动态的分配了内存空间给a、b两个指针。析构函数负责删除这些指针，确保Tester对象不会发生内存泄露（C++中delete一个空指针也是安全的）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Tester *tes = NULL;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		tes = <span class="keyword">new</span> Tester(<span class="string">"songlee"</span>,<span class="string">"201"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(exception e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">delete</span> tes; <span class="comment">// 删除NULL指针是安全的</span></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行输出结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造 B 对象!</span><br><span class="line">构造 Tester 对象!</span><br><span class="line">销毁 B 对象!</span><br><span class="line">销毁 Tester 对象!</span><br></pre></td></tr></table></figure></p>
<p>看上去好像一切良好，在正常情况下确实没有错。但是在有异常的情况下，恐怕就不会良好了。</p>
<p><strong>试想在 Tester 的构造函数执行时，</strong><code>b = new B()</code><strong>抛出了异常：</strong>可能是因为operator new不能给B对象分配足够的内存，也可能是因为 B 的构造函数自己抛出了一个异常。不论什么原因，在 Tester 构造函数内抛出异常，这个异常将传递到建立 Tester 对象的地方（程序控制权也会转移）。</p>
<p>在 B 的构造函数里抛出异常（去掉注释）时，程序运行结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试：在B的构造函数中抛出一个异常</span><br></pre></td></tr></table></figure></p>
<p>可以看出，C++拒绝为没有完成构造操作的对象调用析构函数，即使你使用了<code>delete</code>语句。由于 Tester 的析构函数不会执行，所以给A对象 a 动态分配（new）的空间无法释放，将造成内存泄露。</p>
<p><strong>注：</strong>不用为 Tester 对象中的非指针数据成员操心，因为它们不是new出来的，且在异常抛出之前已经构造完全，所以它们会自动逆序析构。</p>
<h3 id="三、解决上述内存泄露的方法">三、解决上述内存泄露的方法</h3><p>因为当对象在构造中抛出异常后C++不负责清除（动态分配）的对象，所以你必须重新设计构造函数以让它们自己清除。<strong>常用的方法</strong>是捕获所有的异常，然后执行一些清除代码，最后再重新抛出异常让它继续传递。</p>
<p>示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Tester::Tester(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">string</span>&amp; address):</span><br><span class="line">	theName(name),</span><br><span class="line">	theAddress(address),</span><br><span class="line">	a(NULL),   <span class="comment">// 初始化为空指针是必须的</span></span><br><span class="line">	b(NULL)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> </span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="keyword">new</span> A();</span><br><span class="line">		b = <span class="keyword">new</span> B();  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(...)   <span class="comment">// 捕获所有异常</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> a;</span><br><span class="line">		<span class="keyword">delete</span> b;</span><br><span class="line">		<span class="keyword">throw</span>;   <span class="comment">// 继续传递异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种更好的方法是使用<strong>智能指针（smart pointer）</strong>，不过关于智能指针的内容比较多，在这里就不说了。</p>
<p><br><br><br><br><br><br><strong>总结：</strong></p>
<ul>
<li><p>在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。</p>
</li>
<li><p>构造函数中抛出异常，对象的析构函数将不会被执行。</p>
</li>
<li><p>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露。</p>
</li>
<li><p>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>构造函数中可不可以抛出异常？当然可以。从语法上来说，是可以的；从实际情况来看，现在的软件系统日渐庞大和复杂，很难保证 Constructor 在执行过程中完全不发生一点异常。</p>
<p>那么，如果构造函数中抛出异常，会发生什么情况呢？</p>
<h3 id="一、构造函数中抛出异常将导致对象的析构函数不被执行。">一、构造函数中抛出异常将导致对象的析构函数不被执行。</h3><p>C++仅能 delete 被完全构造的对象（fully constructed objects），只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。所以如果在构造函数中抛出一个异常，这个异常将传递到创建对象的地方（程序控制权也会随之转移），这样对象就只是部分被构造，它的析构函数将不会被执行。]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Lang.-Cpp" scheme="http://yoursite.com/categories/Lang-Cpp/"/>
    
  </entry>
  
</feed>